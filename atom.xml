<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-04-30T07:58:56.870Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>清华操作系统课程Chapter1—操作系统概述</title>
    <link href="https://blog.slks.xyz/2022/04/28/7c4029518fb7/"/>
    <id>https://blog.slks.xyz/2022/04/28/7c4029518fb7/</id>
    <published>2022-04-28T09:48:19.000Z</published>
    <updated>2022-04-30T07:58:56.870Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"></h3>]]></content>
    
    
    <summary type="html">包含清华操作系统课程Chapter1的笔记</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <link href="https://blog.slks.xyz/2022/04/27/0d3e11e91f94/"/>
    <id>https://blog.slks.xyz/2022/04/27/0d3e11e91f94/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:59:03.660Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一电子计算机组成">一、电子计算机组成：</h4><h5 id="控制电路">1、控制电路</h5><p>​ 计算机控制电路开关发展历程：电磁继电器——真空管——晶体管</p><p>​ 发展趋势：每秒开关次数更大，更不容易损坏，体积更小</p><ul><li>硅谷的名字来由？晶体管的主要制作来源是硅</li></ul><h5 id="为什么电子计算机是二进制表示">2、为什么电子计算机是二进制表示？</h5><p>​ 1、晶体管本身是不仅可以有电流流过和不流过两种状态，还可以表示电流大小，所以早期电子计算机可能采用三进制、五进制。但是由于状态太多，晶体管变化太快，很容易导致信号混杂出现问题。</p><p>​ 2、布尔代数的理论完善。</p><h5 id="逻辑门">3、逻辑门：</h5><p>​ 我们可以通过二进制的形式，使用晶体管来构建逻辑门。可以构建更为复杂的逻辑电路。我们可以搭建最基础的 AND/ OR / NOT / XOR 逻辑门，从而构建更为复杂的逻辑门。</p><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220427175830177.png" alt="“与”逻辑电路" style="zoom:25%;" /></p><h5 id="计算机如何存储">4、计算机如何存储？</h5><p>​ 使用True和False表示二进制数的0和1。计算机中使用二进制数进行存储和计算。</p><p>​ <strong>整数表示：</strong>使用第一位表示数字的正负，1是负，0为正。</p><p>​ <strong>浮点数表示：</strong>IEEE754标准，使用科学计数的形式进行存储。</p><p>​ 32位浮点数：1 + 8 + 23 （正负 + 指数 + 数字）</p><p>​ <strong>ASCII码：</strong>8位，用于表示各种各样的英文符号。</p><p>​ <strong>Unicode编码：</strong>设计与1992年，解决了不同国家不同标准的问题。最常见的Unicode是16位，完全足够所有语言、表情进行使用。</p><h5 id="计算机如何计算">5、计算机如何计算：</h5><p>​ <strong>算数逻辑单元ALU</strong>：计算机里负责运算的组件</p>]]></content>
    
    
    <summary type="html">计算机科学速成课笔记1，包含P1-P10集内容，电子计算机、布尔逻辑、逻辑门、二进制、算术逻辑单元、寄存器、内存、中央处理器、指令和程序、高级CPU设计、早期编程方式等</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机科学课" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE/"/>
    
    
    <category term="Computer Science" scheme="https://blog.slks.xyz/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <link href="https://blog.slks.xyz/2022/04/27/fb6fde05ab36/"/>
    <id>https://blog.slks.xyz/2022/04/27/fb6fde05ab36/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:58:59.905Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">计算机科学速成课笔记1，包含P1-P10集内容，电子计算机、布尔逻辑、逻辑门、二进制、算术逻辑单元、寄存器、内存、中央处理器、指令和程序、高级CPU设计、早期编程方式等</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机科学课" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE/"/>
    
    
    <category term="Computer Science" scheme="https://blog.slks.xyz/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>计网微课堂Chap1——计网基础知识与概述</title>
    <link href="https://blog.slks.xyz/2022/04/27/dcdee696a9ce/"/>
    <id>https://blog.slks.xyz/2022/04/27/dcdee696a9ce/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:59:05.988Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=2</p><h4 id="一网络互联网和因特网概述">一、网络、互联网和因特网概述：</h4><p>1、网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p><p>2、多个网络可以通过路由器互联，就构成了一个覆盖范围更大的网络，即<strong>互联网</strong></p><p>3、<strong>因特网</strong>是世界山给最大的互联网。</p><h4 id="二因特网发展阶段">二、因特网发展阶段：</h4><p>1、从单个网络ARPANET向互联网发展</p><p>2、逐步构成三级结构的因特网</p><p>3、逐步形成多层次ISP结构的因特网（ISP：因特网服务提供者）</p><h4 id="三因特网服务提供者isp">三、因特网服务提供者ISP：</h4><p>​ ISP拥有接入因特网的能力，个人或企业需要向ISP申请IP。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140348424.png" /></p><h4 id="四基于isp的三层结构的因特网">四、基于ISP的三层结构的因特网：</h4><ul><li>第一层：国际性区域</li><li>第二层：区域性或国家性覆盖规模</li><li>第三层：本地范围</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140515599.png" style="zoom: 33%;" /></p><p>​ 一个个人主机在接入因特网后也可以成为一个ISP，只要使用路由器等内容将其他主机连入即可。</p><h4 id="五因特网的标准化工作">五、因特网的标准化工作：</h4><p>​ 因特网在制定其标准上的一个很大的特点是<strong>面向公众。</strong></p><p>​ 因特网所有的RFC（Request For Comments）技术文档都可从因特网上免费下载；</p><p>​ 因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><h4 id="六因特网的组成">六、因特网的组成：</h4><ul><li>边缘部分：<ul><li>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li></ul></li><li>核心部分：<ul><li>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（<strong>提供连通性和交换</strong>）。</li></ul></li></ul><h4 id="七三种交换方式">七、三种交换方式：</h4><h5 id="电路交换-circuit-switching">1、电路交换 Circuit Switching</h5><p>​ 当电话数量增多时，无法使得两两电话机之间接通，只能使用电话交换机来完成电话机之间两两的通信任务。</p><p>​ <strong>电话交换机接通电话线的方式称为电路交换；</strong>从通信资源的分配角度来看，<strong>交换（Switching）就是按照某种方式动态地分配传输线路的资源；</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141032502.png" alt="image-20220428141032502" style="zoom:33%;" /></p><p><strong>电路交换的三个步骤</strong>：</p><ul><li><p>建立连接：分配通信资源（一条固定的物理连接，在双方通信时不会被其他用户占用）</p></li><li><p>通话（一直占用通信资源）</p></li><li><p>释放连接（归还通信资源）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141314096.png" style="zoom: 33%;" /></p><p>​ 当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。<strong>这是由于计算机的数据往往是突发的出现在链路上的</strong></p></li></ul><h5 id="分组交换-packet-switching">2、分组交换 Packet Switching</h5><p>​ <strong>路由器是分组交换中最重要的设备</strong></p><p>发送方：</p><ul><li>构造分组 + 发送分组</li></ul><p>路由器：</p><ul><li>缓存分组 + 转发分组</li></ul><p>接收方：</p><ul><li>接受分组 + 还原报文</li></ul><h5 id="报文交换">3、报文交换：</h5><p>​ 大致与分组交换一致，但是报文交换<strong>不限制报文的大小，也就要求转发的中间节点有足够的缓存空间</strong>，而分组交换是会把整个报文分成一个个分组，从而进行传输。</p><h5 id="对比">4、对比：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428142115539.png" alt="image-20220428142115539" style="zoom:50%;" /></p><ul><li>电路交换：<ul><li>通信延时小、有序传输、无冲突、适用范围广（传输模拟、数字信号都可）、实时性强</li><li>建立连接时间长，线路独占，使用效率低、灵活性差（只要中间有一个点出错就要重新拨号）</li></ul></li><li>报文交换：<ul><li>无需建立连接</li><li>动态分配线路（节点交换机会先存储整个报文，再选择合适的空闲路径转发报文）</li><li>提高线路利用率，可靠性。</li><li>提供多目标服务</li><li>存在转发时延、需要较大存储缓存空间、需要传输额外信息量（报文头等）</li></ul></li><li>分组交换：<ul><li>优点：报文交换所拥有的所有优点，同时简化了存储管理，因为分组的大小固定，所有缓冲区大小也会固定，方便管理。加速传输、减少出错概率和重发数据量（如果出错，只需要重传出错分组即可）</li><li>缺点：存在转发时延、需要较大存储缓存空间、需要传输额外信息量（控制信息等）。</li></ul></li><li>分组交换中：<ul><li>对于数据报服务而言：存在失序、丢序、或者重复分组的问题</li><li>对于虚电路服务而言：存在呼叫建立、数据传输、虚电路释放三个过程</li></ul></li></ul><h4 id="八计算机网络分类">八、计算机网络分类：</h4><ul><li>按照覆盖范围分类：<ul><li>广域网WAN（覆盖范围最广，用于高速长途传输）</li><li>城域网MAN（通常作为城市骨干网）</li><li>局域网LAN</li><li>个域网PAN</li></ul></li><li>按拓扑结构分类：<ul><li>总线型网络</li><li>星型网络</li><li>环型网络</li><li>网状型网络</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428150509644.png" style="zoom:50%;" /></p><h4 id="九计算机网络的性能指标">九、计算机网络的性能指标：</h4><h5 id="速率">1、速率</h5><p>​ 连接在计算机网络上的<strong>主机在数字信道上传送比特的速率</strong>，也称为比特率或数据率。</p><h5 id="带宽">2、带宽</h5><ul><li>在模拟信号系统中的意义：<ul><li>信号所包含的各种不同频率成分所占据的频率范围；</li><li>单位：Hz ，带宽3.1Hz( 300Hz ~ 3.4kHz)</li></ul></li><li>在计算机网络中的意义：<ul><li>用来表示<strong>网络的通信线路所能传送数据的能力</strong>，因此<strong>网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”；</strong></li><li>单位：b/s</li></ul></li></ul><h5 id="吞吐量">3、吞吐量</h5><p>​ 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>​ 吞吐量受网络的带宽或额定速率的限制</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173106779.png" style="zoom: 50%;" /></p><h5 id="时延">4、时延</h5><p>​ 网络时延由三部分组成：发送时延、传播时延、处理时延，计算公式如下所示：（处理时延一般不做计算）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173416712.png" /></p><h5 id="时延带宽积">5、时延带宽积</h5><ul><li><p>时延带宽积 = 传播时延 * 带宽</p><p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；</p></li></ul><p>​ 链路的时延带宽积又称为以比特为单位的链路长度。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173800437.png" style="zoom:50%;" /></p><h5 id="往返时间-rtt">6、往返时间 RTT</h5><p>​ 从源主机到目标主机，直到源主机收到目标主机的答复所花费的时间</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173913426.png" style="zoom: 67%;" /></p><h5 id="利用率">7、利用率</h5><ul><li>信道利用率<ul><li>用来表示某信道有百分之几的时间是被利用的（有数据通过）。</li></ul></li><li>网络利用率<ul><li>全网络的信道利用率的加权平均。</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428174105464.png" /></p><h5 id="丢包率">8、丢包率</h5><p>​ 是指在一定的时间范围内，<strong>传输过程中丢失的分组数量与总分组数量的比率。</strong></p><p>​ <strong>分组丢失一般有两种情况</strong>：</p><ul><li>分组在传输过程中出现误码，被节点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li></ul><p>因此，丢包率反映了网络的拥塞情况：</p><ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul><h4 id="十计算机网络体系结构">十、计算机网络体系结构：</h4><h5 id="常见的计算机网络体系结构">1、常见的计算机网络体系结构：</h5><p>​ OSI体系结构 （法律上的国际标准）、TCP/IP 体系结构（事实上的国际标准）</p><ul><li>OSI协议制定较为复杂，运行效率低，层次划分并不合理，被TCP/IP体系代替</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160500448.png" style="zoom:50%;" /></p><p>​ 如果用户主机需要接入因特网，必须含有TCP/IP协议族。路由器也需要含有TCP/IP协议族，但是往往路由器只具有 网际层和网络接口层。</p><p>​ TCP/IP的网络接口层并没有做过多规定，可以兼容多种网络接口，如有线网络、WIFI接口等。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160803014.png" style="zoom:50%;" /></p><p>​ 使用IP协议互联不同的网络接口，为向其上的TCP协议和UDP协议提供网络互联服务，TCP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供可靠传输的服务，而UDP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供不可靠传输的服务。</p><h5 id="计网结构分层的必要性">2、计网结构分层的必要性：</h5><p>在实现计算机网络的过程中常见需要考虑的问题，并将相应问题划分给相应的层去进行处理：</p><p><strong>情况1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161416991.png" alt="两台直连计算机间的传输" style="zoom:50%;" /></p><ul><li><p>物理层问题</p><ul><li><p>采用何种传输媒体</p></li><li><p>采用怎样的物理接口</p></li><li><p>使用怎样的信号表示比特0和比特1</p></li></ul></li></ul><p><strong>情况2：在上述问题解决前提下，考虑如下总线型网络：（现在已经不常用了）</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161454976.png" alt="总线型网络" style="zoom:50%;" /></p><ul><li><p>数据链路层问题：</p><ul><li><p>如何标识网络中各主机（主机编址问题，例如MAC地址）</p></li><li><p>如何从信号所标识的一连串比特流中区分出<strong>地址和数据</strong></p></li><li><p>如何协调各个主机争用总线</p></li><li><p>使用以太网交换机将多台主机互联形成的交换式以太网中：以太网交换机是如何实现的</p></li></ul></li></ul><p><strong>情况3：解决以上问题后，分组就可以在一组网络中传输了，然而我们日常使用的因特网更为复杂，其是由许多路由器将多个网络进行互连起来的互联网，考虑如下由3个路由器和4个网络构成的小型互联网</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162242434.png" alt="=" style="zoom:50%;" /></p><ul><li><p>网络层:</p><ul><li><p>如何标识各个网络以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</p></li><li><p>分组从源主机到目的主机可走路径不止一条，路由器应当如何转发分组，如何进行路由选择</p></li></ul></li></ul><p><strong>情况4：解决以上问题后，可以实现分组在网络两主机间传输的问题，对于计算机网络应用而言远远不够，对于一台主机而言，可能存在多个进程</strong></p><ul><li><p>运输层</p><ul><li><p><strong>如何标识与网络通信相关的应用进程</strong>，即解决进程之间基于网络的通信问题</p></li><li><p>出现传输错误时，如何处理？（某个分组在传输过程中出现误码，或由于路由器繁忙丢弃分组）</p></li></ul></li></ul><p><strong>情况5：解决上述问题后，可以实现进程之间，基于网络的通信，在此基础上，制定应用层协议，根据协议内容完成特定网络应用即可</strong></p><ul><li>应用层<ul><li>支持万维网应用的HTTP</li><li>支持邮件服务的SMTP</li><li>……</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162801442.png" style="zoom:50%;" /></p><h5 id="分层思想举例">3、分层思想举例：</h5><video src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/2022_04_29_19_04_47_435.mp4"></video><h5 id="专用术语">4、专用术语：</h5><ul><li>实体：任何可发送或接收信息的硬件或软件进程。</li><li>对等实体：收发双发相同层次中的实体<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202752020.png" style="zoom:50%;" /></li></ul></li><li>协议：控制两个对等实体<strong>进行逻辑通信</strong>的规则的集合。<ul><li>协议的三要素：<ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双方的时序关系（ 例如 TCP客户端与 TCP服务器之间的时序关系，状态转换）</li></ul></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202822644.png" style="zoom:50%;" /></li></ul></li><li>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。<ul><li>要实现本层协议，还需要使用下面一层所提供的服务。</li><li>协议是“水平的"，服务是“垂直的"。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203246032.png" /></li></ul></li><li>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</li><li>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li><li>协议数据单元PDU：对等层次之间传送的数据包称为该层的<strong>协议数据单元</strong>。<ul><li>比特流、帧、IP数据报、TCP报文段、UDP用户数据报、报文</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203352501.png" style="zoom:67%;" /></li></ul></li><li>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。</li></ul><h4 id="十一习题">十一、习题：</h4><h5 id="section">1、</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113545991.png" /></p><h5 id="section-1">2、</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113940223.png" /></p><h5 id="section-2">3、</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430114621627.png" /></p>]]></content>
    
    
    <summary type="html">计网微课堂Chap1——计网基础知识与概述</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Computer Network" scheme="https://blog.slks.xyz/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理Chapter1—概述</title>
    <link href="https://blog.slks.xyz/2022/04/27/5b4ea41fcadf/"/>
    <id>https://blog.slks.xyz/2022/04/27/5b4ea41fcadf/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:59:12.725Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1BE411D7ii</p><h4 id="一计算机硬件发展">一、计算机硬件发展：</h4><p>​ 电子管时代——晶体管时代——中小规模集成电路——大规模集成电路</p><h4 id="二冯诺伊曼结构原理及层次结构分析">二、冯诺伊曼结构原理及层次结构分析</h4><h5 id="冯诺依曼的计算机工作原理">1、冯诺依曼的计算机工作原理：</h5><ul><li><strong>存储程序：</strong>将程序存放在计算机的存储器中</li><li><strong>程序控制：</strong>按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算的控制，完成指令的功能。</li></ul><h5 id="冯诺依曼的计算机的组成">2、冯诺依曼的计算机的组成：</h5><ul><li>硬件系统：<ul><li>主机：CPU（运算器 + 控制器）、内存</li><li>外设：输入输出设备、外存储器</li><li>总线：地址线、数据线、控制线</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429102314735.png" /></li></ul></li><li>硬件系统：<ul><li>运算器：算术运算、逻辑运算<ul><li>基本结构：ALU（算术逻辑运算单元）、寄存器、连接通路</li></ul></li><li>控制器：产生指令执行过程所需要的所有控制信号，控制相关功能部件执行相应操作。<ul><li>控制信号分为：电平信号和脉冲信号</li><li>产生控制信号的依据：指令、状态、时序</li><li>控制信号的产生方式：微程序、硬布线</li></ul></li><li>存储器：<ul><li>存储原程序、原数据、运算中间结果</li><li>按地址访问，读写数据。</li><li>容量与地址线数量的对应关系：<ul><li>访问1K 的存储空间：需要10根地址线</li><li>访问1M的存储空间：需要20根地址线</li></ul></li></ul></li><li>输入输出设备：<ul><li>键盘、鼠标、网卡、显示器、声卡等</li></ul></li></ul></li><li>软件系统：<ul><li>系统软件、支持软件、应用软件</li></ul></li></ul><h5 id="计算机的层次结构">3、计算机的层次结构：</h5><p>​ 不同用户处在不同层次，不同层次具有不同属性，不同层次代码效率不同</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429105741386.png" style="zoom:50%;" /></p><h4 id="三计算机系统性能评价">三、计算机系统性能评价</h4><h5 id="非时间指标">1、非时间指标：</h5><ul><li><p>1）机器字长：指机器一次能处理的二进制位数</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110326661.png" style="zoom: 67%;" /></p><ul><li>由加法器、寄存器的位数决定；</li><li>一般与内部寄存器的位数相等（字长）；</li><li>字长越长，表示数据的范围就越大，精确度越高；</li><li>目前常见的有32位和64位字长。</li></ul></li><li><p>2）总线宽度：数据总线一次能够并行传送的最大信息位数</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110651202.png" /></p><ul><li>一般指运算器与存储器之间的数据总线位数。有些计算机内部与外部数据总线宽度不一致：</li></ul></li><li><p>3）主存容量与存储带宽</p><ul><li><strong>主存容量：</strong>一台计算机贮存所包含的存储单元总数</li><li><strong>存储带宽：</strong>指单位时间内与贮存交换的二进制信息量</li></ul></li></ul><h5 id="时间指标">2、时间指标：</h5><ul><li>主频f / 时钟周期T，外频与倍频<ul><li>主频f：CPU内核工作的时钟频率</li><li>时钟周期T：</li></ul></li></ul>]]></content>
    
    
    <summary type="html">王道计算机组成原理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Computer Composition" scheme="https://blog.slks.xyz/tags/Computer-Composition/"/>
    
  </entry>
  
  <entry>
    <title>《Not All Tokens Are Equal Human-centric Visual Analysis via Token Clustering Transformer》</title>
    <link href="https://blog.slks.xyz/2022/04/24/22e32ee5ba59/"/>
    <id>https://blog.slks.xyz/2022/04/24/22e32ee5ba59/</id>
    <published>2022-04-24T09:12:19.000Z</published>
    <updated>2022-04-27T11:15:31.147Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称not-all-tokens-are-equal-human-centric-visual-analysis-via-token-clustering-transformer">论文名称：《Not All Tokens Are Equal Human-centric Visual Analysis via Token Clustering Transformer》</h4><h4 id="论文地址-httparxiv.orgabs2204.08680">论文地址： http://arxiv.org/abs/2204.08680</h4><h2 id="关键词">1、关键词：</h2><p>​ Dynamic Token</p><h2 id="摘要">2、摘要：</h2><p>​ ViT在许多计算机视觉任务中取得了巨大的成功。大多数方法通过将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。 ​ 然而，在以人为中心的视觉任务中，并不是所有区域都同等重要，例如，人体需要一个带有许多token的精细表示，而图像背景可以由少量token建模。 ​ 为了解决这个问题，论文提出了一种新的ViT，称为令牌聚类转换器(TCFormer)，它通过渐进聚类来合并token，其中token可以从不同的位置以灵活的形状和大小合并。</p><p>​ TCFormer中的令牌不仅可以关注重要区域，还可以调整令牌形状以适应语义概念，并对包含关键细节的区域采用精细分辨率，有利于捕获详细信息。</p><h2 id="领域背景">3、领域背景：</h2><p>​ 暂略</p><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 为了解决传统ViT中，大多将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。然而在以人为中心的视觉任务中，并不是所有区域都同等重要，所以论文提出了一种新的ViT(TCFormer)，它通过渐进的令牌聚类生成TOKENS。</p><p>​ TCFormer在每个阶段动态生成TOKENS。如图所示，它能够生成具有不同位置、大小和形状的Token。首先，与基于网格的标记不同，聚类后的标记不局限于规则形状，可以专注于重要的区域，如人体。其次，TCFormer动态生成具有适当大小的令牌来表示不同的区域。比如说：<strong>对于充满重要细节(如人脸)的区域，分配更小尺寸的令牌。而仅有单个token(例如，图中的蓝色标记)被用来表示背景的大片区域。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424202223439.png" /></p><p>​ 在TCFormer中，特征图中的每个像素在第一阶段被初始化为一个vision token，其token区域就是像素所覆盖的区域。我们逐步合并语义相近的token，在不同阶段得到不同数量的token。</p><p>​ 为此，我们精心设计了一个聚类令牌合并(CTM)块：</p><ul><li>首先，给定上一阶段的tokens，CTM模块使用k-nearest-neighbor based density peaks clustering聚类算法对token进行分组。</li><li>那些被分到一组的tokens，会合并到一个单独的token，其值为所有特征的平均值。</li><li>最后，将tokens输入到一个transformer block中进行特征聚合。最终合并得到的token区域是所有输入导transformer block中的tokens的并集。</li></ul><p>​ 多阶段特征的聚合已经被证明有利于以人为中心的分析。大多数之前的研究将视觉token转换为特征图，并以特征图的形式聚合特征。然而，当我们将动态视觉token转换为特征图时，多个token可能位于同一个像素网格中，导致细节丢失。 ​ 为了解决这一问题，我们提出了一种多阶段令牌聚合(MTA)块，它能够有效地保存所有阶段的图像细节。具体来说：</p><ul><li>MTA从最后一个阶段的令牌开始，然后从前一个阶段逐步上采样tokens并聚合token特征，直到聚合所有阶段的特征。聚合的tokens与特征映射中的像素一一对应，并被reshape为特征映射以进行后续处理。</li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203340869.png" /><strong>概述：</strong>TCFormer由4个阶段和一个(MTA)头组成。每个阶段包含几个堆叠的Transformer块。在两个相邻的阶段之间，插入一个(CTM)块，以合并令牌并为下一个阶段生成令牌。最后MTA头将所有阶段的token特征聚集起来，并输出最终的热图</p><h4 id="核心1-transformer-block">1） 核心1： Transformer Block：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203928917.png" style="zoom:50%;" /></p><p>​ 采用Spatial Reduction层来降低计算复杂度。Spatial Reduction层首先将视觉token转换为特征映射，然后通过跨卷积层降低特征映射分辨率。处理后的特征图中的像素，比视觉标记要少得多，被作为K和V输入到多头注意模块。多头注意模块在token之间聚合特征。 ​ 我们利用Depth-Wise Convolution来捕获局部特征和位置信息，并去除显式位置嵌入。</p><h4 id="核心2-clustering-based-token-merge-ctm-block">2） 核心2： Clustering-based Token Merge (CTM) Block：</h4><p>​ 如图所示，我们的CTM块有两个过程，即Clustering和特征Merge。我们使用通过Clustering来将vision tokens归到一定数量的聚类中.</p><ul><li>Clustering<ul><li>在Clustering过程中，我们使用了一种基于k近邻密度峰值聚类算法(DPC-KNN)的变体。</li><li>给定一组令牌X，我们根据其k近邻计算每个令牌的局部密度ρ:</li><li>然后，对于每个令牌，我们 计算距离 作为它与任何其他具有更高局部密度的令牌之间的最小距离。 对于局部密度最高的token，其指示器设置为 它与任何其他标记之间的最大距离。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150522682.png" /></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150412421.png" /></li><li>δi 是距离指示指标 ，ρi 是局部密度指标</li><li>我们将δi 和 ρi 结合起来，得到每个token的得分为 ρi×δi。</li><li>分数越高，成为集群中心的可能性就越大。我们通过选择得分最高的token来确定聚类中心，然后根据特征距离将其他标记分配到最近的聚类中心。</li></ul></li><li>Merge</li></ul><p>​ 对于token特征的合并，一种直观的方法是直接对一个聚类中的token特征进行平均。但是，即使是语义意义相似的符号，其重要性也不完全相同。论文引入了一个重要度评分P来明确表示每个token的重要性，它是由token的特征估计的。然后在token重要性的指导下，对token特征进行平均:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150756742.png" /></p><p>​ 其中<span class="math inline">\(C_i\)</span>表示第<span class="math inline">\(i\)</span>个聚类的集合，<span class="math inline">\(x_j\)</span>和<span class="math inline">\(p_j\)</span>分别为原始token特征和对应的重要性得分，yi为合并后token的特征。合并令牌的令牌区域是原始令牌区域的并集。</p><ul><li><p>Final</p><p>最终合并好的令牌作为查询Q被送入一个Transformer Block，原始的Token用作K和V。为了保证 重要的token对输出的贡献更大，在注意力机制中增加重要性权重P，如下所示:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425151005438.png" style="zoom:50%;" /></p><p>引入token重要性评分使我们的CTM块在合并视觉标记时能够专注于关键的图像特征</p></li></ul><h4 id="核心3-multi-stage-token-aggregation-mta-head">3） 核心3： Multi-stage Token Aggregation (MTA) Head：</h4><p>​ 之前的研究证明了在以人为中心的视觉任务中，在多个阶段中进行特征聚合的好处。为了聚合特性，我们提出了一种基于Transformer的多阶段令牌聚合(MTA)头，它能够维护所有阶段的细节信息。</p><p>​ 下图 (a)显示了令牌上采样过程。在令牌合并过程中(章节3.3)，每个令牌被分配到一个聚类，每个聚类由一个合并的令牌表示。 我们记录原始token和合并token之间的关系。在token上采样过程中，我们利用所记录的信息将合并的token特征复制到相应的上采样token中。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425152443159.png" style="zoom:67%;" /></p><p>​ MTA Head将上一阶段的token特征添加到上采样的视觉token。然后，视觉token进入一个Transformer块。这样的处理是逐步执行的，直到所有的视觉token被聚合。最终的token，其token表示的区域是高分辨率特征图中的单个像素，可以很容易地重构为特征图进行进一步处理。</p><p>​ 整体而言，有点像UFormer的那种形式。</p>]]></content>
    
    
    <summary type="html">论文提出了一种新的ViT，称为令牌聚类转换器(TCFormer)，它通过渐进聚类来合并token，其中token可以从不同的位置以灵活的形状和大小合并。TCFormer中的令牌不仅可以关注重要区域，还可以调整令牌形状以适应语义概念，并对包含关键细节的区域采用精细分辨率，有利于捕获详细信息。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>《Vision Transformer with Deformable Attention》</title>
    <link href="https://blog.slks.xyz/2022/04/24/503bff4618b7/"/>
    <id>https://blog.slks.xyz/2022/04/24/503bff4618b7/</id>
    <published>2022-04-24T09:12:19.000Z</published>
    <updated>2022-04-27T11:15:20.156Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称vision-transformer-with-deformable-attention">论文名称：《Vision Transformer with Deformable Attention》</h4><h4 id="论文地址-httparxiv.orgabs2201.00520">论文地址： http://arxiv.org/abs/2201.00520</h4><h2 id="关键词">1、关键词：</h2><p>​ Deformable Attention</p><h2 id="摘要">2、摘要：</h2><p>​ Transformer最近在各种视觉任务中表现优异。全局的感知域使Transformer模型比CNN具有更强的表示能力。 ​ 然而，简单地扩大感受野也引起了一些问题。一方面，使用较为密集的注意力，例如在ViT中，会导致过多的内存和计算成本，并且功能可能会受到超出兴趣区域的无关部分的影响。另一方面，在PVT或Swin Transformer中采用的较为稀疏的注意机制是与数据无关的，这可能会限制对于长距离关系的建模能力。 ​ 为了缓解这些问题，论文提出了一种新的可变形的Self Attention模块，在自我注意模块中，KV键值对与数据相关。这种灵活的方案使Self Attention模块能够关注相关区域，并捕获更多的信息特性。 ​ 大量实验表明，我们的模型在综合基准上取得了持续改进的结果。</p><p>【类似于DCN对于普通卷积的改进思想】</p><h2 id="研究背景">3、研究背景：</h2><p>​ Transformer最初是为了解决自然语言处理任务而引入的。近年来，它在计算机视觉领域显示出巨大的潜力。Vision Transformer (ViT)这项开创性的工作，将多个Transformer块堆叠起来，以处理不重叠的图像patches序列，从而产生用于图像分类的无卷积模型。与CNN模型相比，基于transformer的模型具有更大的接受域，擅长建模远程依赖关系，在大量训练数据和模型参数的情况下具有更优越的性能。</p><p>​ 然而，在视觉识别中过多的注意力是一把双刃剑，存在着多方面的弊端。</p><p>​ 具体来说，如果每个查询patch要参与的Key数过多，会导致计算成本高、收敛速度慢，并增加过拟合的风险。为了避免过度的注意力计算，现有的研究都利用精心设计的高效注意力模式来降低计算复杂度。其中以Swin Transformer和金字塔视觉转换器(PVT)作为两个最经典的方式。</p><p>​ 理想情况下，我们期望对于一个给定Query而言，Key和Value的选择应该是具有弹性的，这样才能避免因为人工指定的稀疏注意模式中存在的问题。</p><p>​ 事实上，在cnn的文献中，学习卷积滤波器的可变形感受野已被证明可以有效地在数据依赖的基础上选择性地关注更有信息的区域，也就是DCN变形卷积。</p><p>​ CNN中DCN的思想如果直接应用在SelfAttention机制中，会导致不合理的高内存/计算复杂度。由可变形偏移引入的开销是Patches数量的二次方。 ​ 因此，尽管最近的一些工作研究了Transformer中的变形机制的思想，但由于计算成本高，它们都没有将其作为构建像DCN这样强大的骨干网络的基本构件。它们的变形机制要么被用于Head网络中，要么作为预处理层对后续骨干网络中的Patches进行采样。</p><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 基于上述研究背景，该论文提出了一个简单高效的可变形自我注意模块，并通过该模块构造了一个强大的金字塔形式的骨干网络，名为Deformable Attention Transformer(DAT)，用于图像分类和各种密集预测任务。 ​ 与DCN学习整个feature map中不同像素的不同偏移量不同，论文提出的方法基于这样一个思想：对于不同的查询，全局attention通常会导致对于不同的Query来说，都是近乎相同的attention模式。于是论文提出，网络通过学习几组与Query无关的偏移量，将键和值移到重要区域。</p><p>​ 该设计既具有线性空间复杂性，又引入了变形的注意模式。</p><p>​ 具体来说，对于每个注意力模块：</p><ul><li>参考点首先作为统一的网格生成，这些网格在输入数据中是相同的。</li><li>然后，一个offset网络以query特征为输入，生成所有参考点对应的偏移量。</li><li>通过这种方式，候选 键/值 向重要区域转移，从而使原来的self-attention模块具有更高的灵活性和效率，从而捕捉到更多的信息特征。</li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425194741367.png" /></p><p>​ 现有的ViT，特别是PVT和Swin Transformer试图解决过度关注的挑战。前者的下采样技术会导致严重的信息丢失，而后者的滑动窗口注意力会导致接收域的缓慢增长，这限制了对大对象建模的潜力。 ​ 因此，需要一种与数据相关的稀疏Attention机制来灵活地建模相关特征，这导致DCN中首次提出了可变形机制。</p><p>​ 然而，在Transformer模型中简单地实现DCN并不是一个微不足道的问题。在DCN中，feature map上的每个元素单独学习其偏移量，其中在<span class="math inline">\(H \times W \times C\)</span> 的特征图上的<span class="math inline">\(3 \times 3\)</span>可变形卷积的空间复杂度为<span class="math inline">\(9 \times H \times W \times C\)</span>。如果我们直接在Attention模块中应用同样的机制，空间复杂度将急剧上升到<span class="math inline">\(N_qN_kC\)</span>，其中<span class="math inline">\(N_q,N_k\)</span>为Query和Key的数量，通常与特征图的size：<span class="math inline">\(HW\)</span>具有相同的比例，带来近似双二次复杂度。</p><h4 id="核心机制1-deformable-attention">1）核心机制1： Deformable Attention</h4><p>​ 具体来说，我们提出了 在特征图中重要区域的指导下，使用可变形Attention来有效地建模tokens之间的关系。 ​ 这些被视为重要的区域是由偏移网络从查询中学习到的多组变形采样点来确定的。 我们对特征图中的sample特征应用双线性差值，然后在将插值后的特征送入Key和Value的映射矩阵中，得到变形后的Key和Value。 ​ 最后，应用标准的多头注意力机制对采样点Key进行查询，并从变形的Value中聚合特征。 ​ 此外，变形点的位置提供了一个更强大的相对位置偏差，以促进Deformable Attention的学习。这个会在第二个核心机制中讨论。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425201030829.png" /></p><ul><li><p><strong>Input:</strong> 特征图: <span class="math inline">\(x \in R^{H \times W \times C}\)</span></p></li><li><p><strong>Step1:</strong> 根据特征图建立全局的网格参考点，网格的尺寸是由输入特征图依据因子r下采样得到的。网格 <span class="math inline">\(p \in R^{H_G \times W_G \times C}\)</span>, <span class="math inline">\(H_G = H /r , W_G = W /r\)</span></p></li><li><p><strong>Step2:</strong> 参考点的值为网格的线性二维坐标：<span class="math inline">\(\{ (0,0),……,(H_G-1,W_G-1)\}\)</span>，我们将这些值根据网格的大小Normalize归一化到[-1,+1]之间。(-1,-1)代表最左上角的网格点，(+1,+1)代表最右下角的网格点。</p></li><li><p><strong>Step3:</strong> 为了获得每个参考点的偏移量Offset，特征图通过映射矩阵<span class="math inline">\(W_q\)</span>得到<span class="math inline">\(q\)</span>，然后将<span class="math inline">\(q\)</span>喂入一个轻量级的子网络<span class="math inline">\(\theta_{offset}\)</span>中，得到每个Q的Offsets。</p><p>（注：为了稳定训练过程，我们将网格点p的振幅用一些预定义的因素s来缩放以防止过大的偏移，具体公式如下：使用<span class="math inline">\(s\times tanh(offset_p)\)</span> 代替 <span class="math inline">\(offset_p\)</span></p></li><li><p><strong>Step4:</strong> 将Step2得到的参考点值和Step3得到的Offset相加，得到变形后的网格参考点Deformed Points。</p></li><li><p><strong>Step5: </strong>在变形后的网格参考点的位置进行特征采样，使用Bilinear Interpolation作为采样函数<span class="math inline">\(\phi\)</span>，将采样后的变形特征作为Key和Value，然后经过投影矩阵<span class="math inline">\(W_v\)</span>和<span class="math inline">\(W_k\)</span>，得到<span class="math inline">\(\hat v\)</span>和<span class="math inline">\(\hat k\)</span>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202601636.png" style="zoom:67%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202654922.png" style="zoom: 67%;" /></p><p><span class="math inline">\(g(a,b) = max(0,1-|a-b|)\)</span>，<span class="math inline">\((r_x,r_y)\)</span>代表z上所有的位置索引。</p><p>​ 因为函数g使得只有在4个最接近(px,py)的点上才会是非零，所以可以将等式(8)简化为4个位置的加权平均值</p></li><li><p><strong>Step6</strong>:</p><p>​ 对q,k,v应用相对位置偏差编码R，然后再经过经典的多头注意力层。单层的输出如下：最后，每个head输出的特征拼接在一起，然后经过Wo进行投影，得到最终输出。<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100345837.png" style="zoom:67%;" /></p></li></ul><h4 id="核心机制2offset-generation">2）核心机制2：Offset Generation</h4><p>​ 先前说道，Offset使用一个子网络进行生成，这个自网络接受Query特征，然后输出参考点的偏移值。考虑到每个参考点覆盖了一个局部的<span class="math inline">\(s \times s\)</span>的区域，为了学习到合理的偏移量，生成网络还需要对局部特征进行感知。因此，具体做法如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100823173.png" style="zoom: 67%;" /></p><p>​ 输入特征先通过 一个 <span class="math inline">\(5\times 5\)</span>的depthwise卷积层，来捕获局部特征。然后，应用GELU激活层，以及<span class="math inline">\(1\times1\)</span>的卷积层。注意：我们没有使用<span class="math inline">\(1\times1\)</span>的卷积层中的Bias，是为了避免所有位置的强制位移。</p><p>其中：<strong>模仿MHSA设计了Offset Group的机制：</strong></p><p>​ 为了提高变形参考点的多样性，我们遵循MHSA（MultiHead Self Attention）中类似的范式，将特征通道划分为G组。 ​ 每个组的特征使用共享的子网络参数分别产生相应的偏移量。 在实际操作中，注意模块的Head数：M，将会是OffsetGroup中Group数：G的数倍，以确保多个注意头能被分配给一组变形Key和Value。</p><h4 id="核心机制3-deformable-relative-position-bias">3）核心机制3： Deformable Relative Position Bias</h4><p>​ 相对位置偏差对每对查询和键之间的相对位置进行编码，用空间信息来增加普遍的注意。考虑一个<span class="math inline">\(H \times W\)</span>的特征图，相对位置偏差应该在<span class="math inline">\([-H,H]和[-W,W]\)</span>间。</p><p>​ 因为我们的可变形的注意力，有keys的连续位置，我们在正则化的范围内计算位置偏差，即在<span class="math inline">\([-1,+1]\)</span>之间。然后，我们对Swin Transformer中的 BiasTable 应用插值函数，来覆盖所有可能的offset值。</p>]]></content>
    
    
    <summary type="html">该论文提出了一个简单高效的可变形自我注意模块，并通过该模块构造了一个强大的金字塔形式的骨干网络，名为Deformable Attention Transformer(DAT)，用于图像分类和各种密集预测任务。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>论文略读笔记——CVPR2022 Transformer相关（1）</title>
    <link href="https://blog.slks.xyz/2022/04/22/1076c1e77e53/"/>
    <id>https://blog.slks.xyz/2022/04/22/1076c1e77e53/</id>
    <published>2022-04-22T00:51:19.000Z</published>
    <updated>2022-04-23T00:41:26.825Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一论文名称batchformer-learning-to-explore-sample-relationships-for-robust-representation-learning">一、论文名称：《BatchFormer: Learning to Explore Sample Relationships for Robust Representation Learning》</h2><p>论文地址： https://arxiv.org/abs/2203.01522</p><h4 id="关键词">1、关键词：</h4><p>​ deep representation learning 深度表征学习</p><h4 id="摘要">2、摘要：</h4><p>​ 尽管深度神经网络取得了成功，但由于数据不平衡、不可见分布、域漂移等数据稀缺问题，深度表征学习仍面临许多挑战。为了解决上述问题，已经设计了各种方法以一种普通的方式(即从输入函数或损失函数的角度)探索样本关系，但未能探索具有样本关系学习的深度神经网络的内部结构。受此启发，<strong>我们建议使深度神经网络本身具有从每个小批中学习样本间关系的能力。</strong></p><p>​ <strong>我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。通过这样做，所提出的方法可以实现不同样本之间的协作，例如，头类样本也可以有助于尾类的学习以进行长尾识别。</strong></p><p>​ <strong>此外，为了减少训练和测试之间的差距，我们在训练过程中使用或不使用BatchFormer共享分类器，从而可以在测试过程中删除。</strong></p><h4 id="主要设计思想">3、主要设计思想：</h4><p>​ 我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。</p><p>​ 对于深度神经网络来说，由于训练和推理的差距，在批处理维度上进行学习并不容易。因此，为了探索用于鲁棒表示学习的样本关系，我们建议通过样本关系学习的结构改进来增强深度神经网络。</p><p>​ <strong>具体来说，我们试图通过在批维度中引入一个Transformer来捕获和建模每个小批训练数据样本中的样本关系，此外，为了减少训练和测试之间的差距，我们在BatchFormer模块之前和之后使用一个共享分类器来强制批不变学习。这样，BatchFormer模块只在训练过程中需要使用，即不需要改变深度神经网络的推理结构。</strong></p><p>​ 从优化的角度来看，BatchFormer实现了小批量样本所有特征的信息传播。</p><p>​ 因此，所有的样本都可以帮助学习任何类别的对象，而这可能会从整个小批量中含蓄地用幻觉特征丰富当前的训练样本</p><h4 id="具体方法与网络架构">4、具体方法与网络架构：</h4><p>​ 设计了一个简单而有效的模块，称为BatchFormer，这是一个即插即用模块，用于探索每个小批中的样本关系.</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422091934114.png" /></p><p>​ 具体来说，骨干网首先用来学习单个数据样本的表示，即在每个小批量中，不同样本之间不存在交互。在此之后，我们引入了一个新的模块，利用Transformer中的交叉注意机制对不同样本之间的关系进行建模，我们将其称为Batch transformer或BatchFormer模块。然后，BatchFormer的输出被用作最终分类器的输入。</p><p>​ 为了满足训练和测试之间的差距，我们还在BatchFormer模块之前使用了一个辅助分类器，<strong>即通过共享最终分类器和辅助分类器之间的权值，</strong>我们可以将从样本关系中学习到的知识转移到骨干和辅助分类器。 因此，在测试时我们可以去掉BatchFormer，直接使用辅助分类器进行分类。</p><p>​ 多头注意层已被广泛用于从Channel和Spatial维度建模关系</p><p>​ <strong>因此，我们认为它也可以被扩展以探索Batch维度中的关系。因此，与变压器层的典型使用不同，BatchFormer的输入将首先被重构，以使变压器层能够处理输入数据的批处理维度。</strong> ​ 通过这样做，变压器层中的自我注意机制就变成了BatchFormer不同样本之间的交叉注意。</p><ul><li>测试时的差别：<ul><li>由于我们不能为测试假定批处理统计信息，例如样本关系，因此在BatchFormer模块之前和之后的特性之间可能存在差距。</li><li>因此，除了最终的分类器，我们还引入了一个新的辅助分类器，既可以学习最终的分类器，又可以保持BatchFormer之前的特征。</li><li>为了实现这一点，我们只需在辅助分类器和最终分类器之间共享参数/权重。 我们将这种简单而有效的策略称为“共享分类器”。 有了提议的“共享分类器”，我们可以在测试期间删除BatchFormer模块，同时仍然受益于使用BatchFormer的示例关系学习。</li></ul></li><li><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220422093222300.png" /></li></ul><h4 id="梯度传播过程及视角">5、梯度传播过程及视角：</h4><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093240599.png" /></p><p>​ 直观上，没有BatchFormer，所有损失只传播梯度在相应的样本和类别。与其他示例相比，BatchFormer(虚线)具有梯度，如图所示。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093454357.png" /></p><p>​ 从梯度优化的角度来看，Li还根据样本Xj(j != i)对网络进行了优化，这与没有BatchFormer的模型有显著的差异。换句话说，Xj(j != i)可以看作yi的一个虚拟样本，其中yi是Xi的标签。</p><p>​ 我们认为BatchFormer和Mixup都可以看作是数据依赖的扩充。</p><p>​ BatchFormer隐式地通过交叉注意模块从样本的附近分布中提取虚拟示例。</p><p>​ 从这个角度来看，BatchFormer通过小批量样品之间的关系建模，隐式增加了每个标签yi的N - 1虚拟样本。</p><h2 id="二论文名称beyond-fixation-dynamic-window-visual-transformer">二、论文名称：《Beyond Fixation: Dynamic Window Visual Transformer》</h2><p>论文地址：https://arxiv.org/abs/2203.12856</p><h4 id="关键词-1">1、关键词：</h4><p>​ Dynamic Window</p><h4 id="摘要-1">2、摘要：</h4><p>​ 近年来，人们对视觉变压器的兴趣越来越大，主要是通过将自我注意的计算限制在局部窗口来降低计算成本。目前大多数工作默认使用固定的单尺度窗口进行建模，忽略了窗口大小对模型性能的影响。然而，这可能会限制这些基于窗口的模型对多尺度信息的建模潜力。</p><p>​ <strong>使用动态多尺度窗口来探索窗口设置对模型性能影响的上限。在DW-ViT中，通过将不同大小的窗口分配给不同的WMSA来获得多尺度信息。然后，通过对多尺度窗口分支分配不同的权重来动态融合信息。</strong></p><h4 id="主要设计思想-1">3、主要设计思想：</h4><p>​ Swin提出将自我注意的计算限制在局部窗口，以降低计算复杂度，并取得了一定的效果。这种局部窗口自我注意很快吸引了大量的注意.然而，大多数这些方法默认使用固定的单尺度窗口(例如，win = 7)。 ​ 以下问题随之产生:</p><ul><li>这个窗口大小是最佳的吗?</li><li>更大的窗口意味着更好的性能吗?</li><li>多尺度窗口是否比单尺度窗口更有优势?</li><li>此外，动态多尺度窗口会产生更好的结果吗?</li></ul><p>作者实验后得出：</p><p>​ <strong>随着窗口大小的增加，模型的性能得到了显著的提高，但这并不是绝对单调的。此外，很难从多个可选窗口大小中选择最佳窗口大小。而不同图层的最佳窗口设置也可能不同。一个自然的想法是将来自不同规模窗口的信息混合用于预测任务。</strong></p><p>​ 基于这一思想，我们设计了一种基于窗口的ViT的多尺度窗口多头自关注(MSW-MSA)机制。</p><p>​ <strong>在DW-ViT中，我们首先通过给变压器中多头自注意的不同头组分配不同的尺度窗口来获得多尺度信息。然后，通过对多尺度窗口分支分配权重，实现信息的动态融合。具体来说，在DW-ViT中，MSW-MSA负责多尺度窗口信息的提取，而DMSW负责这些多尺度信息的动态增强。通过以上两部分，DW-ViT可以动态地提高模型的多尺度信息建模能力，同时保证相对较低的计算复杂度。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422095955551.png" /></p><h4 id="具体方法与网络架构-1">4、具体方法与网络架构：</h4><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100027793.png" alt="DW-ViT网络结构图" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100222424.png" alt="DWM模块示意图" style="zoom:150%;" /></p><p>​ 如图5所示，我们设计的多尺度窗口自关注模块主要由两部分组成:多尺度窗口多头自关注模块(MSW-MSA)和动态多尺度窗口模块(DMSW)。</p><h5 id="msw-msa模块">1） MSW-MSA模块</h5><p>​ 将MSA的多头h均匀分成nwin组，在不同尺度的窗口上进行多头自我注意，获取多尺度窗口信息。</p><p>​ 将每个窗口展开为一个长度为wini × wini的令牌序列，作为MSW-MSA的第i支W-MSA 的输入。</p><p>​ 将W- msa的输出在空间维数上重构为H × W，最终输出维数为H × W × Cnwin。</p><p>​ 最后这些分支的输出在通道维度上被连接起来，并用作整个MSW-MSA模块的输出。</p><h5 id="dmsw模块">2） DMSW模块：</h5><p>​ 这个过程分为两个主要步骤:Fuse和Select。前者负责整合所有分支的信息，后者根据全局信息为每个分支生成相应的权值，完成分支信息的融合。</p><ul><li>Fuse主要由池化层<span class="math inline">\(F_{gp}\)</span> 和 两对全连接层<span class="math inline">\(F_{fc}\)</span> 和 激活层<span class="math inline">\(F_a\)</span>组成。</li><li>Select 主要由两部分组成：<ul><li>第一部分由一组全连通层<span class="math inline">\(F_{\alpha} = \{F_{\alpha_i},i=1,2,……,n_{win}\}\)</span> 和softmax层为每个分支生成相应的权值</li><li>第二部分包含两个线性映射层<span class="math inline">\(F_{fc}\)</span>，用于恢复融合特征的通道维数。</li></ul></li><li>最终还有一个Res的过程</li></ul><h3 id="三论文名称mixformer-mixing-features-across-windows-and-dimensions">三、论文名称：《MixFormer: Mixing Features across Windows and Dimensions》</h3><p>论文地址：https://arxiv.org/abs/2204.02557</p><h4 id="关键词-2">1、关键词：</h4><p>​ Mix</p><h4 id="摘要-2">2、摘要：</h4><p>​ 局部窗口自我注意在视觉任务中表现突出，<strong>但存在接收野有限和建模能力弱的问题。</strong>这主要是因为它在非重叠窗口中执行自我注意，并在通道维度上共享权重。 ​ 我们提出的MixFormer找到一个解决方案。首先，我们将局部窗口自关注与深度卷积并行设计，建模跨窗口连接，以扩大接收域。其次，我们提出跨分支的双向交互，以在渠道和空间维度上提供互补的线索。 ​ 这两种设计集成在一起，以实现窗口和尺寸之间的高效特征混合。</p><h4 id="主要设计思想-2">3、主要设计思想：</h4><p>​ 我们提出了混合块。首先，我们将局部窗口自关注与深度卷积相结合，但以并行的方式。并行设计通过同时模拟窗口内和窗口间的关系来扩大接收域。其次，我们引入跨分支的双向交互(如图1中的蓝色箭头所示)。这些交互抵消了权重共享机制造成的限制，通过为局部窗口自关注和深度卷积提供互补线索，增强了通道维和空间维的建模能力。综合以上设计，实现窗口和尺寸之间的互补特征混合。</p><p>​</p><h4 id="具体方法与网络架构-2">4、具体方法与网络架构：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422205646202.png" /></p><p>​ 我们的混合块(图1)在标准的基于窗口的注意块上增加了两个关键设计:</p><ul><li><ol type="1"><li>采用并行设计，将局部窗口自我注意和深度卷积结合起来</li></ol></li><li>(2)引入跨分支的双向交互。用于解决 局部窗口自我注意中 有限的接受域和薄弱的建模能力 的问题。</li></ul><h5 id="并行设计">1 并行设计</h5><p>​ 虽然在非重叠窗口内执行自我注意可以提高计算效率，但由于没有提取跨窗口连接，它会导致有限的接收域。考虑到<strong>卷积层是用来模拟局部关系的，我们选择了一种有效的方法(深度卷积)来连接窗口。</strong></p><p>​ 在本文中，我们提出了一种并行设计，通过同时建模窗口内和窗口间关系来扩大接收野</p><p>​ 如图1所示，局部窗口自关注和深度卷积位于两条平行路径上。具体来说，它们使用不同的窗口大小。 本地窗口自我注意采用7 × 7窗口，遵循前人的工作，而在深度卷积中，考虑到效率，采用了一个较小的核大小3 x 3。</p><p>​ 它们的输出被不同的归一化层[1,27]归一化，并通过拼接进行合并。 ​ 合并后的特征被发送到后续的前馈网络(FFN)，跨信道混合学习到的关系，生成最终的输出特征。</p><p><strong>好处</strong>： 首先，将局部窗口的自我关注与跨分支的深度卷积结合起来，建模跨窗口的连接，解决有限的接受域问题。其次，并行设计同时建模窗口内和窗口间的关系，为跨分支的特征交织提供机会，并实现更好的特征表示学习。</p><h5 id="双向交互">2 双向交互</h5><p>​ 通常，共享权值限制了共享维度上的建模能力。解决这一困境的常见方法是生成与数据相关的权重，就像在动态网络中所做的那样。局部窗口自关注在空间维度上动态计算权值，同时跨Channel 共享权值，导致在Channel 维度上建模能力弱。</p><p>​ 为了提高局部窗口自关注在 Channel 维度上的建模能力，我们尝试生成基于Channel 的动态权值。 考虑到深度卷积在关注Channel 的同时，在Spatial维度上共享权重,它可以为局部窗口的自我注意提供补充线索，反之亦然。因此，我们提出了双向交互(如图1和图2所示)，以增强在Channel和Spatial维度上对局部窗口自我关注和的建模能力。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422210802291.png" /></p><h5 id="channel交互设计">Channel交互设计</h5><p>​ 对于通道交互，我们遵循SE层[24]的设计，如图2所示。通道交互包括一个全局平均池化层，然后是两个连续的1X1卷积层，它们之间有归一化(BN[27])和激活(GELU[20])。 ​ 最后，我们在C维度上使用sigmoid来产生注意。虽然我们的通道交互与SE层[24]具有相同的设计，但它们在两个方面有所不同:</p><p>（1）注意模块的输入不同。我们的通道交互的输入来自另一个并行分支，而SE层在同一个分支中执行。 （2）我们只将通道交互应用于local window self-attention中的值，而不是像SE层那样将其应用于模块的输出。</p><h5 id="spatial交互设计">Spatial交互设计</h5><p>​ 我们还采用了一种简单的设计，它由两个1 X 1卷积层组成，其次是BN[27]和GELU[20]。 ​ 这两层将通道的数量减少到一个。最后，采用sigmoid层生成空间注意图。与我们在通道交互中所做的一样，空间注意是由另一个分支产生的，其中应用了本地窗口自我注意模块。 ​ 它比深度3 X 3卷积具有更大的核大小(7 X 7)，并且侧重于空间维度，为深度卷积分支提供了强有力的空间线索。</p>]]></content>
    
    
    <summary type="html">此篇略读笔记包含3篇CVPR中与Transformer相关的论文略读记录，可以用于提供改进Transformer的灵感。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
    <category term="CVPR2022" scheme="https://blog.slks.xyz/tags/CVPR2022/"/>
    
  </entry>
  
  <entry>
    <title>2.3.2 经典问题（生产者-消费者等）</title>
    <link href="https://blog.slks.xyz/2022/04/15/ef402168a5bd/"/>
    <id>https://blog.slks.xyz/2022/04/15/ef402168a5bd/</id>
    <published>2022-04-15T03:43:00.000Z</published>
    <updated>2022-04-30T07:58:55.008Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=19</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.3.2节的内容，含生产者-消费者等经典问题</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>2.3.1 进程同步与进程互斥及信号量机制</title>
    <link href="https://blog.slks.xyz/2022/04/13/c34143b1b4b5/"/>
    <id>https://blog.slks.xyz/2022/04/13/c34143b1b4b5/</id>
    <published>2022-04-13T03:43:00.000Z</published>
    <updated>2022-04-30T07:58:53.316Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=18</p><h3 id="一进程同步与进程互斥">一、进程同步与进程互斥</h3><h4 id="进程同步">1、进程同步</h4><p>​ 同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>​ 例如：必须按照写进程然后再读进程的数据进行。</p><h4 id="进程互斥">2、进程互斥</h4><p>​ 我们把一个时间段内只允许一个进程使用的资源称为临界资源。多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>​ 对临界资源的访问，<strong>必须互斥地进行。</strong>互斥，亦称<strong>间接制约关系</strong>。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><h4 id="对临界资源的互斥访问">3、对临界资源的互斥访问：</h4><p>在逻辑上分为4个部分：</p><ul><li>进入区<ul><li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</li></ul></li><li>临界区<ul><li>访问临界资源的那段代码</li></ul></li><li>退出区<ul><li>负责解除正在访问临界资源的标志（可理解为“解销”）</li></ul></li><li>剩余区<ul><li>做其他处理</li></ul></li></ul><h4 id="进程互斥需要遵循的原则">4、进程互斥需要遵循的原则：</h4><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><p>​ 1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p><p>​ 2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p><p>​ 3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</p><p>​ 4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><h3 id="二进程互斥的软件实现方法">二、进程互斥的软件实现方法：</h3><h4 id="单标志法">1、单标志法：</h4><p>​ <strong>算法思想：</strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412173137552.png" /></p><ul><li>这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是Po，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li><li><strong>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</strong></li></ul><h4 id="双标志先检查法">2、双标志先检查法</h4><p>​</p><h4 id="双标志后检查法">3、双标志后检查法</h4><h4 id="peterson算法">4、Peterson算法</h4>]]></content>
    
    
    <summary type="html">包含王道课程第2.3节的内容，含进程同步与进程互斥及信号量机制等内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>字体生成论文研究进度</title>
    <link href="https://blog.slks.xyz/2022/04/01/f225f383e158/"/>
    <id>https://blog.slks.xyz/2022/04/01/f225f383e158/</id>
    <published>2022-04-01T15:09:19.000Z</published>
    <updated>2022-04-16T03:39:19.121Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="a3dd3eece400cd2cedf655680fd51f8166a110fc612c6b7c8de0755375c3f004">1557a4d06c41b8b7cb942a6d0525c027cbeeadc10caf98a45705387558304bb469290ed727bac22c14368bef657fb469dfaa63f24918c0cff3b2760cd4c7e41d903d1a82d66af59312cac4cac46cf8eb876b40a6bca879a6bb5005f2de6cb7700621bad9f290d26f23d98ad7d10aad36bec4e6306e0626ed5b58ff9d6c87b6b9fb9358b7c8663eb4e3f6b73813f33f206cb37ad8174d4a8dec552525d1b17d29a7ff9a69af1c0464d7be2cd47663a8511470a8a9ecf52a3eea3d24def5ef2b867aabfebd01f658d97f48cb62241de8f7a8c19ea8bc92d6c680ec59bc38b048d4a308976e00455157f8a76e5752968a6174c53a18015c2119da1a8f5280dcf70183b2495d28a1d76e15b379546a0b06e6c839ea238fcb28047afe3dbcacff26df81b06af343458ecd208b948b39a2492d48e9642b072c9bfd16ed0cb71ea14f37e75cb08f32c613696c7c4972cb0fb4485bb76c8cb0dc4c3fbbe9c93126e4390a2a8229559bd2c2c6faefceff46203914f2f00652d29fdf010b422e23724088772c9e745cd32593876376cb0a53a040c9e196fe2656eeb704b771fe5475057384f386bb027c4bd1b217ed7001f15d3fdc29fd5181f1fae8ffa2f44c6cc11c2da8959c32fd4a9b3c0062bff9e56396df306d32b348c6e64d0b170d30e8171e18b2d78255d4316693b62691fdfb6a817fe61b1693106c28fccd5ce62b0b0125fd859a8258a078430b4bf7405a514b7773dc08b831140d4f0cc87c8e063d316d264ea95ee263bb9f5cdc91bf30aad5e5a1d714e08baf6f04e7616de3524e57801f1baf7f97870c992a9f3cc3039df01ec0c4275296352a568c1d5321bd4843983cb072df677d45118fd9088bf3b8c00c472d7e46e51154b7b36f57d63fbdc81195af5534e5499fcccc06b591d8eb3371ed5276b41be66ea5f3dbf82a1719259f9120d62d7c013d933d885af7abb62f1705cf99d3bc3c8eee7c175125d4294da1d2de0c91d1631818b17f86b632119fc811c2490464e9f89cbc4e1dac8ad70517617c9d655ec2c5415ff660a847cebc2ebaf0c2f4693bed730c76f1ca6d70b339d56e1fd5d5e150726649ebac0365e0c394a17575fd76323fc5a6d553f5e3d3f52eefb45c116dcb30419816c1d6b4ac4896a2e849da415f1838ec5d74b4be3ec15478e3e590da1d7f06abb166b4dfc49c73e51feaef3fd53fd26fe316a72329ac6238e88d36e3c992b15da7d62c45d062c5c311017e73f99e448c0da49b84864ffe06a036ca0fb7172589beca077aaebccadcd25496b882cab1c263f67cdc4eac7ab3c15ed9dbac2535f179ebb6370202e2d7fa4bcd6365cb7530f584ba62b638770ad3763b47a0ff39d83cfe2054775997d73c6c75314a92f83b0b778ee3cf57f61cf05ebd869e150b5479a50d977b841aace68aecb4e4d02a9f6fd867ea3a88cded5d22d37a0f71ec4938f53af0606d12b7968460ffa2d7801d0880f8cb30457c2f73d5c5038c266274ce360c7c5103f6fa25146e69305beee1ac301138c71e0e639e7bb9acc9740bd36975d389f6604ea7438f567fecf87729acebbf702768cb8835f6c12e2253da46311fccf07f84b3fab625eccfdb951b3a5468167187abbb22765f386d211a15cae350818a718337d26898b29a6c87f9847e439f4c8112741d9d3a4e27cf2393c37b62abe18b2a3f881c4dc0b3234517ab82511ae01c67d5913f66bda910f490ea66d8b886aeac33f6c8cf3915da55d83781dc1662ac812e7f858cef06fcdcc2f460f3fb3d67c962a0fab772ef53eaf175371588430819597cab00f6169595c2cc0086913bebc6797bc8b731164c89ef5ac37e48e364791b430543690cce71dd6bfabf7099c5dee72eef76edcdae324c62c904ac8ad8fcd501cb61a47935b65411a3af7cc8517bc422547f12c508d21c5f4cd1a674a7c5a23e5ab205630e81260ea6929dadca1b04aeefc45c36228d5cf94e1b64ac238173c0378bd3789c08263b90fe69d83ce5125b7d66a580a9116932bd48c79c391de8312844eb1a9648cdbf02e37c2df098ba7e8926d5c71339aed403f4b8089931147eba889298b1c7caa4b25577910adfde5a7259308891f58b7849a6218af1306efa4fb9a9677945003231551e5b209869d416341f7e48e29150fa0b654230c959c521623cec881abd1714c7de102d513817649f0180c315fb06aaa4457e78105cb3b9373c957176dde511e9befd544541b57841635e3c8a367510d575350c85d09b82607e765a03a22b1eea7ef693d775ead21e33b83a6676460e3510cdef839548b3027329d6f8bc2f76e36de3fa3d1700f7172772379d8743fc2eda0bcd44d616f0bd20cbe2791802761a56f994cf9a7446b7856a993fc08d1f888344a5ab76d59c152327c64d2fbe44a4c9bb2db0259b4871255b8e4be4b14e1d4e9ce61525cfeea2e156548c3e4b989e6dfb16c5287af6db48b73332c19583ae24a18e05968ca12b51afa53f5a3e57edd8783a52e5580f9ea2a666a43fbd326b3c488f5a1172fb06476e92d5b96ed9f9cf53f960170030fc010866ace85b70aac65e5db2d48faa0105215e60dbac4df3de47f665a31df0ed079e88bd9a53ae9af23312b301f7c99cd480c750905851ee4cb49b4c758c4edd40b737d475470e9a01250c8935d9dcbb9e5d7507d2344ac31fd87d917531cc7833b60e0e67bb44f70bf25f9d2e4ec2e043978075c7bbdb4c0f74764664da79f7a9304a108323a7fb113ffab07b81e11064e55fa7ccda7942d5422c4660bfdc9dadb08a1019ad532368bed99500b74e377d798237efc64dd25ad571ad4951b7bfa4454b00873e7a20e6b7620db72732ea446d66048d708cb60aa006ba6eb916cde421695a256daf741621fdc13dfa6d9cdc925d21238d051be3413ab06eb6eb7a798cb4b8175b67ef797e78ce75552960cc7cc8f969c079fa0513016d317d539b03fccc2e42c6dfcc5a4776f75fd5b16bacb03d726c5c519beb5a538b7bf34c262e192f314ce264d1decb06a4fa63e2da13628bf57ab2b304f9283245687b3cc8d153ad643f0faf982c76e38089672c7d4bc5aa7787efd0f3178234470c4167d2e0b3296954d4cf0d00a9de0f38573e760062c676dbdef597fe42c577619ac5357b0c4f4c0fe6e46710a93f752c841b8e4af23a96b6fdcb09075bdffbacb2e2d8c2b87fe2a02c50096d42717e737f1c0f1213a8ffeddc0de60d95513f5fb6d3e5fc1b4b2bfa66849a6f33ce04f58feb4dfdac842ec4f66c21873ee61613042083140c6625b7caeb0fef6f42b702150538e3b5dfdaade1166028b94f27007b5323cd30e6ff90fbd179521c42104f7eb9761d6e6904c4c86a6e806b7385cb4ca6c0511ee6ea298dbe9eb45b34ea50a05412af4459250a4fab5e5d148957c6b5ed047b7e3291d4bbbf4c9f43a63707b474fcf87134537f73f1761f02ffcf67e5355000802691b61bb4a27f5b4e306370f9013a86d950bc8517d7ca30f1286854dc00a41478c21bb6ac28c217851b0e477507d5685991a5de31b24827bf6c005af7e8af26e51e820d29e535e9b2d6fb8d15ac9d2fd7c2cb612d00ce229f604f8e09a7a80896da84e88dd51c46f77f6600127a8ce16046516dc5472e3e5ed714c90f691c94150f974ea47e4779dd4b19c5f66aceadb4b66a0886d7801dbc01fa171591c3fa0f67696ee1192665e0c3a1805f3dba44b69c8ac1784abde6f86f131defc3cc13bc9ae540acf17d1a76a0e4adb1efe598e6274f58f64e5072d3e172e6647023b64faf12ed9996d22d371148511e45a4768c2b41c6fc0c1be4c36cd07ee15137e6c401c1bc26f3fc6436e3f1c9ecfdb2a18649ad0006c91621abf05a7c3391188634ae0ca51726ff7c624768a12a285c300474c1b2b662a841d8f4f3792422d22dda890972b6b4f4679638678342f686ba0f59afcb865920073c9efb87991e2b521aa0c83c5bfc364bb5e4d16d26eaaa67841c2d6843c992267a97b56ee7049f0088e42619585d1b554bf563ae787646fbe963064a095bc6151c49a10622844ba56eb3f29035d3aa4a038ff64d5b1db16a222f9f62d903715b430cccb7787fa53707ee76fd83858e21ca9b89d00a68c64639be659078d45c67fccf27f7d17ee72698da26745bbbd8a22701246a0c6dd329816f84a52963305b054909d5ad55dc64175e32c7236473e9289c7af7714d884247bb091ab3370a526108a42f31c4614a35168228351e53fe53603e79e9b5f920b24fd0aa89b9429a5eb6602b98986bc9c7c867f690b0b641ba5acd519e274716d59d5d46f5af19e1e7f5316b24593c4d54bda29b6378bb7949d667b45c0d63abb1b2d916dc7d9ef283feb20f27daee2e9022385df43183a2d4b498dbf7eee4258bf630095c1d9ad4e1f27dba951422a06847b43fe828047efe6edbd671a1f62b085a5f42cdd7fb687addbd30c65eadd08c65678e65a5916b24c01ef30cced172e2b0ccad8424ba12f1e72ad46d8433e1c738a5e64ec189255151a551c844b8d14e763c8369581f81a1bd41234c98b8aeb89b3e1f15385ef3614670ee22168499704c05469e03c421a81537b052c19e282582235965abad795ba0f7ea388b5002508c5f3e4bde89fe1809a3bd834e1429ccb2aa0855a040bf31c7f904b5793ce82b23501e4b4502980a84097346f33e47bef6a81b9eb823511e9ccbdba995f1a977dba75069e8ffca38c251761fcf1dbf0e44f6497b9d54ad40be2e7e772ca8c8b2a0fc5e22e4c338023ec592cf9078d103669c0b82cd6393a7044d0dd1543d8c2962706f8f9ad12f29078e0d438486f29c299d78aee4577f82c92504e32d7ae425c778eded66fba0d1e2dec420bc65ba19a08f2145c17bd5b363d638a5ede1922971eebf013e20304b29db4f25d69c71065ba6ff157b6c4bb0c5b455def3defecbcb00913d7acc6f01fd86179e0229150745ce74dd707a5f23c05e4d9e0031380fdbb806fbdc25dbb32add3252104b7c8c8ab7a03c72c7e90e3cc14f7cdcacdc3b853e606bc40798b574bed25c8dde9943ed62f1f20a8e350270ea816501e1821414344a968faf118480c8dd20c9c25a28d4531494b4adcc4c95b8d8aa93652c87a7af070bf76a1df6672656db1e1955b2b7be033ea3556ab84a936a868e10cbdcb69ce1245cbb181457e63a8ce2dbbe384c2e94ea9b9315c438b2f5ba355e7b97984483414d30105af960fd60fa66ba713cb442990ba46fd8a67edb06a610f2070a2880c717b721a401309b7e4f3d8be69d3a464411ca2903daa4da20beddb0f73966205cd125cea7f6e86732b684dee1058fab67195999994a4b4e680f96b78c5e96d0ce9dd098183da7487623bc996cdf699f982d07f2f6ef1dac852c6ddfc9070e630f0d0d62e293c1f1a10419a56a3ee88d3b8836e6e9944d967d5741a18e68268688802fc6873813437eff3724a6b9d45a47c4441fff5af6b5b3919402d0d57c98007acdd61f5c8d6bf9a9e203defac6bd7f016d663ccf4dac401064d0a648b5d0e772566323c2e7fff9d51d51336ac98eccc175a7575e84a744f957c6492ad76708ad18921d6b1d73978ce763ecf36e61c32bf7a6f183b19e278e1dcd532541cc0bb986a397ac83930dd464e78e3cf21759dc2e4c4ebd815da48656e0e45a83036cd1225abc5bdd346246b365df179c447a414b0780bc9b96489dc186b7c9778263718b26e724de9b35c0075308ffcb8535a04074d83129c2935aaffb611a60657af65524be4534e263485c7bc2db440525a76b824c78bfe79c28adb3ffbd88ceab7539f338bae63a5e799145785295d7bd77bc2a1570dbd99e8ebe73030a683d943c4f2797b0377726a7ab08556e5ec482cad66e3bc24a84a7cffb29896107db7dabc075c7de36cd4688892c086dead71f0b7d76c6d5afe2f9b9c52c02f038b926723c6f4e08bd6abab0526d7539eb4839034f8ee6a93cf7d4c69bcab7dcf661d8a1f18df2dce91d378a6285ca85b4c951e85ec74e2a66f6ff145da79952ea8f1923b0acf56d65f4b750e45e56a8bb1a5f13a0a4adb7557e3706556c668e0794e9d5cc11722de458e7f0d4c1b3b8ec6820476595adf78e052d79e005a53d0ae0397e1bdad14107b29c6a2f88c03d6c1dd8cbdc01c518b1df19cfdd4f5d9ff311b5689551b8e8d47a26bf26091db9d3e0b940eb7a87069fc7fdeb76e1c473b58b99af5898a48fbbdc88b2875129d5802cf210126c082c1fd051c58374e16388ba197a6d4f444bd623718fc5028c835d182be3ce5c14f279c63082238102afb69f8b738755516dccaa902994da04de646bad28f7bc2d72ca5e2d45872d81561f2b8b2c08d8b61ce3a75e78bed293d3282a495927c1d9e656dd7e5d507d7f8ff798a4456943e1d9366710eb0bc3e8767661986e9df77e923d85ec7ecaf599fa8a323258bd73f34d6ea21b48f834ec35f92129115d65657b53bb4d36c0eb66533bb6f4fc05440edd66a3a5d3609c590a624a88916a26949a14615cfc596498ab811c8e62e6c69713bb4373ac1083937c4b80cbbc9064b7c93e5edefc808be91a1d289de244a5bf9a15a15d05c59ce98f5032879a01d74eb87608d4315c2718608ca6da160672895474800adddef16c0d472fa9c9e93a206080f89b4b9e5f55d9dd89e9a984f64c3d273d00985adb296e8306b34e136309d8ff058eab20a3f2dfa701f1e93a8c5056b51854ca99d9828f90b48c7ccc8c700c7dc54b684a445de51cad1f91d14bedec404e4cc84f2b8b3d26fdf27e988b37f8a3cd484ba0d3902933fe61ab331256f4662d306518b5240217ae0864d128e95912477da8f19cde2610c6e7c58e710a33c0615c11b51b56a6234f4c4cc6a96f2b1f03d3e3ae205b9bb412a72d60516d70a26a6b0a2c3977a8e669044585f4d8e1714b693bc9caf07be9fd9455911ed8e7dd3055a9fbfc338b203a5cb4858077b3ec3f119904babb12ee64d107e468669ca4128260f537cfb761694dbc26fd094a68b4d11aabcfce4f77d440f383b7efe5f89731a9387cd8e1d3027b36ddc9e6b2d59f0ed4e167ef5a7eaef03dbd508090f8795bf2eedd3d3155dd641229f8b456fe945351ae4b8f4367b73b76f8f1aa9f8c438c89c2567d60cbf700c84b13d94824e213efe5f9e108ec29c89daa6980df2ef73bf45f349ce1b0745a3d9785fc14369ea2ed626d00ce96d5860847291e2d64c68c1344fec51188bbcf3675b6f201441255fe9b080a4baba2de6a05816479d3668e7e02be0d69c7172aa772cf1bb0b358768ee353c0c93ee181c6df0d24ff593e842d6c344882a0c41d0a66bbbfe4c314474d1b41e75c20b03cebdbaea8d2aa1effaabaaa175c1b8f0a1fe76b84fb0eb080d5184cbe3fff09dee31bb787d066d99411c76e9f6e7428a767b9265a4859a882b920d9f7b8edb0fc1a8a56bf1bc79077296ec9944db2eb04e18af87e1ad47f59ca80b4d2d6b8c2fd07add1fcd783495ad5c36aebad38bd324dce3bad4975e0563edc2863dcadedf071fa6e14a06e2afb6bd29ec09e1d1e27f26eba064d29cff609c40f1b122460ad981c751ae375166de7f1d749ff43f58c2779dbcd5883b2ae69f2fc861b85e540c6ec2afc391ea1b4d1874ec579087ff9ae2238be3b1cfe9eeb711f24db8fdbec953c421d3272ad866da84e2011cfa5f8330f1b5fb861f29b884c195c6887501d7be8bf375b53e77f4acc9bd964b2b073207d9e3aeddbc099aa620723e7fe2a94fe3d5e67b5a0bd4ece7855d726493216962ab255a46a84bf1d18022eb79b4ed952c7242077882a14ec7948fc2c2ae6657e1f02673d59bfb69d3120c70fc53196f28437e7c0962b0e6721d4a1d46ec8a230091b52c48b40248f3b3eb6b00d6152953df24fd77b35310d910bef8ac0448ec8d2d57f39387c66828d5663aafd753ff94c06c4626b2a396712889a2d067ac3c2acd15a0ae0aca53b54e38a46bd4d057b9ededf2c19a2cf0f0125e6610a33fda2659e4ea5fa2f118d36b31812bb2a7d51cbc656d783b297f120c3358f1c4163abf2da269c696c3c50d85307d7d0df16938ced5b378e5a061e2a28d8de43f31153fde807b9a93296288c2b251df8137661a4d0a85c09366e9aded2481a50a2319087c124bbd25b789f0e202c649fcf66de537e896fa0175161bc5e98e5783716515f118fa1cbc9e7c53e936c338a62e8c34d34354ac900a16e5593f92eb1b35fe21f976b16d06d1ac2de547b3ed63d99c74724282a84403f219056a68be4cb490806fbaf7676bf6ab1c4ff8c7beed62fb6cc02f6e4bfc0fab1ddfb095e1508035147178d35a28d13b481603d148ac96f55b5fce7f0cdb5896c3b64fa859cff3900b4a6427a13c98aa93cb5ad3feece366a4c017827bb7a7555b856c7f9e27e9785cc004b7f0cb65f41d0010547d45e5c5e5b08134ec00bc5a0605929e464024c636b796d38f554803f1ff5d22dc14c7d14bae188b5a3c00f45d1199bf778864ef979904073d1980213520f2b84f7eca2d3cec5e9de5ce7befa67950c133347ae38539ea01013bd9dd58368ca64e15a92fc73579a504afbad0105f04fd7c3b51d1c389ae68be8dbb51e6e9128b485f0e59c2a442ab6198264595aebceb702fd606788f8cb038d9b69214668a31bccb57dd85e67ce53c79b14123d400ca12324439268bb258ef47c1cb9ecdc2e571cbd2f9d0df1c8e83214023dd682cb3152f9b7d0a232d9c019993a3336598d4bbe20f35b8c85599749acb41eff48d1be4971576757e0d7e3d5fb92a3eea7e9797c1c4a59a5111a2e7c29506f76e021d45b8b7992eb33f63187b074067f43a4c2454f5eea14908e501ba942035515460eff9671d55baf64c730165d06c501137ccb01fddbb169f4e10678bb8948cab6bfb10b3a6fbc954b484aa94c4249fbb50e0a0748643b3da7a8fb74f7d7380d98d4e835ff2579e07a30538022a7f89420ddaae350f4eb1de3fb55ea4ef60287abadd82508dccb2fd772ed47e7969204b9f2b94f95f068a76c107c8593fadbd1347d89a6f928c64b6887c0e5d82d61e4075e83960668902c1249acc1e2be9f7c67a413f8aa8af329b821a9470f75c1ad868b30f497e52fa5b22059537a12de4c2713a7392df03b74f7e7629c85e8366edc52d6f3ed8d23e0645ee0f45b6ee30353d444b52bd28971a376c1ff05982643e59f679d17cf57d0965cdaf19c11cbde5a28e9b6e59d208661a164a76bfcfe1a030ca9bee379420adaa559a0bdc997e8dfd84ab51d9b8106994f904c59fdf34a5ff90f6f49cda92dbe789ea76ddb79d16cdaafb49911c484a49dd57a3b5556c80ccfd566fd813547af9c0e2bc48c23687d1101082e38b98c79c96aeb6c6e0a957012290f2d98f07e8586bc1bc69bf1097af9af1fc91148fa5302367226ca93a32aef0d9f6257db88e44453d701a07cf40e36a6af7fdcaca21cb817000da33a6e455813358546dd1204e7f11cc088672d26a60b2ad4aa00afa75711d455ac3e56df4402fc223f6b6eeeae8f90f90e166fb6c653fa84f933605db5980fd48e0775d0d9b98ac5a64bed75763712cd396e528d04481d46d59fd3ed898dabc23eb57b5e6b218a8ced69b3aa73aa9823e1d27dfcb1630de213db96efad0b3c3c7a431d59c58db928f7fc2ffdd64025f726beeeb01825236b0fe86e45aba00bcd57e27875ef043e815e18711c6d392b8fea668d683447d1a32bef5911dd336174e5a6c9b41a9ac6ab3829f54c6ab997e2655b3a14bad0ebdb34eb41f092b68ac4743f970fbc4b60b2363619b87c3b55a1faa746fab3ff4ed3ae88e8a156cc12fc264c519dc52eab42a7f1e97176af80b9f3def385fd23fecde3f9e5da2678b83b3a036f5fec7b390395f8c6455109e71503c5e7846a9fb78c2d5903beb3e9ae98145d5d90d2f3b6190ad2215facb2f9dc2f3b821c7db6189c6f5ffd8a4205000b041287cefb4941c0e1137c3b07773fe489a34b7823d005628c4cda70c7265331bf4b34cb332b4bed679471d30cdbdf06219989f20c7536dd7449dac9f00c48bd592e577e35bb9286e7f035e601fb2c051d5710292e6eb464cbe27efad53faeb80509c4c243ae2fa8eadf72a6a3907242f2ad9f21a54de5c37221765bb2db59bf387151885fdd894a76faecf192d4dc5c1c883e0cb7d30cd2410dffefd1de856ec68486c105eaa687b4bd36b64bbefe75095bcda501d1321e4e16a0ed4270853c316a76c25e37ffbb614f21527a50d58b0e86c05acb22f7ec151773fcb213ed3071e8cd0a4ef1210a82fbde4dac6d3366b41eac3ecfb330cad6d5d5c0c598f47d133d30bf50a656a112d2c6bd68c3a42be3b15a72d85b9338a488f42a93ab7b01dbc1e8afc1f841516120710c182659043a1b6b9de27d7431da0267667067c213e5165c36458741360bfc864c51a2e4f05756120631148436cb055d91fdaefae34322f2625d3b96017352d031f70366bae75e05da41d589d50b0a6c1f3d1ed9c9b11c32126a75bebc6985a6cbb0dbab41b89ad47268689074fea47cc0ec9a5fa106c2805d65482ef38f1fbc7a1418a5cbbfd810d0be7a8ee2072fe60d202ade80e17aa73139577510fe74c200d8732fcb9f17e5c074f503bdcf2e6e05bcbbb1ddff8309ff991685f27cee04ab79e1cf387f0dc81937bd324a1eda97e49814331713ab4fd6eab7be816a77cdccfdf287ed4f903f8ccf9900e64fe7d1b0255e4c955277e53d35cab27cbeb97eed55280878faab52e7ee8017771f6b36ef3f5c1760122b83707ba5c8d6006e66294ec700fea51c270aa0867cf1f5233349f79ef92725285844612cfe129dec56a689a5b31d6b111925c7e58e5b3685d01e5d1d365c2b4ecbca823092522cfe9d4595fea36782c77471a70fe739464f9d67b013040ceac14f54f33badf024fe1141f6838f26a0bec96416b7e7c7a301f030b08518b4a48567414601f7e1e66cf4c3b983735f756f4d635ef4b3d6cabe368d444161989909ea95530e4b5a93dfc1fa3cc2699da07cddcb3b7713995d4da145e894d594654aacf9e5c19da733cd86661fee07fd11b5f3b22129a5291b7874d00b0d2471f6148bd6c59c9aea2d03277fbd5bd525f9c84965442e4f5e6eabf353d69b48509b0fc1b507fcbed93fdb4d4ec658809c68e6a89fd0d43fc2bf8687b8c8cb23489bedbf6afc8aaf81dbb4d63c2fc0f0d0e6f8da800a6a119338bf48d266b94122a76852f582438220ac009d792b302a2bd898bef875a5a2f01b54a09ecfa78b9ac13e73ff09d8c37aa77881419d74c46a2a0cc2ae6aed4f89a73cab216f3c82</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">里面包含了字体生成毕业论文研究进度及讨论进展记录</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
  </entry>
  
  <entry>
    <title>GPU占用清除</title>
    <link href="https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/"/>
    <id>https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/</id>
    <published>2022-03-30T13:47:19.000Z</published>
    <updated>2022-03-30T15:27:05.866Z</updated>
    
    <content type="html"><![CDATA[<p>当服务器上的显卡如果被奇怪的进程占用了，但是nvidia-smi并没有显示的时候，可以使用如下命令清除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">描述了GPU占用清除的命令</summary>
    
    
    
    <category term="⓺ 工具使用类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BA-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="GPU" scheme="https://blog.slks.xyz/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记12——分布式DDP基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/29/5a94914aa20a/"/>
    <id>https://blog.slks.xyz/2022/03/29/5a94914aa20a/</id>
    <published>2022-03-29T08:48:19.000Z</published>
    <updated>2022-03-29T12:47:42.430Z</updated>
    
    <content type="html"><![CDATA[<h4 id="node">1、Node</h4><p>​ 物理节点，就是一台机器，节点内部可以有多个GPU(一台机器有多卡)。</p><h4 id="rank-local_rank">2、Rank &amp; Local_Rank</h4><p>​ 用于表示进程的序号，用于进程间通信。每一个进程对应了一个rank。rank=0的进程就是master进程。</p><p>​ rank是指在整个分布式任务中进程的序号；local_rank是指<strong>在一台机器上(一个node上)进程的相对序号</strong>，例如机器一上有0,1,2,3,4,5,6,7，机器二上也有0,1,2,3,4,5,6,7。local_rank在node之间相互独立。</p><h4 id="n_nodes">3、n_nodes</h4><p>​ 物理节点数量</p><h4 id="node_rank">4、node_rank</h4><p>​ 物理节点的序号</p><h4 id="nproc_per_node">5、nproc_per_node</h4><p>​ 每个物理节点上面进程的数量</p><h4 id="world-size">6、world size</h4><p>​ 全局（一个分布式任务）中，进程的数量</p><p>​ 每个node包含16个GPU，且nproc_per_node=8，n_nodes=3，机器的node_rank=5，请问world_size是多少？</p><p>​ 答案：world_size = 3*8 = 24</p><p><img src="https://img-blog.csdnimg.cn/20210811144558161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h4eGp4dw==,size_16,color_FFFFFF,t_70" /></p>]]></content>
    
    
    <summary type="html">PyTorch 中，关于多卡多服务器进行分布式训练的一些基本概念</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Pytorch系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Pytorch%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记19——EMA指数滑动平均原理</title>
    <link href="https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/"/>
    <id>https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/</id>
    <published>2022-03-27T01:44:19.000Z</published>
    <updated>2022-03-17T02:36:22.859Z</updated>
    
    <content type="html"><![CDATA[<p>​ 在训练神经网络时，通常会使用一个叫 Exponential Moving Average (EMA) 的方法，中文名叫指数滑动平均。它的意义在于利用滑动平均的参数来<strong>提高模型在测试数据上的健壮性</strong>。</p><h4 id="一什么是滑动平均">一、什么是滑动平均？</h4><p>​ 滑动平均(exponential moving average)，或者叫做指数加权平均(exponentially weighted moving average)，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。</p><p>​ 首先我们假设一个训练参数a，它在不同的epoch结束后的值分别为： <span class="math display">\[a_1,a_2,a_3,……,a_t\]</span> ​ <span class="math inline">\(a_1\)</span>代表第1轮epoch迭代结束后，可训练参数a的值，以此类推。</p><p>​ 然后，我们假设不同的epoch结束后，滑动平均的值分别为： <span class="math display">\[ mv_1,mv_2,mv_3,……,mv_t\]</span> ​ <span class="math inline">\(mv_1\)</span>代表第1轮epoch迭代结束后，滑动平均mv的值，以此类推。</p><p>​ 滑动平均计算的递推式如下： <span class="math display">\[mv_t = decay * mv_{t-1} + (1-decay)*a_t\]</span> ​ 其中，decay为衰减率，用于控制模型更新的速度。递推式中其实就是利用加权的思想，把新的a和先前的平均，做了一个相加。我们可以发现，再很多轮之后，有些离<span class="math inline">\(a_t\)</span>很远的a,它已经乘了很多遍decay，相当于权重为0，也就是不影响最新的<span class="math inline">\(mv_t\)</span>的值了。</p><p>​ 从直观意义上来看，我们可以把<span class="math inline">\(a_1,a_2,a_3,……,a_t\)</span> 看作是t个位置，然后想象有一个长度为k的窗口，从最前面开始向后滑动。为了方便说明，我们先假设k=3。最开始的时候，窗口把<span class="math inline">\(a_1\)</span>涵括在内，然后一个epoch过后窗口右移，现在窗口内有<span class="math inline">\(a_1,a_2\)</span>，再一个epoch过后窗口再右移，现在窗口内有<span class="math inline">\(a_1,a_2,a_3\)</span>，再一个epoch过后窗口再右移，此时由于窗口长度为3，所以<span class="math inline">\(a_1\)</span>就不在窗口内了，窗口内的元素为<span class="math inline">\(a_2,a_3,a_4\)</span>，从公式上来讲就是在此时，由于<span class="math inline">\(a_1\)</span>已经乘了较多遍数的decay衰减系数了，所以其的系数接近于0了，不会再影响窗口内计算的值了。</p><p>​ 故此称为滑动平均。</p><h4 id="二更为公式化的解读">二、更为公式化的解读：</h4><p>EMA 在实现时如下所述：</p><p>​ Exponential Moving Average 对每一个变量（ <span class="math inline">\(variable\)</span> ）会维护一个影子变量（ <span class="math inline">\(shadow\_variable\)</span> ），这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会更新为： <span class="math display">\[shadow\_variable = decay * shadow\_variable + (1-decay) * variable\]</span> ​ 其中：<span class="math inline">\(variable\)</span>为每一轮结束时，训练参数的值；<span class="math inline">\(shadow\_variable\)</span>为影子变量；<span class="math inline">\(decay\)</span>为衰减速率。</p><p>​ decay 决定了影子变量的更新速度，decay 越大影子变量越趋于稳定。在实际运用中，decay一般会设成非常接近 1 的数（比如0.999或0.9999）。</p><p>​ 为了使得影子变量在训练前期可以更新更快，Exponential Moving Average 还提供了 num_updates 参数动态设置 decay 的大小。如果在初始化 Exponential Moving Average 时提供了 num_updates 参数，那么每次使用的衰减率将是： <span class="math display">\[decay = min\{decay,\frac{1+num\_updates}{10+num\_updates}\}\]</span></p><h4 id="三什么时候用到ema">三、什么时候用到EMA？</h4><p>请注意：</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ 在训练过程中，EMA只是以一个记录者的身份，在进行记录。实际的实现中，如果你在正常训练的网络是network['C']，那么你可以再实例化一个新的网络，叫做network['C_EMA'],其最初和network['C']一模一样，但是network['C_EMA']并不参与实际记录，其里面的参数只是用来记录滑动平均！！！<strong>（这就是DG-Font代码中，network['C_EMA']的作用）</strong></p><p>​ EMA作用是<strong>使得模型在测试数据上更加健壮，有更好的鲁棒性。或者是最后save模型时存储ema的值，取最近n次的近似平均值，使模型具备更好的测试指标(accuracy)等，更强的泛化能力。</strong></p><p>参考：</p><p>https://zhuanlan.zhihu.com/p/51672655</p><p>https://zhuanlan.zhihu.com/p/343210667</p>]]></content>
    
    
    <summary type="html">整理了EMA指数滑动平均的原理，以及pytorch训练中的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="EMA" scheme="https://blog.slks.xyz/tags/EMA/"/>
    
  </entry>
  
  <entry>
    <title>2.2 处理机调度及相关算法</title>
    <link href="https://blog.slks.xyz/2022/03/25/9887f629bb62/"/>
    <id>https://blog.slks.xyz/2022/03/25/9887f629bb62/</id>
    <published>2022-03-25T12:40:19.000Z</published>
    <updated>2022-04-30T07:58:51.448Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=13</p><h3 id="一处理机调度-概念与层次">一、处理机调度 概念与层次</h3><h4 id="调度的基本概念">1、调度的基本概念：</h4><p>​ 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>​ 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</strong></p><h4 id="调度的三个层次高级调度作业调度">2、调度的三个层次—高级调度（作业调度）：</h4><p>​ <strong>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</strong></p><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度是辅存（外存）与内存之间的调度。</li><li>每个作业只调入一次，调出一次。</li><li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li></ul><p>​ <strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</strong></p><h4 id="调度的三个层次中级调度内存调度">3、调度的三个层次—中级调度（内存调度）：</h4><p>​ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。</p><p>​ 等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量。</strong></p><ul><li>暂时调到外存等待的进程状态为挂起状态。</li><li>PCB并不会一起调到外存，而是会常驻内存。</li><li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中。</strong></li></ul><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</strong></p><p><strong>注意：</strong>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p><h4 id="调度的三个层次低级调度进程调度">4、调度的三个层次—低级调度（进程调度）</h4><p>​ 低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>​ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><h4 id="三层调度的联系和对比">5、三层调度的联系和对比：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326111647450.png" /></p><h3 id="二进程调度的时机切换过程与方式">二、进程调度的时机、切换过程与方式</h3><h4 id="何时需要进行进程调度">1、何时需要进行进程调度？</h4><ul><li>当前运行的进程主动放弃<ul><li>正常终止</li><li>发生异常而终止</li><li>进程主动请求阻塞</li></ul></li><li>当前进行的进程被动放弃<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><h4 id="何时不能进行进程调度">2、何时不能进行进程调度？</h4><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难 做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区</strong>中不能进行进程调度。（但是进程在普通临界区中是可以进行调度、切换的。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ul><p><strong>注：什么是临界资源？</strong></p><p>​ 临界资源：一个时间段内只允许一个选程使用的资源。各进程需要互斥地访问临界资源。</p><p>​ 临界区：访问临界资源的那段代码。</p><p>​ <strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p>​ <strong>内核程序临界区</strong>访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p><h4 id="进程调度的方式">3、进程调度的方式</h4><p>​ 有的系统中只允许进程主动放弃处理机，有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><h5 id="非抢占方式">1）非抢占方式：</h5><p>​ 只允许进程主动放弃处理</p><h5 id="抢占方式">2）抢占方式</h5><p>​ 当有更紧急的任务需要处理时，会强行剥夺处理机（被动放弃）。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操停系统、实时操作系统</p><h4 id="进程的切换与过程">4、进程的切换与过程</h4><h5 id="狭义的进程调度与进程切换的区别">1）“狭义的进程调度”与“进程切换”的区别：</h5><ul><li><strong>狭义的进程调度</strong>：指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，</li><li><strong>进程切换</strong>：是指一个进程让出处理机，由另一个进程占用处理机的过程。广义的进程调度包含了选择一个进程和进程切换两个步骤。</li></ul><h5 id="进程切换的过程主要完成了">2）<strong>进程切换的过程主要完成了：</strong></h5><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p><strong>注意：</strong>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h4 id="调度算法的评价指标">5、调度算法的评价指标</h4><h5 id="cpu利用率">1）CPU利用率：</h5><p>​ CPU利用率 = 忙碌时间 / 总时间</p><h5 id="系统吞吐量">2）系统吞吐量：</h5><p>​ 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间</p><h5 id="周转时间">3）周转时间：</h5><p>​ 周转时间，是指<strong>从作业被提交给系统开始，到作业完成为止的这段时间间隔。</strong></p><p>​ 它包括四个部分：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li><li>进程在就绪队列上等待进程调度（低级调度）的时间、</li><li>进程在CPU上执行的时间、</li><li>进程等待I/0操作完成的时间。</li></ul><p>后三项在一个作业的整个处理过程中，可能发生多次。</p><p>​ 平均周转时间 = 各作业周转时间之和 / 作业数</p><h5 id="带权周转时间">4）带权周转时间：</h5><p>​ 带权周转时间 = 作业周转时间 / 作业实际运行的时间</p><ul><li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多， 带权周转时间更小，用户满意度更高。</li><li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</li></ul><h5 id="等待时间">5）等待时间：</h5><p>​ 等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><h5 id="对于进程来说等待时间就是指进程建立后等待被服务的时间之和在等待i0完成的期间其实进程也是在被服务的所以不计入等待时间">对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/0完成的期间其实进程也是在被服务的，所以不计入等待时间。</h5><p>​ <strong>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326114401542.png" /></p><h5 id="响应时间">6）响应时间：</h5><p>​ 响应时间，指从用户提交请求到首次产生响应所用的时间。</p><h4 id="调度算法-1">6、调度算法 1</h4><p><strong>调度算法的重点</strong>：</p><ul><li>算法思想</li><li>算法规则</li><li>用于作业调度还是进程调度</li><li>抢占式还是非抢占式</li><li>优点和缺点</li><li>是否会导致饥饿</li></ul><h5 id="fcfs-先来先服务非抢占式算法">1） FCFS 先来先服务（非抢占式算法）</h5><p>​ 主要从公平的角度考虑，按照作业/进程到达的先后顺序进行服务。</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li><li>非抢占式算法<ul><li>优点：公平，算法实现简单</li><li>缺点：排在长作业后的短作业需要等待很长时间，带权周转时间很大. FCFS算法对长作业有利,对短作业不利.</li></ul></li><li>不会导致饥饿</li></ul><h5 id="sjf-短作业优先算法-非抢占式算法">2） SJF 短作业优先算法 (非抢占式算法):</h5><p>​ 追求最少的平均等待时间,最短的作业或进程优先得到服务(指 要求服务时间最短)</p><p>​ <strong>[每次调度时选择当前已到达且运行时间最短的作业/进程]</strong></p><ul><li>用于作业调度时，称为 短作业优先算法</li><li>用于进程调度时，称为 SPF 短进程优先算法</li><li>SJF和SPF是非抢占式算法,也有抢占式的算法: 最短剩余时间优先算法SRTN<ul><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li>可能导致饥饿,如果有源源不断有短作业来</li><li><strong>示例1:</strong> SPF 算法<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092135300.png" /></li></ul></li><li><strong>示例2:</strong> SRTN 算法( 最短剩余时间优先算法 ): 每当有进程加入就绪队列改变时就需要调度，<strong>如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，</strong>当前运行进程重新回到就绪队列。另外，<strong>当一个进程完成时也需要调度</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092403526.png" /></li></ul></li></ul><h5 id="hrrn-高响应比优先非-抢占式-算法">3） HRRN 高响应比优先:(非 抢占式 算法 )</h5><p>​ 综合考虑作业和进程的等待时间和要求服务的时间,在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务. <span class="math display">\[响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}\]</span></p><ul><li><p>既可以用于进程调度也可以用于作业调度</p><ul><li>优点: 综合考虑了等待时间和运行时间,对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题</li><li>缺点:</li></ul></li><li><p>示例1:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104029587.png" /></p><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104019832.png" /></li></ul></li><li><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104148079.png" /><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104351880.png" /></p></li></ul><h4 id="调度算法-2">7、调度算法 2</h4><h5 id="时间片轮转算法抢占式算法常用于分时操作系统更注重响应时间">1）时间片轮转算法：（抢占式算法）【常用于分时操作系统，更注重响应时间】</h5><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>一般只用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li><li>由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到。<ul><li><strong>优点：</strong>响应快，适合分时操作系统，不会导致饥饿</li><li><strong>缺点：</strong>由于高频率的进程切换，因此有一定开销</li></ul></li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412111910996.png" /></li></ul></li></ul><p>​ 如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>​ 另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h5 id="优先级调度算法抢占式非抢占式版本都有常用于实时操作系统">2）优先级调度算法：（抢占式、非抢占式版本都有）【常用于实时操作系统】</h5><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/0调度中<ul><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。<strong>另外，当就绪队列发生改变时也需要检查是会发生抢占。</strong></li></ul></li><li><strong>优点：</strong>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li><li><strong>缺点：</strong>若源源不断地有高优先级进程到来，则可能导致饥</li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412112408359.png" /></li><li></li></ul></li><li>通常：<ul><li>系统进程优先级高于用户进程会得到提升</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好I/o型进程（或称I/o繁忙型进程）</li><li>注：与I/0型进程相对的是计算型进程（或称CPU繁忙型进程）</li></ul></li></ul><p>【由于I/o设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p><ul><li>可以从追求公平、提升资源利用率等角度考虑<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul><h5 id="多级反馈队列调度算法抢占式算法可能导致饥饿">3）多级反馈队列调度算法：【抢占式算法，可能导致饥饿】</h5><ul><li>对其他调度算法的折中权衡<ul><li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li><li>用于进程调度，抢占式算法<ul><li>在k级队列的进程运行过程中，<strong>若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，</strong>原来运行的进程放回k级队列队尾。</li></ul></li><li><strong>优点：</strong>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/0密集型进程（拓展：可以将因l/O而阻塞的进程重新放回原队列，这样I/o型进程就可以保持较高优先级）</li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113638505.png" /></li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li><li>被抢占处理机的进程重新放回原队列队尾</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113856291.png" /></p><p>​ 注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）*</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.2节的内容，含处理机调度的概念、层次，进程调度的时机、切换和过程，调度算法的评级指标，FCFS、SJF、HRRN调度算法以及时间片轮转、优先级调度、多级反馈队列算法等调度算法</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>《StyTr2 Unbiased Image Style Transfer with Transformers》</title>
    <link href="https://blog.slks.xyz/2022/03/21/58ee25c0143c/"/>
    <id>https://blog.slks.xyz/2022/03/21/58ee25c0143c/</id>
    <published>2022-03-21T10:12:19.000Z</published>
    <updated>2022-03-22T03:14:40.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称stytr2-unbiased-image-style-transfer-with-transformers">论文名称：《StyTr^2 Unbiased Image Style Transfer with Transformers》</h4><h4 id="论文地址-httparxiv.orgabs2105.14576">论文地址： http://arxiv.org/abs/2105.14576</h4><h2 id="关键词">1、关键词：</h2><p>​ Image Style Transfer、Transformer</p><h2 id="摘要">2、摘要：</h2><p>​ 由于CNN的局部感知域性和空间不变性，输入图像的全局信息难以提取和维护。因此，传统的神经网络风格传递方法通常是有偏差的，对于同一幅参考风格图像，<strong>通过多次运行风格迁移过程可以观察到内容泄漏。</strong>为了解决这个关键问题，该文提出了一种基于Transformer的方法，即StyTr2，将输入图像的长期依赖关系考虑到无偏风格传输中。 ​ 与用于其他视觉任务的视觉转换器不同，我们的StyTr2包含两个不同的转换器编码器，分别为内容和样式生成特征序列。在编码器之后，采用多层Transformer解码器，根据样式序列对内容序列进行风格化。</p><h2 id="领域背景style-transfer">3、领域背景—Style Transfer：</h2><p>​ 经典的基于深度学习的图像风格迁移，样式转换方法使用多层cnn来学习样式和内容表示。由于卷积层的接收域有限，CNN无法处理长距离依赖关系。输入图像难以获得全局信息，这是图像风格传递任务的关键。将Transformer应用于计算机视觉的魅力在于:</p><ul><li><ol type="1"><li>它具有较强的表示能力，可以通过自注意机制自由地学习输入的全局信息，从而使每一层都能轻松获得整体的理解。</li></ol></li><li><ol start="2" type="1"><li>Transformer不包含局部性和空间不变性引起的归纳偏差，可以避免风格传递任务中的内容泄漏</li></ol></li></ul><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 在StyTr2框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。此外，针对自然语言处理中提出的位置编码方法，提出了两个方面的考虑:</p><ul><li><ol type="1"><li>不同于按逻辑顺序排列的句子，图像序列符号是通过图像内容的语义信息进行关联的;</li></ol></li><li><ol start="2" type="1"><li>对于风格迁移任务，目标是生成任意大小的风格化图像。输入图像大小的指数增长会导致位置编码的剧烈变化，从而导致较大的位置偏差和较差的输出质量。一般来说，视觉任务所需的位置编码应以输入内容为条件，而不受图像尺度变换的影响。</li></ol></li></ul><p>为此，该文还提出了<strong>基于图像语义特征的位置编码</strong>，并根据图像大小动态扩展位置编码。</p><p><strong>总结：主要贡献</strong></p><ul><li><ol type="a"><li>一个基于Transformer的风格转换框架，即StyTr2，以减少内容泄漏并实现无偏的风格化;</li></ol></li><li><ol start="2" type="a"><li>一种内容感知的位置编码机制，该机制是尺度不变的，适用于视觉生成任务;</li></ol></li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321190212987.png" /></p><h3 id="图像分割为patches-linear-embedding与vit类似">1) 图像分割为Patches + Linear Embedding【与ViT类似】</h3><ul><li><strong>输入：</strong><span class="math inline">\(I_c \in R^{H \times W \times 3}\)</span> 和 <span class="math inline">\(I_s \in R^{H \times W \times 3}\)</span></li><li><strong>输出：</strong>一个特征序列：$ L C<span class="math inline">\(，\)</span>L = $ ，<span class="math inline">\(m\)</span>是PatchSize，<span class="math inline">\(L\)</span>是特征序列tokens长度，<span class="math inline">\(C\)</span>是单个Token的维度。</li></ul><h3 id="位置编码content-aware-positional-encoding">2) 位置编码（Content Aware Positional Encoding）：</h3><ul><li><p><strong>想法：</strong>当使用基于Transformer的模型时，需要在输入序列中加入位置编码(PE)以获取结构信息。此论文提出了基于图像语义的位置编码，这一改进基于以下两个想法：</p></li><li><p>在传统的位置编码中：两个patch之间的位置相对关系仅仅与它们之间的距离有关。而对于图像生成任务，在计算位置编码时，我们应该考虑图像的语义</p></li><li><p>当输入图像的尺寸呈指数增长时，传统的正弦位置编码是否仍然适用于视觉任务? 如下所示当调整输入图像的大小时，相同语义的patches (blue blocks)之间的相对关系会发生巨大的变化，这可能不适合视觉任务中多大小的输入。</p></li><li><p><strong>主要做法：</strong>提出了内容感知的位置编码(CAPE)，该编码具有<strong>尺度不变特性</strong>，更适合于风格迁移任务。与正弦PE只考虑Patches的相对距离不同，CAPE以图像内容语义为条件。</p></li><li><p>首先假设<span class="math inline">\(n \times n\)</span> 可以足够用于表示每幅图像的语义位置。</p></li><li><p>假设输入图像为：<span class="math inline">\(I \in R^{H \times W \times 3}\)</span> ，我们将<span class="math inline">\(n \times n\)</span>的位置编码（依据实验结果，一般情况下<span class="math inline">\(n=18\)</span>），放缩至<span class="math inline">\(L = \frac{H}{m} \times \frac{W}{m}\)</span>的大小，这样就可以使得位置编码不受图像尺度的影响。即对于两个Image Patches而言，它们直接的位置关系不会受到图像尺度的影响。如下图所示：假设有两个不同分辨率的图像，在PatchSize大小一样的情况下，左图分辨率小，被分割后，成为<span class="math inline">\(2 \times 2\)</span>的Patch块，右图成为<span class="math inline">\(4 \times 4\)</span>的Patch块。当位置编码会进行放缩以适应的时候，其就可以自己匹配不同尺度的图像。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210140364.png" /></p></li><li><p><strong>公式化表达</strong>：</p><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210523455.png" /></li><li><span class="math inline">\(P_{CA}(x,y)\)</span>代表第<span class="math inline">\((x,y)\)</span>坐标的Patch的位置编码值</li><li><span class="math inline">\(F_{pos}\)</span>是一个可学习的编码函数</li><li><span class="math inline">\(P_L\)</span>是一个可学习的位置编码，是基于图像的token序列的</li><li><span class="math inline">\(a_{ij}\)</span>为插值权重，<span class="math inline">\(s\)</span>是邻居的数量，其是由周围邻居加权差值计算得到的。</li><li>对于token序列<span class="math inline">\(\epsilon\)</span>中的第i个Patch块，假设这个Patch块的坐标是<span class="math inline">\((x,y)\)</span>，那么我们将计算得到的<span class="math inline">\(P_{CAu}\)</span>值加到<span class="math inline">\(\epsilon_i\)</span>中，形成最后的序列。即，如果原来的token序列<span class="math inline">\(\epsilon\)</span>形状是<span class="math inline">\(L \times C\)</span>，那么新的也应当为<span class="math inline">\(L \times C\)</span></li></ul></li></ul><h3 id="transformer-encoder">3) Transformer Encoder：</h3><p>​ StyTr2有两个转换Encoder来编码特定于风格（内容图像 &amp;&amp; 风格图像）的特性，这些特性用于在下一阶段将序列从一个风格转换到另一个风格。</p><h4 id="part1-content-image">Part1: Content Image</h4><ul><li><strong>输入：</strong>Tokens 序列 <span class="math inline">\(Z_c \in L \times C\)</span></li><li><strong>输出：</strong>$Y_c L C $</li><li><strong>网络结构：</strong>每个transformer encoder layer包含一个MSA和一个FFN，与Transformer结构一致，输入序列被编码至Q，K，V。<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215744833.png" /></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215804639.png" /></li><li><span class="math inline">\(W_q,W_k,W_v,W_o\)</span>是可学习参数矩阵。</li><li>然后使用残差连接结构，每个模块后有LN归一化</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321220112862.png" /></li></ul></li></ul><h4 id="part2-style-image">Part2: Style Image：</h4><p>​ 按照Content Image那样子进行处理，但是对于Style Image我们<strong>不需要进行位置编码，因为我们不需要保持它的图像结构。</strong></p><ul><li><strong>输入：</strong>风格图像Tokens 序列 <span class="math inline">\(Z_s \in L \times C\)</span></li><li><strong>输出：</strong>$Y_s L C $</li></ul><h3 id="transformer-decoder">4）Transformer Decoder：</h3><ul><li><strong>输入：</strong>$Y_c L C $ ， $Y_s L C $ （<span class="math inline">\(\hat Y_c\)</span>是<span class="math inline">\(Y_c\)</span>增加了CAPE位置编码后的序列）</li><li><strong>输出：</strong><span class="math inline">\(output \in \frac{HW}{64} \times C\)</span></li></ul><p>​ 根据参考的风格序列，用回归的方式来生成内容序列。和传统NLP任务不一样，我们使用序列中的所有Patches一次性输入来预测结果。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321224013009.png" style="zoom: 80%;" /></p><p>​ 由两个MSA和一个FNN模块组成。第一个MSA模块的K、V来源于Style序列，Q来源于Content序列。每个模块后面都有一个LN归一化。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232914140.png" /></p><ul><li><p>公式化表达：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232959747.png" /></p></li></ul><h3 id="decoder">5）Decoder：</h3><p>​ 论文使用了一个三层的CNN解码器来细化后面的Transformer解码器的输出，而不是直接对输出进行上采样来构造结果。</p><ul><li>输入：<span class="math inline">\(input \in \frac{HW}{64} \times C\)</span></li><li>输出：<span class="math inline">\(I_{out} \in H \times W \times 3\)</span></li><li>网络结构组成：<ul><li>$3  $ 卷积层</li><li>ReLU</li><li><span class="math inline">\(2 \times\)</span> 上采样操作</li></ul></li></ul><h2 id="采用的损失函数">7、采用的损失函数：</h2><h4 id="content-percepture-loss-感知内容损失-style-percepture-loss感知风格损失">1）Content Percepture Loss 感知内容损失 &amp;&amp; Style Percepture Loss感知风格损失</h4><p>​ 优化结果应保持原有的内容结构，同时传递参考风格的模式。VGG提取的特征图可以作为内容特征来表示图像结构。<strong>Gram</strong>矩阵是两两向量的内积组成,所以<em>Gram</em>矩阵可以反映出该组向量中各个向量之间的某种关系。特征图的Gram矩阵可以作为风格特征来表示颜色、纹理等信息。因此，论文构建了<strong>感知内容损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_c\)</span>之间的内容差异，构建<strong>感知风格损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_s\)</span>之间的风格差异。</p><ul><li>Content Percepture Loss：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103100728.png" /></p><ul><li>Style Percepture Loss:</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103340777.png" /></p><p>​ 因为神经网络各层的统计量(如均值和方差)包含了不同领域的特征。<span class="math inline">\(\phi_i\)</span>代表使用预训练的VGG19网络，其第i层提取出的特征。<span class="math inline">\(\mu()\)</span>代表特征的均值，<span class="math inline">\(\sigma()\)</span>代表特征的方差。风格的感知损失可以书写如上。</p><h4 id="identity-loss">2) Identity Loss</h4><p>​ 自监督学习可以利用PreText从大规模的非监督数据中挖掘其监督信息。网络可以用这种构造的监督信息进行训练，以学习下游任务的有价值表示。 论文采用一个辅助的<strong>自我风格迁移任务</strong>来学习更丰富、更准确的语义和风格表达。<strong>该任务具体操作如下：</strong></p><p>​ <strong>注</strong>：Pretext任务可以进一步理解为：<strong>对目标任务有帮助的辅助任务。</strong></p><p>​ 论文在StyTr2中输入两个相同的<span class="math inline">\(内容/风格\)</span>图像，生成的图像<span class="math inline">\(I_{cc}/I_{ss}\)</span>应该与输入图像<span class="math inline">\(I_{c}/I_{s}\)</span>相同。因此，<span class="math inline">\(Identity Loss\)</span>模拟<span class="math inline">\(I_{c}/I_{s}\)</span>与<span class="math inline">\(I_{cc}/I_{ss}\)</span>之间的差异:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104028070.png" /></p><h4 id="最终loss">3）最终Loss</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104224116.png" /></p><p><span class="math inline">\(\lambda_c\)</span>、<span class="math inline">\(\lambda_s\)</span>、<span class="math inline">\(\lambda_{id1}\)</span>、<span class="math inline">\(\lambda_{id2}\)</span> = { 10 , 7 , 50 , 1 }</p>]]></content>
    
    
    <summary type="html">提出了StyTr2，该框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Style Transfer" scheme="https://blog.slks.xyz/tags/Style-Transfer/"/>
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
    <category term="CNN" scheme="https://blog.slks.xyz/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>关于文献综述、开题报告写作逻辑记录</title>
    <link href="https://blog.slks.xyz/2022/03/21/70cfb7bd8141/"/>
    <id>https://blog.slks.xyz/2022/03/21/70cfb7bd8141/</id>
    <published>2022-03-21T08:27:23.000Z</published>
    <updated>2022-03-21T06:47:52.216Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b9f124314e793a8ea4b25367429819e4db42db95545ee66f18eecfe80e01d16">0b64cd3abe5b0a0a039a37d86c66d75ed031bee0799e8ec352d0d5180826a0a50691d982f2be0c5f85267e748633a6bf94990a16c95008190a889750cecd7480a14477abc4a295eb514b8297cd2924e002a1c70812d056bcf0409e6fb92de26df0950a25ddafaeb99d1c3cf682cce4fc1226e9d0e6fb11561e2b615fc0eb9bac9ce2ad086a04463456aa373ccbe45d294bf436c7ac973af9bea0f2b9e447d448246d7c64ec3314b5e4baaaac014f5f2ff018c4ec4935ca0aa91b2bed76a66bf8a610827cb51bb660dc08067cfa0df4ba59f9bae520f9ce17fd1ff0a34505b0cc01663191ed701004f91d60e3605d8f50be8345dfd6f40431d3a6925178b63dd5331af544a52e572dbeb5ca133211a94a51b31273c2a07dad3a65d09f31bf7d650e8ff0228317ee19a107fadd4adaeea132918d286444c05aef91c1ef031637e1f1cb36e60e2f36b1cd22b684ebcbd44eebee5071662672485493e50a4f15ae933ab9734632c986e21d2323a20d60cac9c397fb888867c5e5b0c43a9c569457ab8bd5ec7619615cef9345aa701544e87d246731c9ffa9c07940386b29b0b14990f742cae9a254ad440ffe76d913bae62bc5f5418644c2d0f41f0c6593a5a4bf10577f9e2a01bf76eec279423298e44ba9a1aa3dd944ec6209d6b366bd5970d5693a0a3de247211917e24bf74a3a8649917f9725fef0a84c4751c9f17a47e06502b7e8eb94a0e3eb761ddb31cc04827bffbd071de865d5003de59ec9565d58b0bac3eeb984d2776667d4fdcec04b05fc0ef623774fce69b9e6c13f9bed5a33d948f4b7fe2e32c3ec9df3be76b1ec78510b0a165ef2f6d88e61d966361b5d2794c32ee337c0eb688febc00f6cd3231acfd239287d3a34eefe95c8385993f64a332688b73527f6e0a857b490df293cf96a4722e2d1457cf2f77024347da5650d24d691502e5103557e9fe814e44474ce09b015f2194eb312d794f1e416e394b2bad4c42786594b64076adf8d9451bcad12d8b31a005f2bc23788a5e937865336c6ddf4c2df44d3c0b2edd0348e31067bbb232d9b6e6eb582fe62b2a123aa1b5654da6507da228086736c76841e52d5c32f432331b58d64f2cb94ae874adfb2f663ba85a3c033064f95aa5e47daa60353de46c8b908b0824c61b76069a398f259c9cf350c583236e7c5d2af891445c2d16c01ed8d20da0ab66880c2fe32947625191ebeba3e3a65ee9397451cef6cc861c8367ad0f73980c8a5f937803f2f495374f1563c4720161c585394f17dcaf71e7788f13b9bfb55a7dde3ac31e10768d2cb175f40fe8257ead6a1564b24cf8519889cf65efcbab43d72a0876f2daf700aac7db122f60b919c7bf7d2cc127285295eed7393f1d4a57c94a6390ae0155af3bd93f203a540b0f5125c096841ea3f58cdc467f6d8aaf70da00df7b8dba5ab04d117e6cfe2a5ef9a371104e6674a85af50dd97aa17472e7bd367ee4ca1ce860d6cf234cad3ecbfacd08e09fcff12aa50e9935a77494daaa99d9a4faa4f89c18afa34767723858c4a707fea61f9030befb9e2d0108aaa9c052ada705d5b34ff28d03cace480a1776688cbafd1e00ae59947d163f1f28aa89e1ed3c6f4907e672919d214bf4973a4ea8249aa62924c9b34534a3736fecd73d94afd8982e569f2b953ebc005d6595bb943fb472dce2ffa324ab185bd8fa8153a1e600e3c1f628168917b25749094d0751a9be544414a7748cf4ac700167632441eafe1d761d6c29326cdfceefea229753b38072b01e23685570ac2b6d842cd00abd7e5a5ed0cf892388d2de0470e0aafbef91f53a85f63ddfc14d2eb45f4409d2cd946b5cca3089b211f302dbbf64410ddd9fea56e20f4ad5f794ad716d90badf1cbb8ad31adb765eb1330273e441ec0a2fa45e15016ea0f86b5c47ca451fa7b0af20c170d12408c424b761bc5a982a46d70ed005c692f322b36326d3bb3fdc9d7faacd1182155d9b3d1fb3ef4a4d38e1ff0370cbd2b1a339426c4a793a3819589017b566a8eacc3931253e5234822718fa3bbf34d5244fab4ee2fe9dd49d9c8e5a748179dad9f66e84a2595d69caa128908565b49c3b58bc60afc88660724b36e5394db0d37c2ebcb73bdf4d7669dc20e4c03a80aded961abfc88c1c6fce85b5a70f23ff4737e2d7f36b0dec664b376cfecf91468a064067227f0d9b00b329e7f2459787fe84ba1f8c311cffe8008e11eb8c579743bb21e2456fec4ddb031fdd6eed0d8f7b4dbb6f2696b086d3b6cf6afc4ea196f8f47e309f2dc00c62c53515656a4732c2f6185adfb39e876f87ecadc8ebb670d67afd160785568a4d8c3f4bb9cda58e6010755abb9ed12290e11ffa5daf4304b97c801d07faa4d4491444fcf9f1f784b4fdf8efc49a9ce02dd3735b3ff131fc7cd33c75549ffaaa492630fa0079a7af76b0abcf760d4d53162e870d99de380bbd17cc7d8267d365d67234f83834e628ff2e892a7e73c59205938a436b903464b6c34c68ed3147dd4980d6cfb64c57cec2b63afde06de5316aa9ce2b9e5c133f5272e38a3f5be02cec438e7ee77b6619152ae6c5a8337feac865895c5833741cef808f8503248e773fb841200c27d4861ec3f525fb6290c6ba054b7b14a34fc6bd7b316071ceacfb268006488b1472fc72dedfc5b50552ac56476a31b3078d2bb20d76a428bf28193ad47d653e53870b8f2e8b80e8cb767da78dac9ef6313947cd73785902df23cc9cbd0436a82a43eca7a9bd3aba83ae17aa5b9c7663ee3e17ec026272421598b372954c1fc5cfb3fab4b2c1d2c6c9c044c9a78026e5c03af1e25963cdd366d3de839428db45ac950d6a4f123a0c018e1c5137aa35836cbb9bd54c44d33039b16b9c7cb8283ef7084a9696c464a477488da63a4eeba06cc8616b55fa8d9ac5fe180451646d68317cccadb344092f8c2ad4d4ab45e4943b4900aa123afb0aa7f9dda7db168c047f3ce8b5b5e680cadc41bc7196e8249467563e711ace43d5f86ecb83eb300a4829af28cc2bd0a4572ed6c3dff507c035f269221967fc9b71b96d16f7ad2266f9b0e93b578cd31704c5213496e605701af575626a1b30aeb474d67f7b05215260c328c9880fbdeb24846e597ade1e0bfb77ef2842fb97321f8a2aee5d82bcf9fe9b000748a86f67a5e9188f6dc4f63bbf918f285276d2ed0ea7d3ce4db430db35026d168ad3833616e25b8335570fe70ebe90cb7baa3d5e34bed7d78eb868eec2786ed2dda6debb1fce6b0fb8d3e3258a247548f94eb235dd0cdf58c901dcfc011f9c098a90a18b08105758b267cafb815e07fad19680b1f044c88daa23e8a6b3294c83891068a5da5bee776bd26b36e390d37ac44cf978ffd90bc23a6924fd89e7657bcd3c92ad3dad42dab02cffd3b135dfed9329d17811c36fa405b343485ef7df2bf1dc9dd826c8ead29b2bb03a90738bcb76fec7146bcb1b6b65fc34c85c2b3dd6044ee4c47f55b35e3bca952bda7b3c2ae10a4f3eb21626427580c6739063636106e3b2c0eece813974a3bd1e05db9944e3e090d3370e247014144d5bc041bdf57fddd77a037197992368a942de5671b102f5fc971ff154e80c64760ec77af5b8284e9192e5bdeb77ab74f665b5b913d8f5f02b6b0a952dabd42ecbcf6ccd6ed450e7754b57eba01907a3aa26082454fb57cd8469b8fe0082395d5294b02d3085d1c587cd18c9bf69836167db4a28f56f3af972598624f71440f388a9be38548ebb9c0af3fc054be2f51e30e4857256f6751a4e77f719264b993dd8df596d84ff7a8720db0df392d260f38a34fab9151e2c7ec5f374fc5638c2cd30052f18cbfbfe015ae4585b3570f3864b09d55f8b190c4bd2723283ee1eec406f7c14efc72915942ffa919a9263f096819c121093373470192cfdceb17f255b3bb0b5c4c9add58997abf7fc6f17e35ea1110c4edb25972bfa22b3c9ec2ac31d01c038b34386edcb5e16270ea59924d22216789a8db2156998b900a1a6638cbf47d4dbc3a9d86b0ce8591538d50ffdd0a4c26de3902daff219a81f5ee1b4038adc81929dd7e6b480bd3e97ee6c5b848fa5c28fa59e688f6126f14146db0afe1fa483e61e6cc2b63217f0a0f877ee53ba39409eb170e157496fd93201d728b9d5a689e126a13ee418aec16c2ffa2d7d4f186d34fad2177312d427681abb6db88b4099ba681de508fd688732f969b69676a4f6627970c9e92726bfa927ffd25bb08cbc2795242ef852d0d2b6e1d792e96eee2566116859e66b7c80d55f635f6dd45b84bc5234b21e2f567be75b6ce77f62ea408a3f278dd768f6b80b4d00a61ffc4bc3daa67c253df340c229695de17f8fbe35310759d54fb87afd2c3c93e7e6a5a46911b6c2eed4305f25d4f4da6437a48e8ec468f5bfde5fac6fba9a64667d260173a83a3701334078e5378b13d4500df9861dde390ad3d9db23b516e9444849ea0e7acdd738832fd25c8153efb762e905619d7122ac271ad5f9450471a464060fe25fc2df8584b7282b16d3bc06678b3d05250d797b9c6e0328bd2e83e9943e0b1217a60a9e4ab2ca8b0ae0bced2211661ec7fd6cc1e0398245d5f9442a73abddd17328c3dfc2dccc73ea2c41af541379f15b436289e429f77ecc8859d645b56b5f78e0a8d264271eddaa26c02e1f9b013a7b230a7cda4b4c6b931688a6e4cc92b6ebd4692c7ca049e8e9b6c6ad8ae5e730c9bf2cf9acf86813cec873920c8d68ed3c0582a0fdc0c15ff15ad06381afe5a97d4f63217e4e17bedcaa6b78951c1beabf2baa573c54c7c0facde6ca71ee604047aa4a1f50e488d43a4b61bf42a8f00459ec7f77d2daf0a35ee3ca308c0c3b476fb0aac042456a90fe1c63fb1ee594e5fcd6e771dbf42710d6e6a993ad77313d99e5792489abd837d6efef5a6d008f5226f05493b722a363a1417097054719d6b5196efec818d05895ed5dee5ebd61d55cf5e5a27ea5a7d0ad9bcb1ec80137702f651572f16eae83c6c61cb618c37c5048e6ddffb087d6b8242e5d95bb290b805b8acfb65262d39cea1bbb681052723006f009743f09cc8bec11f1a34526141b597700bbac962d9101bb5bf5e065ad752a31b789ff79773bc2394c460fefe9574c63786523a4a8533334c7a1bfd71c0791c78e7285a57e4a326d65de7339a471de53aced40d41856542fd7bf643ea5fa11bee26a901ae11882ee7092584a4f4fad694a45e2ef255627b71bc917f1ec0926fea89fa4180936b5eb11a692bdffa4f1109e3852fc9579631c6e2c714c4dc73fbcf62a781585dace8d4996a0c4682ed8a818bef1aa79bcdbe759d1fd8f7942da22f467436eae82b5eddf296c5eb57adb8728d5cd2f2e9b0ef4f0741a00d36866725aa17d9b4a59b05614cf9ec8106ee199068bd3e9a3e903d16c49669cf674203cf72083b49ec0482c37b5c815c639c7a596f9cac3875385b2f54895b6986f5b7d1800c4fb6ebe29d3b1d1ec1ec131b3a8de10083239f3ee2d50a13f67f5639d65c6893c12fc652f3dfa51580ccbdaabe06b6d59c1f76c98cbbd890533097ecf3275aef692a4b7c851541d840c3b2207853f390fd4ba077df695714d4a9a799956aa972e6e1e9351768b0b8079cd367b60f0ff572e911f3b0e647bebc2ca659e2f896d8ab98d8af58430d1222a684b94b8b2d769467a653d57776b74509e8bcfa4997c084af3d9dd97b01c721b9abfa83c008ace7e694b8c272d5f75b99dfb230b2e2529ca51cb82482546bd4fdcbe9e086dac96d848a3ed9a462c6a654e6b1163f1097f853021a2e280d59e1463b0c4f6723902492fd28f298e61ba4d1994eb7df7ceec29dc2e6e99926bc410940720cf5d0e084a2347b5ce7dd0e97671ab00dfb61e672224f3f474ce3ac5b43cb64df3504a7c27de9f4bfcc8318e6056731a2855fe2eceeb5595f8f0a751f3114a1498a6911f1d257607c590eb6fe6b9ce03544ac89cf386507f17410ea9cfb891e0b922427ecd3db892f7336b8f62e2b68b6544b68a8805404cf0d6d4c660e336ace9011e92fdbea12e914204037cbe1f5f9e492268a2b28396d6be93cccb1d942abf28ae8d55f74005bb945645b9b88bccfadc16945237ec46c6a416bc5c7fe4114264eb6f3cab16bb5287fd0e3709717af8122725e651c0b9ebe236badfa5431d8c55c01b48c9b5f4530d3238d35b42e16cb2c9cc3d0bbe50307cb63cc2f42bf1cdc53678915cdb0a60430f86ca8c5dede3a8e3b53079e0c67199e48ba5b3ada36880f1c03d324702cebff44f6df34dbcf92100e91ff24d0188861bd38d63d80801b89fa99d0484cbadadd05a783a88eb414df17aa2090bec6f3c6d6948eca65ed46b1148bcbb2313b1889dd6f4b0295e4d18c0a89afcae26e699cd4964b39970f1d0da25b25d307ad922c069abebef70939528c604b2aeeb1c85b225f18ad2ac4cc0d88f2403ad293c50bc4a1f333b8a146d58294cf8c77bd9dc60a9393b4dd3bc4c701af5180545bbaa99d187b6488f5fbe91c1a8bb70f858dbd40e07a791e96c730a2d748566a8d370d029b37a7d66d5064a5c4f7e38a3c02c5526025350da91c5d87dc1917a91a04e3bab4a12464e1e75df43beaa15ce591f16272191203ce1da3208f59d178320f8a88484ab98c2708c3dce496c2ef0d1beb97c496ca2919840ba56a5323b8b944129ed4ce93bc96657e148895813418dbb3e6778fe15a0f5936cbcfedbfd1e49a1f3fb817cab6f750df2c923494c995b7efe49d0c8d0c2ca02e8708b8ebaee8abd65b69d65422343de2f76519b7bcb3f13a8b843ad41eb5b7f6c28aac1f12d2a42296103155958886246d873a67640542de79c44d8d13869dacd2cc2eeda1562f147484d71efd87d6e6007bc9bfbb6cc6b809d1c2af45a36531bd89a2e05043126727d9eb9dee274dad43ec6d87d49a9fc35c7ba47b2cac122328b7dfe55deda3eb49f1ff26407360d9b41cc8cbd034b9b8beefb6dced522b30e32850b33794a59a708bab7db1568b48b6fba45a7712551b8aed5d2ce5203ba1507eb0b05d00e4aac9af344df2a5fecd49508b1b484cd081c30b4e00639e56a28335294bb25e157e2c47e99a231c66035ef2cdf93ddd512356748bf1fa9ea2d33ce38fb8ba3440eb87278a657c2369e77c7835928f2a7047669fc3f96746c04980c386a1d7adc1570db205a39b1b9d189aaf0b1f931c2511df4c32c36797b5cfaa31c0ba3440ab4d0ed6187914fb18d7de428ee1112ac1091f6f3a109277d8efa9d9d43dd7333eaac2290941ef474099e2936e591dc70ee251f4fae13b88dbb8a5e4a4d34e0b1afb804cff093f527db478f12807c7f126affcddac2610733014e640d0ab411215cc954ed9fbf61455c5fe0235bd46759d7892d43b67d87037f6f51167a820f319e36533cf98dc5340e003d725939ca5f364d2c402393c3ef9cee8fc1e7161308b313db05f0d894d2ade0e9d54ef929b9e0e3a1089882e2f609bb56423b22a3809c91baca2d1b57583592951cf083b911a889f73cfeca0a0a29944242d90e2687aaa796f8893b4afb213e7991e6b28100b8c9e22844ccd7e59e15093e70c6b59c03c1729489a8e06de021351e505a70bf6d1a93835c64bd198777d9bad928078d54d7939b582a1a5fe88195b993e3db6f8480728df5695c80ddc89715488813aca7a6b15b4012605759e23f6dcb239b1409bc9f6a917c93ea23f9b89020e5d851889f6cff97a4a12a0480ce882def3e729f23019bc441ccf3e3989ef0aa435d7f79f3e6d4c89a705fbe2afb7e6b02f6e47ddc59fa6432cd2c9eedcb43677afcee3773d5b20cc7b589910d22a0556a8f4f4797287bbcfb40570ddc85f0940fbc413d8bf19871d74f4e1c7dd74bcc3b695191fd993304b69bd9eab9d58baaae577fc8ee20ab37477dfe90191da74a37125e57edacf62151965fe65b5a507d415bb4f72b06a8f2a8124160a57488ee7a3383a9b353b7cf8bb5b8f88720f937436c396f42443837487e3595a32856614443adb3f5a0b828e4330dee563ebeea67ba0bdbe5cb4e4eae2af8ed1351394c42340665a5bac091010fc917c3a0892e954284a791f24c7b7134efc6bb5f18c283ae7d588334fd81b4277508adccabdc728278cf736421a11e4d2d847f472e7eecebb284b223bf02f17f40b0eb250e54c24b6a90ce56625fcab1de720a09ff2988da4fa0c95d2a711363fb56700c3711349b4db7b1506dbf015085a6962d66b91e8df37454d485f3b08478c0fa7071a5365be3a1ea43810ae4d00c78e59e1ed11d4e99c5587c07997adfec4c54af8e7a5695fa4c668ed3cc6a71fcd16082118da0b0e2dd5d4c7dfbd691e35d4a2621b25b927a53702338e692c8a4969cf59e54f56881c4e17bb56e1b9c3549f33f29dc13c25cf2fd5d186a766de89b42c5d36da6be53ccdd6f24ba98d1036f6038dd2b6e967614e76556d57564fa80325df86f0e6eda66194dfbc47ce7c8b8a2e5013a7dcf49da870ed122d582be18707f81205127995cb44f58e1c8a98bda265c4fb7a40bb79feb8d460f584b1ccf829f995d8cbd13b9ef1ec6516b9c069e169a1f5bbeb73c549ccc717d47e913b3a0050d87d4f2c0d77ddc448453aaeba00e2b8dc06b3d2cf38b2b9478cb377631bd0fc842eed6753f0648eade71ee7a11faf10f2a842d78e0b954ec31c2069e511884e8f1a0328316a89a9429f1431455d2ec0d25a6054d33625406e3ed9af7e01358eb93c037cd4c4e41af4b8f96195f658d54a9a0af232a8cf94241bd90cdaf8f09617df75fe626b15819920a9f4ef7fc85e2d638e20f8a7d0d1e722a27a9178f1b1caed25a794defb7b930c38792aa5c6983c0f31b09e458ff144a013de56914a14b4f836ddc7242c7dc72e9605c921b4e174dfc2dfb42aff7c53307914d943915df708bc9900e9f4270d11f0571f089f6d5d7cc42fa721bdcf65046e96a121a2dbdd4a2166d99ca0ec0450cd290c909bc7838e14844af97d7b57d4e20dd9da248a7c38bee53d0ed0749e9f2675b82eb4015262900f063aedbc4657db9a27163b047a4d8f4ca3752b7ad5dcbaab94e5d9e4c8f59d348d7441fc4c39cc1a24093d83ac92ca38746bf4022f592385b82e625f7f5bae034f7b6283b49bc67d44e1e1810547fa0459b3c72b1f4aea59510e5264f03dabf077a425cf09483a425dd6e0a0089ed8b464f6c287b71a05d2316d732176cbac74e588547f21cbf037c2bccc93ea53b035964970a19ccde09b61e597bd5445993f3121cbfca2bc0cabe2f0f31ea75d851adf64d95ccb23b1a9ab8d8b008d69326936ee38262cd7c5f8e8adde4835d1f3d090590b6808b7d6398f2ed36ccac0389c813866847defb0c462c48d2c3e4a63d69aca1ef4ac580385d7b041f90af6dcbe7988d1a97eccdf4827b589b5417cd9a9ecf0ed7a14669430b49e2f3f74633267</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">关于文献综述、开题报告写作逻辑记录</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>SCI EI 核心期刊以及计算机领域CCF会议等级分类文件</title>
    <link href="https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/"/>
    <id>https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/</id>
    <published>2022-03-17T01:27:23.000Z</published>
    <updated>2022-03-17T01:39:19.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一sci">一、SCI：</h4><p>​ 美国《科学引文索引》，SCI(科学引文索引 )、EI(工程索引 )、ISTP(科技会议录索引 ) 是世界著名的三大科技文献检索系统，是国际公认的进行科学统计与科学评价的主要检索工具，其中以SCI最为重要。</p><p>​ 一般SCI<strong>侧重科学前沿理论</strong>，审核标准严格，发稿周期也比较长。</p><h4 id="二ei">二、EI：</h4><p>​ 《工程索引》（The Engineering Index, 简称EI）是供查阅<strong>工程技术领域文献</strong>的综合性情报检索刊物。</p><p>​ EI的主要特点是摘录质量较高，文摘直接按字顺排列，索引简便实用</p><h4 id="三核心期刊">三、核心期刊</h4><p>​ 在国内简单地说，核心期刊是学术界通过一整套科学的方法，对于期刊质量进行跟踪评价，并以情报学理论为基础，将期刊进行分类定级，把最为重要的一级称之为核心期刊。</p><ul><li>（1）北京大学图书馆“中文核心期刊”，这个的认可度一般最高。</li><li>（2）南京大学“中文社会科学引文索引（CSSCI）来源期刊”。</li><li>（3）中国科学院文献情报中心“中国科学引文数据库（CSCD）来源期刊”。</li><li>（4）中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”）。</li><li>（5）中国社会科学院文献信息中心“中国人文社会科学核心期刊”。</li><li>（6）中国人文社会科学学报学会“中国人文社科学报核心期刊”。</li></ul><h4 id="四中国计算机学会ccf推荐中文科技期刊目录">四、中国计算机学会CCF推荐中文科技期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%B8%AD%E6%96%87%E7%A7%91%E6%8A%80%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐中文科技期刊目录PDF</a></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1123qwdsa.jpg" /></p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_3](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_3.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_4](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_4.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_5](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_5.jpg)</p><h4 id="五中国计算机学会ccf推荐国际学术会议和期刊目录">五、中国计算机学会CCF推荐国际学术会议和期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐国际学术会议和期刊目录 PDF</a></p><p>参考：https://zhuanlan.zhihu.com/p/57932081</p>]]></content>
    
    
    <summary type="html">SCI EI 核心期刊的区别以及计算机领域CCF会议等级分类文件整理</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>字体生成效果评价指标</title>
    <link href="https://blog.slks.xyz/2022/03/16/827639831232/"/>
    <id>https://blog.slks.xyz/2022/03/16/827639831232/</id>
    <published>2022-03-16T13:09:19.000Z</published>
    <updated>2022-03-21T05:01:33.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一intersection-over-unioniou">一、Intersection-Over-Union（IOU）</h4><p>​ 计算两个矩形的交并比，通常在检测任务里面可以作为一个检测指标。往往可用于目标检测和语义分割。将预测框与ground truth框之间的交集比上两者的并集。</p><p>​ 应用到字体生成任务中，如下所示：img1和img2是参考字体图和生成字体图。由于生成的字体图像像素值很纯粹，所以我们认为 像素值&lt;127的为黑字部分，像素值&gt;=127的为白底部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_iou</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1_change = np.where(img1 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">1</span>)  <span class="comment"># 黑字部分保留，白底部分变为-1，黑字部分统一为0</span></span><br><span class="line">    img2_change = np.where(img2 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">2</span>)  <span class="comment"># 黑字部分保留，白底部分变为-2，黑字部分统一为0</span></span><br><span class="line">    black_num1 = img1_change[img1_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    black_num2 = img2_change[img2_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    intersection_num = img1_change[img1_change == img2_change].shape[<span class="number">0</span>] <span class="comment"># img1 和 img2 黑字部分交叉的像素数</span></span><br><span class="line">    total_num = black_num1 + black_num2 - intersection_num <span class="comment"># 总像素数（img1 和 img2 黑字部分并集的像素数）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;compute_iou:&#x27;</span>, total_num, intersection_num, black_num1, black_num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersection_num / total_num</span><br></pre></td></tr></table></figure><h4 id="二rmse">二、RMSE</h4><p>​ 均方根误差亦称标准误差, 用 真实值-预测值 然后平方之后求和平均,最后再开根号。 <span class="math display">\[\sqrt{\frac{1}{m} \sum_{i=1}^m(y_i - \hat y_i)^2  }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rmse</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    mse = np.mean((img1 - img2) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(mse)</span><br></pre></td></tr></table></figure><h4 id="三l1-loss">三、L1 Loss</h4><p><span class="math display">\[\frac{1}{m} \sum_{i=1}^mabs(y_i - \hat y_i)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_l1_loss</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>(img1 - img2))</span><br></pre></td></tr></table></figure><h4 id="四structural-similarityssim">四、<strong>Structural Similarity</strong>（SSIM）</h4><p>​ 结构相似性，是一种衡量两幅图像相似度的指标。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。</p><p>​ 给定两个图像x和y , 两张图像的结构相似性可按照以下方式求出：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/cdebeba369b6159f2e3fa5364412f4ff.svg" /></p><p>​ 其中<span class="math inline">\(u_x\)</span>是<span class="math inline">\(x\)</span>的平均值，<span class="math inline">\(u_y\)</span>是<span class="math inline">\(y\)</span>的平均值，<span class="math inline">\(\sigma_x\)</span>是x的方差，<span class="math inline">\(\sigma_y\)</span>是y的方差，<span class="math inline">\(\sigma_{xy}\)</span>是x和y的协方差，</p><p><span class="math inline">\(c_1=(k_1L)^2\)</span> 和<span class="math inline">\(c_2=(k_2L)^2\)</span>是用来维持稳定的常数。<span class="math inline">\(L\)</span>是像素值的动态范围。<span class="math inline">\(k_1=0.01\)</span>,<span class="math inline">\(k_2=0.03\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> structural_similarity</span><br><span class="line"></span><br><span class="line">structural_similarity(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="五peak-signal-noise-ratio-psnr">五、Peak Signal Noise Ratio( PSNR )</h4><p>​ 峰值信噪比，是一种评价图像的客观标准，它具有局限性，一般是用于最大值信号和背景噪音之间的一个工程项目。在图像处理中，要对图像进行客观的评价，常常需要计算<em>PSNR。PSNR</em>是衡量图像失真或是噪声水平的客观标准。2个图像之间的PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。</p><p>​ 定义： <span class="math display">\[PSNR = 10log_{10}(\frac{MAX^2}{MSE})\]</span> ​ MAX表示图像颜色的最大数值，8bit图像最大取值为255</p><p>​ MSE为均方差，定义为如下内容： <span class="math display">\[MSE = \frac{1}{mn}\sum^{n}_{i=1}\sum^{m}_{j=1}||K(i,j)-I(i,j)||^2\]</span> ​ 其中，<strong>I</strong>和<strong>K</strong>分辨是原始图像和处理后的图像，<strong><em>m*n</em></strong>为两图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> peak_signal_noise_ratio</span><br><span class="line"></span><br><span class="line">peak_signal_noise_ratio(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="六frechet-inception-distance-score-fid">六、Frechet Inception Distance Score( FID )</h4><p>​ Frechet Inception 距离得分（Frechet Inception Distance score，FID）是计算真实图像和生成图像的<strong>特征向量之间距离的一种度量</strong>。</p><p>​ FID 分数被用于评估由生成性对抗网络生成的图像的质量，较低的分数与较高质量的图像有很高的相关性。 <span class="math display">\[FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g = 2(\sum_r\sum_g)^{1/2})\]</span> ​ <span class="math inline">\(u\)</span>为经验均值，<span class="math inline">\(\sum\)</span> 为经验协方差，<span class="math inline">\(T_r\)</span>为矩阵的迹，<span class="math inline">\(r\)</span>代表真实数据集，<span class="math inline">\(g\)</span>代表生成数据集。</p><p><strong>FID的计算过程为：</strong></p><ul><li><p>对目标数据集的N张图片使用InceptionV3生成N*2048的向量，取平均值，得到<span class="math inline">\(u_r\)</span> 。</p></li><li><p>对生成的M张图片使用InceptionV3生成M*2048的向量，取平均得到<span class="math inline">\(u_g\)</span>。</p></li><li><p>通过<span class="math inline">\(u_r\)</span> 和 <span class="math inline">\(u_g\)</span> 得到 <span class="math inline">\(\sum_r\)</span>和<span class="math inline">\(\sum_g\)</span>最后得到FID。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fid</span><br><span class="line"></span><br><span class="line">fid_value = fid.calculate_fid_given_paths([output_dir, target_dir], <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>FID优势：</p><blockquote><p>1、生成模型的训练集和 Inception V3 的训练集可以不同。 2、计算 FID 时同时用到了生成的数据和真实数据，比起 IS 来更灵活。可以理解成，IS 判断真实性与否，是把生成数据和 ImageNet 数据做比较，而 FID 是把生成数据和训练数据做比较，因此更 reasonable。 3、以优化 FID 为目标，不会产生对抗样本。因为优化的是 lantent space feature，不是最终的输出图片，不会导致最终的生成图片失真。</p></blockquote><p>FID 问题：</p><blockquote><p>1、FID 只是某一层的特征的分布，是否足以衡量真实数据分布与生成数据分布的距离？同时，提出 FID 公式计算的是多元正态分布的距离，显然神经网络提取的特征并不是多元正态分布。 2、针对同一个生成模型，不同框架下预训练的 Inception V3 算出的 FID 差别是否可以忽略？ F3、ID 无法反映生成模型过拟合的情况，如果某个生成模型只是简单拷贝训练数据，FID 会非常小，认为这是一个完美的生成模型，因此，使用 FID 时同时也要通过别的手段证明生成模型没有过拟合。</p></blockquote><h4 id="七四象限评估">七、四象限评估：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/%7B58D5EE05-1CD3-1E12-45C6-0A5D78F53358%7D.png" alt="四象限评估准则" /><figcaption aria-hidden="true">四象限评估准则</figcaption></figure><p>​ <strong>D1：</strong>已知内容、已知风格</p><p>​ <strong>D2：</strong>未知内容、已知风格</p><p>​ <strong>D3：</strong>已知内容、未知风格</p><p>​ <strong>D4：</strong>未知内容、未知风格</p><p>参考：https://zhuanlan.zhihu.com/p/99375611</p>]]></content>
    
    
    <summary type="html">里面包含了目前我们用于衡量字体生成效果的一些指标的介绍以及代码实现，同时也包含字体生成领域的四象限评估。</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
    <category term="Evaluation" scheme="https://blog.slks.xyz/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>2.1 进程与线程的基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/14/32aa5a2632ac/"/>
    <id>https://blog.slks.xyz/2022/03/14/32aa5a2632ac/</id>
    <published>2022-03-14T13:04:19.000Z</published>
    <updated>2022-04-30T07:58:49.490Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=12</p><h3 id="一进程的定义组成和组织方式">一、进程的定义、组成和组织方式</h3><h4 id="进程的由来">1、进程的由来：</h4><p>程序本身其实就是一个指令序列。</p><p>早期的计算机只支持单道程序，程序运行时，内存中会分配两块区域：</p><ul><li>程序段：程序的代码放在程序段内</li><li>数据段：程序运行过程处理的数据放在数据段内</li></ul><p>​ 引入多道程序技术后，内存中需要存放多道程序：</p><p>​ <strong>为方便操作系统管理，完成个程序并发执行</strong>，故而操作系统为每个运行的程序配置一个数据结构，被称为<strong>进程控制块（PCB）</strong>，用于描述进程的各种信息（比如该进程程序代码存放位置等）。</p><h4 id="进程的定义">2、进程的定义：</h4><p>​ <strong>PCB、程序段、数据段</strong>三部分构成了<strong>进程实体</strong>。<strong>所谓创建进程，实质上是创建进程实体中的PCB；</strong>而撤销进程，实质上是撤销进程实体中的PCB。</p><p>​ PCB是进程存在的唯一标志。</p><p>​ 引入进程实体的概念后，可把进程定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong>注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314212804178.png" style="zoom:50%;" /></p><h4 id="进程组成">3、进程组成：</h4><h5 id="进程由以下三部分组成">1）进程由以下三部分组成：</h5><ul><li>PCB：进程的管理者所需的数据都在PCB中</li><li>程序段：存放要执行的代码</li><li>数据段：存放程序运行过程中处理的各种数据</li></ul><h5 id="pcb结构体中包含如下内容">2）PCB结构体中包含如下内容：</h5><ul><li>进程描述信息<ul><li>进程标识符PID</li><li>用户标识符UID</li></ul></li><li>进程控制和管理信息<ul><li>进程当前状态</li><li>进程优先级</li></ul></li><li>资源分配清单<ul><li>程序段指针</li><li>数据段指针</li><li>键盘、鼠标</li></ul></li><li>处理机相关信息<ul><li>各种寄存器的值</li></ul></li></ul><h4 id="进程的组织多个进程间">4、进程的组织：（多个进程间）</h4><h5 id="链接方式">1）链接方式</h5><p>按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221020998.png" alt="进程组织的链接方式" style="zoom: 50%;" /></p><h5 id="索引方式">2）索引方式</h5><p>​ 根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221055019.png" alt="进程组织的索引方式" style="zoom:50%;" /></p><h4 id="进程的特征">5、进程的特征：</h4><ul><li><strong>动态性（最基本特征）</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li><strong>并发性：</strong>内存中有多个进程实体，各进程可并发执行</li><li><strong>独立性：</strong>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性：</strong>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制"来解决异步问题。异步性可能会导致并发程序执行结果的不确定性。</li><li><strong>结构性：</strong>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ul><h3 id="二进程的状态和转换">二、进程的状态和转换</h3><h4 id="进程的三种基本状态">1、进程的三种基本状态：</h4><h5 id="运行态占用cpu并在cpu上运行">1）运行态：占用CPU，并在CPU上运行。</h5><p>​ 注意：单核处理机环境下，每一时刻最多见有一个进程处于运行态。（双核环境下可以同时有两个进程处于运</p><p>行态）。</p><h5 id="就绪态已经具备运行条件但由于没有空闲cpu而暂时不能运行">2）就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</h5><p>​ 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。 即：万事俱备，只欠CPU即：万事俱备，只欠CPU</p><h5 id="阻塞态因等待某一事件而暂时不能运行">3）阻塞态：因等待某一事件而暂时不能运行</h5><p>​ 如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p><h4 id="进程的另外两种状态">2、进程的另外两种状态：</h4><h5 id="创建态进程正在被创建操作系统为进程分配资源初始化pcb进程正在被创建操作系统为进程分配资源初始化pcb">1）创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB进程正在被创建，操作系统为进程分配资源、初始化PCB</h5><p>​ 操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p><h5 id="终止态进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb">2）终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</h5><p>​ 进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p><h4 id="进程状态的转换">2、进程状态的转换：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223023656.png" alt="进程状态转换图" /><figcaption aria-hidden="true">进程状态转换图</figcaption></figure><ul><li><p>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></p></li><li><p>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</p></li><li><p>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p></li></ul><h3 id="三进程控制">三、进程控制</h3><h4 id="什么是进程控制">1、什么是进程控制：</h4><p>​ 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><h4 id="如何实现进程控制">2、如何实现进程控制：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223828760.png" style="zoom:50%;" /></p><ul><li>创建进程：需要初始化PCB、分配系统资源</li><li>创建态→就绪态：需修改PCB内容和相应队列</li><li>就绪态→运行态：需恢复进程运行环境、修改PCB内容和相应队列</li><li>运行态→阻塞态：需保存进程运行环境、修改PCB内容和相应队列</li><li>阻塞态→就绪态：需修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</li><li>运行态→就绪态：（进程切换）需保存进程运行环境、修改PCB内容和相应队列</li><li>运行态→终止态：需回收进程拥有的资源，撤销PCB的资源，撤销PCB</li></ul><p>​ 为了使得进程状态切换中，数据具有一致性（类似于事务的概念），用<strong>原语</strong>实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p><p><strong>这种不可被中断的操作即原子操作。</strong></p><p><strong>原语采用“关中断指令”和“开中断指令”实现，如下所示</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314224013167.png" alt="" style="zoom: 67%;" /></p><p>​ 当在关中断指令执行后，如果系统收到外部中断信号，此时会将该信号转至开中断指令结束后再进行处理，即再开中断指令执行结束后，才会启动中断处理程序。如此，原语部分的代码就不会被打断执行。</p><p>​ 显然，<strong>关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p><p>​</p><h4 id="原语的具体操作">3、原语的具体操作：</h4><h5 id="进程控制会导致进程状态的转换无论哪个原语要做的无非三类事情">进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</h5><ul><li>1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<ul><li>a.所有的进程控制原语一定都会修改进程状态标志</li><li>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>c.某进程开始运行前必然要恢复期运行环境</li></ul></li><li>2.将PCB插入合适的队列</li><li>3.分配/回收资源</li></ul><h5 id="创建原语无创建态就绪态">1）创建原语：（无→创建态→就绪态）</h5><p>申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列</p><h5 id="能够引起进程创建的事件如下">能够引起进程创建的事件如下：</h5><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程引起进程创建的事件 l引起进程创建的事件</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul><h5 id="撤销原语就绪态阻塞态运行态终止态无">2）撤销原语：（就绪态/阻塞态/运行态→终止态→无）</h5><p>​ 从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统。删除PCB</p><h5 id="能够引起进程撤销的事件如下">能够引起进程撤销的事件如下：</h5><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><h5 id="阻塞原语运行态阻塞态">3）阻塞原语：（运行态→阻塞态）</h5><p>​ 找到要阻塞的进程对应的PCB，保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行，将PCB插入相应事件的等待队列。</p><p><strong>能够引起进程阻塞的事件如下：</strong></p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><h5 id="唤醒原语阻塞态运行态">4）唤醒原语：（阻塞态→运行态）</h5><p>​ 在事件等待队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度</p><p><strong>能够引起进程唤醒的事件如下：</strong></p><ul><li>正在等待的事件发生（因何事阻塞，就应当由何事唤醒，需与阻塞原语成对使用）</li></ul><h5 id="切换原语运行态阻塞态就绪态-或-就绪态运行态">5）切换原语：（运行态→阻塞态/就绪态 或 就绪态→运行态）</h5><p>​ 将运行环境信息存入PCB，PCB移入相应队列。选择另一个进程执行，并更新其PCB，根据PCB恢复新进程所需的运行环境</p><p><strong>能够引起进程切换的事件如下：</strong></p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="四进程通信">四、进程通信：</h3><h4 id="什么是进程通信">1、什么是进程通信？</h4><p>​ 进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立。</strong>进程1可以访问进程1的地址空间，但不能直接访问进程2的地址空间。</p><p>​ <strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法就是进程通信</strong></p><h4 id="进程通信共享存储-方法">2、进程通信——共享存储 方法</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171055164.png" alt="共享存储" style="zoom: 67%;" /></p><p>​ 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p><p>​ 操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p><p>​ <strong>其又有两种方式</strong>：</p><ul><li><p>基于数据结构的共享</p><p>​ 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式<strong>速度慢、限制多，是一种低级通信方式</strong></p></li><li><p>基于存储区的共享</p><p>​ 基于存储区的共享：在内存中画出一块共享存储区，<strong>数据的形式、存放位置都由进程控制，而不是操作系统。</strong>相比之下，这种共享方式<strong>速度更快，是一种高级通信方式。</strong></p></li></ul><h4 id="进程通信管道通信-方法">3、进程通信——管道通信 方法</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171447871.png" alt="管道通信" /><figcaption aria-hidden="true">管道通信</figcaption></figure><p>​ “管道”是指用于连接读写进程的一个共享文件，又名pipe程的一个共享文件，又名pipe 文件。其实就是<strong>在内存中开辟一个大小固定的缓冲区 </strong></p><ul><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各个进程需要互斥的访问管道</li><li>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的write（）系统调用将被阻塞</strong>，等待读进程将数据取走。<strong>当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。</strong></li><li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li><li><strong>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情</strong></li></ul><h4 id="进程通信消息传递-方法">4、进程通信——消息传递 方法</h4><p>​ 进程间的数据交换<strong>以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的<strong>“发送消息/接收消息”两个原语进行数据交换</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180227145.png" /></p><p>​ 消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p><p>​ 每个进程都会有一个消息缓冲队列：消息传递有以下两种方式：</p><ul><li>直接通信方式: 消息直接挂到接受进程的消息缓冲队列上<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180138885.png" /></li></ul></li><li>间接通信方式：消息先发送到中间实体中<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180217571.png" /></li></ul></li></ul><h3 id="五线程概念和多线程模型">五、线程概念和多线程模型：</h3><h4 id="什么是线程">1、什么是线程？</h4><p>​ 在传统的机制中，<strong>进程是程序执行流的最小单位。</strong></p><p>​ <strong>有的进程</strong>可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>​ 一个进程中，被分为多个线程。CPU轮流为不同的线程服务。故而，引入线程后，<strong>线程是程序执行流的最小单位。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180730244.png" style="zoom:67%;" /></p><p>​</p><p><strong>官方定义：线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong></p><p>​ 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p><p>​ 引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的），<strong>线程才是CPU的执行单元</strong>（而CPU是分配给不同的线程的）</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181019487.png" alt="引入线程后的变化" /></p><h4 id="线程的属性">2、线程的属性：</h4><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li><strong>同一进程的不同线程间共享进程的资源（例如打印机等）</strong></li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h4 id="线程的实现方式">3、线程的实现方式：</h4><h5 id="用户级线程">1）用户级线程：</h5><p>​ 用户级线程由应用程序通过线程库实现。</p><p>​ 所有的线程管理工作都<strong>由应用程序负责（包括线程切换）</strong></p><p>​ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>​ <strong>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</strong>（用户级线程对用户不透明，对操作系统透明）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181528334.png" alt="用户级线程" style="zoom: 67%;" /></p><h5 id="内核级线程">2）内核级线程：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181555209.png" alt="内核级线程" style="zoom:67%;" /></p><p>​ 核级线程的管理工作由操作系统内核完成。</p><p>​ 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p><h5 id="两者组合">3）两者组合：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181640824.png" alt="" style="zoom:67%;" /></p><p>​ 在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m 个内核级线程上（n&gt;=m）</p><p>​ 重点：<strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p><p>​ 例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，<strong>也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</strong></p><h4 id="多线程模型">4、多线程模型：</h4><p>​ 在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><h5 id="多对一模型">1）多对一模型：</h5><p>​ 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182055006.png" style="zoom:67%;" /></p><p>​ <strong>优点：</strong>用尸级线程的切换在用尸空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>​ <strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h5 id="一对一模型">2）一对一模型：</h5><p>​ 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182003606.png" alt="一对一模型" style="zoom:67%;" /></p><p>​ <strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>​ <strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h5 id="多对多模型">3）多对多模型：</h5><p>​ n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182148042.png" style="zoom:67%;" /></p><p>​ 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.1节的内容，含进程的定义、组成、组织方式、状态与转换，进程控制、进程通信、线程概念和多线程模型等内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
</feed>
