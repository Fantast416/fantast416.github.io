<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-02-22T15:24:52.752Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记3——优化器类的代码实现（更新中）</title>
    <link href="https://blog.slks.xyz/2022/02/23/bcff8db3f50b/"/>
    <id>https://blog.slks.xyz/2022/02/23/bcff8db3f50b/</id>
    <published>2022-02-23T04:17:19.000Z</published>
    <updated>2022-02-22T15:24:52.752Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 优化器的理论部分以及各种常见的优化器可以参见如下博客：<a href="https://blog.slks.xyz/2022/02/11/ced858ce48dc/">机器学习基础系列笔记16——常见的梯度下降优化器整理</a></p><p>本文所讲的是如何使用Python搭建优化器类，从而帮助实现整个机器学习的训练过程。</p><h3 id="一优化器optimizer">一、优化器Optimizer</h3><h4 id="在不封装优化器的时候如何在计算图上执行梯度下降法">1、在不封装优化器的时候，如何在计算图上执行梯度下降法？</h4><p>当我们还没有明确提出优化器这个概念的时候，我们遵循如下过程去在计算图上执行梯度下降来优化损失函数：</p><ul><li>1）对结果节点的上游变量节点(Variable)赋值或初始化【包括输入向量节点和训练参数节点】</li><li>2）在结果节点上调用forward，计算出它的值，数据前向传播</li><li>3）在所有需要训练的变量节点( Variable, trainable = True )上调用backward方法，梯度反向传播，计算出结果节点对该节点的雅可比矩阵。【仅包括训练参数节点】</li><li>4）根据变量节点的jacobi属性中的值，从变量节点的当前值中减去 用学习率 * 梯度的值即为更新后的值。</li><li>5）清除所有节点的value和jacobi属性，回到第2步</li></ul><h4 id="优化器的封装">2、优化器的封装</h4><p>​ 其实，优化器所实现的功能就是上述训练过程中对可训练的变量节点的值进行优化的过程。但是由于，可能存在各种多种多样的优化器，为了便于外层用户使用，代码的整洁，我们需要将优化器的功能封装起来，然后进行使用。</p>]]></content>
    
    
    <summary type="html">本文记录使用Python搭建深度学习框架，实现其中优化器类的代码，包含优化器基类的抽象和需要执行的任务，以及一些常见的梯度下降优化器类的实现。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记2——计算图、前向传播、反向传播与自动微分的代码实现</title>
    <link href="https://blog.slks.xyz/2022/02/22/6bfa5496ebc4/"/>
    <id>https://blog.slks.xyz/2022/02/22/6bfa5496ebc4/</id>
    <published>2022-02-22T15:11:19.000Z</published>
    <updated>2022-02-22T15:17:04.310Z</updated>
    
    <content type="html"><![CDATA[<p>​ 首先，我们看完上一节的理论以后，应该需要知晓在上述过程中，我们需要在代码中实现的最核心的节点相关的类如下所示，我们以以下这张经典的计算图来分析：</p><p>​ 其中，存储整个图我们需要一个类，也就是计算图类，然后图中又有许多类型的节点，第一种类型的节点是变量节点，也就是x、w这种，是无父节点的，第二种类型是Op操作符节点，也就是+、x这种节点，剩下的就是普通的中间节点。故而我们需要实现的类如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" /></p><p>​</p><ul><li><strong>Node类（基类-非抽象类）</strong><ul><li>普通中间节点（直接使用Node类即可）</li><li>变量节点（继承Node类，无父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识）</li><li>Op操作符节点（继承Node类，抽象类，然后根据不同的运算符定义类来继承它，其他运算符类需要实现两个方法：compute 和 get_jacobi，分别用于根据父节点的值计算本节点的值，以及计算本节点对某个父节点的雅可比矩阵）。</li></ul></li><li><strong>Graph计算图类</strong></li></ul><p>接下来，我们来一一看它们的实现代码：</p><h3 id="graph计算图类-一些基本函数">1、Graph计算图类 （一些基本函数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nodes = []  <span class="comment"># 计算图内的节点的列表</span></span><br><span class="line">        self.name_scope = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nodes.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        清除图中全部节点的雅可比矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.clear_jacobi()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重置图中全部节点的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.reset_value(<span class="literal">False</span>)  <span class="comment"># 每个节点不递归清除自己的子节点的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_count</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.nodes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 全局默认计算图</span></span><br><span class="line">default_graph = Graph()</span><br></pre></td></tr></table></figure><h3 id="node类基类---非抽象类">2、Node类（基类 - 非抽象类）</h3><ul><li><strong>Part1：构造函数</strong><ul><li>此部分较好理解，做一些初始化，将节点添加到计算图的list里，然后将该节点添加到父节点的子节点列表中。</li><li>需要注意的是：构造函数需要传入两个参数，第一个参数是父节点列表，第二个参数是一些参数列表</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图节点类基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *parents, **kargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图对象，默认为全局对象default_graph</span></span><br><span class="line">        self.kargs = kargs</span><br><span class="line">        self.graph = kargs.get(<span class="string">&#x27;graph&#x27;</span>, default_graph) <span class="comment"># 节点所属的计算图，默认为 全局计算图default_graph</span></span><br><span class="line">        self.need_save = kargs.get(<span class="string">&#x27;need_save&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 是否需要被保存</span></span><br><span class="line">        self.gen_node_name(**kargs)     <span class="comment"># 依据参数生成节点名称</span></span><br><span class="line"></span><br><span class="line">        self.parents = <span class="built_in">list</span>(parents)  <span class="comment"># 父节点列表</span></span><br><span class="line">        self.children = []  <span class="comment"># 子节点列表</span></span><br><span class="line">        self.value = <span class="literal">None</span>  <span class="comment"># 本节点的值</span></span><br><span class="line">        self.jacobi = <span class="literal">None</span>  <span class="comment"># 结果节点对本节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到父节点的子节点列表中</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            parent.children.append(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到计算图中</span></span><br><span class="line">        self.graph.add_node(self)</span><br></pre></td></tr></table></figure><ul><li><strong>Part2: 常见函数</strong>:<ul><li>此部分也是Node类中一些基本的工具型函数，其中gen_node_name就是在构造函数中生成节点名称用的。</li><li>dimension 和 shape 函数是用来返回节点值的维度的</li><li>reset_value 递归重置该节点 + 该节点下游的节点的值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parents</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的父节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.parents</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_children</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的子节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.children</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">gen_node_name</span>(<span class="params">self, **kargs</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       生成节点名称，如果用户不指定，则根据节点类型生成类似于&quot;MatMul:3&quot;的节点名，</span></span><br><span class="line"><span class="string">       如果指定了name_scope，则生成类似&quot;Hidden/MatMul:3&quot;的节点名</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.name = kargs.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">           self.__class__.__name__, self.graph.node_count()))</span><br><span class="line">       <span class="keyword">if</span> self.graph.name_scope:</span><br><span class="line">           self.name = <span class="string">&#x27;&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.graph.name_scope, self.name)</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       清空结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.jacobi = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">dimension</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值展平成向量后的维数</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape[<span class="number">0</span>] * self.value.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值作为矩阵的形状：（行数，列数）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self, recursive=<span class="literal">True</span></span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       重置本节点的值，并递归重置本节点的下游节点的值</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> recursive:</span><br><span class="line">           <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</span><br><span class="line">               child.reset_value()</span><br></pre></td></tr></table></figure><ul><li><strong>Part3：虚函数</strong>：<ul><li>这两个函数，是等会儿 操作符节点需要重载的函数内容，在forward和backword中有用到。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，根据父节点的值计算本节点的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，计算本节点对某个父节点的雅可比矩阵的计算，因为计算父节点的雅可比矩阵可能需要该父节点以及其他父节点的值，所以只能够在子节点中完成。父节点调用子节点的getjacobi方法，就可以得到子节点对自己的雅可比矩阵。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Part4：核心函数</strong>：<ul><li>forward() 和 backward() 函数, 都是以递归的形式进行计算，请注意这边的两个函数的含义和pytorch库中的同名函数含义相差较大，不要搞混。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> node <span class="keyword">in</span> self.parents:</span><br><span class="line">          <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">              node.forward()</span><br><span class="line"></span><br><span class="line">      self.compute()</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  属性jacobi用于保存最终结果对自己的雅可比矩阵，在代码一开始先判断自己的jacobi属性是否为None,如果不是说明最终结果对自己的雅可比矩阵已经计算过了（因为一次反向传播中，某个节点可能被多次访问）。</span></span><br><span class="line"><span class="string">  result参数传进来的是最终的结果节点。</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, result</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      反向传播，计算结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> self.jacobi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">if</span> self <span class="keyword">is</span> result:  <span class="comment"># 如果本节点自身就是最终的结果节点</span></span><br><span class="line">              self.jacobi = np.mat(np.eye(self.dimension()))  <span class="comment">#构造一个维度正确的单位矩阵即可</span></span><br><span class="line">          <span class="keyword">else</span>:   <span class="comment"># 如果本节点不是最终的结果节点，而是正常的一个节点</span></span><br><span class="line">              self.jacobi = np.mat(  <span class="comment"># 先构造一个维度正确的全为0的矩阵</span></span><br><span class="line">                  np.zeros((result.dimension(), self.dimension())))</span><br><span class="line"><span class="comment"># 然后遍历所有子节点</span></span><br><span class="line">              <span class="keyword">for</span> child <span class="keyword">in</span> self.get_children():</span><br><span class="line">                   <span class="comment"># 如果子节点的值不为空，说明它在本次的计算路径上，因为对于某些复杂的计算图而言，有些节点可能不在某次前向传播的计算路径上，它们是无关的节点。</span></span><br><span class="line">                  <span class="keyword">if</span> child.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                      <span class="comment"># 递归调用child的backward()方法，得到最终结果对子节点的雅可比，再乘上 子节点对该节点的雅可比，就得到了最终结果对该节点的雅可比，将其累加到之前初始化好的全为0的矩阵中。</span></span><br><span class="line">                      self.jacobi += child.backward(result) * child.get_jacobi(self)</span><br><span class="line"><span class="comment"># 返回雅可比矩阵即可</span></span><br><span class="line">      <span class="keyword">return</span> self.jacobi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="变量节点继承自node类">3、变量节点（继承自Node类）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    变量节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, init=<span class="literal">False</span>, trainable=<span class="literal">True</span>, **kargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        变量节点没有父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Node.__init__(self,  **kargs)</span><br><span class="line">        self.dim = dim</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果需要初始化，则以正态分布随机初始化变量的值</span></span><br><span class="line">        <span class="keyword">if</span> init:</span><br><span class="line">            self.value = np.mat(np.random.normal(<span class="number">0</span>, <span class="number">0.001</span>, self.dim))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 变量节点是否参与训练</span></span><br><span class="line">        self.trainable = trainable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为变量赋值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判定赋值的值matrix 是不是和dim一致</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(value, np.matrix) <span class="keyword">and</span> value.shape == self.dim</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 本节点的值被改变，重置所有下游节点的值</span></span><br><span class="line">        self.reset_value()</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><h3 id="运算符操作子节点继承自node类需要覆写compute和get_jacobi两个函数">4、运算符操作子节点（继承自Node类，需要覆写compute和get_jacobi两个函数）</h3><p>抽象类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义操作符抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>定义 Add操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    （多个）矩阵加法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">## 根据父节点的值计算本节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># assert len(self.parents) == 2 and self.parents[0].shape() == self.parents[1].shape()</span></span><br><span class="line">        self.value = np.mat(np.zeros(self.parents[<span class="number">0</span>].shape()))</span><br><span class="line"><span class="comment"># 把所有的父节点的值相加，就是正向传播计算的值</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            self.value += parent.value</span><br><span class="line">            </span><br><span class="line"><span class="comment">## 计算本节点对某个父节点的雅可比矩阵的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.mat(np.eye(self.dimension()))  <span class="comment"># 矩阵之和对其中任一个矩阵的雅可比矩阵是单位矩阵</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 比如说： 父节点为矩阵 A，B(维度为 3 * 2)，子节点为矩阵 A + B（维度为3 * 2）</span></span><br><span class="line"><span class="comment">## 子节点为 Add操作符节点</span></span><br><span class="line"><span class="comment">## 那么这样一个映射函数就是 6维向量 -》映射到-》 6维向量 的映射函数</span></span><br><span class="line"><span class="comment">## A 展平 [ a1 a2 a3 a4 a5 a6 ] B 展平 [ b1 b2 b3 b4 b5 b6]  均为6维向量</span></span><br><span class="line"><span class="comment">## A+B 展平 [a1+b1 a2+b2 a3+b3 a4+b4 a5+b5 a6+b6] 6维向量</span></span><br><span class="line"><span class="comment">## 最终得到的雅可比矩阵是 6 * 6 的单位阵</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [d(a1+b1)/d(a1) d(a1+b1)/d(a2) d(a1+b1)/d(a3) d(a1+b1)/d(a4) d(a1+b1)/d(a5) d(a1+b1)/d(a6)  ]</span></span><br><span class="line"><span class="string">   [d(a2+b2)/d(a1) d(a2+b2)/d(a2) d(a2+b2)/d(a3) d(a2+b2)/d(a4) d(a2+b2)/d(a5) d(a2+b2)/d(a6)  ]</span></span><br><span class="line"><span class="string">    ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">   [d(a6+b6)/d(a1) d(a6+b6)/d(a2) d(a6+b6)/d(a3) d(a6+b6)/d(a4) d(a6+b6)/d(a5) d(a6+b6)/d(a6)  ]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [1 0 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>定义Matmul操作符：结论如下，推导可以见书：</p><p>定义矩阵A： 形状为 M x N</p><p>定义矩阵B： 形状为 N x K</p><p>矩阵乘法得到的结果C： 形状为 M X K</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_51_51_228.png" /></p><p>​ 我们将矩阵乘法视为多到多映射，如下：以左矩阵A为自变量，以右矩阵B为常量，将映射的结果矩阵C视为 M x K维的向量。如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_56_22_981.png" style="zoom: 50%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_56_29_570.png" style="zoom:50%;" /></p><p>​ 最终获得的雅可比矩阵的第一行，就是C矩阵的第1个元素，分别对A的mn个元素求导：得到的如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_58_05_680.png" style="zoom:50%;" /></p><p>​ 第二行同理，如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_58_34_369.png" style="zoom:50%;" /></p><p>​ 一直到雅可比矩阵的第K行，都是这样的规律。然后接下去雅可比矩阵的K+1行是这样的：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_15_59_42_707.png" alt="屏幕捕获_2022_02_11_15_59_42_707" style="zoom:50%;" /></p><p>​ 我们会发现一个规律，如下所示，也就是最终的结论：C对A的雅可比矩阵如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_11_16_00_40_821.png" style="zoom:50%;" /></p><p>​ <span class="math inline">\(B^T 是 B的转置\)</span>，我们把 m 个 形状为 <span class="math inline">\(k \times n\)</span>的<span class="math inline">\(B^T\)</span>矩阵放在对角线上，得到一个<span class="math inline">\(mk \times mn\)</span> 的矩阵。以下代码就是干了这样一个事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatMul</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    矩阵乘法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">2</span> <span class="keyword">and</span> self.parents[<span class="number">0</span>].shape()[</span><br><span class="line">            <span class="number">1</span>] == self.parents[<span class="number">1</span>].shape()[<span class="number">0</span>]</span><br><span class="line">        self.value = self.parents[<span class="number">0</span>].value * self.parents[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将矩阵乘法视作映射，求映射对参与计算的矩阵的雅克比矩阵。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        zeros = np.mat(np.zeros((self.dimension(), parent.dimension())))</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> fill_diagonal(zeros, self.parents[<span class="number">1</span>].value.T)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            jacobi = fill_diagonal(zeros, self.parents[<span class="number">0</span>].value)</span><br><span class="line">            row_sort = np.arange(self.dimension()).reshape(</span><br><span class="line">                self.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            col_sort = np.arange(parent.dimension()).reshape(</span><br><span class="line">                parent.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            <span class="keyword">return</span> jacobi[row_sort, :][:, col_sort]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>定义ReLU操作符：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对矩阵的元素施加ReLU函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    nslope = <span class="number">0.1</span>  <span class="comment"># 负半轴的斜率</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt; <span class="number">0.0</span>,</span><br><span class="line">            self.parents[<span class="number">0</span>].value,</span><br><span class="line">            self.nslope * self.parents[<span class="number">0</span>].value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(np.where(self.parents[<span class="number">0</span>].value.A1 &gt; <span class="number">0.0</span>, <span class="number">1.0</span>, self.nslope))</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p>代码实现参考：https://github.com/zc911/MatrixSlow</p><p>1、《用python实现深度学习框架》张觉非、陈震</p>]]></content>
    
    
    <summary type="html">本文结合上一节中的理论部分，使用Python搭建深度学习框架，实现其中最为基础核心的计算图、前向传播、反向传播以及自动微分的代码，对各个类以及其内的函数做了详细的介绍。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>BFS系列——开密码锁</title>
    <link href="https://blog.slks.xyz/2022/02/22/2c663a313e31/"/>
    <id>https://blog.slks.xyz/2022/02/22/2c663a313e31/</id>
    <published>2022-02-22T06:06:19.000Z</published>
    <updated>2022-02-22T06:32:05.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-109.-开密码锁"><a href="https://leetcode-cn.com/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h4><p>​ 一个密码锁由 4 个环形拨轮组成，每个拨轮都有 10 个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>​ 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。</p><p>​ 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>​ 字符串 target 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><ul><li>示例 1:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： 可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><p><strong>解题思路1：单向BFS</strong>：</p><p>​ 本题可以采用BFS搜索进行求解，但是由于每一个数字，其对应的领居有高达8个，再不断的扩展的过程中，搜索的空间会非常大，就会导致比较大的复杂度。在本题的BFS过程中，需要注意的是，还有死亡数字列表，一种方案是我们可以使用哈希表存储死亡数字，在每次遍历获取邻居的时候，判断是否为死亡数字，如果为死亡数字，那么就不将其考虑在内。这样子需要多出一定的空间和时间来进行处理。</p><p>​ 其实，我们可以不需要额外的空间来进行处理。因为在BFS的过程中，我们会记录哪些节点被访问过，就不要重复入队，故而，只需要提前将所有的死亡数字，都设定为已经被访问过，那么就不会被考虑在内。</p><p><strong>解题代码1</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; dead;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++) dead[deadends[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dead.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != dead.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dead.<span class="built_in">find</span>(neighbor[i]) != dead.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(target) == res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.31.38.png" /></p><p>​ 此方法花费的执行用时和内存消耗都是下下选。</p><p><strong>解题思路2：双向BFS</strong>：</p><p>​ 双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率</p><p>​ 同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案，用一张图来进行说明如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/jevyd2TPC7FX6GA.png" alt="jevyd2TPC7FX6GA" style="zoom: 33%;" /></p><p>​ 具体如何实现判断相遇，见如下的代码：我们构建vis，代表某个字符串的位置是否被访问过。这个在单向的BFS中，我们不需要设置，因为我们可以通过res这个Hash表有没有某个元素来进行判断，实际上此处的vis起到的也并不是判断有没有被访问过的作用（后面代码还是通过res中有没有某个元素来判断的），此处的vis最大的作用是记录某个节点是被正向搜索访问过，还是被反向搜索访问过，如果被正向访问过设置为1，被反向搜索访问过设置为2。</p><p>​ 同时，在每一遍while中，我们扩展<strong>较小的搜索队列</strong>，并利用flag记录扩展的是前向还是反向。如果在遍历某一轮的领居的过程中，发现：curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询结果</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//构建vis，代表某个字符串的位置是否被访问过 被正向访问过为1，被反向搜索访问过为2</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res[deadends[i]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&quot;0000&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q1;  <span class="comment">//前向搜索序列</span></span><br><span class="line">        queue&lt;string&gt; q2;  <span class="comment">//反向搜索序列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        q2.<span class="built_in">push</span>(target);   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        res[target] = <span class="number">0</span>;   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        vis[<span class="string">&quot;0000&quot;</span>] = <span class="number">1</span>; <span class="comment">//前向搜索初始化</span></span><br><span class="line">        vis[target] = <span class="number">2</span>; <span class="comment">//反向搜索初始化</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//在每一遍while中，我们扩展 较小的搜索队列,利用flag记录扩展的是前向还是反向</span></span><br><span class="line">            string curr;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                curr = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                curr = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123; <span class="comment">//如果这个领居点从来没被访问过 </span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                    vis[neighbor[i]] = vis[curr];  <span class="comment">//继承当前访问的队列编号，1为正向，2为反向</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果这个领居点被访问过：</span></span><br><span class="line">                    <span class="keyword">if</span>(vis[neighbor[i]] + vis[curr] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[curr] + res[neighbor[i]] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.30.39.png" /></p><p>可以看到，使用双向BFS比先前的单向BFS节省了非常多的时间与空间复杂度。</p>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，其中记录了BFS的进阶技巧。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>图系列——多余的边（DSU应用）</title>
    <link href="https://blog.slks.xyz/2022/02/21/0f9e9b187c29/"/>
    <id>https://blog.slks.xyz/2022/02/21/0f9e9b187c29/</id>
    <published>2022-02-21T08:29:19.000Z</published>
    <updated>2022-02-21T14:43:34.334Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-118.-多余的边"><a href="https://leetcode-cn.com/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h4><p>​ 树可以看成是一个连通且 无环 的 无向 图。</p><p>​ 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>​ 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><p><strong>示例 1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626676174-hOEVUL-image.png" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: edges = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 一开始，我的思路是找到一种方法，能够判断一个图有无环。毫无疑问，我们可以使用拓扑排序去进行这个思路，但是这样子的话，对于每删掉一条边就要进行一次拓扑排序来判断，时间复杂度无疑是比较高的。</p><p>​ 这个时候，查看官方解答，原来这类题目还可以使用<strong>并查集</strong>来做：</p><p>​ 初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为多余的边，将当前的边作为答案返回。</li></ul><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;edges.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> res = <span class="built_in">unionTwo</span>(edges[i][<span class="number">0</span>],edges[i][<span class="number">1</span>],root);</span><br><span class="line">            <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> index,vector&lt;<span class="keyword">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root[index] != <span class="number">-1</span>)&#123;</span><br><span class="line">            index = root[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> index1,<span class="keyword">int</span> index2,vector&lt;<span class="keyword">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = <span class="built_in">getRoot</span>(index1,root);</span><br><span class="line">        <span class="keyword">int</span> root2 = <span class="built_in">getRoot</span>(index2,root);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">            root[root1] = root2;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，与图有关</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="DSU" scheme="https://blog.slks.xyz/tags/DSU/"/>
    
  </entry>
  
  <entry>
    <title>图系列——矩阵中的距离</title>
    <link href="https://blog.slks.xyz/2022/02/21/80b7b127a404/"/>
    <id>https://blog.slks.xyz/2022/02/21/80b7b127a404/</id>
    <published>2022-02-21T08:29:19.000Z</published>
    <updated>2022-02-22T08:14:33.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-107.-矩阵中的距离"><a href="https://leetcode-cn.com/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h4><p>​ 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>​ 两个相邻元素间的距离为 1 。</p><p><strong>示例 1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626667201-NCWmuP-image.png" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：[[0,0,0],[0,1,0],[0,0,0]]</span><br></pre></td></tr></table></figure><p><strong>解题思路1:多源BFS</strong></p><p>​ 一开始看这题，应当能够较快的反应使用BFS进行解答，但核心的问题在于，如果使用传统 的BFS进行解答，起点是任意一个节点，终点为任意一个值为0的节点，我们需要做很多遍BFS才能够解决问题。</p><p>​ 故而，本题中所涉及到的是一个叫做<strong>多源BFS</strong>的方法，其实多源的BFS和单源BFS非常相似，在上述问题中，整体思路如下：首先我们遍历整个矩阵，将所有的值为0的节点得出结果，并加入到队列中去。我们采用逆向思维的方法，将这些值为0的节点全部放入队列中，且这些值为0的节点对应的结果距离也为0，后续经由它们扩散得到的别的点的距离，是在它们的距离0的基础上逐渐进行叠加的，直到扩散至全图范围，我们的多源BFS也就完成了。</p><p>​ 有一个可能会令人担忧的问题：那就是如果某一个点一开始被遍历到，设定好值以后，后面再作为别人的领居北遍历到的时候，会不会要设定的值比之前设定的值小呢？这是不可能的，因为我们采用的是BFS，一层层像波纹一样向外扩散，后遍历到的设定的值，必定大于或等于先前设定的值。所以不需要担心。</p><p><strong>解题代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; neighbor = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>)); <span class="comment">//初始化为-1，代表未访问过的点</span></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 初始化那些0的点，res也应当为0，将他们入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    res[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="keyword">int</span> y = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> new_x = x + neighbor[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y = y + neighbor[i][<span class="number">1</span>];</span><br><span class="line">              <span class="comment">//如果节点不合法，或者节点已经访问过了，直接跳过</span></span><br><span class="line">                <span class="keyword">if</span>(new_x &lt; <span class="number">0</span> || new_x &gt;= m || new_y &lt; <span class="number">0</span> || new_y &gt;= n || res[new_x][new_y] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="comment">//计算res，push进入</span></span><br><span class="line">                res[new_x][new_y] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;new_x,new_y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解题思路2:动态规划</strong></p><p>​ <strong>采用DP，状态转移方程如下：</strong> <span class="math display">\[f(i,j) =  1 + min(\ f(i − 1, j),\  f(i, j − 1),\ f(i + 1, j), \ f(i, j + 1) \ \ )\ \ \ \ \  if (matrix[i][j] == 1)\]</span></p><p>$$ f(i,j)= 0        if (matrix[i][j] == 0)</p><p>$$</p><p>​ 此时，我们需要注意，按照上述状态转移方程，我们好像没有一个办法遍历i，j，能够保证满足，在计算<span class="math inline">\(f(i,j)\)</span>前，我们一定已经获知了<span class="math inline">\(f(i-1,j)\)</span> 和<span class="math inline">\(f(i+1,j)\)</span> 和<span class="math inline">\(f(i,j-1)\)</span> 和<span class="math inline">\(f(i,j+1)\)</span>这四个节点的状态。所以，我们需要分两步来进行计算遍历，先从左上角往右下角计算一遍，计算的时候仅考虑 <span class="math inline">\(f(i-1,j)\)</span> 和<span class="math inline">\(f(i,j-1)\)</span> 这两个节点。再从右下角往左上角计算一遍，计算的时候仅考虑 <span class="math inline">\(f(i+1,j)\)</span> 和<span class="math inline">\(f(i,j+1)\)</span> 这两个节点。由于在前面一遍 遍历中，会将结果存在<span class="math inline">\(f(i,j)\)</span>中，再第二轮遍历的时候，只要将那两个节点和当前节点比较，就相当于完成了和上一轮遍历中的两个节点比较。故而能够达到和上述状态转移方程一致的效果，具体请看代码：</p><p><strong>解题代码：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">                dp[i][j] = mat[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1e7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左上角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右下角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，与图有关</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——经典背包问题及扩展（待更新整理）</title>
    <link href="https://blog.slks.xyz/2022/02/21/8eca8d666ea6/"/>
    <id>https://blog.slks.xyz/2022/02/21/8eca8d666ea6/</id>
    <published>2022-02-21T07:47:19.000Z</published>
    <updated>2022-02-22T12:09:47.144Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一背包问题简介">一、背包问题简介</h3><p>​ 背包问题其实分很多种，此类问题的一般描述为：能否选择若干物品，使它们刚好放满一个容量为 t 的背包。在该篇博文中，我对其进行了详细的梳理。</p><ul><li><p>若每种物品可以选择拿一部分，则为<strong>分数背包问题</strong>，可以使用贪婪解决。</p></li><li><p>若每种物品只有一个，只能拿或者不拿，则为<strong>0-1背包问题</strong>，贪婪无法得到最优解，需用DP。</p></li><li><p>若每个物品的个数有限，则为<strong>多重背包问题</strong>；</p></li><li><p>若每个物品的个数无限，则为<strong>完全背包问题</strong>。</p></li></ul><h3 id="二分数背包问题">二、分数背包问题：</h3><p>​ 分数背包问题思路非常简单，采用贪婪的思路，我们只需要先计算每一种物品，它的性价比，然后进行排序，拿性价比高的物品，直到背包被装满即可。 <span class="math display">\[性价比 = 物品总价值 / 物品总体积\]</span></p><h3 id="三0-1背包问题">三、0-1背包问题：</h3><h4 id="题目描述">题目描述：</h4><p>​ 一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析">分析：</h4><p>​ 如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的<strong>目标是书包内物品的总价值，而变量是物品和书包的限重</strong>，所以我们可有如下解决方案</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p><ol type="1"><li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li><li>装入第 i 件物品（前提是能装下），即 <code>dp[i−1][j−w[i]] + v[i]</code>。</li></ol></li><li><p>``` dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])        if( j &gt;= w[i] ) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">    第 i 件物品装入或者不装入而获得的最大价值完全可以由前面 i-1 件物品的最大价值决定，暴力枚举忽略了这个事实</span><br><span class="line"></span><br><span class="line">- 核心代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;W;j++)</span><br><span class="line">  dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h3 id="四完全背包问题">四、完全背包问题：</h3><h4 id="题目描述-1">题目描述：</h4><p>​ 完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析思路1">分析思路1：</h4><p>​ 大体的规则与初始化状态都和0-1背包问题一致，在状态转移方程处有所区别：</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p><ol type="1"><li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li><li>装入第i种物品，此时和0-1背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第 i种商品后还可以再继续装入第i种商品。</li></ol></li><li><p>``` dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) if( j &gt;= w[i] ) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">  此解法时间复杂度为O(NW)</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure> for(int i=0;i&lt;n;i++) for(int j=0;j&lt;W;j++) dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 分析思路2：</span><br><span class="line"></span><br><span class="line">​我们从装入第 i 种物品多少件出发，0-1背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件...直到超过限重（k &gt; j/w[i]），所以状态转移方程为：</span><br><span class="line"></span><br><span class="line">- 定义规则如下：与0-1相同</span><br><span class="line">  - `dp[i][j]` 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中  `0&lt;=i&lt;=N, 0&lt;=j&lt;=W`</span><br><span class="line"></span><br><span class="line">- 初始化状态：与0-1相同</span><br><span class="line"></span><br><span class="line">  - 将`dp[0][0...W]`初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</span><br><span class="line"></span><br><span class="line">- 状态转移方程：</span><br><span class="line"></span><br><span class="line">  - ```text</span><br><span class="line">    # k为装入第i种物品的件数, k &lt;= j/w[i]</span><br><span class="line">    dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure></p><p>从上述方程中，我们知晓<code>dp[i][j]</code>的值只与<code>dp[i-1][0,...,j-1]</code>有关，就可以开始书写动态规划代码</p></li></ul></li><li><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;W;j++)</span><br><span class="line">        <span class="keyword">for</span>（<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;j/w[i];k++)  <span class="comment">// j / w[i] 为可以装进的最大数目</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li></ul><h3 id="五多重背包问题">五、多重背包问题：</h3><h4 id="题目描述-2">题目描述：</h4><p>​ 多重背包（bounded knapsack problem）与前面不同就是<strong>每种物品是有限个</strong>：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析-1">分析：</h4><p>​ 大体的规则与初始化状态都和完全背包的分析2角度一致，就是在状态转移方程处的k的大小有了一个更高的限制。</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li>```text # k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i]) dp[i][j] = max{(dp[i-1][j − k<em>w[i]] + k</em>v[i]) for every k} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;W;j++)</span><br><span class="line">          for（int k = 0;k&lt;min(n[i], j/w[i]);k++)  // min(n[i], j/w[i]) 为可以装进的背包的最大数目</span><br><span class="line">              dp[i][j] = max(dp[i-1][j], dp[i-1][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="六备注">六、备注：</h3><p>​ 上述所有的算法，由于状态转移方程的特殊性，所以其实在空间复杂度上是可以进行优化的，我们可以使用<strong>滚动数组</strong>的方法来进行优化，就比如最普通的0-1问题，使用滚动数组优化后，我们可以仅用一个一维数组来存储结果，丢掉原先二维数组的第1个维度。</p><p>​ 但是需要注意的是，在对j遍历的时候，必须逆向枚举，这是为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>,...,W] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,...,N</span><br><span class="line">    <span class="keyword">for</span> j = W,...,w[i] <span class="comment">// 必须逆向枚举!!!</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure><p>参考：<strong>https://zhuanlan.zhihu.com/p/93857890</strong></p>]]></content>
    
    
    <summary type="html">本篇笔记记录经典的背包问题系列解题思路及方法，可以活用至许多相似题目</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="knapsack problem" scheme="https://blog.slks.xyz/tags/knapsack-problem/"/>
    
  </entry>
  
  <entry>
    <title>字符串交织问题</title>
    <link href="https://blog.slks.xyz/2022/02/21/f178664086c4/"/>
    <id>https://blog.slks.xyz/2022/02/21/f178664086c4/</id>
    <published>2022-02-21T06:36:19.000Z</published>
    <updated>2022-02-21T06:56:35.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-096.-字符串交织"><a href="https://leetcode-cn.com/problems/IY6buf/">剑指 Offer II 096. 字符串交织</a></h4><p>给定三个字符串 s1、s2、s3，请判断 s3 能不能由 s1 和 s2 交织（交错） 组成。</p><p>两个字符串 s 和 t 交织 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><pre><code>s = s1 + s2 + ... + snt = t1 + t2 + ... + tm|n - m| &lt;= 1交织 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</code></pre><p>提示：a + b 意味着字符串 a 和 b 连接。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>解题思路1</strong>：</p><p>​ 该题其实可以使用非常方便的回溯法思想进行解题，利用递归的形式：我们定义三个指针i，j，k，分别指向三个字符串，如果s1[i] == s3[k]，那么递归处理(i+1,j,k+1)。同理，如果s2[j] == s3[k]，那么递归处理(i,j+1,k+1)。递归边界是：如果i，j，k都到达了字符串的最后，就代表能够完成字符串交织。</p><p><strong>代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，会出现一个严重的问题，对于一些较长的序列来说，会通不过，运行超时。这是因为，这个回溯法，在分支进行的过程中，是很容易出现非常多的分支，并且会容易递归很多次的。所以，对于一些已经递归过的i，j，k结果，我们需要直接让它返回，不要继续递归计算，也就是对回溯法进行剪枝的操作。</p><p><strong>优化代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; </span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3,unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> checkpoint = i * <span class="number">100</span> + j * <span class="number">10</span> + k;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(checkpoint) != m.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> m[checkpoint] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-21%20下午2.48.28.png" /></p><p><strong>解题思路2：Dynamic Programming 动态规划</strong></p><p><strong>参考题解：</strong>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offerguan-jie-de-ge-ren-li-jie-gpspb/</p><p>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offer-2-mian-shi-ti-96-shu-zhon-5kc7/</p><p>​ 可以把题目进行一定的等效转换。约定从s1和s2中按从头到尾的顺序，依次取出一个字符（每次可以从s1中取，也可以从s2中取），加入字符串s3中，这样s3一定是s1和s2交错组成的结果。</p><p>​ 那么问题就转换为在按顺序取的情况下，s1的前i个字符和s2的前jjj个字符是否能构成s3的前i+j个字符？</p><p><strong>状态转移方程</strong>：用f(i,j)表示s1[0:i]和s2[0:j]能否组成s3[0:i+j+1]</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if s3[i+j+1] == s1[i]</span><br><span class="line">    f(i,j) = f(i-1,j)</span><br><span class="line">if s3[i+j+1] == s2[j]</span><br><span class="line">    f(i,j) = f(i,j-1)</span><br><span class="line">if s3[i+j+1] == s1[i] == s2[j]</span><br><span class="line">    f(i,j) = f(i-1,j) || f(i,j-1)</span><br></pre></td></tr></table></figure><p><strong>状态转移方程的原理:</strong> 对于字符串s3[0:i+j+1]的最后一个字符：</p><ul><li>如果该字符等于s1最后一个字符，原问题变为子问题1： s3[0:i+j]是否可以由s1[0:i-1]与s2[0:j]构成；</li><li>如果该字符等于s2最后一个字符，原问题变为子问题2： s3[0:i+j]可以由s1[0:i]与s2[0:j-1]构成。</li><li>如果该字符等于s2最后一个字符，也等于s1最后一个字符，那么子问题1和子问题2中任何一个成立，都可以推出原问题成立</li></ul><p><strong>其余注意初始状态即可</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>() != s3.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(s2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>() &amp;&amp; s2[j] == s3[j]; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>() &amp;&amp; s1[i] == s3[i]; ++i) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>(); ++j) &#123; </span><br><span class="line">                <span class="keyword">char</span> ch1 = s1[i];</span><br><span class="line">                <span class="keyword">char</span> ch2 = s2[j];</span><br><span class="line">                <span class="keyword">char</span> ch3 = s3[i + j + <span class="number">1</span>];</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = ((ch1 == ch3) &amp;&amp; dp[i][j + <span class="number">1</span>]) || ((ch2 == ch3) &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s1.<span class="built_in">size</span>()][s2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为字符串的交织。提供2种解题思路</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    <category term="字符串系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="string" scheme="https://blog.slks.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——最长斐波那契数列</title>
    <link href="https://blog.slks.xyz/2022/02/21/aa9aa6191741/"/>
    <id>https://blog.slks.xyz/2022/02/21/aa9aa6191741/</id>
    <published>2022-02-21T05:47:19.000Z</published>
    <updated>2022-02-21T05:56:16.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-093.-最长斐波那契数列"><a href="https://leetcode-cn.com/problems/Q91FMA/">剑指 Offer II 093. 最长斐波那契数列</a></h4><p>如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：</p><pre><code>n &gt;= 3对于所有 i + 2 &lt;= n，都有 X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></pre><p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,3,7,11,12,14,18]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 本题在LeetCode上，大多采用动态规划的方法解决，我借鉴了部分思路后，发现其实可以用与动态规划时间复杂度类似的算法解决。如下所示：</p><p>​ <strong>对于一个斐波那契数列来说，其性质给它带来了一个非常重要特性：也就是我们只要知道斐波那契数列中的最后两个数，或者前两个数，亦或者中间的任意的连续的两个数，我们就能够确定一整个斐波那契数列的元素</strong></p><p>​ 举例而言，我们知道一个斐波那契数列中，有两个连续的数为5，8，那么整个斐波那契数列前面可能拥有的数为3，再前面可能的数为2，再前面可能的数为1。反之，再后面的数为13，再后面的数为21，等等。</p><p>​ 之所以称之为可能的数，是因为我们并不知道斐波那契数列的长度，所以可能不存在这些数。放到这道题目中，我们可以用两个指针，i和j，遍历arr中所有的元素，例如：当i=2，j=4的时候，我们就假设arr[i]和arr[j]是斐波那契数列的最后两个数，然后循环的向前计算，观察arr中是否有满足条件的前面的数。</p><p>​ 遍历整个数列的时间复杂度为O(n^2)，而查找arr中是否有满足条件的数，我们可以使用Hash表来完成，先再代码开始处，用O(n)的时间，进行插入，后续查找都只需要O(1)的时间。</p><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">//构建hash表，以便后续查找</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[arr[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//遍历i，j，计算以arr[i]和arr[j]为最后两个元素的斐波那契数列的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="built_in">calculateMaxLen</span>(arr[i],arr[j],m);</span><br><span class="line">                <span class="keyword">if</span>( res &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = res;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMaxLen</span><span class="params">(<span class="keyword">int</span> ele1,<span class="keyword">int</span> ele2,unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果找不到的话，退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(ele2 - ele1 &gt;= ele1) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(ele2-ele1) == m.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了,迭代：继续循环</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = ele2-ele1;</span><br><span class="line">                ele2 = ele1;</span><br><span class="line">                ele1 = tmp;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">讲解最长斐波那契数列问题的非dp解法与思路</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——最少回文分割问题</title>
    <link href="https://blog.slks.xyz/2022/02/18/52df1a6e55af/"/>
    <id>https://blog.slks.xyz/2022/02/18/52df1a6e55af/</id>
    <published>2022-02-18T02:41:19.000Z</published>
    <updated>2022-02-21T05:56:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-094.-最少回文分割"><a href="https://leetcode-cn.com/problems/omKAoA/">剑指 Offer II 094. 最少回文分割</a></h4><p>给定一个字符串 <code>s</code>，请将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 其内部其实含有两个DP子问题：</p><ul><li>1、字符串所有的子串，它们是不是回文串。即 s[i, j] 这一段是不是回文字符串</li><li>2、如何分割能够有最少的分割次数</li></ul><p><strong>子问题1：</strong></p><p>​ 我们用一个二维数组 isPalindrome 来进行记录，初始化为false。按照len长度进行遍历：状态转移方程如下所示： <span class="math display">\[s[i][j] = true  \ \ \ \ \ (len = 1)\]</span></p><p><span class="math display">\[s[i][j] = (s[i] == s[j])  \ \ \ \ \ (len = 2)\]</span></p><p><span class="math display">\[s[i][j] = (s[i] == s[j] \ \ \ \&amp;\&amp; \ \ \ isPalindrome[i+1][j-1])  \ \ \ \ (len &gt; 2)\]</span></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="comment">// 初始化全false</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">// 长度为1的是回文串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 从长度为2的子串开始枚举[left, right]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">    <span class="comment">// 左端点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left + len &lt;= n; ++left) &#123;</span><br><span class="line">        <span class="comment">// 右端点</span></span><br><span class="line">        <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 长度为2就是这俩是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]);</span><br><span class="line">        <span class="comment">// 长度大于2, 端点相同的同时，内侧也要是回文</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]) &amp;&amp; isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>子问题2：</strong></p><p>​ 我们用一维数组存储，字符串前i个字符组成的子串，最少需要多少分割次数。dp[i] 为将 [0,i] 这一段字符分割为若干回文串的最小分割次数，状态转移方程如下：</p><ul><li><p>从「起点字符」到「第 i 个字符」能形成回文串。那么最小分割次数为 0，此时有 dp[i] = 0； <span class="math display">\[dp[i] = 0 \ \ \ \ \ ( isPalindrome[0][i] == true)\]</span></p></li><li><p>从「起点字符」到「第 i 个字符」不能形成回文串。此时我们需要枚举左端点l，如果 [l, i] 这一段是回文串的话，那么有 dp[i] = dp[l- 1] + 1 ( 满足回文要求的左端点位置 l 可能有很多个，取最小 )</p></li></ul><p><span class="math display">\[dp[i] = min(dp[l_0-1],dp[l_1-1],……,dp[l_{i} - 1]  ) + 1 \ \ \ ( isPalindrome[0][i] == false)(l_i = i)\]</span></p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCzuizui题目，题目核心为动态规划。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——房屋偷盗问题</title>
    <link href="https://blog.slks.xyz/2022/02/17/d13b71a5983a/"/>
    <id>https://blog.slks.xyz/2022/02/17/d13b71a5983a/</id>
    <published>2022-02-17T09:51:19.000Z</published>
    <updated>2022-02-20T13:32:51.650Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-089.-房屋偷盗"><a href="https://leetcode-cn.com/problems/Gu0c2T/">剑指 Offer II 089. 房屋偷盗</a></h4><p>​ 一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响小偷偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</p><p>​ 给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1]</span><br><span class="line">输出：4</span><br><span class="line">解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 从纯解题的角度而言，本题是可以采用DFS进行的，但是使用DFS会超时，我们需要时间复杂度更为简单的算法。动态规划就起到了比较大的作用：</p><p>​ 设动态规划列表 dp ，dp[i] 代表前 i 个房子在满足条件下的能偷盗到的最高金额。</p><p>​ 状态转移方程如下： <span class="math display">\[dp[n+1]=max(dp[n],dp[n−1]+num)\]</span> ​ 其中，<span class="math inline">\(dp[n]\)</span> 来源于：我们不抢第n+1个房子。</p><p>​ 其中，<span class="math inline">\(dp[n−1]+num[n+1]\)</span> 来源于：我们抢当前的房子，这样的话第n个房子就不能再抢了，所以我们只要加上前n-1个房子能抢到的最大金额即可。</p><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">maxNum</span><span class="params">(nums.size()+<span class="number">1</span>)</span></span>;</span><br><span class="line">        maxNum[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        maxNum[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            maxNum[i] = <span class="built_in">max</span>(maxNum[i<span class="number">-1</span>],maxNum[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxNum[nums.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-090.-环形房屋偷盗"><a href="https://leetcode-cn.com/problems/PzWKhm/">剑指 Offer II 090. 环形房屋偷盗</a></h4><p>一个专业的小偷，计划偷窃一个环形街道上沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。</p><p>给定一个代表每个房屋存放金额的非负整数数组 nums ，请计算 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,3,2]</span><br><span class="line">输出：3</span><br><span class="line">解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 与上题其实大体一致，只不过需要转一个脑筋急转弯：</p><p>​ 环状排列意味着第一个房子和最后一个房子中只能选择一个偷盗，因此可以把此环状排列房间问题约化为两个单排排列房间子问题：</p><ul><li><p>在不偷盗第一个房子的情况下（即 nums[1:]），最大金额是 p1 ；</p></li><li><p>在不偷盗最后一个房子的情况下（即 nums[:n−1]），最大金额是 p2 。</p></li><li><p>综合偷盗最大金额： 为以上两种情况的较大值，即 max(p1,p2)。</p></li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">rob</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>) <span class="keyword">return</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp1</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">dp2</span><span class="params">(nums.size())</span></span>;</span><br><span class="line">        <span class="comment">//dp1 不把nums[0]计算入</span></span><br><span class="line">        dp1[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp1[<span class="number">1</span>] = nums[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">//dp2 不把nums[nums.size()-1]计算入</span></span><br><span class="line">        dp2[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        dp2[<span class="number">1</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            dp1[i] = <span class="built_in">max</span>(dp1[i<span class="number">-1</span>],dp1[i<span class="number">-2</span>] + nums[i]);</span><br><span class="line">            dp2[i] = <span class="built_in">max</span>(dp2[i<span class="number">-1</span>],dp2[i<span class="number">-2</span>] + nums[i<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">max</span>(dp1[nums.<span class="built_in">size</span>()<span class="number">-1</span>],dp2[nums.<span class="built_in">size</span>()<span class="number">-1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为动态规划。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——经典最长公共子序列问题</title>
    <link href="https://blog.slks.xyz/2022/02/16/513d3a9242d5/"/>
    <id>https://blog.slks.xyz/2022/02/16/513d3a9242d5/</id>
    <published>2022-02-16T03:02:19.000Z</published>
    <updated>2022-02-20T13:33:24.358Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-095.-最长公共子序列"><a href="https://leetcode-cn.com/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列</a></h4><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><ul><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p><strong>解题思路</strong>：</p><p>​ 最长公共子序列问题是典型的二维动态规划问题。</p><p>​ 我们设定一个二维数组 res, <span class="math inline">\(res[i][j]\)</span> 代表text1的前i个字符和text2的前j个字符的最长公共子序列。当i = 0或j=0时，均初始化为0，然后我们写出递归表达式： <span class="math display">\[res[i][j] = res[i-1][j-1] + 1  \ \ \ \ \ (if \ \ \ \ text1[i-1] == text2[j-1])\]</span></p><p><span class="math display">\[res[i][j] = max(res[i-1][j],res[i][j-1])  \ \ \ \ \ (if \ \ \ \ text1[i-1] != text2[j-1])\]</span></p><p>​ 然后按照动态规划规则，进行循环求解即可。</p><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_1 = text1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> len_2 = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(len_1 + <span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(len_2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len_1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len_2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = <span class="built_in">max</span>(res[i<span class="number">-1</span>][j] , res[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len_1][len_2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>C++代码技巧注意</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维数组的方法</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为经典的动态规划问题——最长公共子序列问题。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记18——常见的位置编码Position Encoding方法</title>
    <link href="https://blog.slks.xyz/2022/02/15/c20d8f810e24/"/>
    <id>https://blog.slks.xyz/2022/02/15/c20d8f810e24/</id>
    <published>2022-02-15T01:33:19.000Z</published>
    <updated>2022-02-20T13:31:19.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一固定的绝对位置编码">一、固定的绝对位置编码：</h3><p>​ 在Transformer中使用的就是绝对位置编码，我们会将输入的序列首先通过Linear Embedding的形式，编码成 $ n d_{model}$ 的形式，<span class="math inline">\(n\)</span> 代表token的数量，<span class="math inline">\(d_{model}\)</span> 代表一个token的维度。</p><p>​ 然后我们会生成位置编码，绝对位置编码是固定值，其能够支持较长的序列，我们假设支持最长的序列长度为5000，那么就应当先生成一个维度为 $ 5000 d_{model}$ 的矩阵，具体公式如下：（不唯一）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220215094001163.png" /></p><p>​ 使用如上所述的公式，代表不同频率的正弦和余弦函数进行表示：pos代表 第1个维度，也就是5000那个维度， i代表<span class="math inline">\(d_{model}\)</span>那个维度，对于一个固定的<span class="math inline">\(i\)</span>而言，我们会发现，其就是关于pos的正弦或余弦函数，对于不同的i而言，就是不同的频率而已。这样子预先计算好一个 $ 5000 d_{model}$ 的矩阵以后：</p><p>​ 等到要使用了，我们检测到token的数量是n，那么就直接取前整个矩阵的前 $ n d_{model}$切片就可以，然后与序列的Linear Embedding相加即可。</p><h3 id="二可学习的绝对位置编码-learned-positional-embedding">二、可学习的绝对位置编码 Learned Positional Embedding：</h3><p>​ <strong>直接对不同的位置随机初始化一个postion embedding</strong>，加到word embedding上输入模型，<strong>作为参数进行训练。</strong>使用Learned Positional Embedding编码，位置之间没有约束关系，我们只能期待它隐式地学到，是否有更合理的方法能够显示的让模型理解位置的相对关系呢？见后：</p><h3 id="三相对位置编码-rpe">三、相对位置编码 RPE：</h3><p>​ 在Swin Transformer中，使用的就是相对位置编码，使用绝对位置编码，不同位置对应的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1和位置2与位置3和位置4都只相差1，这些关于位置的相对含义模型能够通过绝对位置编码get到吗？并不太行。</p><p>​ 在Swin Transformer中，这种相对位置编码在计算Attention的时候进行应用：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120718204.png" /></p><p>​ 相对位置偏差是怎么确定的呢？如下所示，假设我们的特征图是左侧的2*2的格子，下方是我们熟知的绝对位置索引，相对位置索引如右侧上面一排所示，其实就是当前计算格子的绝对位置索引减去其他格子的绝对位置索引。然后将四个像素的相对位置索引展开后拼接在一起形成一个新的矩阵。这个矩阵就是二维的相对位置索引矩阵。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/iiioio.png" /> 在作者的源码中，其使用的是1维的的相对位置索引矩阵，我们不能简单的将x,y相加，不然可能导致不同位置的相对位置索引一致，导致出现问题。所以作者在源码中经过了一个简单处理。我们先把所有的行列标加上M-1，然后再将行标乘2M-1，然后再将行列标相加，得到的矩阵。</p><p>​ 然后我们需要把Relative Position Index通过一张Bias Table映射成relative position bias才是用于计算Self-Attention最终用于计算的Bias值，也就是公式里的矩阵B。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120814669.png" /></p>]]></content>
    
    
    <summary type="html">整理了三个常见的位置编码方法，包括绝对位置编码、相对位置编码、可学习的位置编码。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Position Encoding" scheme="https://blog.slks.xyz/tags/Position-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记17——常见的Loss损失函数整理</title>
    <link href="https://blog.slks.xyz/2022/02/11/a5a0c2a08899/"/>
    <id>https://blog.slks.xyz/2022/02/11/a5a0c2a08899/</id>
    <published>2022-02-11T14:18:19.000Z</published>
    <updated>2022-02-20T13:31:16.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一多类别分类任务常用损失信息熵交叉熵相对熵的概念与应用">一、多类别分类任务常用损失：信息熵、交叉熵、相对熵的概念与应用</h3><h4 id="信息熵">1、信息熵</h4><ol type="1"><li>随机变量 <span class="math inline">\(x\)</span> 的自信息 (self-information)，描述的是随机变量的某个事件发生所带来的信息量。</li></ol><p>​ <span class="math inline">\(I(x) = -log(p(x))\)</span></p><ol start="2" type="1"><li><strong>信息熵</strong>即所有信息量的期望,其中<span class="math inline">\(n\)</span>为事件的所有可能性。</li></ol><figure><img src="https://www.zhihu.com/equation?tex=H%28X%29%3D%E2%88%92%E2%88%91_xp%28x%29log%28p%28x%29%29%3D%E2%88%92%E2%88%91_%7Bi%3D1%7D%5Enp%28x_i%29log%28p%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><h4 id="相对熵">2、相对熵</h4><p>​ KL散度，如果对于同一个随机变量x有两个单独的概率分布 <span class="math inline">\(p(x)\)</span>和 <span class="math inline">\(q(x)\)</span>，可以使用相对熵来衡量这两个分布的差异。</p><figure><img src="https://www.zhihu.com/equation?tex=D_%7BKL%7D%28p%7C%7Cq%29%3D%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28%5Cfrac%7Bp%28x_i%29%7D%7Bq%28x_i%29%7D%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ K-L散度其实是<strong>数据的原始分布p和近似分布q之间的对数差值的期望</strong>。</p><p>​ K-L散度<strong>并非距离，其不满足对称性</strong>，即 $D_{KL}(p||q) $ <span class="math inline">\(!=\)</span> $D_{KL}(q||p) $</p><h4 id="交叉熵">3、交叉熵：</h4><figure><img src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 在机器学习中，往往用 <span class="math inline">\(p(x)\)</span> 用来描述<strong>真实分布</strong>， <span class="math inline">\(q(x)\)</span> 用来描述模型<strong>预测的分布</strong>。</p><p>​ 计算损失，理应使用相对熵来计算概率分布的差异，然而由相对熵推导出的结果看：</p><p>​ 由于信息熵描述的是消除 p (即真实分布) 的不确定性所需信息量的度量，所以其值应该是最小的、固定的。那么：<strong>优化相对熵也就是优化交叉熵，所以在机器学习中使用交叉熵就可以了</strong></p><h4 id="为什么使用交叉熵">4、为什么使用交叉熵：</h4><p>​ 在机器学习中，我们希望模型在训练数据上学到的<strong>预测数据分布</strong>与<strong>真实数据分布</strong>越相近越好，上面讲过了，用相对熵，但是为了简便计算使用交叉熵就可以了。</p><p>在二分类中，交叉熵损失函数如下：<span class="math inline">\(y\)</span>是实际标签，<span class="math inline">\(\hat y\)</span> 是预测值z经过sigmoid函数之后的预测概率。</p><figure><img src="https://www.zhihu.com/equation?tex=L%3D-%5Bylog+\hat+y%2B(1-y)log+(1-\hat+y)%5D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>Sigmoid函数如下：</p><figure><img src="https://www.zhihu.com/equation?tex=\sigma(z)+%3D+\frac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 交叉熵损失函数一般用来代替均方差损失函数与sigmoid激活函数的组合：对于sigmoid函数，当 <span class="math inline">\(x\)</span> 的取值越大或越小，函数曲线变得越平缓，意味着导数<span class="math inline">\(\sigma(x)&#39;\)</span> 越趋近于0。以单个样本的梯度下降为例子：</p><figure><img src="https://www.zhihu.com/equation?tex=z%3D+wx%2Bb" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\hat%7By%7D%3D+a+%3D\sigma(z)" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=L_1(y%2Ca)%3D\frac%7B1%7D%7B2%7D(y-a)%5E2" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=L_2%28y%2Ca%29%3D-%28ylog%28a%29%2B%281-y%29log%281-a%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 前两个公式是前向传播过程中线性的部分，和非线性的部分。L1是MSE损失函数，L2是交叉熵损失函数。然后我们分别用L1和L2对参数w和b，利用链式法则求解梯度。</p><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+w%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)x" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+b%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+w%7D%3Dx%5B\sigma(z)-y%5D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+b%7D%3D\sigma(z)-y" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 可以看出，<strong>均方差</strong>对参数的偏导的结果都<strong>乘了sigmoid的导数</strong> <span class="math inline">\(\sigma(z)&#39;\)</span> ，而之前看图发现sigmoid导数在其变量值很大或很小时趋近于0，所以偏导数很有可能接近于0。反观<strong>交叉熵</strong>对参数的偏导就<strong>没有sigmoid导数</strong>，所以不存在这个问题。<strong>这就是选择交叉熵而不选择均方差的原因。</strong></p><p><strong>分类任务的学习过程：</strong></p><p>​ 用神经网络最后一层输出的情况，来看一眼整个模型预测、获得损失和学习的流程：</p><ol type="1"><li>神经网络最后一层得到每个类别的得分<strong>scores（也叫logits）</strong>；</li><li>该得分经过<strong>sigmoid(或softmax)函数</strong>获得概率输出；</li><li>模型预测的类别概率输出与真实类别的one hot形式进行交叉熵损失函数的计算。</li></ol><h3 id="二多标签分类任务">二、多标签分类任务：</h3><p>​ 在多标签分类任务中，一般采用<strong>sigmoid</strong>作为输出层的激活函数，使用 binary_crossentropy（二分类交叉熵损失函数）作为损失函数. <span class="math display">\[\sigma(x) = \frac{1}{1 + e^{-x}}\]</span> ​ 其中<span class="math inline">\(a\)</span>表示使用 sigmoid 函数激活输出层对应的神经元，<strong>此时最后一层的输出就不能看成一个分布了，因为加起来不为 1，现在把输出层每个神经元看作是一个二项分布， 这相当于将一个多标签问题转化为了在每个标签上的二分类问题。</strong></p><p>​ <img src="https://www.zhihu.com/equation?tex=L_2(y%2Ca)%3D-(ylog(a)%2B(1-y)log(1-a))" alt="[公式]" /></p><p>​ 计算一个样本各个标签的损失，然后取平均值，得到最后的损失。</p><h3 id="三回归任务常用损失">三、回归任务常用损失：</h3><h4 id="l1-loss-平均绝对误差">1、L1 Loss 平均绝对误差</h4><p>​ <strong>目标变量和预测变量之间绝对差值之和</strong></p><p>​ MAE曲线连续，但是在<em>y</em>−<em>f</em>(<em>x</em>)=0处不可导。而且 MAE 大部分情况下梯度都是相等的，这意味着即使对于小的损失值，其梯度也是大的。这不利于函数的收敛和模型的学习。但是，无论对于什么样的输入值，都有着稳定的梯度，不会导致梯度爆炸问题，具有较为稳健性的解。</p><p>​ MAE有个优点就是，对于离群点不那么敏感。因为MAE计算的是误差<em>y</em>−<em>f</em>(<em>x</em>) 的绝对值，对于任意大小的差值，其惩罚都是固定的。<strong>针对带有离群点的数据，MAE的效果要好于MSE。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_15_642.png" style="zoom:50%;" /></p><h4 id="l2-loss-均方误差mse">2、L2 Loss 均方误差MSE</h4><p>​ MSE的函数曲线光滑、连续，处处可导，便于使用梯度下降算法，是一种常用的损失函数。 而且，随着误差的减小，梯度也在减小，这有利于收敛，即使使用固定的学习速率，也能较快的收敛到最小值。</p><p>​ 当<span class="math inline">\(y\)</span>和<span class="math inline">\(f(x)\)</span>也就是真实值和预测值的差值大于1时，会放大误差；而当差值小于1时，则会缩小误差，这是平方运算决定的。MSE对于较大的误差（&gt;1）给予较大的惩罚，较小的误差（&lt;1）给予较小的惩罚。也就是说，<strong>对离群点比较敏感，受其影响较大。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_12_56.png" style="zoom:50%;" /></p><h4 id="smooth-l1-loss">3、Smooth L1 Loss</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_04_33_822.png" style="zoom: 50%;" /></p><p>​ 从下图种中可以看出，该函数实际是一个分段函数，既解决了L1不光滑的问题，也解决了L2容易产生梯度爆炸的问题。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_05_00_718.png" style="zoom:50%;" /></p><p><strong>Smooth L1的优点</strong></p><ul><li>相比于L1损失函数，可以收敛得更快。</li><li>相比于L2损失函数，对离群点、异常值不敏感，梯度变化相对更小，训练时不容易跑飞。</li></ul><p><strong>参考：</strong></p><p>https://zhuanlan.zhihu.com/p/35709485</p><p>https://www.zhihu.com/question/336677048/answer/761385679</p><p>https://www.cnblogs.com/wangguchangqing/p/12021638.html</p>]]></content>
    
    
    <summary type="html">整理了一些不同任务中常见的Loss损失函数\信息熵、交叉熵、相对熵以及相关的基础知识内容。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Loss Function" scheme="https://blog.slks.xyz/tags/Loss-Function/"/>
    
  </entry>
  
  <entry>
    <title>博文复习日志1</title>
    <link href="https://blog.slks.xyz/2022/02/11/962c9a0cc3b5/"/>
    <id>https://blog.slks.xyz/2022/02/11/962c9a0cc3b5/</id>
    <published>2022-02-11T13:52:19.000Z</published>
    <updated>2022-02-20T13:29:22.282Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5734a7de8e600d231091ff676bd42181369bfba87d201edfc5c14b2e92db6878">0b64cd3abe5b0a0a039a37d86c66d75eaeb9cde5c6dadc3c6d4d424e956e68e5859de93c067c256c245d75df485065102f6e2903c24acc225d3947c06b46eb863dd4b5852f98aab38803012f003c6c5ce6fff79afb10e1792ca7214d925987e0c717d406814885b789fb91e2e91f62e79489c1eb338c6615f677769d830ccf190fb9bbb686abd703322115c45664a457c7196ebc5128f0dbc61fa90adc2470af75105015c70e866cf9e65b8431b286f91724aada9a9fd5965d62719e3af60032aa7a2f77ed452eac7ab39f33c601c5d6de7df46cb4de25570ccbf95f141c0967a7b34c72683919d199358e5f05f83fc8af0d4a187180a67e0dfe958e0af9d66d33ab8d086e02df177e615e8042752039b5aa8ebbbf03fd595157a16f93e9d8aa7f0b856ccb5a1ec0ac5a77b1362d12bdc9c4ff39d2127ba4fa1a34736ed266b04fafccd0a982584b7e617ef2c7abee5c2cc4fbc96fa0391fe18bb0613a55fbdf71d01cafec27c0e41772b97d10dd173daa0e0dc1b05aa7b9d97e8244f9fba4f4018e4818e86e70f34c862bd69d9675ed15877d5449c4b7e8a6d6bc656ea82eba26ae72ad6ef75be44700be429e708bf43289740b82d67832194999149db733dd79f9775627aca1553102949d134429a4b5ec014c19965b51aacdd0b8af88faa8f0dd23ee465a91973610403e7f7015e27c4ca73425c835a103746324927ac9961a1fbbfa364ec6f09dca400884a8cd26d49df0e797f917bf5e1ddd4ce84f68c180d01f4a2b8fa7ffb12c378c27f7d149c0574024f6c7d997926a562382a75b7df0671abdb0741935b21dd625401ae2c8d83fe10f25ad46985c2442617293a87fa44bbe23878f5f0a341dd752b7d2f22ca0c80b746b4da56555f586c5ff770b6bc47b247939fd87fd97df54dee143d09a3572eb4097e5f0acb6a7c82b3d0bd31f0a92cb99e2c8c3cab16ed7b365b2a600a5fa080289d1d865a6b4c227ecbbb2fd1d2fdfd66082ef6074198a5aaa6aba8d4829da5c094a86176a0841491ccf4dc7ee545dd7a034ee8259f5f0011b7db9e433b4673050c085dd734b2e70a09f2866709876a15e124d99989ea943727a984ca6d5fc822e64d93de977821ab9d78a78ef14d4567d09ff69b40b6e6c01fc6b8680b5e704e23e00aedbcbea610a97288743de8f574fb680a2444d1c9d3f94bab3288a3ad504535c89a6c20f7dc83354a56877fb4beb4518dfce2d32f5293c16af8aa7f66eb6226c5fa93f423ffb44e166affdca16f9a05ffbdb05f1f2538680745a068f73f4f030afaf58b008316ecabc4bf15eeeed12b2a52f68c9ea007ac8768c5c6369f545833605181f6bac06257a122e6ffbee6c14cf2560e5a3b90604789144a509dcffc9236565ac7c26ffdac2199fbd3f470921f9c58fce79be41fd174f513de5530a298d2163c94cb7367570c6d709e3c6eedf24bc7f3e257d899a37ee636ba4fe04cb801f41d3c5b0716f199f23245ae06122c75a258215886896d8e941bf301108f3462f67f73121ea5b0aa5cabb8acfc32b4daa04a6014d2b05523627fb55d8b62b8565d6f2742035f260619cdae288d7b95e305a7b63421ceea761a047995e93ac206cdbf1fe479b687041f30d9083acd89f42d977a9257aa6f25950b3aeb3f06861ce31b9a0be69af54e637cb197c1238eb3fadd76adb0a97a323c64e2a34f9bdd00d779740449a5558edfc0187cd35c7a2ee95e0c21a0d27cd826e9416d9c405093e796a880a3a0cc20dec018e9c71f66aab54c8ebc7b2080498895a41512129103fa751121bd758cbd12e794685d1087a2844eb0494812bd86a5ca45157ca56a8e9451ea285e0f4c4aa3fcf8ea8af6c5021bba6fd67f9c2e3fc9aa5ac9f3c02a1cb57ce09b545d81b93cf3a9ed1c9cea76e5f2c8324a405e21bec4f37dd50b47d82cf68e0be38d9c8abcb3dfdf7086e46fe9a474e8253fc2d4a50b1ea681c53f39eb8051d3d1d7100b6184437a37ff53f34faf3f2b2e76e117ce47273c0fe4f75873df7fc377e1c3b7e8a180207ec326f2caaa79e5e672744f6795f10a78abef27b27e0953f29e2feb01fd6200284d0fb97e16534f8a234e4cc3134f5a103d2143b40523d277cda610eb3ebb53cce25b589fb3202da36018584b201f0efa38ec2d614a655cf21a56a0cbf67f439514f3445a07592f65ade23ac22f420830df90c395561b29e21156abd5e8af33cfd468013c1f04c0e3220820eeb86cc17d45798140c744c786b738ba23ae99675f189ee70dcf02cf5744c19b5c1084f3400caf5fc6b6456c8832e41d92cb1b664fd0297157d64629fd388961ee389a5226b60068a0eb0a78d48af553412d2e0866a1acbb5fb1f1754dd617e9f97b7c8f52cf8f2e76ec50e6c35ab04a5db2145b09344ec548405ca26274d6ac8471a1cb6dfbb1b616c26b2e45c85e87bd1a542563eb2b0c0d8f1ba79af341c4734c93cda4e93e05a8e1963c7ed0d320281388e552965dd33ac8f4e7ab0e38b7eb506e41b123c270fba5731b62372f40e5a4723155543790496c3e13e8999601978f9b51cfeffd3384b131367ea10bf445e905999513d0fae7f1293d91824a27fd8ebac8a0d614838ffbeb5d96f92522291435daba7c4fd34641136cc74009ce4da35484a180b2cf738d560196729705a95fc6e4a0a131e7ad1f6e58c6a5509fc0d193db3581f1529c91ba368f33d8d436d1c57eeb9efc2222b43f9c05ef45ef9cc7af5d44d73b8eee95061490f3755d80b7401f215ed7d358736f9e39b8664b73b50b8f6928a09bb3e3ec9f7f0b12dcb33638e684fb1ea23e182002d69213033ff32081f3677d4da9f4da9a6200d32af6345611f43a811b90c14b113e7efe51db0ffa66c63d8c7ef4b8f8c4c18346de3ebc2904386dc5909f3fcf87c3e538f98362ebc9ce8a2b9a3f1ee4e98c79ffe505049bf3ecb03d052e3c9005687ce224189a0a7b2cad32cd6e833f8d5bb900d08735398e5b930bce023d6700a90d05ee7774743910920e9e3127b35043485ca0fba788a988c514c45f8771f704a5c934f4ea0f6bee0a9dd76d8b493f470fb2e321558b3ef19151eb97ea08471a0b12c6ecadf139849d1609986cb0dafe576df189a60085cd29ade011e7cf9c7b63c5f4ed81c9bd40c26fef4b225d8b26ed8ec94338e3a651d4f2573204f1488c488aed9af338a630e02ee8b4ab8727adfc060d3c1dd2ae37f8c589666037a6718cccae93b8f3b976b4b5a17affd40008cae1689ee249ef445d8a5315cd21a1b957efffd6524bf3645cdc95869f2a43dfce4d6bb71ba4008f2ae005ecdb12f9bea4722ad836b1f6abd424ad3f02a02c048567c3bdcf7f489566d44c5f3a21877698bf9163989c22dcc3647e3340e114266381801df786c6fde82b052c4a521fb2b26565c0c5ccb2569dde84414de256a78df1118cbb08cfdb14bb87ec1ded2f0b7e718e31e7288850d76205ab005d98a8374a0b8f55645919e7cc4380538b0079f8f97a3568c338015907111df6c0e490ee582677d72b80b33f01aac61326d41897a9d56dff2b683c7624b4bb4e71cd22e78f8d73d7a99607cef2ad26379416f969a7aa52ad973121799a09771d8c6e53787477eb859168e7a1b0705df97724abce2aba5d1b56616715438c4340e26268622e3b36c0fcd21b2fd51b0ef6b9489a6abc6299b6589ac3b59bcd182369968bce00bc7499b75faba475e52194c0d7351be37c8b220308c3aa04af599c19818cf275ff8409f84d3ed6846706f63b57c0520e3d3914f32bf9daceed10d3923508aad66e5468cdef671d6521c001af5d1056db3a104ad7eda6df050b83fdb74b20ccb7d2e55d060e3e13e41bfc5c1768305bfcf8b2a2e42eedb1f7d4c36b3ec4e182c858f6935e0659eef7cb687f654e27c4194c9690f8913e66a1df9f524b93faf1789cd5aa85d303f47e741041046f82f08bd7c186492824236abd0e446e6668669e787aec7195a62c0775beae4a1e902b976bf92055a89300f02a909011cab0c27d2796204280c654837ae9c8f9122a7004b475c557bc45c80dc58806692cd0fd0d31efef3b0b78a034bd978ed5eac292439b347619017aa2e96d1e3f4325baa0c72ec635a6e5f52164cde2d4e9640539292bb73e7f5ee283b22c89d8b5b047a7e835e5ae71f23f7a1391a735b7eaceb8006a384090ae9c60a55e646c29d9f7141c65360a2b6c14b8756fc4b1aa57b0b508e790ea9aa9ee476cfeda4b335003a1506e077a46819ae03478c3328fa711e339f8a83d194f3f271d284cf56410a66913032300b1660600e9d4cb1ccca83ba64e82aebe7ed490752ea7f85b452bc926b29c274d7976e84b14b96d60b6103de6990eceba1785cc968ba8bf003632b5c42bd8d7bc428d575a0dfc28434f04a008fe3571db357061ce0a52686f153fc95b1163722a42484c46a50227bcc61fa812e4fcf1f8deb5164206ef0a5d6976c81b28888be0ebe0b15d4186a084d0442e090406df08a6449ed0400e4c275d266ce520441fbbc7a72c6f23767c2c6cf1eb12c2b6c574679cc6e2ed3e4c4c8203828aac4e811fac757e2eb640aee657e2c2df6b747ba2148964098a70616aee179d08afa935f4013a7d8a8747d20759588abf3420ad24950aa867d50d54fe2e1c25df5dddaa8b528013e82ff13ff3d6a94e2453a3f1c44024d3daf08477e62ea9494b1fd37fe96baf126122816ac7becc18721535254e657e5f5194e4698f87626ad56ba7ac6d7a13a8818bf2bc6b293b1a93979836ded825d23e77f0d8d13a333851c0897c56edff76e90d5cd6f3956da857ad6c4538dbdcbdfb83c4d307961b4c7f4d9dcc59ad2994bfced36a2d4f54a43d18272c3de1ffe3806d6206fd3a81df1558f3f5f6e2b52aa631c999cf7b9758f9fdb60bf553ebd7430ecc62e7d888f1c0be56df04b55189b8292f93d809ee1ce46aea0cea359105d122c8e9be28a1a796440d7b125590e949dc1665e3e1a17a7c7322012999d1ab5bcb3710d376765c9cba6bff8fbf79b894b3c6ce0ea8ce3072f4de8584e353395aeeb46c9504e3357c6b8b5fc2e6e71b19a70374b926af0f3b49843f49c1254e53e7c4257c56752ecde0bb756a828c05be23127cdd6afa7ee7d611b832c10e8e51d63e6d4f1947eb2808e8ec48fa1340e8742dc9d7523cb6c18d6e96b1e3b70051fa908557652d98ba77317c8af4adfbcc54cd6783861d5e8965a073aee61401856f454ae1dc0abad74d98d23ae757bc5368be0fcc3ea6366fe6dc7bcde2c86491e16d40a7463202d272b42efa0a38a41d53523eb75a17ce0379a09ed353a15d29d2885ff58df61ddb082a8082377e471a85ff6c3ae1a9a4924d08aef7d7980d972f5686d4be2185f70d1df8cb4b152df63e07784d0f0ea4c7b606770c042a40e6aca834e3c6846f064a7bb99d7167833bd40ab4786766d4527e8474936d56853f84d9f2097551789cc804655229011a5b202cd2c95046074484c93e60b4e4f635145290743188dca22011b75d539aa09a98fd37de1d62f8eff7dc45563090b4684b6bcef6f6eeb7e486d916cbde2ed84eb34a23f0c62b98fa37be5f3b883202230217d5b9b6e3bd897b845defebd0977afa5f702fffd0a8e29978d86ac1ca2751946261a7c9afd189853f30a5a183bc7fd9c63b466544d5afe730e77f920caf673f019c762f1f2d3b4d58fdc6b7f115433f60518d1944a780a4668cd5a08cdd4769f8d810a8434f90c281abef969cb6730b0f9a5a34bad2625135c0cd7474976557df8bdbd276fe6d6970f928e4845ef852323f390ade0728b721567926287b68830edd81c1bdebf325dd73e6536feb100516cbbe02b61009856a42089bc0b670acb1d988606150ff32529bd16987d8fbc8aba08d8f04a4955a1f529ba8285b5db99ab0f77dc5365b629c11f1479fa8ec4e8556b171c4b5a53cd63189b0791d67eb304f8b5517e2e0cde44d4cb2d78638835ad4235276411c14415e401c08f1842efae0f459858907f4131876be1c32f823cbc2910990994d5862257490b08351180fcc0feb0e68cbc5d84e4c75d187fbfa8b3dbe8660561521cc1f19c7ffc79d1e998f2a3702121054aa7374600551166a2dda64f3bd682f0ec606b9741816d5d258385cffef3ee87e7f7275c0ce5270a4d7855b8ee545a79149a79f6ac212688dd43e963edf51369938a1ae026f216bfa621b2894ea35bcfc7a303380d310758862ad2d72871669d6494fac26c04a1b6e1ae73e5c1cf2d45677363ec956baea1eea23b00fdbc77f8d4e1a87e84cea7fa79b68a16be064cc23b8dab2aa0d1e356853b60b392bee92296292e42df1950d2a9c14b4815ec5e3d95fe462d52e7556075141e4cc08ed512f89a7f112a5665655e6640cbb057711f63aa5d823faa41ea40ffc088bf7947dd2ffee21b42e21c1c2c865fc752d2010bdcdbb5f4f487b9f54ea6dced854039bb67ad0b22a1fb64cb13d63d29eba83cee898c7e51b53ab8f24313c0d52663387b3a98e57ba7d37b4da339648af591e7afc228e34df64ab1aede31157ee67cef4daf1e2b3dd414bbc0684189c042d24c0da3653aa71343c015506391ddfc52548b5a5a1b8e46de5fbb405306d6e0af078eb0e221250a58968b07189b6ff60b53ff9c5a4b1a02e13b00bf5afeffc747baff22f3f91b547abbc2444a73ac5380c35bad2f4be96e4cafdd85caf55b73ad8ffb66838dbe982577a2d3078defe26f0f4b81d8ba1953c918d0be4b692490d21e0b327c8a5d19efba8152fc976eba198597c36ae69cd579ec088cf0e23e4e57edc7903d5674168248a2245ed45cdc4f4a9d00c88c2f5c3d94fd74b0fcde5ad73bad8f3596e8b6d9028edd38717e44c8b84ff505bbc386793ad97ec571ce2abbb26173bb7faaa270a821ec4e670a6e97b7eb278f6b479e40855dc8eb4b0c991bd23fe041835985747934435f4f38618f5bd5a6b487001ad4fb8a08853bf40920ee89792b8136b0e1d8b87bd7b8ddaf9a1c6900c546a1cb8a4460c53d2297eb93a418308c9c8a0b8ced525fbbbf5f4e8cfb025ced158b3054eb6bfa3fd647b2fea0fd06ea98bf57111a138eb2f5f4141417ad6da249429ce53842b694b8a730a87ec42ee46907e52e501812a15846f829b97cd95d72eef27856e7661f3453d7699eef0fea7a622b0cf94f8c6b4d0f6f0ff02d2bb265cebe52cfca7094387f404381f66f837b86dc4f7afa69d1291bb48304e78a073556b1f3a612bfd108163d6c798cece9c2d23268cf204bd602ee0cae3640292956dbea8eabe7095f69c44d976824e5244e411946f77ae9daf6f0d1bbb813dc9c1dee7a9fe7c1f2fb64d506e1ebbf423e4acf3579d82c0a50e69d87b8ada137b260730d57a82781bb894c66eb55a9565268ea956c70334b92572aafe49a27393a26aef71dc1eba3e3f8c68d38866d0314d95340779c645c18ede7d71eae6324c47165c19b4b93d530f0f541a649b81ca3166597405b0d08dd6fec64fcabf124618bb422694a73682d1bd30a686fe88d3c15fec4de474da92f07fa0400a9353bced7f2a9089faff3770acc39a1c38d65c37bb82298ab599f7c9963a852ff793afee1a40720d0d86a020585759a45f51d88a021221b6ed08d33ad1d07124de78815c7f434edf83e8515c9d3c4845801e97d1daadf7a2a4dfc99e0d1a0739c8efeb4b52ec3c9dfe666dc78b5b19a4de94e2d03f05476996f87e0adb4c3f8979293408fe880d425a822c3464633c459ecf51c3ddac57197d72565e3bfcfe3b31f1df863f0d1d169c6b687bc8462794ac1735e854b44cdd3503b5e229b0283dc5554aec4f24d4f6cf7cb3a28ce42e05e07c5789a1c1b59756a447da7602a4bd26c8be62ba7eb0933795e3fd794d8226d9008115f42b3191563fd5bd816d4da78e0392763781216c1fb2dc44d06f2925bce5cd79e11bd7565c57f86d4f5688bf3b00bc1ad4efeebd0b9b21e56d2dad5d2f35041ff8fac5ea170081e38e615893ddff1e112f2b572b73fe2fadbdbe4c07669a65000a306d6a7cf8e7f8e7005c4c4662529185393fb5e9200ce61933dc08e94b3e6df3c06afeca74582f66dd0cbb392bf573009b052da8c754c417d1359923b7c7c79c9b22ddcfcb4d7f745ce47c0ece455829c74494c23ebb55647a0850e6052a88212b41dc37992db9261debc9449fdf499b6123c61c2ea74f59967291c2af9abcefbdc0e86111358251a5630aa71d4097abd0eb20519121d6004884d3da80241b2460aea9046b4c5ec79097aab5bcf8f8ee12f347e16ae4cf85cf8f8399148eae86d16495cdcf0eff613ef627d2633dc3f33e9818a4e53140a5a1b2aaf9316b586f07a072ac4a3010852af9cefe803f46edd26a8c72185e2a12102b5a4f54fc6dc181ad6c4dea2be7791c1acae6854a8ceb8a060852fa44f828ee7c7b755e893eaeed5fca4092cee1e226ee6c858615b09db63f377e94af7248e7c138f1371ee9039a3bfb1b106de26da962cf7f6e638dadcfb9fd2accf2c7b09f16b0016a8f4e7f310fbf5b390110f71bd791a1f9eee41bab61c015e07889ed137ed288e87c9bde88314690a356d47467e75b970eb2075403920acc8ae1e041b1e0fd4ca620bb5a2d25c49f9322df6be3fb3b5db134f081ee2ed477f54cb3a7d342f9820dd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">ML课程笔记复习 + 机器学习基础系列笔记复习 + 论文阅读笔记复习 + Transformer系列笔记复习 + GAN系列笔记复习</summary>
    
    
    
    <category term="⓻ 博文复习日志" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%8D%9A%E6%96%87%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Review" scheme="https://blog.slks.xyz/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记16——常见的梯度下降优化器整理</title>
    <link href="https://blog.slks.xyz/2022/02/11/ced858ce48dc/"/>
    <id>https://blog.slks.xyz/2022/02/11/ced858ce48dc/</id>
    <published>2022-02-11T08:54:19.000Z</published>
    <updated>2022-02-20T13:31:14.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一批量梯度下降法bgd">一、批量梯度下降法BGD：</h4><p>​ 更新每一参数都用所有样本去进行更新，在下面例子中，总共有n个参数，m个样本，我们如果想要更新参数$ _j$ ，就需要遍历所有的m个训练样本，然后将所有的梯度累加起来取平均，然后再进行更新。</p><p>​ <img src="https://pic2.zhimg.com/80/v2-890e5ab2843f3b22467a5e6aeef58b59_720w.png" /></p><h4 id="二随机梯度下降法sgd">二、随机梯度下降法SGD：</h4><p>​ 由于BGD每跟新一个参数的时候，要用到所有的样本数，所以训练速度会随着样本数量的增加而变得非常缓慢。随机梯度下降正是为了解决这个办法而提出的。它是<strong>利用每个样本的损失函数</strong>对θ求偏导得到对应的梯度，来更新θ：</p><p><img src="https://pic1.zhimg.com/80/v2-65566b643790ca6c89919fd970f34e2c_720w.png" /></p><p>​ 随机梯度下降是通过每个样本来迭代更新一次，对比上面的批量梯度下降，迭代一次需要用到所有训练样本（<strong>往往如今真实问题训练数据都是非常巨大</strong>），一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。<strong>但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</strong></p><p>​ 但是可以并行化计算。</p><h4 id="三min-batch小批量梯度下降法-mbgd">三、<strong>min-batch</strong>小批量梯度下降法 MBGD：</h4><p>​ 我们假设每次更新参数的时候用到的样本数为10个</p><p><img src="https://pic2.zhimg.com/80/v2-9d473c89948f1ddc8c4f294c55123f59_720w.png" /></p><p>​ <strong>随机取batch个样本，</strong>而不是1个样本，然后对参数进行更新即可。</p><h4 id="四冲量优化器momentum">四、冲量优化器（Momentum）</h4><p>​ 在Gradient Descent + Momentum的算法如下：最开始第一步和原来的一样，从<span class="math inline">\(\theta^0\)</span>开始计算梯度，然后沿着梯度反方向移动下降，达到<span class="math inline">\(\theta^1\)</span>时，此时和原先就会发生不同了，其现在的移动会结合前一步的movement（即<span class="math inline">\(m^1\)</span>）以及当前点的梯度<span class="math inline">\(g^1\)</span>，计算出一个新的下降方向<span class="math inline">\(m^2\)</span>，然后进行更新。如图所示：<span class="math inline">\(m^2\)</span>是由 <span class="math inline">\(m^1\)</span>和 <span class="math inline">\(-g^1\)</span>两个向量相加所得到的。从公式上来讲就是$m^1 - g^1 $，两者都有自己的参数，来控制影响整个梯度下降方向的比例。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113022761.png" style="zoom:50%;" /></p><h4 id="五adagrad优化器auto-learning-rate">五、AdaGrad优化器（Auto Learning Rate）</h4><p>​ 如果Loss函数在某个方向上比较平坦,梯度比较小，那么我们希望Learning Rate比较大，快速的走过这一片平坦的区域。如果在某个方向上比较陡峭，我们希望Learning Rate比较小.</p><p>​ 将原来的学习率η修改成 $  <span class="math inline">\(, 这个\)</span>_{it}$既跟参数相关又跟训练步骤（不同点所在的梯度）相关。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170754841.png" /></p><p>​ 以下是σ的计算方式，通过计算每次更新得到的参数空间所在点的梯度的Norm值的平方的平均，即RMS来计算每步中σ。</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113547513.png" alt="image-20220114113547513" style="zoom:25%;" /></p><h4 id="六rmsprop优化器">六、RMSProp优化器</h4><p>​ <strong>AdaGrad的进阶版本：</strong></p><p>​ 它在计算每一步的σ的时候，结合了上一步的σ以及该步的梯度g，同时还有一个超参数α，可以进行调整。如果我们调整α比较大的话，代表其参考当前的梯度较多，也就是说如果梯度突然产生较大变化，其就能快速的反应过来，对LearningRate进行快速的调整。相较于前RMS所有先前的梯度都平均权值考虑的做法，这一做法能够更快速的对梯度的变化进行响应。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113634056.png" alt="image-20220114113634056" style="zoom:25%;" /></p><h4 id="七adam优化器">七、Adam优化器：</h4><p>​ 综合了RMSProp和Momentum技术的优化</p><p>​ Adam可以理解为加了Momentum 的 RMSprop</p><p><img src="C:\Users\14012\Desktop\d50735fae6cd7b891692d4d0b34087a1d8330e56.jpeg" /></p><p>参考资料：https://zhuanlan.zhihu.com/p/25765735</p>]]></content>
    
    
    <summary type="html">整理了一些常见的梯度下降优化器，相关的基础知识内容。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Gradient Descent" scheme="https://blog.slks.xyz/tags/Gradient-Descent/"/>
    
    <category term="Optimizer" scheme="https://blog.slks.xyz/tags/Optimizer/"/>
    
  </entry>
  
  <entry>
    <title>科研方法经验整理帖（待更新）</title>
    <link href="https://blog.slks.xyz/2022/02/11/0ef005888202/"/>
    <id>https://blog.slks.xyz/2022/02/11/0ef005888202/</id>
    <published>2022-02-11T08:27:23.000Z</published>
    <updated>2022-02-20T13:31:31.895Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="b4930639b86a22e78e2f34aded24395adc765efcbe3aa58debd225b115003347">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b654708d242507cfe6c32d1c8eaaeb7ce715ba6f5bf94402f27c710f076b984cdf666814bfd0feddd6bef4230c9b5fc5ef63e0abe1d8a0e076522fdf5d47543cb4a31cdb81d6f51075c9c431920495d752565dc8362a2dd4159a90cd1ddc842263881d6551575f2ddf84b0e16eae3070efee31f714363128f2ed57b4daf59d6993581f3d3e232d9f9e0e557255c6333fda79be78b77d10db6f09464976c5bc7fffba2524a64aa1aa741cdb2378fb38f145d7ce56e3d3d0854c256441055ac06c43f3a6478ea5f16ffba691bd8ff66ca371bfe48fb7166cc7b818aea63c9a77f0d9c6a8527a9d912e90bdb1e31a5bee8acf9af1e955e693460377f6d2937a35f54aef7260b4770e3418929728897786d982b27227b8565d377edf1686ff3d4941ef69929b9ed7ed143ab15b84f24c4a9f4499be4bcf618b113d9a1e8725628d5efe944fd49feabeb6bae8ca77f71f6cbcb597ae7aa7de63f64c306bb27737fa1de9601d194cfd19c8b9c2ddd4eb5d850715f733449606462b97e6ed11ec2d87eeb46c628ab4561ab636af7d3b2ead947c359e96cde0931188ad0d232fa66773a11670c6243e93c42c4e4d624507f6765cd16aa023d54a0b7e4cbd0b71d1addb9a47181bb082d88e76bc420cbbe64557edfcc296e12bb8d95ee9b5831d09c840acf7452ec371ddf268d41e278185f440903ffc1e69ceb2223a02bed1a8932535a08cacf22d1b52d9ac2c9e593bd22b64c0d12b2a932afb888a88fe51cfd02c19b12211c584d162dc444e33c324f780a4bab705b9c1baf49aa384fde84cac54f2b9b3159e6aff418d081959cf20becd56f51b98b578b68ac4d1c05a662dfd5d88edd5a561329f62df930a21f0a25cf65bc041a6af31900b07d29903d8c006dbc15a737a6716cd5fcacb11b8595272925cf4fee9682879188f4db5011e9670e6eb2b097c55f6f8ab8bbaf6d6d3f86ef5739620549c29f16357286ffb71693dcde445c0ef7fd936deb0b0fd828d0b1cf74e926d07c95301d7dcca70009936b9b5452e9ae75ecc3fd82463f8eaa41e77366779871f35eca7bbddabfe1ac6beb31d3e616e8dd7228667f6fc2c0ab0757fe1670ce3a2a9eee44efcda670c38af9b8f8ee1f9035b941d287ea3586e80161a7dd86d620e7105c671c46128937d45e4e4408897b54b90b090bd0be0cd991b218afa09facc677d2f3798896db5561736a43d81e3cf905494cc348cf4f527f23ffd57b2dd9907d207953028dd52d2ebcab21cf202dab6a9bde2b21a939aec123038cf5d420dd5786c8854cc705bab03a6f364cada994e49a8178b799327c791082e32c30a76911b43ebb584618eb57df9a4d22bf345c270a59585288c9db1eebb318adc9cf33a07e5c6360461f25576e13c2c3fb46fd9087b9b42d3f1af5523ab82d9bce5c32a047f5899554ed6aeb3c81d5d7c7cd3bae90938293200d864a3584919d7d3cd2e7006d2db27664075ccdbff652d47924810e46129fac683a9820658c88c66829e244f29523c89d41e1d96c863d0cdee86c858b1f745bac5e36dae98df780b297dd08d6040b43c9b95d0cac17f7093e1e4d5d5f7e59c3cc40fc88fec0e9640f34a7dc05efc754ed6d4d179e8d5fdc21c2e402802b54d9e01c7bf6d42314483d905a075cb7692ea83a83e9717fae37e8aea985ebd9f2153a5d303e289fdbf51d155f704a53ea72c08a09779d6b24414cd874d97e3b0301942c3744c587dcb4c3e219ab43cc58559b3929f9fec293517895929a73889d33f8661498c5c69c38100c9afee987bdf9c2115a7f7f3e695b13ed662396db843f1ffd89a783460bb5e0b148effc21766aa21e465b899119431b8b2d5cc286a93a5ba935812be96eb8ff4b7d6b4a87eba1f43b6324ac3d6938d189816870ad73d7ae4a17c3a3ad45cef4e10d5595039fc52190c0f3d0b376dceceb71eb344b488127dab4cf3b1e7c2227fcc12e5150af108ecee42bf4526a2637619586f6c0fbe70764db2fc21fa8b176e4083356b81492a053d8e02f86520428803c66e68fbaedc3eec35958937abd080b17b132406dee9b6f6292f45f0d32a153fc6089a9ce61e6f57f4ef03b4a9de954adb0064dd2138fec50ca5efb5cd390100779d62d9dc4072563d5109e8269d17049067033a0dc82b72fbb47f75932f421c06deffe1b49f943feb3a1ae6ae08c54abf261627200b3387457d34d241dc7a71a3f0d556931e19de8df231e509dbe5295fc5528df24378bbb70ed96542cb6e4147deff677f2cad9151fc198c3ffc711b41c426bed37ee1a455fba0886606482824cb260058d55ae635b641a8cd6dfb06a1f4e72ebc2475ff12cbe92627a8f8b985856d6d80e0c685e082516e2bd16a43317906d194e46fc7c8060d0f2423ff09e1ad0945fd5cae3d3dfd24d2c68bc2ccc7cbd65f78b505e1e2d399bfb38c4083ff7910778d9531ca68cf767ee762afbd244f01a045e77312be03098d923a45c944f4462f5c18df158f3316f679095a408a984b65a153591dddc65ab47fcdb862a6702ea57a8b99dc5fffd0ae8a589dfde6691152f0e743dccb4c74d29dad842bffb71332b9f8095a6a2f685587aeb00fbaf98c86bd0a8c44752b67e565378bedf61260014181dd1480fc4da425d60d44dd2dc8aba178efa6044d200f2216603adb44495c9bcfdd2d104101f7ccff26514a5d764486266913925e0d0297db3d28fe4fa5726a02d147b6b7b8b2e505479dda2518f308347dc1d7aaf5868f59fa53168dbac28b15e7528c509d35d54d86d80a230b06ae130eb0fc985c2bfde0b2c50eb65769d6bd79973d22dfd2e12fb9a35c68b3d7da6ff70aa4288bdf5f44d9cb0cd348cba3e1cb320d0465a1e29eb2b6ce87f0ac42e0ff3c3e65f1c852e9cc19bd512969377ca09c4912063d022dd4bf66327d35688292da0e3a642a7690994d4f7816d31308c202019679bb8ed9dd128b4da3921f7b20cdc62235bb189ad8dc0656f38091458f7e8797e4c66b103187f3c9d9618a334f3d1b54d87ae2662741dced941f8df77700a4c14708014211357ee6e94b91f7dd3314622453588ff005cc82395bd437cb2195125f658d318290107878cbe039f997947076323e326217b30fe9b33a7fb91410f1fadd82c5cdcd06e822d08cfee9820cb7b09c4c61a43dc6911ea122b9451aedf550ca9380d0a3d351262c06f313404bde46e13caa0250fbff33e9541ed15d1e0fd304f5f5d20e97770c656d25c209f2875dc322281d974633c79ebdee57472604e914bae5d23af68909c153e8019f24c95d50678f66ceae9c58683f061bb67e8805a063c66c779fc429ede31e898f398606f1a4073187bdec634c6bdd54000e7caee028bd6f99eee58e811a79925be5b502768bb1e4904ae2b9732c935afb9a08f50e06a17656e9943e577b31f33b6c3e3b38a585336dccb08a3c5731ccd6f91ea284f6b0fd583cc0a5bfac5067dde6d0c6a74e6bfcee2468666d609180e17370eaffe0fc0f5c3802497dd3df6bc0c9397839e14c52d67f49eb85c4805fb3fef70336686f538e35fee7e31bff1eb74dff914197539af3a6fbc591e9b2c99b32d93bab2348feedb80f51e47bfbff4d6c0671ea33ce3879725a3764d796fa86d81df58e664a637f5dcdf52ebf86846af1891f11ff420e9c9a51ee65ec010e7570969dcdda7e2039366f90001ee4afc6731160b9794640160d394bb6589748f9aac1c8babb7a38351abc98acb438dae7f139003bc571a09dc7c0a81a2440db9ab87fcf37da747eba4d2805f5879097e709356263fd2acbda8ceb0ba841e279b6868af2375f784d52799f85150e9b1b211c2e4858111c522483aeffd692a9a5a4e1aa557739f357345ca5d3dff72f72ea2938de81def991295adcc715665eb7f2a7e09bb03f5be9cb95c096ebc4c1c426a2561b08e13fd9c6b7b44a99e3295a3b810e886072a42f1804f3fc4e903486c82f3ac7efb03404afee3a1a3644373ec64ff645b96e278429ec6f686cf908970aaeb6d8f8bb0e84c73604663cf0316692b4fa674a737f58072ff13bd49706636ec85f240ef04c375e96a807096c8715207d0b61289d579d021c1c8a3e2f560aead56201727a0a2af5486689ce23cc8eee37bfc361600f7bb5fbad26027bfb172b22b0d6ee657fabccdadac322e327fc7737b764b4f70381f069c13794f9e38816b5cb6170de25fe7e4ae3485b0e600642de769afcb24e6ada741f624bd29c07911661dfa1a9972db79f43d87d158330f68a0efb9081374b3b7282affaf1afeba678f17a5fdb6c5785573e3819baed2da1dabb1fc61a76cd8a391563ce1287887a5201a9ce270b0939cf9c09e8a1090a14185699bdad734dac6c56e29010e4ee7d1058e8b1a8911b092934db76d2ea1fe607dc9feff75c36ef79418d41db0d36ec1ab1dc796bce78f90f36fd866db041844008f81dda1587df5323148871b12fdd4b36889f55b8df5c49cfe3379c512a8d7c599d59115fc86b85491eacbd3684d262450a89aab0b5407367b34f6b6d43409b0b1878bdaadc6c7a1c7da762e30cd0679be49b0a96390774d333567ce35b2180dc0011528c044802f6d08069e853667b8f475b39e8c90c128e8c8fb19c8a9b39dfa44ce0b36520ab55c6701256b1e569b1bec46a544fc81765525ff79cd011fd3efa1468f63b6e6de4c7592aa9508d4bb983936fdf2a587ad055650ec6754afd0338740e8f0ac0e4f2c72929033bfabd989b969534ea0d82640c1d847b53396fe6ae2160c8e9866437a0cd5fe14651a3673edfe8b4a5f3383403929d4b5ae3eb0862ed21c7ab7c0aaf311ff02514a3c59abd43505f222070c74888fc37c1b7eefec11ed9dc3997e41c71596601dd4bdab33ce683e443c04e03f5229d91cf72b21eea42da8e40a1be4312fbc1a579c309a79a7aaf573897cfe0c83d78ce7ad672797ebe5eaad4e4028ec3f756b53d940135f99c1421c6518eca1cfb7475f62a460eef96bc386932643383d34218cbce9044aecf3a0ec5e27ae4008353dc09ace216dd459349f540d0858b6c3b6c2121f01b039887b12ecc158afc16fce492a3947ff28a87f57a09ee05e8af83c555f5c6fbf8203846ae026e2738d8cc5dfc4871f6f170d93cce3fa040190fbea222a9ce24bb03d677cc3b4086355a0d2e412ad16632a85e2485ac4fdf1cc918645ee75e08a542a20097721b94acc37919f9c90aa96a9072dfcfab479ed93f776c577cfcbde1bf9bb2618fecc1e348387bd4ff262e80c9c91163600aec141c8a4b6ab77a5c55e683ada4ad5c1d603b5f56cacb7d9abbe9ac262b9d935669950d785fb7d94ce52b8736a0209a57b3679848430196ce3aa47f26b3180f95faf0bca21182c632daa98d84b6c0b815d4df3a4a77a712fb0fae6a5cc8c3555740f031c2e3b05114110a25dc73ce3c7797b8be47b58c9424a8cba5505d9ca399b328d82f8509fc574d93016a1f186088aa1db61d61025acf05259af53a1cd39fe0fad8702990dd772d2568738b910d41bd5e9fb14d86d6126a05815b0b27ed33840f4ed53f08c61c0de748b091f8d66c4906f23b6d12ad737f711e6988ad7eb6d6d45b3ba06dd39ec1f539c0235e7f3802a686d1e4f0c4bdcd408a74c79092fb3ec8f90ff9f6ab2c957772789f28f4333c692d3ab8f8817086f60604739d0c36d53e78618a8684f972066d236da21d92facffafec9b3bb28055ad684b9df1ec72daf3fe9fadf6370bd55020e3e9288edcc2eebbb339159f03c375cdb805cb3f9318fdc0e6e095d5c2772b7f6588bddb4150e8852f154698fc7b6f4c3ee13c472adafaffaad2f554a892526e8030991a0046cbb1082957a1234d3e9d4c965f5a2fbca3010006a0419d918413fd121a171988b7925f003ca914777a5c6deeb3891db9d0358181467dcefba216cd221dc92610ffe363f9e037e22a37e18f435c946a02ab7808c4d46a5f18a5ec776c217a3339e5de5737c98d736c1266adc76bedf4b87552bc312c9a2bdcb75e1770fa4d6bfb96afadee96ff365866fe855188fd6b1322fbcd42a41ed18c3f37e787b38c2e5b9fcac1b82d0d7728f4ca358a7071bd46e39d934d76cffe167d11820c7e0c4405bec53f7def646d4fe744a0c1606f9b2f4505f0a803958724b8363d8c269b222d76a9956b12c09b13c89943ce1c21ef077d4e6aaedf818a374ad08f760a5f8d88b7f8ac3b0d2f21665c3e59459685d64752add59c9af5271fb5944886d828ff8ca637de43be89711d75b4b414924ed38109f322a5de43dd1a9d89d3a7a6a5604b24f8a2ca939d3d19e3d752277e6dc1de56124e5cf123d1dc80cc144a423f48701e6df3223068a44c2a7f21fa32ac7ee667224663bf5e1458b09cad412fde6806731acc2630146adb809cb07b7b8a0eea8f1e688fb98c5dee5bb7e3e7083c29a82afcaef155f6898f7670921f1c032f46d7c20a25cf98b28c835d7eb22340e180ca3d6472d34884de49de6537b8cce1cd3472af0fa2de2c8e90a2a3e7991a4d127cb24dbf7f4e0abbbe4d0e5c2e1cd9be43bf69097d9737832b10945c72d552e9ef7cf5794acfa112a3f6fd9b5b070e6f4cbf5f363cd7bcb0f953a5f0e6063062ebe874d6fcb7af1d171bee6535a1d839a825f1cb54441f56b3b9f1d030f98cfb051408195421735b731192d7c6c5e69101f821d05e56b45969b02b737fba33d519822c873dc0ffba3f3483efd2b5ef4e930d6f32eafe8488e3f6a9ac4497b619920930a1358622b1b4cd1ebc0bddefc2b323a5b115ea3a60054432ea50572fc879a3715606ecdd062f56bef4465646cacad5afadefd0cad2067a86677ba61d6f0fcec678afa2cb4dba940aa1e05b7a35d1f5b3e6a5652553330c832a27d20f57547d0102abdaf68a6577d270621a84cb6a06d32d3351b326e866dbc767e99b9a54798ddbcb29fd7ca57c84942b8d1ae4eb21c4d8d91c5d019aff4e394884d7ff7b2e5d1856602eed08069e5c06ff2b1b3f622bd3dbc8e51ffdd85457e8c69be5d5249eda3a07db3e608b1a3fa2f4a35efbb6831c82d402d0c148de7a42e2c8d6bbe50ef950057d54adeac7e67c3997b038003b1d22e298cf7bd7ca13d61f655529baab38236cb8973c2a1e55c72d50304930ccdaa152d7855f1ec6db0b3f687a0f2859ef044b22c458ef21d51b45cfb7462420756c7840a74a561a9a665b323429280c6256f0e6fca664f8112f616608ccdc814c65ec4146cb0785e3129a792543586efaf310f5f3eba62f1b70cb30706a133471b88d232fd0c20ef1aecdaa1b55e93fbedbb23738f34968da800b1eb3eef8cfea7e254da051473b5c2bf2fecfd23a289c991f10723698b935561824f65ee7ac5f5de63a933be845e88b2dd22fc998736a8287fa4b71aa3cccb4bae855134fb60fcb773b780b45687a40692a1a19871ef0301ba2c0abbfacb561ed3ce1f46c5ab8242b43075b6f56a5e2c8ec951135a5ac5fe311212639586df7ad883f92bd3c9631bc644bc39a92bf3e773728dbc3159b06624e8943840c10a4629e60c2b9f346ad4216bf2adadabafdf4de9d473a74436fb4b1055c11a999d68e631f3df04d14544ce75a512e25bf3716abbc3979646559e4841c32f8fe141fbdb17d45a7ab3b0d64b2f4aff2d357799ce79ef8759c156f2b1ee8295343587305c7b242683432115c5e2ca46785c2ef68ee33a35bfdfdfd614b5231ccd61e61043ca230ab7f10b899d0fdb3c0619fb4dae4276f83e631ceacaf1e2e4aafe08ed0df682030f6fd5a53b8ec58780a2952ac1d51e25be04c6a69bdf5e241d07be88f17acf1465e409a8ebdd689c3983937fd99c4bdea1f8cc563de71b180a882ddc1663628ee5e594a05691e5e0e505af46c677c800dc6ac73c42d66016f4ad84a97df3e2a9a82d118c582e62b1e1e4733ddaa42ac40cdd3442e1e374b49adcf4aecf28cf9a6e82adfd1869a0dac280105a5916f95d2151ac7756b5baeb23b83e3a181fe669876f38bc220faab85743755b87f247fee890a1f35d794514dc7c292db28d335824922ce9e6809bc8de6725d297acd6b9ba0239e98f0744393058e25be77717d321aac8fa302b81c5cc64a328f97d0b0ee80e30d054f2d134c12152873f59e43517596eda4158da038d21fd8e2254164228844f55baf12fe898ff3411bb9a285276ae90e0437f7c7a795d28c333a6bef90a48370e4bbe8c0a6597a725ed856f8536d2feb76632054d3e1d18a0a4adb5b1db4c5db1b30c4fe52531aceaddb009cd9c0ea30f42b0265fec7f1baa95d43c9f65945a93dfd8aef72a051a65f7c71a95cc57158058581e282d8a199f21ed9750af287030871feb5389ba38938249c61ff9a560e4dfd173e167b28b2e88be365c0253e10a398e2c88c449da5ac458816ba25834957f16d28dda6f27b756700936a05ec8b37722f5388ebf8ee49cb9a26df271d51e504250a73e99a900a987998e97127731ca1c930dd41688dc511690a1a8c48b684fa7dbf5700ce05c22ae48eb31ed87263d36552e6366d9044916fdda15e5a8fa3b0806866c1cb02776cb30546c911afa1d7e6017815f169991f374312dec742a131774ff8fbdf81936cadae72c5b1fcfd85e0456fd97754aae0ff60c20d3d1b60ed169addca879e2fda8cbd5edb359288392abb5883760303ecc5dd9cac4c5de103889e495fdde83842b8247f7aa00884891eedcdd2b1a4c86b02f7e865349b0a16fbd8e5861cfe7adab210f1d6de0261b060bf829ca2f5a4c2d0119c02ec9eab1011b69cb3285682cf411c45c345dc671b8388804666f331ecf8fc3f86b898e5dbdca9d52af06de1e99a3cc372c3ce905a1934f52072c0ddc6ab5a54ac9d7eb9e7b0114c428290e9968cf3ef0d49a521fd8ef7cdeb5a9e307718ec8ebf6c91413f499c39653e797a051b26ad63d5d4eb4fd86ec0882cd7794e5f6a67264c0a7bcc0e6d0e3320c3e27f5b0aeea9ce92d9eb2c8d0191a554b86df3d4577999295a4d5d96b50af73ac34c6a10246e03cbc752a7ae4c816e36acc4dad9de825e8763710fb8c0047e4d61c3952e20a3bb3814b4a34a13b01f871eff7ac0af88e5a401bed37912a80b03e8fe39253420b5dc3e9b57a57e3bdd6fea46bf6d786b1b0e0faa4acbbb5097d4c1e2ca7798db22f555ec0358d0313191349edf0110b366b12e9a46ca5619148152070d561ef1699e279d4afa14c71af41b5c7024f4fba821d026f2b4a9ef3e38abd621269b85aa2528e4b71b26bcbbfeec2b0260bec21a66394c4a47271c6330278adc6b48fbf698afbb44cbb1a7114f0bbd81eaf49e7c7579e2f0e977c987e81407c51a551ed7ca59875ceffb3f41a31f8f668cbdf8680bdedb500e479a1912fa5e3fb7f70fb65f98e5a09edd9b</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">科研方法笔记整理</summary>
    
    
    
    <category term="⓺ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BA-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>Python搭建深度学习框架系列笔记1——计算图、反向传播、自动微分的理论部分</title>
    <link href="https://blog.slks.xyz/2022/02/10/f5cccb7aefe2/"/>
    <id>https://blog.slks.xyz/2022/02/10/f5cccb7aefe2/</id>
    <published>2022-02-10T04:19:19.000Z</published>
    <updated>2022-02-22T15:11:44.490Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一深度学习训练逻辑框架梳理">一、深度学习训练逻辑框架梳理：</h3><p>​ 我们以解决一个简单的问题的深度学习训练逻辑为例，梳理一下在框架内部发生的整体步骤：</p><ul><li>1、构建模型函数 F（此步其实就是对应着用户传入的<strong>构建的深度学习模型model，深度学习模型model中又可能含有许多层layer</strong>）</li><li>2、确定损失函数 L （用户传入的损失函数，常见的有交叉熵、L1、L2等损失函数，还可能是混合损失函数）</li><li>3、依据 F 和 L 构建<strong>计算图 Graph</strong>（ 框架内部完成 ）</li><li>4、在each update中，干如下两件事情<ul><li>将输入的数据，<strong>根据计算图</strong>进行前向传播计算，得到Loss值</li><li><strong>根据计算图</strong>，进行反向传播计算，获得 损失函数L 对 模型参数 w 的 梯度向量（具体采用的技术就是<strong>自动微分</strong>）</li></ul></li><li>5、将 梯度向量信息与 每个模型参数w 信息 传入<strong>优化器</strong>中，更新参数，然后回到步骤4，循环往复。（优化器往往也是框架在内部提前写好的，几个比较通用的优化器：Adam，Adagrad等）</li></ul><p><strong>注意</strong>：实际上，如果对于一些简单的模型函数，比如 wx + b , 我们是可以不定义计算图的，只要我们人工的实现了该模型的forward函数，以及该模型的backward函数，框架应当就会在前向传播和反向传播的过程中，调用这两个函数来进行计算。</p><p>​ 那么，计算图和自动微分的作用是什么呢？我们知道，在pytorch中，我们在一个模型中只需要定义forward函数即可，是不需要定义backward函数的，那么模型又应当怎么去定义反向传播的过程呢？这个时候就是计算图和自动微分起作用了。因为现在的模型函数F都非常复杂，人工求导是不现实的，所以我们就需要依据前向传播过程和损失函数，构建计算图，然后依据自动微分技术，用反向传播的形式，计算损失函数L 对 模型参数 w，最终实现梯度下降优化。</p><h3 id="二计算图反向传播自动微分详解">二、计算图、反向传播、自动微分详解：</h3><h4 id="最基本的计算图">1、最基本的计算图：</h4><p>​ 计算图是用来描述运算的有向无环图，有两个主要元素：节点 (Node) 和边 (Edge)。节点表示数据，如向量、矩阵、张量。边表示运算，如加减乘除卷积等。</p><p><img src="https://pic2.zhimg.com/80/v2-464ea7ee4475f3c7f08c389f65fd3e89_1440w.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># y=(x+w)*(w+1)</span></span><br><span class="line">a = torch.add(w, x)     <span class="comment"># retain_grad()</span></span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line">y = torch.mul(a, b)</span><br><span class="line"><span class="comment"># y 求导</span></span><br><span class="line">y.backward()</span><br><span class="line"><span class="comment"># 打印 w 的梯度，就是 y 对 w 的导数</span></span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br></pre></td></tr></table></figure><p>​ 在上面的例子中，x 和 w 是叶子节点，其他所有节点都依赖于叶子节点。叶子节点的概念主要是为了节省内存，<strong>在计算图中的一轮反向传播结束之后，非叶子节点的梯度是会被释放的。</strong></p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看叶子结点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;is_leaf:\n&quot;</span>, w.is_leaf, x.is_leaf, a.is_leaf, b.is_leaf, y.is_leaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradient:\n&quot;</span>, w.grad, x.grad, a.grad, b.grad, y.grad)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is_leaf:</span><br><span class="line"> True True False False False</span><br><span class="line">gradient:</span><br><span class="line"> tensor([5.]) tensor([2.]) None None None</span><br></pre></td></tr></table></figure><h4 id="区分静态图和动态图">2、区分静态图和动态图：</h4><p>​ PyTorch 采用的是动态图机制 (Dynamic Computational Graph)，而 Tensorflow 采用的是静态图机制 (Static Computational Graph)。</p><ul><li><p><strong>动态图</strong>是运算和搭建同时进行，也就是可以先计算前面的节点的值，再根据这些值搭建后面的计算图。优点是灵活，易调节，易调试</p></li><li><p><strong>静态图</strong>是先搭建图，然后再输入数据进行运算。优点是高效，因为静态计算是通过先定义后运行的方式，之后再次运行的时候就不再需要重新构建计算图，所以速度会比动态图更快。但是不灵活。TensorFlow 每次运行的时候图都是一样的，是不能够改变的</p></li></ul><p>​ 所以，其实在pytorch中，比如你定义的一个继承自nn.Module的网络类中，你会重载这个类的forward函数，然后在网络训练运行的过程中，其就会根据你的forward里面张量的计算过程来搭建动态的计算图，并且依据此计算图，在反向传播的时候使用自动微分计算梯度。</p><h4 id="什么是反向传播和自动微分">3、什么是反向传播和自动微分？</h4><h5 id="训练时自动微分在哪里应用">1）训练时自动微分在哪里应用？</h5><p>​ 自动微分用于反向传播的过程中，依据计算图计算<strong>损失函数对参数的梯度</strong>。在Pytorch常见的训练步骤中，应当就是封装在 .backward() 函数中的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_loss = criterion(outputs, labels) <span class="comment"># 通过损失函数，计算本次损失值</span></span><br><span class="line">batch_loss.backward()  <span class="comment"># 损失反向传播，计算梯度</span></span><br></pre></td></tr></table></figure><p>​ 举一个更简单明了的例子：考虑最简单的一层神经网络，输入 x，参数 w 和 b，以及一些损失函数。 它可以通过以下方式在 PyTorch 中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>)  <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>)  <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure><p>pytorch在上述运算进行的过程中，就会搭建好如下的计算图。</p><figure><img src="https://pytorch.org/tutorials/_images/comp-graph.png" alt="avatar" /><figcaption aria-hidden="true">avatar</figcaption></figure><p>​ 然后，调用如下函数,即可计算梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loss.backward() // 计算梯度</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359]])</span></span><br><span class="line"><span class="string">tensor([0.2175, 0.0032, 0.1359])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>​ Pytorch 这边其实实际上隐藏了非常多的内部细节，从外表函数调用来看，根本看不到计算图、自动微分的逻辑，这是因为Pytorch都已经将其封装在了底层中。实际上，Pytorch的计算图是什么时候搭建的呢？其就是在每一个Tensor张量参与计算的时候进行搭建的：</p><p>例如，执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = torch.matmul(x, w)+b</span><br></pre></td></tr></table></figure><p>计算图中，关于x、w、b、z节点之间的DAG就已经搭建好了</p><p>再当执行如下代码的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure><p>​ Pytorch又将loss和z、y的节点关系加入计算图中了。</p><p>​ 同时，截至此时，x,y,w,z,loss 的值都已经计算出来了，也就是说已经完成了一遍前向传播，这时候这些值都被记录在这一个个Tensor中。（下图是torch.Tensor内部的成员变量，我们可以看到，其内部是记录了非常多东西的，前向传播的值就是记录在Tensor.data中，也就是其表现出来的值）</p><p><img src="https://pic2.zhimg.com/80/v2-3bc1ff0ab920582a3491111b81a32fe5_1440w.jpg" /></p><p>然后当我们在外层调用如下函数的时候:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><p>​ Pytorch 内部实际上就是开始反向传播，利用自动微分引擎，链式法则计算loss对参数w的梯度值。对于我们人而言，是如下的一个过程：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dsa98uyc89dsahkj.jpg" style="zoom:33%;" /></p><p>​ 那么，这个时候我们就需要思考了，对于电脑来说我们根本没有告诉它，loss对参数w的导数怎么求啊？即使是按照上述靠链式法则去求，但是我们也没告诉它链式法则中的每一项的导数是什么（比如说loss对z的导数，z对w的导数），那怎么求呢？其实，这个时候Pytorch内部就是利用其带的自动微分引擎，去解析函数，然后进行计算的。从外层看来，我们只知道只要设定一些参数，调用backward()函数，就能够获得loss对某个参数w的梯度，外层完全不用关心内部的事情。我们再详细的先拓展一下反向传播的具体数学原理，随后会记录自动微分。</p><h5 id="反向传播的数学原理扩展">2）反向传播的数学原理扩展：</h5><p>​ 反向传播写成上面的链式传播导数的形式十分好理解，但是不仅仅是上述这样子。我们应该需要知道，上面我们都默认所有的字母都只是一个常量，而不是一个变量，就比如说 w 是一个值， x 也仅是一个值，这些节点，我们通常称之为变量节点，它们没有父节点，它们的值不是被计算出来的，而是被赋予的。但其实，节点的值可以是一个数，也可以是一个向量，我们可以用一个节点保存输入向量(x1,x2,x3)，再用一个节点保存权值向量(w1,w2,w3)。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" /></p><p>那么也就是说，其实计算图中每一个节点都是多个值到多个值的映射，也就是向量 到向量的映射，自变量是父节点，因变量是子节点。虽然一个子节点可能拥有多个父节点，但是我们在计算子节点对某一个父节点的梯度的时候，可以把其他的父节点视为常量。</p><p>​ 举例如下：比如我们从n维向量( w )，计算出m维向量的映射就可以视为m个标量函数：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_15_14_456.png" /></p><p>​ 我们可以知道，每一个<span class="math inline">\(f_i(w)\)</span>对 <span class="math inline">\(w\)</span>来说，应该都有一个梯度 <span class="math inline">\(\nabla f_i(w)\)</span> ,而每一个梯度都是一个n维向量（因为自变量是n维向量）。</p><p>​ 以m个梯度作为行，每个梯度都是一个n维向量：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_19_20_861.png" /></p><p>​ 这个<span class="math inline">\(J_f(w)\)</span> 叫做映射 <span class="math inline">\(f(w)\)</span>在 w 处的雅可比矩阵。因为<span class="math inline">\(f(w)\)</span>是从n维到m维的映射，所以雅可比矩阵是一个$ m n$的矩阵。</p><p>​ 故而，我们知道，<strong>对于计算图中的每一对父子节点，都可以计算出子节点对父节点的映射的雅可比矩阵。 雅克比矩阵其实也就是映射的每个分量对输入向量的每个分量的偏导数。</strong></p><p>​ 在上述图2-1中的内积节点x = (x1,x2,x3) ， w = (w1,w2,w3)，它们的子节点 对 他们的映射，就是一个 n维(n=3)到1维的映射，故而，子节点到父节点的雅可比矩阵应当是 $ 1 n$矩阵。</p><p>​ <strong>至此为止，我们已经能够知晓计算图中每一对父子节点的雅可比矩阵怎么求解了，可是，我们最终要求的是损失函数对参数w的雅可比矩阵</strong>。仍然如2-1所示，w节点是h节点的祖先，它必须要经过 内积节点、+节点、*节点后，才会最终到达h节点。 这个时候，我们就可以利用链式法则： 复合映射的雅可比矩阵式组成复合映射的多个映射的雅可比矩阵的乘积。</p><p>​ 即复合映射<span class="math inline">\(f(g(h(w))\)</span> 在w处的雅可比矩阵是 <span class="math inline">\(J_f\)</span> 、<span class="math inline">\(J_g\)</span> 、<span class="math inline">\(J_h\)</span>三个雅可比矩阵的乘积。</p><p>​ （我们先假设一个父节点只有一个子节点）<strong>那么所谓反向传播：就是从计算图中作为结果的节点开始，依次从后向前，每个节点都将结果对自己的雅可比矩阵和自己对父节点的雅可比矩阵传给自己的父节点，然后这个父节点再将 结果节点对自己的雅可比矩阵和 自己对父节点的雅可比矩阵传给父节点，再前面的父节点会将两矩阵相乘，得到结果对自己的雅可比矩阵，一直这样子到我们的 变量节点</strong>。</p><p>​ 所以“反向传播”传播的是结果节点对自己的雅可比矩阵，同时也将自己对父节点的雅可比矩阵传给父节点。父节点将这两个矩阵相乘，就得到最终结果对自己的雅可比矩阵。</p><p>​ 接下来就剩最后一个问题了，<strong>如果一个父节点有多个子节点，它应该如何得到结果对自己的雅可比矩阵呢？</strong>在数学上能够证明，其实就是先按照上述方法，将结果节点 对 各个子结点的雅可比矩阵 和 各个子节点对自己的雅可比矩阵分别相乘，然后再相加即可。如下所示：</p><p>​ $ J_f = <em>s J</em>{rs}J_{sf}$</p><p>​ <span class="math inline">\(J_f\)</span>是最终结果对父节点的雅可比矩阵。</p><p>​ <span class="math inline">\(J_{rs}\)</span>是最终结果对某个子节点的雅可比矩阵。</p><p>​ <span class="math inline">\(J_{sf}\)</span>是某个子节点对父节点的雅可比矩阵。</p><p>【附：最开始的时候，结果节点对自己的雅可比矩阵是啥？ 回答：是一个单位矩阵，即对角线元素为1，其余元素都为0】</p><h5 id="自动微分的工作原理解析">3）自动微分的工作原理解析：</h5><p>​ 在上述描述的反向传播过程中，我们有一个核心的地方还没有细说，那就是如何让计算机计算 一对子节点和父节点 它们之间的雅可比矩阵，也就是它们之间的导数关系，如何计算？【此处留有陷阱，请继续往下看】</p><p>​ 让计算机实现微分功能有以下几种微分方式，</p><ul><li>手工计算出微分，然后编码进代码中</li><li>数值微分 (numerical differentiation)</li><li>符号微分 (symbolic differentiation)</li><li>自动微分</li></ul><figure><img src="https://pic4.zhimg.com/80/v2-4c305dc170d7a165aec1b5d7017828c7_1440w.jpg" alt="四种微分方式的对比。 手工微分、符号微分、 自动微分得出的都是精确解， 而数值微分得出的只是近似解。" /><figcaption aria-hidden="true">四种微分方式的对比。 手工微分、符号微分、 自动微分得出的都是精确解， 而数值微分得出的只是近似解。</figcaption></figure><p>我们简单的先介绍以下前三种方式，然后再着重介绍自动微分：</p><ul><li><p><strong>手工编码</strong>：故名思意，自己计算函数的导数然后编码入计算机代码中。</p></li><li><p><strong>数值差分</strong>，其分为两种方式—前向差分、中心差分</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_17_31_03_38.png" /></p><p>​ 一般我们使用中心差分来对神经网络的反向传播进行 <strong>梯度检验</strong>， 前向差分很少使用， 因为前向差分的误差是 <span class="math inline">\(O(h)\)</span> , 而中心差分的误差是 <span class="math inline">\(O(h^2)\)</span> , 使用泰勒公式将上面的 <span class="math inline">\(f(x+h)\)</span> 和<span class="math inline">\(f(x-h)\)</span>展开，就能得出前向差分和中心差分的误差</p><ul><li><p><strong>符号微分：</strong></p><p>​ 类似于我们人的手工计算，它是计算机根据规则进行微分的方式。符号微分的明显的缺陷是容易产生 <strong>表达式膨胀</strong> (expression swell)。</p><figure><img src="https://pic3.zhimg.com/80/v2-fb2923b77c6a8cbed2716e58e44f191e_1440w.jpg" alt="符号微分的微分结果不一定是最简的形式" /><figcaption aria-hidden="true">符号微分的微分结果不一定是最简的形式</figcaption></figure></li><li><p><strong>自动微分：</strong></p><p>​ 自动微分将符号微分法应用于最基本的算子，比如常数，幂函数，指数函数，对数函数，三角函数等，然后代入数值，保留中间结果，最后再应用于整个函数。因此它应用相当灵活，可以做到完全向用户隐藏微分求解过程，由于它只对基本函数或常数运用符号微分法则。</p><p>​ 自动微分有前向模式和反向模式两种，<strong>当输出的维度大于输入的时候，适宜使用前向模式微分；当输出维度远远小于输入的时候，适宜使用反向模式微分。</strong>一般在神经网络中使用的都是反向模式。因为神经网路的输入通常 &gt;&gt; 输出，</p><p>​ 细节上来说，自动微分是将复合函数分解为输出量（根节点）和一系列的输入量（叶子节点）及基本函数（中间节点），构成一个计算图（Computational Graph），并以此计算任意两个节点间的梯度：</p><ul><li>加法法则：任意两个节点间的梯度为它们两节点之间所有路径的偏微分之和；</li><li>链式法则：一条路径的偏微分为路径上各相邻节点间偏微分的连乘。</li></ul></li></ul><p>​ <strong>看到这里，会觉得很熟悉，诶等等！这不就是反向传播干的事情吗，一摸一样！</strong>然后我就发现自己一开始理解错概念了，我一开始以为反向传播过程中计算一对父节点和子节点的雅可比矩阵 这边的过程用的是自动微分，其他都是反向传播的过程，其实从某种意义上来说，反向传播就是在计算自动微分的过程，而计算一对子节点和父节点它们之间的雅可比矩阵，其实就已经是分解到最基本的算子了。在后面的代码实现环节，会更清楚明了一些。</p><p>​ 总结一下，计算图的变量节点被赋值或初始化后，在结果节点（比如损失值节点）上调用 前向传播 ，递归计算路径上各个节点的值，信息沿着计算图向前传播，最终得到结果节点的值。之后，在需要更新的节点上调用 反向传播 方法，该方法会递归计算<strong>结果节点对路径上各个节点的雅可比矩阵，信息反向传播</strong>。如果有多个节点需要更新，比如权值向量节点和偏置节点，就在这些节点上分别调用 反向传播 方法。<strong>由于中间节点的雅可比矩阵（如果已经被计算）已经保存在了 节点的 jacobi 属性中，所以在多个节点上多次调用其 反向传播 方法时并不会增加额外的计算负担。</strong>这其实就是“反向传播”的精髓，它执行的无非就是复杂复合映射的求导链式法则，保存中间结果，从而以空间换时间。具体的内容会在下一节的实现中详解</p><p><strong>参考资料：</strong></p><p>代码实现参考：https://github.com/zc911/MatrixSlow</p><p>1、《用python实现深度学习框架》张觉非、陈震</p><p>2、https://zhuanlan.zhihu.com/p/191648279</p><p>3、https://zhuanlan.zhihu.com/p/61103504</p><p>4、https://blog.csdn.net/aws3217150/article/details/70214422</p><p>5、https://zhuanlan.zhihu.com/p/53506221</p>]]></content>
    
    
    <summary type="html">本文是最近回顾深度学习的基础概念时，想要更深一步的了解框架内部的实现方法的实践系列笔记1，该部分文中先对深度学习训练的逻辑框架做了简单的梳理，然后对计算图、反向传播、自动微分理论部分做了详细的介绍。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——字符串比较中广义邻居的应用</title>
    <link href="https://blog.slks.xyz/2022/02/08/4ccc50ba5a4e/"/>
    <id>https://blog.slks.xyz/2022/02/08/4ccc50ba5a4e/</id>
    <published>2022-02-08T11:02:19.000Z</published>
    <updated>2022-02-21T05:46:50.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-064.-神奇的字典"><a href="https://leetcode-cn.com/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a></h4><p>​ 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p><p>实现 MagicDictionary 类：</p><ul><li>MagicDictionary() 初始化对象</li><li>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同</li><li>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]</span><br><span class="line">inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, false, true, false, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MagicDictionary magicDictionary = new MagicDictionary();</span><br><span class="line">magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);</span><br><span class="line">magicDictionary.search(&quot;hello&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True</span><br><span class="line">magicDictionary.search(&quot;hell&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;leetcoded&quot;); // 返回 False</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= dictionary.length &lt;= 1001 &lt;= dictionary[i].length &lt;= 100dictionary[i] 仅由小写英文字母组成dictionary 中的所有字符串 互不相同1 &lt;= searchWord.length &lt;= 100searchWord 仅由小写英文字母组成buildDict 仅在 search 之前调用一次最多调用 100 次 search</code></pre><p><strong>解题思路</strong>：</p><p>​ 一开始看到这道题，想到前缀树，但是经过尝试，发现前缀树没法使用，判定两个字符串只差1个字符，非常非常绕，并且当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,hallo。我们查找hello，我的前缀树算法因为找到了完全匹配的hello，就会返回false，而忽略了字典中存在的hallo。</strong></p><p>​ 然后，我们发现，如果想要采用先前的方法，用一个vector(26)来统计字符串字符出现的个数，然后利用相差1个字符来进行判定也不可行，当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,我们查找llohh，在vector统计中，两者确实只在h的个数上有不同，但是问题是两个单词顺序完全不一样，vector统计会将单词的顺序信息丢失。</strong></p><p><strong>故而：这题需要一个全新的概念叫做 广义邻居：</strong></p><p><strong>思路引用</strong>：https://leetcode-cn.com/problems/US1pGT/solution/offerii064shen-qi-de-zi-dian-by-logilong-4hmn/</p><p><strong>广义邻居：</strong>也就是一字只差的单词，比如说【*pple, a*ple, ap*le, app*e, appl*】，这几个单词互为广义邻居。</p><p>然后，我们这道题就可以按照如下的步骤进行求解：</p><ul><li><p>初始化字典： 生成字典中所有单词的广义邻居，例如 apple 就生成上述五个广义邻居。将所有字典词的广义邻居都以 <code>&lt;广义邻居，个数&gt;</code> 保存到 <code>HashMap</code>。</p></li><li><p>查找：当我们需要在字典中查找是否有一个单词和 word 只有一字只差，那不就是查找第二步中 HashMap 中是否存在 word 的广义邻居吗？这时候我们就只要生成 word 所有的广义邻居，然后在 HashMap 中查找是否存在其中的一个就可以了。</p></li></ul><p><strong>关键疑问</strong>：为什么需要记录所有字典词的广义邻居数量？</p><p>​ <strong>这是为了防止字典中出现和查找词一摸一样的词，如果出现上述情况，则会找到符合条件的广义邻居，但是其实并不是邻居，而是它自己！</strong></p><p>所以，刚才的查找不是很完整，<strong>完整正确的查找应当如下</strong>：</p><p>​ 生成待查找词 word 的所有广义邻居。每个广义邻居都到 HashMap 中查找出现的次数，根据出现次数分为3种情况。</p><ul><li>广义邻居数 &gt; 1 ，则说明字典中肯定存在两个不同的字符，这两个字符互为广义邻居，且和查找字符也是广义邻居，由于字典中的单词是不重复的，所以此时满足条件。</li><li>广义邻居数 == 1 , 说明字典中可能存在一个广义邻居，也可能存在查找字符串本身，如果是广义邻居就满足条件，如果是查找字符串本身的话就不符合条件。</li><li>广义邻居数 == 0 , 说明不存在广义邻居，则继续遍历下一个广义邻居。</li></ul><p><strong>代码如下</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; neighbors;</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; dictionary;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateNeighbors</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = word;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>()) neighbors[new_word] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> neighbors[new_word]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">generateNeighbors</span>(dictionary[i]);</span><br><span class="line">            <span class="keyword">this</span>-&gt;dictionary[dictionary[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;searchWord.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = searchWord;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>())&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//可能存在广义邻居，需要看searchWord在不在dictionary种</span></span><br><span class="line">                <span class="keyword">if</span>(dictionary.<span class="built_in">find</span>(searchWord) == dictionary.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为字符串的差值比较，但是无法用简单的Hash表统计解决，提出了一种新的概念，叫做广义邻居，通过广义邻居来对不同的字符串进行相似性比较。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字符串系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="string" scheme="https://blog.slks.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>C++ 优先队列 PriorityQueue 容器使用</title>
    <link href="https://blog.slks.xyz/2022/02/08/945d3241b7fc/"/>
    <id>https://blog.slks.xyz/2022/02/08/945d3241b7fc/</id>
    <published>2022-02-08T07:53:19.000Z</published>
    <updated>2022-02-20T13:33:21.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>​ Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，<strong>默认是大顶堆</strong></p><ul><li>1、一般情况：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><ul><li>2、如果内部的元素是Pair的话，其也自带了比较函数,比较规则是先比较第一个元素，第一个相等比较第二个。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>3、内部为自定义元素：一个是通过重载自定义struct的 &lt; 规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="keyword">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> tmp1&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">priority_queue&lt;tmp1&gt; d;</span><br></pre></td></tr></table></figure><ul><li>另一个方法是通过定义一个比较类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优先队列存放 Node* 时优先级的比较方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare_Node_Pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Node::priority 大的优先 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node* &amp;a, Node* &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;priority &lt; b-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法 */</span></span><br><span class="line">std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Compare_Node_Pointer&gt; my_queue;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-061.-和最小的-k-个数对"><a href="https://leetcode-cn.com/problems/qn8gGX/">剑指 Offer II 061. 和最小的 k 个数对</a></h4><p><strong>题目描述</strong>：</p><p>​ 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。</p><p><strong>解题思路</strong>：</p><p>​ 遍历nums1 和 nums2 ，然后将所有的组合push进入自定义的优先队列中，然后按照顺序，出队前k个元素或将队列出空即可。但是这样子的话，时间复杂度会达到O(mn)，也就是nums1和nums2的长度的乘积。其实，因为提供的数组是有序序列，所以我们只需要进队列 nums1的前k个和nums2的前k个的组合，也就是O(K^2)即可。</p><p><strong>解题代码</strong>：（熟悉priority queue的操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v1 = v1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeCompare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node* &amp;a,Node* &amp;b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;v1 + a-&gt;v2 &gt; b-&gt;v1 + b-&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;Node*,vector&lt;Node*&gt;,NodeCompare&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k &amp;&amp; i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k &amp;&amp; j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(nums1[i],nums2[j]);</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node* tmp = q.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;tmp-&gt;v1,tmp-&gt;v2&#125;);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录PriorityQueue C++中的使用，主要是其的一些构造函数以及额外排序规则如何确定。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="堆栈系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%A0%86%E6%A0%88%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——&quot;动态数据流+第k大的数值&quot;相关问题优化</title>
    <link href="https://blog.slks.xyz/2022/02/08/42903a1f937a/"/>
    <id>https://blog.slks.xyz/2022/02/08/42903a1f937a/</id>
    <published>2022-02-08T03:20:19.000Z</published>
    <updated>2022-02-20T13:32:40.994Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a href="https://leetcode-cn.com/problems/jBjn9C/">剑指 Offer II 059. 数据流的第 K 大数值</a></h4><p><strong>题目描述</strong>：</p><p>​ 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p>​ 请实现 KthLargest 类：</p><pre><code>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</code></pre><p><strong>解题思路</strong>：</p><p>​ 我对于这类没有设计类实现的题目，数据结构的敏感度不够高，基本上想起来都只能用最暴力的方法去解决。此题目，我一开始是想要在内部维护一个Vector，但是我发现，维护有序向量的成本太高了，虽然通过了测试点，但是时间复杂度等方面可以优化的内容实在太多了。</p><p><strong>优化思路</strong>：</p><p>​ 比较重要重要的信息点是 <strong>动态插入</strong>、<strong>第K大</strong>，这两个关键信息，应当能够导向一个动态的数据结构，也就是优先队列——堆。可以维护一个优先队列（最小堆），然后在其内维护最大的K个元素。这样的话，每次插入完需要返回第K大的元素的时候，直接返回堆顶的元素（堆顶的元素是堆中最小的那个元素，但是是所有数组中第K大的那个元素）即可。</p><p>​ 故而，在单次插入的操作中，我们首先将元素 val 加入到优先队列中。如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 k。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">             <span class="built_in">add</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为动态数据流+第k大的数值，利用内置数据结构优化解题思路。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="堆栈系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%A0%86%E6%A0%88%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
</feed>
