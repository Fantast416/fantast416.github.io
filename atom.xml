<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-03-17T02:36:22.859Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>机器学习基础系列笔记19——EMA指数滑动平均原理</title>
    <link href="https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/"/>
    <id>https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/</id>
    <published>2022-03-27T01:44:19.000Z</published>
    <updated>2022-03-17T02:36:22.859Z</updated>
    
    <content type="html"><![CDATA[<p>​ 在训练神经网络时，通常会使用一个叫 Exponential Moving Average (EMA) 的方法，中文名叫指数滑动平均。它的意义在于利用滑动平均的参数来<strong>提高模型在测试数据上的健壮性</strong>。</p><h4 id="一什么是滑动平均">一、什么是滑动平均？</h4><p>​ 滑动平均(exponential moving average)，或者叫做指数加权平均(exponentially weighted moving average)，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。</p><p>​ 首先我们假设一个训练参数a，它在不同的epoch结束后的值分别为： <span class="math display">\[a_1,a_2,a_3,……,a_t\]</span> ​ <span class="math inline">\(a_1\)</span>代表第1轮epoch迭代结束后，可训练参数a的值，以此类推。</p><p>​ 然后，我们假设不同的epoch结束后，滑动平均的值分别为： <span class="math display">\[ mv_1,mv_2,mv_3,……,mv_t\]</span> ​ <span class="math inline">\(mv_1\)</span>代表第1轮epoch迭代结束后，滑动平均mv的值，以此类推。</p><p>​ 滑动平均计算的递推式如下： <span class="math display">\[mv_t = decay * mv_{t-1} + (1-decay)*a_t\]</span> ​ 其中，decay为衰减率，用于控制模型更新的速度。递推式中其实就是利用加权的思想，把新的a和先前的平均，做了一个相加。我们可以发现，再很多轮之后，有些离<span class="math inline">\(a_t\)</span>很远的a,它已经乘了很多遍decay，相当于权重为0，也就是不影响最新的<span class="math inline">\(mv_t\)</span>的值了。</p><p>​ 从直观意义上来看，我们可以把<span class="math inline">\(a_1,a_2,a_3,……,a_t\)</span> 看作是t个位置，然后想象有一个长度为k的窗口，从最前面开始向后滑动。为了方便说明，我们先假设k=3。最开始的时候，窗口把<span class="math inline">\(a_1\)</span>涵括在内，然后一个epoch过后窗口右移，现在窗口内有<span class="math inline">\(a_1,a_2\)</span>，再一个epoch过后窗口再右移，现在窗口内有<span class="math inline">\(a_1,a_2,a_3\)</span>，再一个epoch过后窗口再右移，此时由于窗口长度为3，所以<span class="math inline">\(a_1\)</span>就不在窗口内了，窗口内的元素为<span class="math inline">\(a_2,a_3,a_4\)</span>，从公式上来讲就是在此时，由于<span class="math inline">\(a_1\)</span>已经乘了较多遍数的decay衰减系数了，所以其的系数接近于0了，不会再影响窗口内计算的值了。</p><p>​ 故此称为滑动平均。</p><h4 id="二更为公式化的解读">二、更为公式化的解读：</h4><p>EMA 在实现时如下所述：</p><p>​ Exponential Moving Average 对每一个变量（ <span class="math inline">\(variable\)</span> ）会维护一个影子变量（ <span class="math inline">\(shadow\_variable\)</span> ），这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会更新为： <span class="math display">\[shadow\_variable = decay * shadow\_variable + (1-decay) * variable\]</span> ​ 其中：<span class="math inline">\(variable\)</span>为每一轮结束时，训练参数的值；<span class="math inline">\(shadow\_variable\)</span>为影子变量；<span class="math inline">\(decay\)</span>为衰减速率。</p><p>​ decay 决定了影子变量的更新速度，decay 越大影子变量越趋于稳定。在实际运用中，decay一般会设成非常接近 1 的数（比如0.999或0.9999）。</p><p>​ 为了使得影子变量在训练前期可以更新更快，Exponential Moving Average 还提供了 num_updates 参数动态设置 decay 的大小。如果在初始化 Exponential Moving Average 时提供了 num_updates 参数，那么每次使用的衰减率将是： <span class="math display">\[decay = min\{decay,\frac{1+num\_updates}{10+num\_updates}\}\]</span></p><h4 id="三什么时候用到ema">三、什么时候用到EMA？</h4><p>请注意：</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ 在训练过程中，EMA只是以一个记录者的身份，在进行记录。实际的实现中，如果你在正常训练的网络是network['C']，那么你可以再实例化一个新的网络，叫做network['C_EMA'],其最初和network['C']一模一样，但是network['C_EMA']并不参与实际记录，其里面的参数只是用来记录滑动平均！！！<strong>（这就是DG-Font代码中，network['C_EMA']的作用）</strong></p><p>​ EMA作用是<strong>使得模型在测试数据上更加健壮，有更好的鲁棒性。或者是最后save模型时存储ema的值，取最近n次的近似平均值，使模型具备更好的测试指标(accuracy)等，更强的泛化能力。</strong></p><p>参考：</p><p>https://zhuanlan.zhihu.com/p/51672655</p><p>https://zhuanlan.zhihu.com/p/343210667</p>]]></content>
    
    
    <summary type="html">整理了EMA指数滑动平均的原理，以及pytorch训练中的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="EMA" scheme="https://blog.slks.xyz/tags/EMA/"/>
    
  </entry>
  
  <entry>
    <title>《StyTr2 Unbiased Image Style Transfer with Transformers》</title>
    <link href="https://blog.slks.xyz/2022/03/21/5a98629a4dd3/"/>
    <id>https://blog.slks.xyz/2022/03/21/5a98629a4dd3/</id>
    <published>2022-03-21T10:12:19.000Z</published>
    <updated>2022-03-22T02:43:33.767Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称stytr2-unbiased-image-style-transfer-with-transformers">论文名称：《StyTr^2 Unbiased Image Style Transfer with Transformers》</h4><h4 id="论文地址-httparxiv.orgabs2105.14576">论文地址： http://arxiv.org/abs/2105.14576</h4><h2 id="关键词">1、关键词：</h2><p>​ Image Style Transfer、Transformer</p><h2 id="摘要">2、摘要：</h2><p>​ 由于CNN的局部感知域性和空间不变性，输入图像的全局信息难以提取和维护。因此，传统的神经网络风格传递方法通常是有偏差的，对于同一幅参考风格图像，<strong>通过多次运行风格迁移过程可以观察到内容泄漏。</strong>为了解决这个关键问题，该文提出了一种基于Transformer的方法，即StyTr2，将输入图像的长期依赖关系考虑到无偏风格传输中。 ​ 与用于其他视觉任务的视觉转换器不同，我们的StyTr2包含两个不同的转换器编码器，分别为内容和样式生成特征序列。在编码器之后，采用多层Transformer解码器，根据样式序列对内容序列进行风格化。</p><h2 id="领域背景style-transfer">3、领域背景—Style Transfer：</h2><p>​ 经典的基于深度学习的图像风格迁移，样式转换方法使用多层cnn来学习样式和内容表示。由于卷积层的接收域有限，CNN无法处理长距离依赖关系。输入图像难以获得全局信息，这是图像风格传递任务的关键。将Transformer应用于计算机视觉的魅力在于:</p><ul><li><ol type="1"><li>它具有较强的表示能力，可以通过自注意机制自由地学习输入的全局信息，从而使每一层都能轻松获得整体的理解。</li></ol></li><li><ol start="2" type="1"><li>Transformer不包含局部性和空间不变性引起的归纳偏差，可以避免风格传递任务中的内容泄漏</li></ol></li></ul><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 在StyTr2框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。此外，针对自然语言处理中提出的位置编码方法，提出了两个方面的考虑:</p><ul><li><ol type="1"><li>不同于按逻辑顺序排列的句子，图像序列符号是通过图像内容的语义信息进行关联的;</li></ol></li><li><ol start="2" type="1"><li>对于风格迁移任务，目标是生成任意大小的风格化图像。输入图像大小的指数增长会导致位置编码的剧烈变化，从而导致较大的位置偏差和较差的输出质量。一般来说，视觉任务所需的位置编码应以输入内容为条件，而不受图像尺度变换的影响。</li></ol></li></ul><p>为此，该文还提出了<strong>基于图像语义特征的位置编码</strong>，并根据图像大小动态扩展位置编码。</p><p><strong>总结：主要贡献</strong></p><ul><li><ol type="a"><li>一个基于Transformer的风格转换框架，即StyTr2，以减少内容泄漏并实现无偏的风格化;</li></ol></li><li><ol start="2" type="a"><li>一种内容感知的位置编码机制，该机制是尺度不变的，适用于视觉生成任务;</li></ol></li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321190212987.png" /></p><h3 id="图像分割为patches-linear-embedding与vit类似">1) 图像分割为Patches + Linear Embedding【与ViT类似】</h3><ul><li><strong>输入：</strong><span class="math inline">\(I_c \in R^{H \times W \times 3}\)</span> 和 <span class="math inline">\(I_s \in R^{H \times W \times 3}\)</span></li><li><strong>输出：</strong>一个特征序列：$ L C<span class="math inline">\(，\)</span>L = $ ，<span class="math inline">\(m\)</span>是PatchSize，<span class="math inline">\(L\)</span>是特征序列tokens长度，<span class="math inline">\(C\)</span>是单个Token的维度。</li></ul><h3 id="位置编码content-aware-positional-encoding">2) 位置编码（Content Aware Positional Encoding）：</h3><ul><li><p><strong>想法：</strong>当使用基于Transformer的模型时，需要在输入序列中加入位置编码(PE)以获取结构信息。此论文提出了基于图像语义的位置编码，这一改进基于以下两个想法：</p></li><li><p>在传统的位置编码中：两个patch之间的位置相对关系仅仅与它们之间的距离有关。而对于图像生成任务，在计算位置编码时，我们应该考虑图像的语义</p></li><li><p>当输入图像的尺寸呈指数增长时，传统的正弦位置编码是否仍然适用于视觉任务? 如下所示当调整输入图像的大小时，相同语义的patches (blue blocks)之间的相对关系会发生巨大的变化，这可能不适合视觉任务中多大小的输入。</p></li><li><p><strong>主要做法：</strong>提出了内容感知的位置编码(CAPE)，该编码具有<strong>尺度不变特性</strong>，更适合于风格迁移任务。与正弦PE只考虑Patches的相对距离不同，CAPE以图像内容语义为条件。</p></li><li><p>首先假设<span class="math inline">\(n \times n\)</span> 可以足够用于表示每幅图像的语义位置。</p></li><li><p>假设输入图像为：<span class="math inline">\(I \in R^{H \times W \times 3}\)</span> ，我们将<span class="math inline">\(n \times n\)</span>的位置编码（依据实验结果，一般情况下<span class="math inline">\(n=18\)</span>），放缩至<span class="math inline">\(L = \frac{H}{m} \times \frac{W}{m}\)</span>的大小，这样就可以使得位置编码不受图像尺度的影响。即对于两个Image Patches而言，它们直接的位置关系不会受到图像尺度的影响。如下图所示：假设有两个不同分辨率的图像，在PatchSize大小一样的情况下，左图分辨率小，被分割后，成为<span class="math inline">\(2 \times 2\)</span>的Patch块，右图成为<span class="math inline">\(4 \times 4\)</span>的Patch块。当位置编码会进行放缩以适应的时候，其就可以自己匹配不同尺度的图像。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210140364.png" /></p></li><li><p><strong>公式化表达</strong>：</p><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210523455.png" /></li><li><span class="math inline">\(P_{CA}(x,y)\)</span>代表第<span class="math inline">\((x,y)\)</span>坐标的Patch的位置编码值</li><li><span class="math inline">\(F_{pos}\)</span>是一个可学习的编码函数</li><li><span class="math inline">\(P_L\)</span>是一个可学习的位置编码，是基于图像的token序列的</li><li><span class="math inline">\(a_{ij}\)</span>为插值权重，<span class="math inline">\(s\)</span>是邻居的数量，其是由周围邻居加权差值计算得到的。</li><li>对于token序列<span class="math inline">\(\epsilon\)</span>中的第i个Patch块，假设这个Patch块的坐标是<span class="math inline">\((x,y)\)</span>，那么我们将计算得到的<span class="math inline">\(P_{CAu}\)</span>值加到<span class="math inline">\(\epsilon_i\)</span>中，形成最后的序列。即，如果原来的token序列<span class="math inline">\(\epsilon\)</span>形状是<span class="math inline">\(L \times C\)</span>，那么新的也应当为<span class="math inline">\(L \times C\)</span></li></ul></li></ul><h3 id="transformer-encoder">3) Transformer Encoder：</h3><p>​ StyTr2有两个转换Encoder来编码特定于风格（内容图像 &amp;&amp; 风格图像）的特性，这些特性用于在下一阶段将序列从一个风格转换到另一个风格。</p><h4 id="part1-content-image">Part1: Content Image</h4><ul><li><strong>输入：</strong>Tokens 序列 <span class="math inline">\(Z_c \in L \times C\)</span></li><li><strong>输出：</strong>$Y_c L C $</li><li><strong>网络结构：</strong>每个transformer encoder layer包含一个MSA和一个FFN，与Transformer结构一致，输入序列被编码至Q，K，V。<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215744833.png" /></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215804639.png" /></li><li><span class="math inline">\(W_q,W_k,W_v,W_o\)</span>是可学习参数矩阵。</li><li>然后使用残差连接结构，每个模块后有LN归一化</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321220112862.png" /></li></ul></li></ul><h4 id="part2-style-image">Part2: Style Image：</h4><p>​ 按照Content Image那样子进行处理，但是对于Style Image我们<strong>不需要进行位置编码，因为我们不需要保持它的图像结构。</strong></p><ul><li><strong>输入：</strong>风格图像Tokens 序列 <span class="math inline">\(Z_s \in L \times C\)</span></li><li><strong>输出：</strong>$Y_s L C $</li></ul><h3 id="transformer-decoder">4）Transformer Decoder：</h3><ul><li><strong>输入：</strong>$Y_c L C $ ， $Y_s L C $ （<span class="math inline">\(\hat Y_c\)</span>是<span class="math inline">\(Y_c\)</span>增加了CAPE位置编码后的序列）</li><li><strong>输出：</strong><span class="math inline">\(output \in \frac{HW}{64} \times C\)</span></li></ul><p>​ 根据参考的风格序列，用回归的方式来生成内容序列。和传统NLP任务不一样，我们使用序列中的所有Patches一次性输入来预测结果。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321224013009.png" style="zoom: 80%;" /></p><p>​ 由两个MSA和一个FNN模块组成。第一个MSA模块的K、V来源于Style序列，Q来源于Content序列。每个模块后面都有一个LN归一化。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232914140.png" /></p><ul><li><p>公式化表达：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232959747.png" /></p></li></ul><h3 id="decoder">5）Decoder：</h3><p>​ 论文使用了一个三层的CNN解码器来细化后面的Transformer解码器的输出，而不是直接对输出进行上采样来构造结果。</p><ul><li>输入：<span class="math inline">\(input \in \frac{HW}{64} \times C\)</span></li><li>输出：<span class="math inline">\(I_{out} \in H \times W \times 3\)</span></li><li>网络结构组成：<ul><li>$3  $ 卷积层</li><li>ReLU</li><li><span class="math inline">\(2 \times\)</span> 上采样操作</li></ul></li></ul><h2 id="采用的损失函数">7、采用的损失函数：</h2><h4 id="content-percepture-loss-感知内容损失-style-percepture-loss感知风格损失">1）Content Percepture Loss 感知内容损失 &amp;&amp; Style Percepture Loss感知风格损失</h4><p>​ 优化结果应保持原有的内容结构，同时传递参考风格的模式。VGG提取的特征图可以作为内容特征来表示图像结构。<strong>Gram</strong>矩阵是两两向量的内积组成,所以<em>Gram</em>矩阵可以反映出该组向量中各个向量之间的某种关系。特征图的Gram矩阵可以作为风格特征来表示颜色、纹理等信息。因此，论文构建了<strong>感知内容损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_c\)</span>之间的内容差异，构建<strong>感知风格损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_s\)</span>之间的风格差异。</p><ul><li>Content Percepture Loss：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103100728.png" /></p><ul><li>Style Percepture Loss:</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103340777.png" /></p><p>​ 因为神经网络各层的统计量(如均值和方差)包含了不同领域的特征。<span class="math inline">\(\phi_i\)</span>代表使用预训练的VGG19网络，其第i层提取出的特征。<span class="math inline">\(\mu()\)</span>代表特征的均值，<span class="math inline">\(\sigma()\)</span>代表特征的方差。风格的感知损失可以书写如上。</p><h4 id="identity-loss">2) Identity Loss</h4><p>​ 自监督学习可以利用PreText从大规模的非监督数据中挖掘其监督信息。网络可以用这种构造的监督信息进行训练，以学习下游任务的有价值表示。 论文采用一个辅助的<strong>自我风格迁移任务</strong>来学习更丰富、更准确的语义和风格表达。<strong>该任务具体操作如下：</strong></p><p>​ <strong>注</strong>：Pretext任务可以进一步理解为：<strong>对目标任务有帮助的辅助任务。</strong></p><p>​ 论文在StyTr2中输入两个相同的<span class="math inline">\(内容/风格\)</span>图像，生成的图像<span class="math inline">\(I_{cc}/I_{ss}\)</span>应该与输入图像<span class="math inline">\(I_{c}/I_{s}\)</span>相同。因此，<span class="math inline">\(Identity Loss\)</span>模拟<span class="math inline">\(I_{c}/I_{s}\)</span>与<span class="math inline">\(I_{cc}/I_{ss}\)</span>之间的差异:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104028070.png" /></p><h4 id="最终loss">3）最终Loss</h4><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220322104224116.png" /></p><p><span class="math inline">\(\lambda_c\)</span>、<span class="math inline">\(\lambda_s\)</span>、<span class="math inline">\(\lambda_{id1}\)</span>、<span class="math inline">\(\lambda_{id2}\)</span> = { 10 , 7 , 50 , 1 }</p>]]></content>
    
    
    <summary type="html">提出了StyTr2，该框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
    <category term="Style Transfer" scheme="https://blog.slks.xyz/tags/Style-Transfer/"/>
    
    <category term="CNN" scheme="https://blog.slks.xyz/tags/CNN/"/>
    
  </entry>
  
  <entry>
    <title>关于文献综述、开题报告写作逻辑记录</title>
    <link href="https://blog.slks.xyz/2022/03/21/70cfb7bd8141/"/>
    <id>https://blog.slks.xyz/2022/03/21/70cfb7bd8141/</id>
    <published>2022-03-21T08:27:23.000Z</published>
    <updated>2022-03-21T06:47:52.216Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b9f124314e793a8ea4b25367429819e4db42db95545ee66f18eecfe80e01d16">0b64cd3abe5b0a0a039a37d86c66d75ed031bee0799e8ec352d0d5180826a0a50691d982f2be0c5f85267e748633a6bf94990a16c95008190a889750cecd7480a14477abc4a295eb514b8297cd2924e002a1c70812d056bcf0409e6fb92de26df0950a25ddafaeb99d1c3cf682cce4fc1226e9d0e6fb11561e2b615fc0eb9bac9ce2ad086a04463456aa373ccbe45d294bf436c7ac973af9bea0f2b9e447d448246d7c64ec3314b5e4baaaac014f5f2ff018c4ec4935ca0aa91b2bed76a66bf8a610827cb51bb660dc08067cfa0df4ba59f9bae520f9ce17fd1ff0a34505b0cc01663191ed701004f91d60e3605d8f50be8345dfd6f40431d3a6925178b63dd5331af544a52e572dbeb5ca133211a94a51b31273c2a07dad3a65d09f31bf7d650e8ff0228317ee19a107fadd4adaeea132918d286444c05aef91c1ef031637e1f1cb36e60e2f36b1cd22b684ebcbd44eebee5071662672485493e50a4f15ae933ab9734632c986e21d2323a20d60cac9c397fb888867c5e5b0c43a9c569457ab8bd5ec7619615cef9345aa701544e87d246731c9ffa9c07940386b29b0b14990f742cae9a254ad440ffe76d913bae62bc5f5418644c2d0f41f0c6593a5a4bf10577f9e2a01bf76eec279423298e44ba9a1aa3dd944ec6209d6b366bd5970d5693a0a3de247211917e24bf74a3a8649917f9725fef0a84c4751c9f17a47e06502b7e8eb94a0e3eb761ddb31cc04827bffbd071de865d5003de59ec9565d58b0bac3eeb984d2776667d4fdcec04b05fc0ef623774fce69b9e6c13f9bed5a33d948f4b7fe2e32c3ec9df3be76b1ec78510b0a165ef2f6d88e61d966361b5d2794c32ee337c0eb688febc00f6cd3231acfd239287d3a34eefe95c8385993f64a332688b73527f6e0a857b490df293cf96a4722e2d1457cf2f77024347da5650d24d691502e5103557e9fe814e44474ce09b015f2194eb312d794f1e416e394b2bad4c42786594b64076adf8d9451bcad12d8b31a005f2bc23788a5e937865336c6ddf4c2df44d3c0b2edd0348e31067bbb232d9b6e6eb582fe62b2a123aa1b5654da6507da228086736c76841e52d5c32f432331b58d64f2cb94ae874adfb2f663ba85a3c033064f95aa5e47daa60353de46c8b908b0824c61b76069a398f259c9cf350c583236e7c5d2af891445c2d16c01ed8d20da0ab66880c2fe32947625191ebeba3e3a65ee9397451cef6cc861c8367ad0f73980c8a5f937803f2f495374f1563c4720161c585394f17dcaf71e7788f13b9bfb55a7dde3ac31e10768d2cb175f40fe8257ead6a1564b24cf8519889cf65efcbab43d72a0876f2daf700aac7db122f60b919c7bf7d2cc127285295eed7393f1d4a57c94a6390ae0155af3bd93f203a540b0f5125c096841ea3f58cdc467f6d8aaf70da00df7b8dba5ab04d117e6cfe2a5ef9a371104e6674a85af50dd97aa17472e7bd367ee4ca1ce860d6cf234cad3ecbfacd08e09fcff12aa50e9935a77494daaa99d9a4faa4f89c18afa34767723858c4a707fea61f9030befb9e2d0108aaa9c052ada705d5b34ff28d03cace480a1776688cbafd1e00ae59947d163f1f28aa89e1ed3c6f4907e672919d214bf4973a4ea8249aa62924c9b34534a3736fecd73d94afd8982e569f2b953ebc005d6595bb943fb472dce2ffa324ab185bd8fa8153a1e600e3c1f628168917b25749094d0751a9be544414a7748cf4ac700167632441eafe1d761d6c29326cdfceefea229753b38072b01e23685570ac2b6d842cd00abd7e5a5ed0cf892388d2de0470e0aafbef91f53a85f63ddfc14d2eb45f4409d2cd946b5cca3089b211f302dbbf64410ddd9fea56e20f4ad5f794ad716d90badf1cbb8ad31adb765eb1330273e441ec0a2fa45e15016ea0f86b5c47ca451fa7b0af20c170d12408c424b761bc5a982a46d70ed005c692f322b36326d3bb3fdc9d7faacd1182155d9b3d1fb3ef4a4d38e1ff0370cbd2b1a339426c4a793a3819589017b566a8eacc3931253e5234822718fa3bbf34d5244fab4ee2fe9dd49d9c8e5a748179dad9f66e84a2595d69caa128908565b49c3b58bc60afc88660724b36e5394db0d37c2ebcb73bdf4d7669dc20e4c03a80aded961abfc88c1c6fce85b5a70f23ff4737e2d7f36b0dec664b376cfecf91468a064067227f0d9b00b329e7f2459787fe84ba1f8c311cffe8008e11eb8c579743bb21e2456fec4ddb031fdd6eed0d8f7b4dbb6f2696b086d3b6cf6afc4ea196f8f47e309f2dc00c62c53515656a4732c2f6185adfb39e876f87ecadc8ebb670d67afd160785568a4d8c3f4bb9cda58e6010755abb9ed12290e11ffa5daf4304b97c801d07faa4d4491444fcf9f1f784b4fdf8efc49a9ce02dd3735b3ff131fc7cd33c75549ffaaa492630fa0079a7af76b0abcf760d4d53162e870d99de380bbd17cc7d8267d365d67234f83834e628ff2e892a7e73c59205938a436b903464b6c34c68ed3147dd4980d6cfb64c57cec2b63afde06de5316aa9ce2b9e5c133f5272e38a3f5be02cec438e7ee77b6619152ae6c5a8337feac865895c5833741cef808f8503248e773fb841200c27d4861ec3f525fb6290c6ba054b7b14a34fc6bd7b316071ceacfb268006488b1472fc72dedfc5b50552ac56476a31b3078d2bb20d76a428bf28193ad47d653e53870b8f2e8b80e8cb767da78dac9ef6313947cd73785902df23cc9cbd0436a82a43eca7a9bd3aba83ae17aa5b9c7663ee3e17ec026272421598b372954c1fc5cfb3fab4b2c1d2c6c9c044c9a78026e5c03af1e25963cdd366d3de839428db45ac950d6a4f123a0c018e1c5137aa35836cbb9bd54c44d33039b16b9c7cb8283ef7084a9696c464a477488da63a4eeba06cc8616b55fa8d9ac5fe180451646d68317cccadb344092f8c2ad4d4ab45e4943b4900aa123afb0aa7f9dda7db168c047f3ce8b5b5e680cadc41bc7196e8249467563e711ace43d5f86ecb83eb300a4829af28cc2bd0a4572ed6c3dff507c035f269221967fc9b71b96d16f7ad2266f9b0e93b578cd31704c5213496e605701af575626a1b30aeb474d67f7b05215260c328c9880fbdeb24846e597ade1e0bfb77ef2842fb97321f8a2aee5d82bcf9fe9b000748a86f67a5e9188f6dc4f63bbf918f285276d2ed0ea7d3ce4db430db35026d168ad3833616e25b8335570fe70ebe90cb7baa3d5e34bed7d78eb868eec2786ed2dda6debb1fce6b0fb8d3e3258a247548f94eb235dd0cdf58c901dcfc011f9c098a90a18b08105758b267cafb815e07fad19680b1f044c88daa23e8a6b3294c83891068a5da5bee776bd26b36e390d37ac44cf978ffd90bc23a6924fd89e7657bcd3c92ad3dad42dab02cffd3b135dfed9329d17811c36fa405b343485ef7df2bf1dc9dd826c8ead29b2bb03a90738bcb76fec7146bcb1b6b65fc34c85c2b3dd6044ee4c47f55b35e3bca952bda7b3c2ae10a4f3eb21626427580c6739063636106e3b2c0eece813974a3bd1e05db9944e3e090d3370e247014144d5bc041bdf57fddd77a037197992368a942de5671b102f5fc971ff154e80c64760ec77af5b8284e9192e5bdeb77ab74f665b5b913d8f5f02b6b0a952dabd42ecbcf6ccd6ed450e7754b57eba01907a3aa26082454fb57cd8469b8fe0082395d5294b02d3085d1c587cd18c9bf69836167db4a28f56f3af972598624f71440f388a9be38548ebb9c0af3fc054be2f51e30e4857256f6751a4e77f719264b993dd8df596d84ff7a8720db0df392d260f38a34fab9151e2c7ec5f374fc5638c2cd30052f18cbfbfe015ae4585b3570f3864b09d55f8b190c4bd2723283ee1eec406f7c14efc72915942ffa919a9263f096819c121093373470192cfdceb17f255b3bb0b5c4c9add58997abf7fc6f17e35ea1110c4edb25972bfa22b3c9ec2ac31d01c038b34386edcb5e16270ea59924d22216789a8db2156998b900a1a6638cbf47d4dbc3a9d86b0ce8591538d50ffdd0a4c26de3902daff219a81f5ee1b4038adc81929dd7e6b480bd3e97ee6c5b848fa5c28fa59e688f6126f14146db0afe1fa483e61e6cc2b63217f0a0f877ee53ba39409eb170e157496fd93201d728b9d5a689e126a13ee418aec16c2ffa2d7d4f186d34fad2177312d427681abb6db88b4099ba681de508fd688732f969b69676a4f6627970c9e92726bfa927ffd25bb08cbc2795242ef852d0d2b6e1d792e96eee2566116859e66b7c80d55f635f6dd45b84bc5234b21e2f567be75b6ce77f62ea408a3f278dd768f6b80b4d00a61ffc4bc3daa67c253df340c229695de17f8fbe35310759d54fb87afd2c3c93e7e6a5a46911b6c2eed4305f25d4f4da6437a48e8ec468f5bfde5fac6fba9a64667d260173a83a3701334078e5378b13d4500df9861dde390ad3d9db23b516e9444849ea0e7acdd738832fd25c8153efb762e905619d7122ac271ad5f9450471a464060fe25fc2df8584b7282b16d3bc06678b3d05250d797b9c6e0328bd2e83e9943e0b1217a60a9e4ab2ca8b0ae0bced2211661ec7fd6cc1e0398245d5f9442a73abddd17328c3dfc2dccc73ea2c41af541379f15b436289e429f77ecc8859d645b56b5f78e0a8d264271eddaa26c02e1f9b013a7b230a7cda4b4c6b931688a6e4cc92b6ebd4692c7ca049e8e9b6c6ad8ae5e730c9bf2cf9acf86813cec873920c8d68ed3c0582a0fdc0c15ff15ad06381afe5a97d4f63217e4e17bedcaa6b78951c1beabf2baa573c54c7c0facde6ca71ee604047aa4a1f50e488d43a4b61bf42a8f00459ec7f77d2daf0a35ee3ca308c0c3b476fb0aac042456a90fe1c63fb1ee594e5fcd6e771dbf42710d6e6a993ad77313d99e5792489abd837d6efef5a6d008f5226f05493b722a363a1417097054719d6b5196efec818d05895ed5dee5ebd61d55cf5e5a27ea5a7d0ad9bcb1ec80137702f651572f16eae83c6c61cb618c37c5048e6ddffb087d6b8242e5d95bb290b805b8acfb65262d39cea1bbb681052723006f009743f09cc8bec11f1a34526141b597700bbac962d9101bb5bf5e065ad752a31b789ff79773bc2394c460fefe9574c63786523a4a8533334c7a1bfd71c0791c78e7285a57e4a326d65de7339a471de53aced40d41856542fd7bf643ea5fa11bee26a901ae11882ee7092584a4f4fad694a45e2ef255627b71bc917f1ec0926fea89fa4180936b5eb11a692bdffa4f1109e3852fc9579631c6e2c714c4dc73fbcf62a781585dace8d4996a0c4682ed8a818bef1aa79bcdbe759d1fd8f7942da22f467436eae82b5eddf296c5eb57adb8728d5cd2f2e9b0ef4f0741a00d36866725aa17d9b4a59b05614cf9ec8106ee199068bd3e9a3e903d16c49669cf674203cf72083b49ec0482c37b5c815c639c7a596f9cac3875385b2f54895b6986f5b7d1800c4fb6ebe29d3b1d1ec1ec131b3a8de10083239f3ee2d50a13f67f5639d65c6893c12fc652f3dfa51580ccbdaabe06b6d59c1f76c98cbbd890533097ecf3275aef692a4b7c851541d840c3b2207853f390fd4ba077df695714d4a9a799956aa972e6e1e9351768b0b8079cd367b60f0ff572e911f3b0e647bebc2ca659e2f896d8ab98d8af58430d1222a684b94b8b2d769467a653d57776b74509e8bcfa4997c084af3d9dd97b01c721b9abfa83c008ace7e694b8c272d5f75b99dfb230b2e2529ca51cb82482546bd4fdcbe9e086dac96d848a3ed9a462c6a654e6b1163f1097f853021a2e280d59e1463b0c4f6723902492fd28f298e61ba4d1994eb7df7ceec29dc2e6e99926bc410940720cf5d0e084a2347b5ce7dd0e97671ab00dfb61e672224f3f474ce3ac5b43cb64df3504a7c27de9f4bfcc8318e6056731a2855fe2eceeb5595f8f0a751f3114a1498a6911f1d257607c590eb6fe6b9ce03544ac89cf386507f17410ea9cfb891e0b922427ecd3db892f7336b8f62e2b68b6544b68a8805404cf0d6d4c660e336ace9011e92fdbea12e914204037cbe1f5f9e492268a2b28396d6be93cccb1d942abf28ae8d55f74005bb945645b9b88bccfadc16945237ec46c6a416bc5c7fe4114264eb6f3cab16bb5287fd0e3709717af8122725e651c0b9ebe236badfa5431d8c55c01b48c9b5f4530d3238d35b42e16cb2c9cc3d0bbe50307cb63cc2f42bf1cdc53678915cdb0a60430f86ca8c5dede3a8e3b53079e0c67199e48ba5b3ada36880f1c03d324702cebff44f6df34dbcf92100e91ff24d0188861bd38d63d80801b89fa99d0484cbadadd05a783a88eb414df17aa2090bec6f3c6d6948eca65ed46b1148bcbb2313b1889dd6f4b0295e4d18c0a89afcae26e699cd4964b39970f1d0da25b25d307ad922c069abebef70939528c604b2aeeb1c85b225f18ad2ac4cc0d88f2403ad293c50bc4a1f333b8a146d58294cf8c77bd9dc60a9393b4dd3bc4c701af5180545bbaa99d187b6488f5fbe91c1a8bb70f858dbd40e07a791e96c730a2d748566a8d370d029b37a7d66d5064a5c4f7e38a3c02c5526025350da91c5d87dc1917a91a04e3bab4a12464e1e75df43beaa15ce591f16272191203ce1da3208f59d178320f8a88484ab98c2708c3dce496c2ef0d1beb97c496ca2919840ba56a5323b8b944129ed4ce93bc96657e148895813418dbb3e6778fe15a0f5936cbcfedbfd1e49a1f3fb817cab6f750df2c923494c995b7efe49d0c8d0c2ca02e8708b8ebaee8abd65b69d65422343de2f76519b7bcb3f13a8b843ad41eb5b7f6c28aac1f12d2a42296103155958886246d873a67640542de79c44d8d13869dacd2cc2eeda1562f147484d71efd87d6e6007bc9bfbb6cc6b809d1c2af45a36531bd89a2e05043126727d9eb9dee274dad43ec6d87d49a9fc35c7ba47b2cac122328b7dfe55deda3eb49f1ff26407360d9b41cc8cbd034b9b8beefb6dced522b30e32850b33794a59a708bab7db1568b48b6fba45a7712551b8aed5d2ce5203ba1507eb0b05d00e4aac9af344df2a5fecd49508b1b484cd081c30b4e00639e56a28335294bb25e157e2c47e99a231c66035ef2cdf93ddd512356748bf1fa9ea2d33ce38fb8ba3440eb87278a657c2369e77c7835928f2a7047669fc3f96746c04980c386a1d7adc1570db205a39b1b9d189aaf0b1f931c2511df4c32c36797b5cfaa31c0ba3440ab4d0ed6187914fb18d7de428ee1112ac1091f6f3a109277d8efa9d9d43dd7333eaac2290941ef474099e2936e591dc70ee251f4fae13b88dbb8a5e4a4d34e0b1afb804cff093f527db478f12807c7f126affcddac2610733014e640d0ab411215cc954ed9fbf61455c5fe0235bd46759d7892d43b67d87037f6f51167a820f319e36533cf98dc5340e003d725939ca5f364d2c402393c3ef9cee8fc1e7161308b313db05f0d894d2ade0e9d54ef929b9e0e3a1089882e2f609bb56423b22a3809c91baca2d1b57583592951cf083b911a889f73cfeca0a0a29944242d90e2687aaa796f8893b4afb213e7991e6b28100b8c9e22844ccd7e59e15093e70c6b59c03c1729489a8e06de021351e505a70bf6d1a93835c64bd198777d9bad928078d54d7939b582a1a5fe88195b993e3db6f8480728df5695c80ddc89715488813aca7a6b15b4012605759e23f6dcb239b1409bc9f6a917c93ea23f9b89020e5d851889f6cff97a4a12a0480ce882def3e729f23019bc441ccf3e3989ef0aa435d7f79f3e6d4c89a705fbe2afb7e6b02f6e47ddc59fa6432cd2c9eedcb43677afcee3773d5b20cc7b589910d22a0556a8f4f4797287bbcfb40570ddc85f0940fbc413d8bf19871d74f4e1c7dd74bcc3b695191fd993304b69bd9eab9d58baaae577fc8ee20ab37477dfe90191da74a37125e57edacf62151965fe65b5a507d415bb4f72b06a8f2a8124160a57488ee7a3383a9b353b7cf8bb5b8f88720f937436c396f42443837487e3595a32856614443adb3f5a0b828e4330dee563ebeea67ba0bdbe5cb4e4eae2af8ed1351394c42340665a5bac091010fc917c3a0892e954284a791f24c7b7134efc6bb5f18c283ae7d588334fd81b4277508adccabdc728278cf736421a11e4d2d847f472e7eecebb284b223bf02f17f40b0eb250e54c24b6a90ce56625fcab1de720a09ff2988da4fa0c95d2a711363fb56700c3711349b4db7b1506dbf015085a6962d66b91e8df37454d485f3b08478c0fa7071a5365be3a1ea43810ae4d00c78e59e1ed11d4e99c5587c07997adfec4c54af8e7a5695fa4c668ed3cc6a71fcd16082118da0b0e2dd5d4c7dfbd691e35d4a2621b25b927a53702338e692c8a4969cf59e54f56881c4e17bb56e1b9c3549f33f29dc13c25cf2fd5d186a766de89b42c5d36da6be53ccdd6f24ba98d1036f6038dd2b6e967614e76556d57564fa80325df86f0e6eda66194dfbc47ce7c8b8a2e5013a7dcf49da870ed122d582be18707f81205127995cb44f58e1c8a98bda265c4fb7a40bb79feb8d460f584b1ccf829f995d8cbd13b9ef1ec6516b9c069e169a1f5bbeb73c549ccc717d47e913b3a0050d87d4f2c0d77ddc448453aaeba00e2b8dc06b3d2cf38b2b9478cb377631bd0fc842eed6753f0648eade71ee7a11faf10f2a842d78e0b954ec31c2069e511884e8f1a0328316a89a9429f1431455d2ec0d25a6054d33625406e3ed9af7e01358eb93c037cd4c4e41af4b8f96195f658d54a9a0af232a8cf94241bd90cdaf8f09617df75fe626b15819920a9f4ef7fc85e2d638e20f8a7d0d1e722a27a9178f1b1caed25a794defb7b930c38792aa5c6983c0f31b09e458ff144a013de56914a14b4f836ddc7242c7dc72e9605c921b4e174dfc2dfb42aff7c53307914d943915df708bc9900e9f4270d11f0571f089f6d5d7cc42fa721bdcf65046e96a121a2dbdd4a2166d99ca0ec0450cd290c909bc7838e14844af97d7b57d4e20dd9da248a7c38bee53d0ed0749e9f2675b82eb4015262900f063aedbc4657db9a27163b047a4d8f4ca3752b7ad5dcbaab94e5d9e4c8f59d348d7441fc4c39cc1a24093d83ac92ca38746bf4022f592385b82e625f7f5bae034f7b6283b49bc67d44e1e1810547fa0459b3c72b1f4aea59510e5264f03dabf077a425cf09483a425dd6e0a0089ed8b464f6c287b71a05d2316d732176cbac74e588547f21cbf037c2bccc93ea53b035964970a19ccde09b61e597bd5445993f3121cbfca2bc0cabe2f0f31ea75d851adf64d95ccb23b1a9ab8d8b008d69326936ee38262cd7c5f8e8adde4835d1f3d090590b6808b7d6398f2ed36ccac0389c813866847defb0c462c48d2c3e4a63d69aca1ef4ac580385d7b041f90af6dcbe7988d1a97eccdf4827b589b5417cd9a9ecf0ed7a14669430b49e2f3f74633267</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">关于文献综述、开题报告写作逻辑记录</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>SCI EI 核心期刊以及计算机领域CCF会议等级分类文件</title>
    <link href="https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/"/>
    <id>https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/</id>
    <published>2022-03-17T01:27:23.000Z</published>
    <updated>2022-03-17T01:39:19.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一sci">一、SCI：</h4><p>​ 美国《科学引文索引》，SCI(科学引文索引 )、EI(工程索引 )、ISTP(科技会议录索引 ) 是世界著名的三大科技文献检索系统，是国际公认的进行科学统计与科学评价的主要检索工具，其中以SCI最为重要。</p><p>​ 一般SCI<strong>侧重科学前沿理论</strong>，审核标准严格，发稿周期也比较长。</p><h4 id="二ei">二、EI：</h4><p>​ 《工程索引》（The Engineering Index, 简称EI）是供查阅<strong>工程技术领域文献</strong>的综合性情报检索刊物。</p><p>​ EI的主要特点是摘录质量较高，文摘直接按字顺排列，索引简便实用</p><h4 id="三核心期刊">三、核心期刊</h4><p>​ 在国内简单地说，核心期刊是学术界通过一整套科学的方法，对于期刊质量进行跟踪评价，并以情报学理论为基础，将期刊进行分类定级，把最为重要的一级称之为核心期刊。</p><ul><li>（1）北京大学图书馆“中文核心期刊”，这个的认可度一般最高。</li><li>（2）南京大学“中文社会科学引文索引（CSSCI）来源期刊”。</li><li>（3）中国科学院文献情报中心“中国科学引文数据库（CSCD）来源期刊”。</li><li>（4）中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”）。</li><li>（5）中国社会科学院文献信息中心“中国人文社会科学核心期刊”。</li><li>（6）中国人文社会科学学报学会“中国人文社科学报核心期刊”。</li></ul><h4 id="四中国计算机学会ccf推荐中文科技期刊目录">四、中国计算机学会CCF推荐中文科技期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%B8%AD%E6%96%87%E7%A7%91%E6%8A%80%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐中文科技期刊目录PDF</a></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1123qwdsa.jpg" /></p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_3](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_3.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_4](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_4.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_5](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_5.jpg)</p><h4 id="五中国计算机学会ccf推荐国际学术会议和期刊目录">五、中国计算机学会CCF推荐国际学术会议和期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐国际学术会议和期刊目录 PDF</a></p><p>参考：https://zhuanlan.zhihu.com/p/57932081</p>]]></content>
    
    
    <summary type="html">SCI EI 核心期刊的区别以及计算机领域CCF会议等级分类文件整理</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>字体生成效果评价指标</title>
    <link href="https://blog.slks.xyz/2022/03/16/827639831232/"/>
    <id>https://blog.slks.xyz/2022/03/16/827639831232/</id>
    <published>2022-03-16T13:09:19.000Z</published>
    <updated>2022-03-21T05:01:33.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一intersection-over-unioniou">一、Intersection-Over-Union（IOU）</h4><p>​ 计算两个矩形的交并比，通常在检测任务里面可以作为一个检测指标。往往可用于目标检测和语义分割。将预测框与ground truth框之间的交集比上两者的并集。</p><p>​ 应用到字体生成任务中，如下所示：img1和img2是参考字体图和生成字体图。由于生成的字体图像像素值很纯粹，所以我们认为 像素值&lt;127的为黑字部分，像素值&gt;=127的为白底部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_iou</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1_change = np.where(img1 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">1</span>)  <span class="comment"># 黑字部分保留，白底部分变为-1，黑字部分统一为0</span></span><br><span class="line">    img2_change = np.where(img2 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">2</span>)  <span class="comment"># 黑字部分保留，白底部分变为-2，黑字部分统一为0</span></span><br><span class="line">    black_num1 = img1_change[img1_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    black_num2 = img2_change[img2_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    intersection_num = img1_change[img1_change == img2_change].shape[<span class="number">0</span>] <span class="comment"># img1 和 img2 黑字部分交叉的像素数</span></span><br><span class="line">    total_num = black_num1 + black_num2 - intersection_num <span class="comment"># 总像素数（img1 和 img2 黑字部分并集的像素数）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;compute_iou:&#x27;</span>, total_num, intersection_num, black_num1, black_num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersection_num / total_num</span><br></pre></td></tr></table></figure><h4 id="二rmse">二、RMSE</h4><p>​ 均方根误差亦称标准误差, 用 真实值-预测值 然后平方之后求和平均,最后再开根号。 <span class="math display">\[\sqrt{\frac{1}{m} \sum_{i=1}^m(y_i - \hat y_i)^2  }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rmse</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    mse = np.mean((img1 - img2) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(mse)</span><br></pre></td></tr></table></figure><h4 id="三l1-loss">三、L1 Loss</h4><p><span class="math display">\[\frac{1}{m} \sum_{i=1}^mabs(y_i - \hat y_i)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_l1_loss</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>(img1 - img2))</span><br></pre></td></tr></table></figure><h4 id="四structural-similarityssim">四、<strong>Structural Similarity</strong>（SSIM）</h4><p>​ 结构相似性，是一种衡量两幅图像相似度的指标。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。</p><p>​ 给定两个图像x和y , 两张图像的结构相似性可按照以下方式求出：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/cdebeba369b6159f2e3fa5364412f4ff.svg" /></p><p>​ 其中<span class="math inline">\(u_x\)</span>是<span class="math inline">\(x\)</span>的平均值，<span class="math inline">\(u_y\)</span>是<span class="math inline">\(y\)</span>的平均值，<span class="math inline">\(\sigma_x\)</span>是x的方差，<span class="math inline">\(\sigma_y\)</span>是y的方差，<span class="math inline">\(\sigma_{xy}\)</span>是x和y的协方差，</p><p><span class="math inline">\(c_1=(k_1L)^2\)</span> 和<span class="math inline">\(c_2=(k_2L)^2\)</span>是用来维持稳定的常数。<span class="math inline">\(L\)</span>是像素值的动态范围。<span class="math inline">\(k_1=0.01\)</span>,<span class="math inline">\(k_2=0.03\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> structural_similarity</span><br><span class="line"></span><br><span class="line">structural_similarity(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="五peak-signal-noise-ratio-psnr">五、Peak Signal Noise Ratio( PSNR )</h4><p>​ 峰值信噪比，是一种评价图像的客观标准，它具有局限性，一般是用于最大值信号和背景噪音之间的一个工程项目。在图像处理中，要对图像进行客观的评价，常常需要计算<em>PSNR。PSNR</em>是衡量图像失真或是噪声水平的客观标准。2个图像之间的PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。</p><p>​ 定义： <span class="math display">\[PSNR = 10log_{10}(\frac{MAX^2}{MSE})\]</span> ​ MAX表示图像颜色的最大数值，8bit图像最大取值为255</p><p>​ MSE为均方差，定义为如下内容： <span class="math display">\[MSE = \frac{1}{mn}\sum^{n}_{i=1}\sum^{m}_{j=1}||K(i,j)-I(i,j)||^2\]</span> ​ 其中，<strong>I</strong>和<strong>K</strong>分辨是原始图像和处理后的图像，<strong><em>m*n</em></strong>为两图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> peak_signal_noise_ratio</span><br><span class="line"></span><br><span class="line">peak_signal_noise_ratio(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="六frechet-inception-distance-score-fid">六、Frechet Inception Distance Score( FID )</h4><p>​ Frechet Inception 距离得分（Frechet Inception Distance score，FID）是计算真实图像和生成图像的<strong>特征向量之间距离的一种度量</strong>。</p><p>​ FID 分数被用于评估由生成性对抗网络生成的图像的质量，较低的分数与较高质量的图像有很高的相关性。 <span class="math display">\[FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g = 2(\sum_r\sum_g)^{1/2})\]</span> ​ <span class="math inline">\(u\)</span>为经验均值，<span class="math inline">\(\sum\)</span> 为经验协方差，<span class="math inline">\(T_r\)</span>为矩阵的迹，<span class="math inline">\(r\)</span>代表真实数据集，<span class="math inline">\(g\)</span>代表生成数据集。</p><p><strong>FID的计算过程为：</strong></p><ul><li><p>对目标数据集的N张图片使用InceptionV3生成N*2048的向量，取平均值，得到<span class="math inline">\(u_r\)</span> 。</p></li><li><p>对生成的M张图片使用InceptionV3生成M*2048的向量，取平均得到<span class="math inline">\(u_g\)</span>。</p></li><li><p>通过<span class="math inline">\(u_r\)</span> 和 <span class="math inline">\(u_g\)</span> 得到 <span class="math inline">\(\sum_r\)</span>和<span class="math inline">\(\sum_g\)</span>最后得到FID。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fid</span><br><span class="line"></span><br><span class="line">fid_value = fid.calculate_fid_given_paths([output_dir, target_dir], <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>FID优势：</p><blockquote><p>1、生成模型的训练集和 Inception V3 的训练集可以不同。 2、计算 FID 时同时用到了生成的数据和真实数据，比起 IS 来更灵活。可以理解成，IS 判断真实性与否，是把生成数据和 ImageNet 数据做比较，而 FID 是把生成数据和训练数据做比较，因此更 reasonable。 3、以优化 FID 为目标，不会产生对抗样本。因为优化的是 lantent space feature，不是最终的输出图片，不会导致最终的生成图片失真。</p></blockquote><p>FID 问题：</p><blockquote><p>1、FID 只是某一层的特征的分布，是否足以衡量真实数据分布与生成数据分布的距离？同时，提出 FID 公式计算的是多元正态分布的距离，显然神经网络提取的特征并不是多元正态分布。 2、针对同一个生成模型，不同框架下预训练的 Inception V3 算出的 FID 差别是否可以忽略？ F3、ID 无法反映生成模型过拟合的情况，如果某个生成模型只是简单拷贝训练数据，FID 会非常小，认为这是一个完美的生成模型，因此，使用 FID 时同时也要通过别的手段证明生成模型没有过拟合。</p></blockquote><h4 id="七四象限评估">七、四象限评估：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/%7B58D5EE05-1CD3-1E12-45C6-0A5D78F53358%7D.png" alt="四象限评估准则" /><figcaption aria-hidden="true">四象限评估准则</figcaption></figure><p>​ <strong>D1：</strong>已知内容、已知风格</p><p>​ <strong>D2：</strong>未知内容、已知风格</p><p>​ <strong>D3：</strong>已知内容、未知风格</p><p>​ <strong>D4：</strong>未知内容、未知风格</p><p>参考：https://zhuanlan.zhihu.com/p/99375611</p>]]></content>
    
    
    <summary type="html">里面包含了目前我们用于衡量字体生成效果的一些指标的介绍以及代码实现，同时也包含字体生成领域的四象限评估。</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
    <category term="Evaluation" scheme="https://blog.slks.xyz/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>2.1 进程与线程的基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/14/32aa5a2632ac/"/>
    <id>https://blog.slks.xyz/2022/03/14/32aa5a2632ac/</id>
    <published>2022-03-14T13:04:19.000Z</published>
    <updated>2022-03-15T10:22:09.094Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=12</p><h3 id="一进程的定义组成和组织方式">一、进程的定义、组成和组织方式</h3><h4 id="进程的由来">1、进程的由来：</h4><p>程序本身其实就是一个指令序列。</p><p>早期的计算机只支持单道程序，程序运行时，内存中会分配两块区域：</p><ul><li>程序段：程序的代码放在程序段内</li><li>数据段：程序运行过程处理的数据放在数据段内</li></ul><p>​ 引入多道程序技术后，内存中需要存放多道程序：</p><p>​ <strong>为方便操作系统管理，完成个程序并发执行</strong>，故而操作系统为每个运行的程序配置一个数据结构，被称为<strong>进程控制块（PCB）</strong>，用于描述进程的各种信息（比如该进程程序代码存放位置等）。</p><h4 id="进程的定义">2、进程的定义：</h4><p>​ <strong>PCB、程序段、数据段</strong>三部分构成了<strong>进程实体</strong>。<strong>所谓创建进程，实质上是创建进程实体中的PCB；</strong>而撤销进程，实质上是撤销进程实体中的PCB。</p><p>​ PCB是进程存在的唯一标志。</p><p>​ 引入进程实体的概念后，可把进程定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong>注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314212804178.png" style="zoom:50%;" /></p><h4 id="进程组成">3、进程组成：</h4><h5 id="进程由以下三部分组成">1）进程由以下三部分组成：</h5><ul><li>PCB：进程的管理者所需的数据都在PCB中</li><li>程序段：存放要执行的代码</li><li>数据段：存放程序运行过程中处理的各种数据</li></ul><h5 id="pcb结构体中包含如下内容">2）PCB结构体中包含如下内容：</h5><ul><li>进程描述信息<ul><li>进程标识符PID</li><li>用户标识符UID</li></ul></li><li>进程控制和管理信息<ul><li>进程当前状态</li><li>进程优先级</li></ul></li><li>资源分配清单<ul><li>程序段指针</li><li>数据段指针</li><li>键盘、鼠标</li></ul></li><li>处理机相关信息<ul><li>各种寄存器的值</li></ul></li></ul><h4 id="进程的组织多个进程间">4、进程的组织：（多个进程间）</h4><h5 id="链接方式">1）链接方式</h5><p>按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221020998.png" alt="进程组织的链接方式" style="zoom: 50%;" /></p><h5 id="索引方式">2）索引方式</h5><p>​ 根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221055019.png" alt="进程组织的索引方式" style="zoom:50%;" /></p><h4 id="进程的特征">5、进程的特征：</h4><ul><li><strong>动态性（最基本特征）</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li><strong>并发性：</strong>内存中有多个进程实体，各进程可并发执行</li><li><strong>独立性：</strong>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性：</strong>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制"来解决异步问题。异步性可能会导致并发程序执行结果的不确定性。</li><li><strong>结构性：</strong>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ul><h3 id="二进程的状态和转换">二、进程的状态和转换</h3><h4 id="进程的三种基本状态">1、进程的三种基本状态：</h4><h5 id="运行态占用cpu并在cpu上运行">1）运行态：占用CPU，并在CPU上运行。</h5><p>​ 注意：单核处理机环境下，每一时刻最多见有一个进程处于运行态。（双核环境下可以同时有两个进程处于运</p><p>行态）。</p><h5 id="就绪态已经具备运行条件但由于没有空闲cpu而暂时不能运行">2）就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</h5><p>​ 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。 即：万事俱备，只欠CPU即：万事俱备，只欠CPU</p><h5 id="阻塞态因等待某一事件而暂时不能运行">3）阻塞态：因等待某一事件而暂时不能运行</h5><p>​ 如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p><h4 id="进程的另外两种状态">2、进程的另外两种状态：</h4><h5 id="创建态进程正在被创建操作系统为进程分配资源初始化pcb进程正在被创建操作系统为进程分配资源初始化pcb">1）创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB进程正在被创建，操作系统为进程分配资源、初始化PCB</h5><p>​ 操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p><h5 id="终止态进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb">2）终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</h5><p>​ 进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p><h4 id="进程状态的转换">2、进程状态的转换：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223023656.png" alt="进程状态转换图" /><figcaption aria-hidden="true">进程状态转换图</figcaption></figure><ul><li><p>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></p></li><li><p>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</p></li><li><p>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p></li></ul><h3 id="三进程控制">三、进程控制</h3><h4 id="什么是进程控制">1、什么是进程控制：</h4><p>​ 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><h4 id="如何实现进程控制">2、如何实现进程控制：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223828760.png" style="zoom:50%;" /></p><ul><li>创建进程：需要初始化PCB、分配系统资源</li><li>创建态→就绪态：需修改PCB内容和相应队列</li><li>就绪态→运行态：需恢复进程运行环境、修改PCB内容和相应队列</li><li>运行态→阻塞态：需保存进程运行环境、修改PCB内容和相应队列</li><li>阻塞态→就绪态：需修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</li><li>运行态→就绪态：（进程切换）需保存进程运行环境、修改PCB内容和相应队列</li><li>运行态→终止态：需回收进程拥有的资源，撤销PCB的资源，撤销PCB</li></ul><p>​ 为了使得进程状态切换中，数据具有一致性（类似于事务的概念），用<strong>原语</strong>实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p><p><strong>这种不可被中断的操作即原子操作。</strong></p><p><strong>原语采用“关中断指令”和“开中断指令”实现，如下所示</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314224013167.png" alt="" style="zoom: 67%;" /></p><p>​ 当在关中断指令执行后，如果系统收到外部中断信号，此时会将该信号转至开中断指令结束后再进行处理，即再开中断指令执行结束后，才会启动中断处理程序。如此，原语部分的代码就不会被打断执行。</p><p>​ 显然，<strong>关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p><p>​</p><h4 id="原语的具体操作">3、原语的具体操作：</h4><h5 id="进程控制会导致进程状态的转换无论哪个原语要做的无非三类事情">进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</h5><ul><li>1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<ul><li>a.所有的进程控制原语一定都会修改进程状态标志</li><li>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>c.某进程开始运行前必然要恢复期运行环境</li></ul></li><li>2.将PCB插入合适的队列</li><li>3.分配/回收资源</li></ul><h5 id="创建原语无创建态就绪态">1）创建原语：（无→创建态→就绪态）</h5><p>申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列</p><h5 id="能够引起进程创建的事件如下">能够引起进程创建的事件如下：</h5><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程引起进程创建的事件 l引起进程创建的事件</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul><h5 id="撤销原语就绪态阻塞态运行态终止态无">2）撤销原语：（就绪态/阻塞态/运行态→终止态→无）</h5><p>​ 从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统。删除PCB</p><h5 id="能够引起进程撤销的事件如下">能够引起进程撤销的事件如下：</h5><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><h5 id="阻塞原语运行态阻塞态">3）阻塞原语：（运行态→阻塞态）</h5><p>​ 找到要阻塞的进程对应的PCB，保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行，将PCB插入相应事件的等待队列。</p><p><strong>能够引起进程阻塞的事件如下：</strong></p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><h5 id="唤醒原语阻塞态运行态">4）唤醒原语：（阻塞态→运行态）</h5><p>​ 在事件等待队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度</p><p><strong>能够引起进程唤醒的事件如下：</strong></p><ul><li>正在等待的事件发生（因何事阻塞，就应当由何事唤醒，需与阻塞原语成对使用）</li></ul><h5 id="切换原语运行态阻塞态就绪态-或-就绪态运行态">5）切换原语：（运行态→阻塞态/就绪态 或 就绪态→运行态）</h5><p>​ 将运行环境信息存入PCB，PCB移入相应队列。选择另一个进程执行，并更新其PCB，根据PCB恢复新进程所需的运行环境</p><p><strong>能够引起进程切换的事件如下：</strong></p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="四进程通信">四、进程通信：</h3><h4 id="什么是进程通信">1、什么是进程通信？</h4><p>​ 进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立。</strong>进程1可以访问进程1的地址空间，但不能直接访问进程2的地址空间。</p><p>​ <strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法就是进程通信</strong></p><h4 id="进程通信共享存储-方法">2、进程通信——共享存储 方法</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171055164.png" alt="共享存储" style="zoom: 67%;" /></p><p>​ 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p><p>​ 操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p><p>​ <strong>其又有两种方式</strong>：</p><ul><li><p>基于数据结构的共享</p><p>​ 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式<strong>速度慢、限制多，是一种低级通信方式</strong></p></li><li><p>基于存储区的共享</p><p>​ 基于存储区的共享：在内存中画出一块共享存储区，<strong>数据的形式、存放位置都由进程控制，而不是操作系统。</strong>相比之下，这种共享方式<strong>速度更快，是一种高级通信方式。</strong></p></li></ul><h4 id="进程通信管道通信-方法">3、进程通信——管道通信 方法</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171447871.png" alt="管道通信" /><figcaption aria-hidden="true">管道通信</figcaption></figure><p>​ “管道”是指用于连接读写进程的一个共享文件，又名pipe程的一个共享文件，又名pipe 文件。其实就是<strong>在内存中开辟一个大小固定的缓冲区 </strong></p><ul><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各个进程需要互斥的访问管道</li><li>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的write（）系统调用将被阻塞</strong>，等待读进程将数据取走。<strong>当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。</strong></li><li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li><li><strong>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情</strong></li></ul><h4 id="进程通信消息传递-方法">4、进程通信——消息传递 方法</h4><p>​ 进程间的数据交换<strong>以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的<strong>“发送消息/接收消息”两个原语进行数据交换</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180227145.png" /></p><p>​ 消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p><p>​ 每个进程都会有一个消息缓冲队列：消息传递有以下两种方式：</p><ul><li>直接通信方式: 消息直接挂到接受进程的消息缓冲队列上<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180138885.png" /></li></ul></li><li>间接通信方式：消息先发送到中间实体中<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180217571.png" /></li></ul></li></ul><h3 id="五线程概念和多线程模型">五、线程概念和多线程模型：</h3><h4 id="什么是线程">1、什么是线程？</h4><p>​ 在传统的机制中，<strong>进程是程序执行流的最小单位。</strong></p><p>​ <strong>有的进程</strong>可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>​ 一个进程中，被分为多个线程。CPU轮流为不同的线程服务。故而，引入线程后，<strong>线程是程序执行流的最小单位。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180730244.png" style="zoom:67%;" /></p><p>​</p><p><strong>官方定义：线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong></p><p>​ 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p><p>​ 引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的），<strong>线程才是CPU的执行单元</strong>（而CPU是分配给不同的线程的）</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181019487.png" alt="引入线程后的变化" /></p><h4 id="线程的属性">2、线程的属性：</h4><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li><strong>同一进程的不同线程间共享进程的资源（例如打印机等）</strong></li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h4 id="线程的实现方式">3、线程的实现方式：</h4><h5 id="用户级线程">1）用户级线程：</h5><p>​ 用户级线程由应用程序通过线程库实现。</p><p>​ 所有的线程管理工作都<strong>由应用程序负责（包括线程切换）</strong></p><p>​ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>​ <strong>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</strong>（用户级线程对用户不透明，对操作系统透明）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181528334.png" alt="用户级线程" style="zoom: 67%;" /></p><h5 id="内核级线程">2）内核级线程：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181555209.png" alt="内核级线程" style="zoom:67%;" /></p><p>​ 核级线程的管理工作由操作系统内核完成。</p><p>​ 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p><h5 id="两者组合">3）两者组合：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181640824.png" alt="" style="zoom:67%;" /></p><p>​ 在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m 个内核级线程上（n&gt;=m）</p><p>​ 重点：<strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p><p>​ 例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，<strong>也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</strong></p><h4 id="多线程模型">4、多线程模型：</h4><p>​ 在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><h5 id="多对一模型">1）多对一模型：</h5><p>​ 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182055006.png" style="zoom:67%;" /></p><p>​ <strong>优点：</strong>用尸级线程的切换在用尸空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>​ <strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h5 id="一对一模型">2）一对一模型：</h5><p>​ 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182003606.png" alt="一对一模型" style="zoom:67%;" /></p><p>​ <strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>​ <strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h5 id="多对多模型">3）多对多模型：</h5><p>​ n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182148042.png" style="zoom:67%;" /></p><p>​ 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.1节的内容，含进程的定义、组成、组织方式、状态与转换，进程控制、进程通信、线程概念和多线程模型等内容</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>__call__方法</title>
    <link href="https://blog.slks.xyz/2022/03/12/6c6b30d1f672/"/>
    <id>https://blog.slks.xyz/2022/03/12/6c6b30d1f672/</id>
    <published>2022-03-12T06:20:19.000Z</published>
    <updated>2022-03-12T06:23:18.228Z</updated>
    
    <content type="html"><![CDATA[<p>​ Python的一个特殊的实例方法<code>__call__</code>，功能类似于在类中重载()运算符，使得类实例对象可以像调用普通函数那样进行使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,name,add</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,name,add)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(<span class="string">&quot;C test&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过在 CLanguage 类中实现<code>__call__</code>方法，使得 clangs 实例对象变为了可调用对象。</p>]]></content>
    
    
    <summary type="html">本文讲解了Python的一个特殊的实例方法__call__，功能类似于在类中重载()运算符，使得类实例对象可以像调用普通函数那样进行使用。</summary>
    
    
    
    <category term="⓸ 编程语言类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python基础扩充笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/Python%E5%9F%BA%E7%A1%80%E6%89%A9%E5%85%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记11——torchvision图像数据预处理</title>
    <link href="https://blog.slks.xyz/2022/03/12/796f9da33963/"/>
    <id>https://blog.slks.xyz/2022/03/12/796f9da33963/</id>
    <published>2022-03-12T05:45:19.000Z</published>
    <updated>2022-03-12T06:18:42.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一torchvision简介">一、TorchVision简介：</h3><p>torchvision 是Pytorch中专门用来处理图像的库。这个包中有四个大类。</p><ul><li><p>torchvision.datasets 包含了很多提前处理好的数据集：如COCO、ImageNet等</p></li><li><p>torchvision.models 包含了已经训练好的模型，可以加载后直接用：如AlexNet、VGG等</p></li><li><p>torchvision.transforms 包含一般的图像转换操作类 如归一化、展平</p></li><li><p>torchvision.utils</p></li></ul><h3 id="二transforms的一些函数">二、Transforms的一些函数：</h3><h4 id="transforms.normalizemeanstdinplacefalse">1、transforms.Normalize(mean,std,inplace=False)</h4><ul><li>mean:各通道的均值</li><li>std：各通道的标准差</li><li>inplace：是否原地操作</li></ul><p>一般可以如下传入mean和std:代表我要将数据归约化至如下的均值和方差的分布</p><p><code>mean = (0.5,0.5,0.5) std = (0.5,0.5,0.5)</code></p><p>该函数就是通过以下公式，对图像3个通道分别依据输入的mean和std进行归约化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x - mean) / std</span><br></pre></td></tr></table></figure><p>最终得到新的数据。整体过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">new_data = transforms.Normalize(mean, std)(data)</span><br></pre></td></tr></table></figure><p>可以看到：其实 transforms.Normalize(mean, std) 只是指定了一个函数，所以还可以如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">normalize = transforms.Normalize(mean=mean, std=std)</span><br><span class="line">new_data = normalize(data)</span><br></pre></td></tr></table></figure><h4 id="transforms.totensor">2、transforms.ToTensor()</h4><p>该函数有两个功能：</p><ol type="1"><li>是将输入的数据改变Shpae，图像数据本身是三维的： W，H，C ，该函数会将其变成 C，W，H的维度</li><li>将所有数除以255，将像素数据归一化到<code>[0,1]</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.shape)   <span class="comment">#（5，5，3）</span></span><br><span class="line">data = transforms.ToTensor()(data)</span><br><span class="line"><span class="built_in">print</span>(data.shape)<span class="comment">#（3，5，5）</span></span><br></pre></td></tr></table></figure><p>和Normalize函数一样：也可以按照如下方法使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toTensor = transforms.ToTensor()</span><br><span class="line">data = toTensor(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">PyTorch 中，关于torchvision库对图像数据预处理的函数记录</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Pytorch系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Pytorch%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>1.1 操作系统概念与基础</title>
    <link href="https://blog.slks.xyz/2022/03/11/b7e4aac04426/"/>
    <id>https://blog.slks.xyz/2022/03/11/b7e4aac04426/</id>
    <published>2022-03-11T12:48:19.000Z</published>
    <updated>2022-03-14T13:03:48.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一概念功能与目标">一、概念功能与目标</h3><h4 id="概念">1、概念</h4><p>操作系统（Operating System，OS）是指控制和管理<strong>整个计算机系统的硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220311205142106.png" style="zoom: 67%;" /></p><p>较为直观的例子：Windows的任务管理器</p><h4 id="功能与目标">2、功能与目标：</h4><h5 id="系统资源的管理者">1) 系统资源的管理者：</h5><p>提供4个功能：</p><ul><li>CPU管理</li><li>存储器管理（内存&amp;外存）</li><li>文件管理</li><li>硬件设备管理</li></ul><p>目标：安全 + 高效</p><h5 id="作为用户和计算机硬件之间的接口">2）作为用户和计算机硬件之间的接口：</h5><p>提供3个功能：</p><ul><li>命令接口<ul><li>联机命令接口（交互式命令接口）：用户说一句，系统做一句。比如win中的<code>cmd</code>命令解释器</li><li>脱机命令接口（批处理命令接口）：用户说一堆，系统做一堆。win中的<code>*.bat</code>文件执行</li></ul></li><li>程序接口<ul><li>如win中，程序员在程序中调用<code>*.dll</code>（该调用过程即为<strong>系统调用</strong>）可以实现某些功能。这类接口只能通过用户程序<strong>间接使用</strong></li></ul></li><li>GUI图形用户界面<ul><li>删除文件：拖拽至回收站</li></ul></li></ul><h5 id="作为最接近硬件的层次">3） 作为最接近硬件的层次：</h5><p>需要实现堆硬件机器的拓展，没有任何软件支持的计算机称为<strong>裸机</strong>。</p><p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p><h3 id="二操作系统的特征">二、操作系统的特征</h3><h4 id="并发最基本的特征之一">1、并发（最基本的特征之一）</h4><p>​ 指两个或多个事件在同一时间间隔内发生。<strong>这些事件宏观上是同时发生的，但微观上是交替发生的。</strong></p><p>​ 操作系统的并发性指<strong>计算机系统中同时存在着多个运行着的程序</strong>。</p><p>​ 一个单核处理机（CPU）同一时刻只能执行一个程序，因此<strong>操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）</strong></p><p>​ 我们现在的4核CPU处理器，意味着同一时刻可以有4个程序<strong>并行</strong>执行，但是操作系统的<strong>并发性</strong>必不可少。</p><h4 id="共享最基本的特征之二">2、共享（最基本的特征之二）</h4><p>​ 资源共享，是指<strong>系统中的资源可供内存中多个并发执行的进程共同使用。</strong></p><ul><li>互斥共享方式：系统中的<strong>某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</strong>比如说：使用QQ和微信视频，<strong>同一时间段摄像头只能分配给其中一个进程。</strong></li><li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程<strong>“同时”</strong>对它们进行访问。比如说：使用QQ发送文件A，同时使用微信发送文件B。<strong>宏观上看，两边都在同时读取并发送文件，</strong>说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></li></ul><h4 id="虚拟">3、虚拟</h4><p>​ 虚拟是指<strong>把一个物理上的实体变为若干个逻辑上的对应物</strong>：物理实体（前者）是实际存在的，而<strong>逻辑上对应物（后者）是用户感受到的。</strong></p><h5 id="虚拟技术">1）虚拟技术</h5><ul><li><p>空分复用技术：如虚拟存储器技术</p></li><li><p>时分复用技术：如虚拟处理器</p></li><li><p>问题1：GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存……而我的电脑只有4GB内存，这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？</p></li><li><p>答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<strong>即空分复用技术</strong></p></li><li><p>问题2：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢？</p></li><li><p>答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。<strong>即时分复用技术</strong></p></li></ul><h4 id="异步">4、异步</h4><p>​ 异步是指，在多道程序环境下，允许多个程序并发执行，<strong>但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，</strong>这就是进程的异步性。</p><h3 id="三操作系统的发展与分类">三、操作系统的发展与分类：</h3><h4 id="手工操作阶段">1、手工操作阶段：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313105737330.png" alt="手工操作阶段" /><figcaption aria-hidden="true">手工操作阶段</figcaption></figure><p><strong>主要缺点：</strong>用户独占全机、人机速度矛盾导致资源利用率极低</p><h4 id="批处理阶段">2、批处理阶段：</h4><h5 id="单道批处理系统">1）单道批处理系统</h5><p>​ 引入脱机输入输出技术（用磁带完成），并由监督程序负责控制作业的输入输出。</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110520259.png" alt="单道批处理系统" /><figcaption aria-hidden="true">单道批处理系统</figcaption></figure><p><strong>主要优点：</strong>缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p><strong>主要缺点：</strong>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待l/0完成。资源利用率依然很低。</p><h5 id="多道批处理系统">2）多道批处理系统</h5><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110759912.png" alt="多道批处理系统" /><figcaption aria-hidden="true">多道批处理系统</figcaption></figure><p><strong>主要优点：</strong>多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p><strong>主要缺点：</strong>用户响应时间长，没有人机交互功能（用户提交自己的作业（程序）之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h4 id="分时操作系统">3、分时操作系统：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111132639.png" alt="分时操作系统" /><figcaption aria-hidden="true">分时操作系统</figcaption></figure><p>​ 计算机以<strong>时间片</strong>（例如50ms）为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p><strong>王要优点：用户请求可以被即时响应，群决了人机交互问题。</strong>允许多个用尸同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p><strong>主要缺点：</strong>不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，<strong>不区分任务的紧急性</strong>。</p><h4 id="实时操作系统">4、实时操作系统：</h4><ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理（如导弹控制系统、自动驾驶等）</li><li>软实时系统：能接受偶尔违反时间规定</li></ul><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后<strong>及时进行处理</strong>，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p><h4 id="其他操作系统">5、其他操作系统：</h4><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</li><li>个人计算机操作系统：如WindowsXP、MacOs，方便个人使用。</li></ul><h3 id="四操作系统的运行机制">四、操作系统的运行机制：</h3><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111750626.png" alt="“指令”和&quot;代码&quot;的区别" /><figcaption aria-hidden="true">“指令”和"代码"的区别</figcaption></figure><h4 id="两种指令">1、两种指令：</h4><h5 id="特权指令如内存清零指令不允许用户程序使用">1） 特权指令：如内存清零指令，不允许用户程序使用</h5><h5 id="非特权指令如普通的运算指令">2） 非特权指令：如普通的运算指令</h5><h4 id="两种处理器状态">2、两种处理器状态：</h4><p>用于判断当前是否可以执行特权指令</p><h5 id="用户态目态只能执行非特权指令">1） 用户态（目态）：只能执行非特权指令</h5><h5 id="核心态管态两种指令都可以执行">2） 核心态（管态）：两种指令都可以执行</h5><h4 id="两种程序">3、两种程序：</h4><h5 id="内核程序">1）内核程序：</h5><p>​ 操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p><h5 id="应用程序">2）应用程序：</h5><p>​ 为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</p><h3 id="五操作系统内核">五、操作系统内核：</h3><h4 id="内核总览示意图">1、内核总览示意图：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112448980.png" alt="计算机系统的层次结构" /><figcaption aria-hidden="true">计算机系统的层次结构</figcaption></figure><p>​ <strong>原子性</strong>指该程序在开始执行后，中间不能被中断。</p><p>​ 内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p><h4 id="操作系统的体系结构">2、操作系统的体系结构：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112907278.png" /></p><h5 id="大内核">1） 大内核：</h5><p>将操作系统的主要功能模块都作为系统内核，运行在核心态</p><p>优点：高性能</p><p>缺点：内核代码庞大，结构混乱，难以维护</p><h5 id="微内核">2）微内核：</h5><p>只把最基本的功能保留在内核</p><p>优点：内核功能少，结构清晰，方便维护</p><p>缺点：需要频繁地在核心态和用户态之间切换，性能低</p><h3 id="六中断和异常">六、中断和异常：</h3><h4 id="中断机制的诞生缘由">1、中断机制的诞生缘由：</h4><p>​ 早期计算机各个程序只能串行执行程序，系统资源利用率会较低。为了解决该问题，就发明了操作系统，引入中断机制，实现了多道程序的并发执行。</p><p><strong>本质</strong>： 发生中断，就意味着需要操作系统接入，进行管理.具体如下:</p><p>​ 我们假设3个进程同时放入内存中进行执行,首先CPU执行进程1,一段时间后,CPU收到计时硬件发出的中断信号,就会切换至<strong>核心态</strong>,CPU知晓进程1的时间片已经用完了,就切换进程2运行.完成该系列操作后,CPU又会切换至<strong>用户态</strong>,然后开始运行进程2,在进程2运行过程中,进程2发出<strong>系统调用(内中断信号)</strong>,请求输出.<strong>(由于输入输出是特权指令,普通程序不能直接调用,只能通过向操作系统申请,即主动发出中断信号)</strong>,此时CPU将切换到<strong>核心态</strong>,<strong>由操作系统内核进行接管</strong>,负责执行输出内容,比如其让打印机IO设备开始工作,<strong>此时进程2就需要暂停运行等待IO完成,故而操作系统此时让进程3先运行</strong>.CPU重新切换为<strong>用户态,</strong>执行进程3.在CPU执行进程3的过程中,IO也在同步进行,当IO完成时,IO设备(打印机)就会向CPU发出中断信号,CPU收到IO设备发来的中断信号,又会切换至<strong>核心态</strong>,<strong>交由操作系统内核进行处理</strong>.此时,操作系统发现是进程2的IO结束了,就会让进程2恢复运行,CPU切换为用户态.进程2继续完成内容.</p><h4 id="中断的概念和作用">2、中断的概念和作用：</h4><ul><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ul><p>​ 发生了中断，就意味着需要<strong>操作系统介入，开展管理工作。</strong>由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从<strong>用户态转为核心态</strong>。<strong>中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。</strong> <strong>有了中断，才能实现多道程序并发执行。</strong></p><p><strong>用户态</strong>到<strong>核心态</strong>的切换是通过<strong>中断</strong>实现的，并且中断是唯一途径。</p><p><strong>核心态</strong>到<strong>用户态</strong>的切换是通过<strong>执行一个特权指令，将PSW标志位设置</strong>实现的。</p><h4 id="中断的分类">3、中断的分类:</h4><p>两者的本质区别： 信号的来源是CPU内部还是CPU外部。与当前的执行的指令是否有关</p><h5 id="内中断异常例外陷入-来源于cpu内部与当前执行的指令有关">1）内中断（异常、例外、陷入）： 来源于CPU内部，与当前执行的指令有关</h5><ul><li>指令中断：系统调用</li><li>强迫中断<ul><li>硬件故障</li><li>软件中断（如整数除0）</li></ul></li></ul><h5 id="外中断来源于cpu外部与当前执行的指令无关">2）外中断：来源于CPU外部，与当前执行的指令无关</h5><ul><li>外设请求：I/0操作完成发出的中断信号</li><li>人工干预：用户强行终止一个进程</li></ul><p>另一种分类：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130033093.png" alt="另一种中断的分类" /><figcaption aria-hidden="true">另一种中断的分类</figcaption></figure><h4 id="外中断的处理过程">4、外中断的处理过程：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130249004.png" alt="外中断的处理过程" /><figcaption aria-hidden="true">外中断的处理过程</figcaption></figure><ul><li>Step1：执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li><li>Step2：如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器)</li><li>Step3：根据中断信号类型转入相应的中断处理程序</li><li>Step 4：恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ul><h3 id="七系统调用">七、系统调用：</h3><h4 id="什么是系统调用">1、什么是系统调用：</h4><p>​ 操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由<strong>一组系统调用组成</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313141435648.png" /></p><p>​ “系统调用”是<strong>操作系统提供给应用程序</strong>（程序员/编程人员)使用的接口，可以理解为一种<strong>可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务</strong>。</p><p>​</p><h4 id="系统调用有什么作用">2、系统调用有什么作用？</h4><p>​ <strong>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</strong></p><p><strong>系统调用</strong>会使得处理器从<strong>用户态</strong>进入<strong>核心态</strong>。</p><h4 id="系统调用分类">3、系统调用分类：</h4><p>​ 系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142304849.png" alt="系统调用分类" /><figcaption aria-hidden="true">系统调用分类</figcaption></figure><h4 id="系统调用与库函数的区别">4、系统调用与库函数的区别：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142453847.png" style="zoom:50%;" /></p><p>从下层至上层如下：</p><ul><li><strong>裸机</strong></li><li><strong>操作系统</strong>：向上提供系统调用</li><li><strong>编程语言</strong>：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</li><li><strong>普通应用程序</strong>：可直接进行系统调用，也可使用库函数。</li></ul><p>注意：有的库函数涉及系统调用，有的不涉及</p><h4 id="系统调用背后的过程">5、系统调用背后的过程：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142828536.png" alt="系统调用背后的过程" /><figcaption aria-hidden="true">系统调用背后的过程</figcaption></figure><p><code>int x</code>指令的参数x，指明了系统调用号。此处的int是interrupt的缩写，执行该指令后，权限就交给了操作系统来接管，切换至核心态处理系统调用相关代码。</p><p><strong>注意：</strong></p><p>1.陷入指令是在<strong>用户态执行的</strong>，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态 2.<strong>发出系统调用请求是在用户态</strong>，而对系统调用的相应处理在核心态下进行 3.<strong>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</strong></p>]]></content>
    
    
    <summary type="html">包含王道课程第1节的内容，含操作系统的概念、功能、目标、运行机制、中断异常和系统调用。</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记5——逻辑回归中的损失函数节点</title>
    <link href="https://blog.slks.xyz/2022/03/02/c830e3a9e023/"/>
    <id>https://blog.slks.xyz/2022/03/02/c830e3a9e023/</id>
    <published>2022-03-02T12:42:19.000Z</published>
    <updated>2022-03-03T02:55:36.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一感知机损失与对数损失">一、感知机损失与对数损失：</h3><h4 id="原理及利弊">1、原理及利弊</h4><p>​ <strong>感知机损失</strong>在原点处有一个硬转折，该点不可导。同时，在x大于0的区间范围内，其函数值一直为0，但这并不太好，虽然此部分的模型分类正确，但是我们希望模型能够更正确，也就是x越大越好。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_45_52_846.png" style="zoom: 50%;" /></p><p>​ 介于上述情况，引入了<strong>对数损失函数</strong>，<span class="math inline">\(L(x) = log(1+e^{-x})\)</span>，处处可导，且在x&gt;0的时候，x越大，函数值越接近0，作了一定的区分。也就是说，对不那么正确的情况施加了一定的惩罚。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_46_33_157.png" style="zoom:50%;" /></p><h4 id="代码实现">2、代码实现：</h4><h5 id="损失函数抽象类">1）损失函数抽象类：</h5><p>​ 按照先前所述，损失函数也可以抽象为计算图中的一个节点，首先定义一个抽象类，继承Node类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LossFunction</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义损失函数抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="实现感知机损失">2）实现感知机损失：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerceptionLoss</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    感知机损失，输入为正时为0，输入为负时为输入的相反数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line">        </span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对父节点中每一个元素，执行上述操作</span></span><br><span class="line">        self.value = np.mat( np.where( x &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -x ) )  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        雅克比矩阵为对角阵，每个对角线元素对应一个父节点元素。若父节点元素大于0，则</span></span><br><span class="line"><span class="string">        相应对角线元素（偏导数）为0，否则为-1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        diag = np.where(parent.value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())  </span><br><span class="line">    <span class="comment"># ravel 函数将 多维数组 扁平化展开</span></span><br><span class="line">        <span class="comment"># np.diag(array) 中</span></span><br><span class="line">        <span class="comment"># array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵</span></span><br><span class="line">        <span class="comment"># array是一个二维矩阵时，结果输出矩阵的对角线元素</span></span><br></pre></td></tr></table></figure><h5 id="实现对数损失类">3）实现对数损失类：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogLoss</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span>  <span class="comment"># 根据父节点的值，计算该节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line"></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line"></span><br><span class="line">        self.value = np.log(<span class="number">1</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))) <span class="comment"># 对于父节点的每个元素都依据公式进行运算，为了防止溢出，对指数进行了截断</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span> <span class="comment"># 计算本节点对某个父节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        x = parent.value</span><br><span class="line">        diag = -<span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, np.where(x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, x))) <span class="comment"># 通过计算可以得到，其实就是对数损失的导数，放在对角线的每个元素上</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二logistic函数">二、Logistic函数</h3><h4 id="原理及操作">1、原理及操作：</h4><p><span class="math display">\[Logistic(x) = \frac{1}{1 + e^{-x}}\]</span></p><p><img src="https://bkimg.cdn.bcebos.com/pic/f3d3572c11dfa9ec71464f3e60d0f703918fc1ab?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" style="zoom:50%;" /></p><p>​ 我们可以对模型的线性部分施加这个变换，来代替原先的阶跃函数。</p><h4 id="logistic操作节点实现">2、Logistic操作节点实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logistic</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对向量的分量施加Logistic函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment"># 对父节点的每个分量施加Logistic</span></span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            <span class="number">1.0</span> / (<span class="number">1.0</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(np.mat(np.multiply(self.value, <span class="number">1</span> - self.value)).A1)  <span class="comment"># 这个计算依赖于Logistic函数对x的导数，在化简后其实就等于 Logistic(x) * (1-Logistic(x))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三逻辑回归">三、逻辑回归：</h3><h4 id="二分类逻辑回归">1、二分类逻辑回归：</h4><p>​ 当我们将先前的AdaLine模型的阶跃函数替换成Logistic函数，得到输出。并且对线性部分施加对数损失，就可以得到逻辑回归模型。</p><p>​ 需要注意的是：由于我们的训练集男女标签为1/-1，但是使用Logistic函数输出的值是在0-1之间的，输出的内容是正类（男性）的概率值，而没有判定样本具体的类别。所以我们可以以0.5为阈值，进行判定。阈值大小也是可以根据具体情况自定义的。</p><p>​ <strong>故而，二分类逻辑回归模型只提供概率，选择阈值的决定权还是在人</strong></p><p>​ <strong>总结</strong>：</p><p>​ 用Logistic函数，得到<strong>最终的概率值输出</strong>。</p><p>​ 对线性部分施加<strong>对数损失，以用于训练</strong>。</p><h4 id="多分类逻辑回归">2、多分类逻辑回归：</h4><p>​ 我们一般采用SoftMax来代替“硬”的Max函数，将所有值归约至0-1之间，进而进行概率值的输出</p><h5 id="softmax节点实现">SoftMax节点实现：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftMax</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SoftMax函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">a</span>):</span></span><br><span class="line">        a[a &gt; <span class="number">1e2</span>] = <span class="number">1e2</span>  <span class="comment"># 防止指数过大</span></span><br><span class="line">        ep = np.power(np.e, a)</span><br><span class="line">        <span class="keyword">return</span> ep / np.<span class="built_in">sum</span>(ep)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        我们不实现SoftMax节点的get_jacobi函数，        训练时，不会通过SoftMax节点进行反向传播</span></span><br><span class="line"><span class="string">        训练时使用CrossEntropyWithSoftMax节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Don&#x27;t use SoftMax&#x27;s get_jacobi&quot;</span>)</span><br></pre></td></tr></table></figure><p>​ 一般使用交叉熵，来衡量SoftMax输出的分布，与真实标签的分布是否相似，具体的公式见常见的损失函数章节。</p><figure><img src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ <span class="math inline">\(q(x_i)\)</span>是预测分布，<span class="math inline">\(p(x_i)\)</span>是标签的分布。交叉熵是符合直觉得，当样本属于第i类的时候，只有<span class="math inline">\(p(x_i)\)</span>为1，其他p的分量都为0，最小化交叉熵函数，其实就是在最大化<span class="math inline">\(log(q(x_i))\)</span>这一项的值，也就是在最大化<span class="math inline">\(q(x_i)\)</span>，及最大化模型输出的第i类概率。</p><h5 id="crossentropywithsoftmax-实现">CrossEntropyWithSoftMax 实现：</h5><p>​ 在上面实现Softmax节点的时候，并没有实现get_jacobi方法，原因就是它的输出会和独热向量一起被送给交叉熵。计算交叉熵对于线性部分的雅可比矩阵，比计算对Softmax输出的雅可比矩阵会更容易。Pytorch框架中也是这么干的。将Softmax操作附在了CrossEntropy损失函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossEntropyWithSoftMax</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对第一个父节点施加SoftMax之后，再以第二个父节点为标签One-Hot向量计算交叉熵</span></span><br><span class="line"><span class="string">    self.parents[0] 为logit向量，也就是线性部分</span></span><br><span class="line"><span class="string">    self.parents[1] 为One-Hot编码的向量标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)      </span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            -np.<span class="built_in">sum</span>(np.multiply(self.parents[<span class="number">1</span>].value, np.log(prob + <span class="number">1e-10</span>))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="comment"># 这里存在重复计算，但为了代码清晰简洁，舍弃进一步优化</span></span><br><span class="line">        <span class="comment"># 推导见下，参考《用Python实现深度学习框架》</span></span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> (prob - self.parents[<span class="number">1</span>].value).T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-np.log(prob)).T</span><br></pre></td></tr></table></figure><h4 id="带交叉熵的多分类逻辑回归计算图示例">3、带交叉熵的多分类逻辑回归计算图示例：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/654F54B060F55AD5E7433929CC7A48B3.jpg" style="zoom: 25%;" /></p><p>​</p>]]></content>
    
    
    <summary type="html">本文介绍逻辑回归中常见的一些损失函数的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记4——优化器类的代码实现（下）</title>
    <link href="https://blog.slks.xyz/2022/02/28/d9d77f183b68/"/>
    <id>https://blog.slks.xyz/2022/02/28/d9d77f183b68/</id>
    <published>2022-02-28T02:59:19.000Z</published>
    <updated>2022-02-28T02:59:58.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="六momentum冲量优化器的实现">六、Momentum冲量优化器的实现：</h4><h5 id="公式">1、公式：</h5><p>​ 由于先前的梯度下降法的速度向量v只依赖于当前的梯度，而不参考历史梯度，很容易让优化器陷入Critical Point中。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/6E1655AA36BAFF6E77328731A966D476.jpg" style="zoom:33%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Momentum</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冲量法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, momentum=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 衰减系数，默认为0.9</span></span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 积累历史速度的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史速度，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.v:</span><br><span class="line">                    self.v[node] = - self.learning_rate * gradient</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史速度</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的速度</span></span><br><span class="line">                    self.v[node] = self.momentum * self.v[node] - self.learning_rate * gradient</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value + self.v[node])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="七adagrad优化器的实现">七、AdaGrad优化器的实现：</h4><h5 id="公式-1">1、公式：</h5><p>​ <strong>针对梯度的每个分量各自的历史，采用不同的学习率。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B02ADB3A208B90C7E30118C018E24361.jpg" style="zoom: 25%;" /></p><p>​ s 是 一个和梯度同维度的向量，<strong>其会在各个分量上累加历史梯度各个分量的平方</strong>。<strong>更新梯度时，求s各个分量的平方根,然后用学习率去除，得到自适应的一个向量，里面每个分量代表的就是各个分量对应的合适的学习率</strong>，将这个向量与梯度向量做内积，就可以得到一个合理的下降方向。从严格意义上来讲，这已经不是再向梯度的反方向下降了。<span class="math inline">\(\epsilon\)</span>是用于防止除数为0.</p><p>​ <span class="math inline">\(\bigotimes\)</span> 代表向量内各个分量分别相乘，将会得到一个和原来向量维度一致的新向量</p><h5 id="代码-1">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdaGrad</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    不同分量，自适应学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史的向量s，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史累积的向量s</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的历史累积的s</span></span><br><span class="line">                    self.s[node] = self.s[node] + np.power(gradient,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八rmsprop优化器的实现">八、RMSProp优化器的实现：</h4><h5 id="公式-2">1、公式：</h5><p>​ AdaGrad累积了全部的历史梯度，而我们其实应该更多地考虑近期地历史梯度。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/35459FAB3F235381D94DED311CECB887.jpg" style="zoom:25%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码-2">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSProp</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    RMSProp优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta = beta</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.s[node] = self.beta * self.s[node] + (<span class="number">1</span> - self.beta) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="九adam优化器的实现">九、Adam优化器的实现：</h4><h5 id="公式-3">1、公式：</h5><p>​ 集大成者，结合冲量与RMSProp的思想：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F34B46DEC057822E872DE8B45F0EDB3F.jpg" style="zoom:25%;" /></p><h5 id="代码-3">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Adam优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta1=<span class="number">0.9</span>,beta2=<span class="number">0.99</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta1 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        <span class="comment"># 衰减系数2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta2 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 积累历史速度向量的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                    self.v[node] = gradient <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 梯度累积</span></span><br><span class="line">                    self.v[node] = self.beta1 * self.v[node] + (<span class="number">1</span> - self.beta1) * gradient</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 各分量平方累积</span></span><br><span class="line">                    self.s[node] = self.beta2 * self.s[node] + (<span class="number">1</span> - self.beta2) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               self.v[node] / np.sqrt(self.s[node] + self.epsilon))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文续上半篇，实现一些常见的梯度下降优化器类。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>毕业相关事项</title>
    <link href="https://blog.slks.xyz/2022/02/26/84b3fb3c559e/"/>
    <id>https://blog.slks.xyz/2022/02/26/84b3fb3c559e/</id>
    <published>2022-02-26T15:52:19.000Z</published>
    <updated>2022-03-11T12:47:48.827Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5f2832a9d17d20fa058514dfe360c6848d2427e84c6d3c3633ffec46b45dcfec">f638d67e356a706b7b082748a96249a9c6215665973a817d195d1e1476666dda00dede9801ee74c82cd7a946d96afe739c132c3adadb052f1b3812d2e382bbb9b67d1a06443ab4b4344bdab2822da6341e5da18560a52307d2bd1f9203199afbad5f76870d7d90ee0f0f579250a59e5260dc5a69a54d8400868d9b23518d413782354b3de38bab4b3070fda0443c74e65d1fdbcd6cb6466819e1e93168ec312c4fc45b115b918b99551b1ea7fbda3ba7675bd17f0712586c6fb48ed4e4522899cf6be56698e6e1f00004f7f70c858b25a7fc069f6b29200a5de2f6af4e968f215dd55c10559179ee9b1a30a0639086c17c71ab66bcb52dbaab7ffdb0db4a0f4d87ce6f666fe844b0d79d0e6086cce4d8fa10c0ca4553fcb5a0e692dd03f89de648462e1bd956ba1cf3594d22f18f7ab30ca2e70ddb923b8c47ff1991b9dc7a622da4928712167ea7bdfffd4a3a3b6d7881816af969fe1f931207e670ceafc5094fa19d37d53928af10ba79a60e2f1f909825b2b27d67631c02abad89f95d6e5d5f62058ce0df2313939939a19fc8c1f8e04cfd3b4d162621e78202ed3a4d0a9aa47ec85024c209860a31e14cb6f381aeeb146312b7ce3f34dc65e73ecfcfc691bd2f1c8e813eacbad5bce3f67bceba55b8f2547385e9328e8ed8940118b478166d50a7ad26772190613862beafc6f28df47cd2a16ef84e28c309a5b3877b87000d80d53446cc58ce33de76b01342272398b60e5920be949aec0e359b7cee75fe804ec381aba268dbad9914313f55f0c4958349505d73c0c4524cfef4571be0d3bbc26edf818344066669e96fb9d7fc88bd57a3ace92ab8deff47ff3e1b97c8638ed459ce3cfd6f41001f206e3e138a829131ec361d90d715cbe1c7b4ed2d3bdb1b4e3062edf350bcf4bdacacaea4b7693b57be9b2fb355dbf3efb2cbc4cee80c69f90818de2c5adb41b868b1885e413694861b46236889809844971258ef964b9a9204eaaa2715ea9e59dfc02d75527ae5a8450e455c5e29a576a41f996eec58c60aaddf9b00799424aade3e2678fc24cdac0afab8e5079f49991f9731f59638d8c9c6b27d872b6012904a26f7b65618eb3edfa0bf09cb1fe0a48a7f857d26bc7bacb66db70470e407ad81abd0f98f46cd1d396f303d4b9d4ae1a1697623e9ea5be4fd695ff120fd7205d3e6beb8467eb68200d095a9c3eb24613784d4b94f8bb4816391543d9e1b551d9f4d87fff20379e8c4657b2a3af725a5c05bc9d296ce3d9293db93a1772f1b8289c3b63132694e483b529e90164171fd3f1065fd5f6fd63f5e906f4c0fb8a6c07f60e94024cdcb3fba85d00b71ecc625c873c111d652749ff9cb7050b24ab1d1b9b1a6037db5190804a4ced4e6f2df1f1f0b2a7f53f6f4365568ab7204ab023231312577b44fa05789372aec3583bd5868cc1092fb7082ce7882650af227712ae75835a13729a2fe99b2a7a1f0c5d63ffa63cbf2ea7a071317567f9a74766e930e27bcc4b62dd01a44ffdf42f6ecf60edf6269956e9ea6b7ac121dd16829b91f169935fa20a8b4e156eae8e0e41ceadbdc4396d0e069fd7aa9b58646ec9114fd4eb3eb2cf101c0b090cfa1ae1b81529658b882e65f8d08ab4c68339372320ec34ceb42e243b6500247dda22a14eb73dd54c032a3195fda6ab4f90c8382e41b2aa6d325daac9b62ed42cdc7c997312e0c76842ce02b3f4a0b026f9fed63297f05b0c91a7abff2df2aa0785a6533bde998fa03008ad2bc0cd733505ce99fcb7c2be7783fac7502a25ba5e7193dac54b76b143695634643fe7372c694c2b3b76fa0aa9b1256adaf420e9cf03891e89af3e2636bbf0aff4522c01e64936d0d9e473f102f3035cb89fa98cd880b0f404b266ef49ac2ffe83b846019eb9d2675fe90881ec4d33f0cd963c6989f8ff82481e64760c52ea84fee0f7007d47c7fb9907427736b35ecf13b61cc157b7a5591ed7fa0555639a214e19a7df206871d585987c892feb9c77dbd27fa1885706c103c5fda6796f576b41c97252a92ff78d8e2498514f6c468b99527dc6482a6a09f1a54e43a3f948ee74321317a3ea08841a8b49f8ba547c693e9c2876fd9e8bd29c037f23e0c84bd06c272e1452f92d9e9126d16667bff55dc0e4f2b2f0d83bdbd5bd34855f09bf177881d55e1c74591b8510fdad8c360ec38af037e5ebcc54f9b4545630aa0438ea671678eeb609a1f11546362233951006497d6abbe9921e4b8a55390edc2e15c03812f017d6edd0af0bf5752a62deab5b6bd6472215fdd960e07e02dbf19b5ed1e2cf7034455269300846de5d098d7b592d03659e37f03504689288620d7f4dbd8fe2876f88792ea41e5e8f98c29a527d14d6d4b3d4816ac2dcb62779febd26bf0c2ffba1314c0b4db5639f5979415eeb81647b6f575f7a9a4be691d01215133f3c5d791e25d03148e41ebfa6f9a92e26fad06fc0d7c4c7b006719edc26aed0137f2f5703d3157a8567a9d152c57c4dd7ea8132204959f2a229b9e622ac6bbb5942dc67a6e8893b7fb776bcd2a19f54ad22688e00dbbbba64e2bdc57d1213a3b15e44400280c916c79540e6e1d9af6dd9fcf94a2754767673edf83ba5fcb74d704bf954015c2c26b24c3b8c766a5e66f76b47688bfc8d84adecbeca41f41ae92496ca399033740fe753f54b8c35084815a6c07f16f61907ef5745f4a5d94ea2de53f8e364a15e6b6f36d43274ade41aa0657f5464b852c4133e67d9c73b8fe681b49fac00cfdd439366e26d31ee688fbda787b94d1f97337be345f87e563f11ffbd9f219ab1889dd8abfceef5ac897a2158cd6e65fa9738270143107d6195b33d7ca3ad530a1d05fb5b17a67cb8f62edd390e5bda8d90ece8c79dcfc85b571eeb475fdf96b601f534536d7daca9ff288c6f1d22766dd086900e01e563dc96ab764fb78687970c21cc4974c159d133d5899fd366f4ff8a00691074a4bd4c25e25905663916ef86c29079f6306bf847a67f7f5051a004f30167d50c6a3d1d94b49a26b7a3d0f7334da0079838eb79e7a5f7f416acfeda2192e43bc0e391eb7cb1a12810f5961c5020e3c18f99e18acefdbf5f5b90470226028eb831bd1739324b4dea4c84d787ac78aa0ecc071d6a77819c79990838b769427f2e401b4e688cb8eb962f53eea7e291238e6e28a81072e176de3d9eabdb0a1876613bb0a6a49d0ca6444eaa33fcda09908e9242d127cec62b64ca6ca23a906028191bfae9f0a3957c383a1a52d3d97c0ab3cea3a43e028ebea5dc474398c4e9cdcc4643dca947452d1e3a8c3ba1f1caa2f29c42a6f87da10596ffa09aea92e747ffe7d0007d034fc06cac216f0aca717949d139fe8397f29f54701a390c4e2fc564c6c1092b1b09d94367751b0800cb13c06030d77957e460da7029af2cbf22a51e29867123fd26fecbcdb48cf5eff8a32e3fd9385bc2afbf951beb9f4dacd5f1d97bb659ffe8225ff235e472a2e51ef2cafdbfba7ae921ad7a13d4af862144d31a74d58ad9b9cb98509152214d47df7180072a52441d94720f531113cbbdc068642a87f5c430d9103d1d36ab341d8cac98ff015507a232a9d63dc7175ac428baaa10b5798e0f90912bd461761c0d00614dbd2c98ed3899ec42b28962c8a30069bf100a22905156aea8940e66f963fca1ec02886da6147fdba2cfc66be484c1b486114988e8def18576bb92777d11494a9aa4ab12c26cac966750aa2e5639902667b945d509d25842cc260ee0efb5dd337292ee932c2598e25ce73f73b62f5be5200e74c347468cc7a2459de6a407f9add47f17518e2cfba3e976cc449b062aac66f2c0569cae0a1404d120ec8007e7353f592f138e8c6a3e7babb98ff73cf6c149036771c42319ab889822ef528c7944600071f13dea99f3d57df4894f27fa1882ac9f4f32950a14f0484d7470dc1bfb720cbb651fc0e51e950058effaf243b698663340c7554c14906eb10f806e7d31f8bf912ad104360fda7027a59ce9953448538bf23ebeb5536c1679b9f7f79e1e8eafc147e1231b8e14f4777f12d15c9b08683c91024ff2e01f98be0bae2c262552869ea621eae1556e499d2870a5c736364103dafdf47fc77a61f93f792389984055c0b8b5da40cf280c6cd132b88ed95955ffd8de5a705316cf2ae5ceddd8953e6df3ca009b0c5c67d0eb8311c15ce97ce02f067dc6a05444bae4d19ddbd2f93ffcb96a42e0223ffb839540b0f8f1dab8c08a47e398ef28348f21597c6a0011d71ac050e9604332125700823b950211ed0e9d28b5cebf64f7b15941e07377b04d061471918e8565dcd11b6f07a304b6860803553fe25065f21e940caf82003f1f5bcce082ffdc10bab7be503e71d832d77f31b7dc594ae1cce624cef2f3a918c017a36b2fbd74989632aa24bd4ea5e81c0fab473c28164375de5829d3a4c394a2cef1d3ce178e76b4c1aac73df5a462894a6d7582b07066c511ff5bdafe23f1f380ef8b2aed8525de165373c06a9663fe8162bf487009ec690137a9f4226db26094aaba2b39efa8a5e10987681e55190a3a61dc9e1d865ff946165f378cee366825721d9c536ed985e6ee0ff206bcbe2f23f253d94695ef8810b19b51031e06de4e6f18ae7cb82f4b7ee68e9a54c850dc706e99b51d871e89c5cb3fb6a9e9c90762f437edb11670d66ac07937f316019aed2426ea82cc73335a24c1845a9683a3f250b95f79316231370598781ee3cc5a3a10b574dd067928d89830847462b1f91020c9a3dc0d1332f49be77efcd18f14a6b5d3ee85c96c5098e33351b4af5cf8bc2ed3ee296ecf391057130b7e4b8e33213615600b3ce15b628a99535a22940fbacf4376651017abd461082f32af78baf941d5da55d30d403cd4bd3464550e81f3b2245e404e3aca506adce3205d97aab271c992594e76e55aedd69bd2cfbd2d646fc7d2ab0e585ab06335962c7bc4967064b62ef4747ea477189b931824c18920a6e456e1af5e4bd3fe15f678ee03934f4315ae1b7e576fcd3d7275b2207644abd59a173f4dd66d68def20257578820c2d446661cffa0104c9acda08d36f0e2aa8fee67c20854cda102e9b63667104286e11278a8a340264342a51030f89cc047f586b2dbffcd29ac2f8912282d022b35c20723b0ae7ab18278305ece8e6ed7784859b6100743f6c3874a6813ea9d2ad507e9811ae780c3acfe1531c7be180bce82b1d777d9b060e6d41fa8c3e76e43862c77a630dd7f55bd4f7a3cce71da38a4bb673b88335ef5724d8cd59bf414df7cc5697426fed0d38cee91243a0571a74a22b9f8fe77079ee415ed17f82ea78a746978eb57d5ac5b01ee1556172fee235f4704ab4006a0caf56750d3fd72d0f4fdd30d266d92f1efe5b8c8d74b81197dd7091b900c0ac700f1fc4462eb5890e4a31d1d6003d2251153420019323660a71890f6e5285588f704a4d175be012a8f706ae42ad3b4a8f2ca4b8b128e4240393012564a6a06fd3f6ffc7470d485dcc8a99fb92186fdc8f7baec952cff401e48b449824193c73114753db2134cda83e5052af80308daae1407b448a5d1d300c417e09e4bf079a3524351b1dcd99b9b768d4eb3a19225056cb5e89c8cb258a1b40dcb032dcc1711d979ee7bd5fb9fac8c82574f57d10e7ae8648b06930714aeeb0fe29f5db88e8e39e51e8a8e892cea84c5049a137406965fac7b222fdbde7bb9c12b835ff4fb587d3370b9a6eb988ca04c8d82abf1d86ab35a571c318a284cb0f3a8817fc881686b1b9e5fa574e69d55ca271ad6f3308a0ac47a6f62dedf9cf6efa3bf081a3e384f48eb95c6a30c818df4a3dd2b698345323ef2d114b960f7b32168222589634567fa31a0dc1e08066047c2cd0d64c4fb70166c922a64d24a816075f0cec7eadf7dcd6bfee67b767c14aa53b569d35f00bbbbb7f92295c4e6ed3f790d2ee7865b7b33ba65fbb1b82e673f1016bba5982bef4cdcc5e109a4a7b5f9169c4b86d140d2b3c79f5529c3eccfb70dc60899bc612db8decc0ea4783dd839faddd0baa05781466ed168c8f1f7e582b24031a6991829d990c828413b8771033e3305489f06ec5a8a25c40c563be5a128467e204a186742713274f42d9d4c0523bdc26f30a1fb6f021bb70a833370f11b93c248270071409d3efa8bc83ad10b40d4b17404f96124f3ded698f9c3c65dc88045caddc063b195d10db10a3dfac1d1b2960ae35d602c2e454ceee12a658f4497bad153c2465031fc546de7bf0ae90e7457f7ce7f69642839e80a5ec8cdc2710f6141cfe6fce21fd28efc3fe15c0d0d8c5666af571c776ee5a1a18dfead4cac7cf3b549bc8fc3913ac87b2c96817e52f307be4017f79663108627368df7e8270f94238abd778a57e98a758a5697a14daa4f1ff5915ba9d6f3e3255c8dab29ad87037d0013b1e255dc86bf524ffc0dcd6845242dbd01bdbb9fef1ca1c7f077ab771f5a0acf44751d1995d6b1f590ab6067cf87af61136109002f9d1dab7fc23bab7782db96b07ffc798aa53097b5af9fc26de3ca80e08a06557539006d1da6dd2c88a5fa78d4b8a43d3213e6bca3f06ab31ba17edb0ca866bbdd7bb9cdeacf6d0fdfd5f09559df602443639d6da1eade2752f416f637b15a842786a734dacf6d26257c9f2996ddb24f62c1d3457de0ff5e2861f1f110069140a413dbaf4d4a95d7d3655ab8062c177e5f36478d6d9bf9655bb579d999304080f1d2190dfb21eb89ab79c68156f6fc694114a8229f7b40d06e70b41b3d20a308adf39666d507ba722e5a44e30a2a80c64c9ad620d1b82731ecbaf87f839fb5480d3297cb1c02a8614acb50c56faf3e15a033a0db9adf6ab44da455c3b5751401beef4a2045aee8c34b80f10e6f7438854b1b51d7bdfff7f9eaa25a9d345d7689dea4aa6c0eff8b55724bdb32c124d14a3400070f2db79ae4325acdb233a22a5e65991a3b479691300fd0f4d53133defbb41252ca22cb4b3efd37cbaa74d611f4fb24f464f80f81607715292e9afa6662d7409a987388d66ac99260c54d5dafc0dc5e96bf190e4e22240c3ef6f48895c3c918fb74d069835ba2a3397401eb105c957dc9ab5adbfa107d806bc04059441f759b2fce61a9e19f885b216066b2b14e82407810e5c2a81b61f377c232200799df4baa81af0317a360afa08f055c39cfe6b4aece0867d02cd2deac8e475ff15805b846ceaaf5ab2d67c50ff086be37d15dfb1347ce1ef4fdf53a6fa733a0108cfb342ff27e37c529d69a32fd3c39561234c0b6ecea95c2b5b47c8d34eaa7c4affaaf3219971d651380d1fb5b9939444bab86290c198cecd7ff32c420549147715386730e042446c4e0af1353d88831e67d52186507538210e3209772e48cec5158a4dc709386cf84a815ed65d9a9541c632ae9363b560b12cf1c984a3c68b544f5cf113dc9f5f617f0e43c8c200ee4d2122702ffe220133f7f534475ec84fcea421e3a93a363fb98c7ec65aad920da8dd7b551958c3b94d3df26bfdfa45a644399892fa50580c335ac0aa9a437ef4292ba3f74603439d55e0e3c73e4f8d07527272fe262fc3992fa25afad8c7f3aab2ab0392b27042405466bb93dfd4c9760851067f2ea7476ea4d3a3f494c5941bed0ac33cb62d7f331a2010e7b9d9ac7c71929d3bcc21a4a639ecc1d3cc0ba90e9f2ab68f2a365a179eeea0ec32085d96daa7c2b7b6ef519f275fb855d2d8c8089489abbb4c8998a4b59949ea4cddbcf507f5e59b851062ee589b4d2f56fe2ac1d8c048a6056f1d78a1f68038bc62e5b841b0f641fd440d4b1c9525cc3189104c011998b242cb6c4733672aaf2470da98847df09382a10a35827c345eb13182f6c1318ee28e40f61098d9d820e8f3775aa76fe9e3d847c739b712021d29051ff9bd6a0fac0e4bf00ae49d7b12c25776373d32303d3176e8f8c5beba28cb534302d73bc47f0cc89011b99d34f1b3ee37d450ca867e8b9f1acaae006b794fab18417dff1bf9f3151d50bacc52f375d3c2c0c9138aeec798b8e15e5beeab6bbc0441db94fc99eb8a390c6eb1a4bbabde29efd4c6222795308e737253e04650a7ac98145c8abf8226174474e87bbe8684f53a3e06bbb0dec52d6f3b6e11892f3e35394bb41ab6512ab5c53a620d8ed80e8c8c49abf9dccec239e36d811a5ce392010e60267bf2f0a360688cc3ce027a4fd9e7c3a6d09182a14b449e753ce64bccc4f56654a6baa324cab4bb35be719f4395f00616d1da9e77f77bfd1cec257a5c1d4fd3a727feb686dd911fee4aad98df2afd3f5fa688b51fb47a6e1afab089a9faa2556f57c132af5a0532ac5252ef1f4bf4eceaa2b6a47118e78a2190f5cc5015dd3612177e3a48c67cc5937dddf148c68dffafed2d2a4e7e189d085ac949859a50801759123bc9cd7cff17d269ccbde96aed8a3aa372f05d8e5beb8e3c607f650106d59b567a6f22b6e0fb8c83c0991217a1ead21bdb758695d4478f72f2b5d7c31a788266c65606f3ca552ef7cb45f7cf166005100efcb6dbe514ef23af96f01372df9240ebf920185a762886188a267a20f0f3bffea1dd5a5a4be2bcfae5f9f977facb27dd71e784a19e20d1142fafa22eaeee89e0580b86c946e16c9fee077073276bd7f79f0ef0b083b604083ef1d7766989760e67d99bc4df4c7ad2c378b9175938f397e331284791d17c1e3f22f34eacfd75d07e7821165b17be9d73fb97fc0285e02162d0a13cf0d7d5cb9872b4ef360a385f3766375f77702b6aa16ad90f9d738424cf967eea8c448ea15ae1519a83c3801edc45121179a81fcfde098005b7c270373542b02fe6118cadfe646481cd6ee343f4a8110645f5804185033e5b38048c5bb295b0d5e9cd365dcd1522ccdbb867ad5a4cf4abaf40b0c0de13e9de6c15ba8ed05f7fe1fe0b4895237e3732ad5e71998d240dd4629c6b8666372ea00c6401b10cf2c9518b49ad7b9c4c956df69350732f13f3038cc730d59f57897431827a1a6c65ad1e5657ca48171f8729a83059337068ea2baf0b1f6749cf4f2ccc0cb39f0eadac38153aa2ce921c78926380483902bee66386cd79478e6cc16ae8d65f548a543ad058b0f71978b9a9f021f9ca6cffe9e271b72f3ebc25b4b4bafcc58140748e31e7423023453d25ce7471b82a3cb9a09fe6870da78e34033f4ea9e250d45269d745f3d1d42279c5efe4ac8a0bcfbaf33a8a8e6d69c8919bab0714a45102099b279bceb1e2a1c24cae631563163725b9e54b608c981d42b4c5f4fe253d944cc7a03fa7792eb58ff17ed7a1905ea99b8d3e4a99686bb8ad2e988d2a5647e1f16307fe8651c3b0a485d70614eff2524136baa27c8fa02e0761c3b48da9f668b0ac1c8feb267b1382676996e7ff9eb6cc75dacd6fcb15d63889f3421481d0b52cf60bce76fd24eeae2a15c9e3390ea5deb67c86021164eefe8ae02d9802985933e3f6bbe25a9a6f57cb1f8c2445cb3ecca91ad446a26cbae57e760033ae7329399fbc681a811718d6a35de56af1f8b982b56294a18ec5a7e1b8cf6d75dc9f31d73bf8673ffb5d965374b4ca9198674ac89ed5aceeb3af0b79f52a1093761152f1909e2b6d20b18de6ab98e6aa4b54ac309d09bacd48601c22fdee1b0161079c193dd8d3c80098522b15c3292d45e636b91859e045e1d0fc9202788acd3a384953660d26b74f1763871a1c34100c7b7b106c09b6ab73cd22725f8087fd19ebc50834e9be6404f3c352b9c1cc77ea98183afd984953abc916705ed04ac52c6bac594b7daa269b3cea34099772fbf30d27b490b23795ce4dad46b86524044da88111426b6f0fd002875fbc42dea2f14bb477c52b6b4e53d9d2508058c9f26f15cad7f1efe1b399fbcdab1a19f3c6d39dc3b5f3c54b2e49e5d5bacc9e58cb86c51e2b74f65e0579d1a22c19403d754c5cf4eb2f6b9f870ba0018a89773c5a798dec5accb37d1d95e26674b51bdab32effa33c14bb94c7df4227f0b10f96a104b3a271af881281f32b64d0108028db98433b74dc86c23e0bc6ebf9b594668eb239e0823be3d966df937d700313d38d68cfc09db243d24d01b5115952cff2c904013285d1eaa93498f65cd25823bac3690ea1613e1b79918f6550cb9f779475815b203a1c6c0aec7389848883df5080442094090812526d5cc5cc9526b57c4d6c05c35f49ea8ed31b1eab13632b53e7fd1ae6486cccfd0f12a29c0cd12d26f371074c6212346c0d3496e17f43cef28c471f27efda27885cd5fa987948a77589844990175491d745b49b857c8284c62b9de5a89da372a101cf59b1de135c0fc0595b49eec50a1d83e44ccb8c3d99acf07fd41476916ef18f32b84551947a9d19269f864d4dd5192fc3525b88529be9a6f097f8e1625ba7e7a63a2f7eb1f567ca5bc62484717f87e0670b9cdd50a6dc6daf0acfbad251e751d6d9594f488541d4e3df05d0de1ad8bc32a21c704bd2de53f20f3f51df46d67641e139fefa1ecb10bf39fe64331152816b8ad6261f12afb872d6ceb5768b52fa235a71fccd73c3500c50c171407406702743ff8d231d6406d70836813c42c4fcee5703bcfd25fff475a8f648cf87a31031e04e656d1c2b9349d780e5ef17d1d354d9399f2f669fc25cd0d49c02376d6ff39314e254af26816f8c3b458499b577df2d941be0e11ad80d0ee2122588ecd71663c4ac26fcf0cb0944e9790b785d015686481e79a17dbfa9b6819fd0e13aca6f98be25c2544294b69d3d895e5b3ad436c51d896091d43b62b5df9de2d78c4c9e7ce780e74a5c222863ed67ebe99f76936950e3105b48620bebef1ba4c63b3b42df090873cc2e209a4e58ecc28df72ecf6c515598fab7a41a01678f6e1b9813f6a992bd7955aa954de54c0e080d66b454727d685ff44e6414cd50cd30b0b79a8104588c3f84100c765cd9783daa987d6ed2ee2f612ccf70bc76a151eb5fbd1cca51de262a790f2df71a8e160bbdaa7bf6d865c2d70d9e9eac47961a6bf9a2a12bd1f9e64fe9499de5069880b38c9ef9b49a67100123616eed81c1d66f4f0770a2d83220f1e815199e66bdf58555d52afd67a4d9d385412c4e685cd6629d2a9db947072b7712cd86fb84b944a27270d46efd74f099f4e689742dd09c04f2457791ac13bd6326263d20700f66cb7198347360cca1917dcf60b13ec63fe2aefd3999581dcfdca8dbd050967de6caa2a43bd300f99357ed9b01d80d22bdb7a26fe775c300c9fc7239fa8eb3f38fcb3ee67eeb16ac55a5d49ae7034ec55d32ea7165cab9688c91c28864e6d30c67dad0f5d95ed12c74a453176025a0e0b812ad3456102b5bce998066d47f599443ed0c57ac5b5ba9d7758ee3d7703fd833d7987f376ba7f23454dd4a0b7fb6c197a1b3786631f4b928c9b8327a60faefed546c05aab6fb42385e52b3edd579b555d2ae500198ba726c241b8e0b66898c188f9054bbcdec5e613c30228c72784b6ff62b3d976c308ebf3c063ea3dafb8a3623e341a8f2fefe395fd64c26f7a5905555db41ff050552ef0760c8c77238a8aa952a0bb8a623d1972fd0fb3b87fc5ccd10f6f70ae69ffe2e4421502882fc037ec0d54c000ae715418672392a5e32d0d95e5cc991682227525ce8cdfcdc9681d8c3f5e9200d5abda60579a7313fd6394ed1437700a95b9d88c36e4f873f3392f231bb8580bf139cb2f27dfba58b60079fa84f7d58b88a411f7b7b8c8dbc62092a4732c2f833ded758178f4fc7fad13a8056d6a9121086156d17ce51da1bd713ea94670063c413558a5c0467e1a072c473a29669fc76d7bd5f6324331542c58b059c9cc1074ba6c618394bb55a74e2f2cdc80dca372e4f911998b01234ac2d2626aff8fbf66c3a28f5aabcfa914e29b3da1c98f5115a735fa4b093d68df20bfae5cd20b4ab2ede0f828d92067f1adf5a4e36f085d24f25096f6a884a46fecad879517260b26eabb5803a2977b8f0ef6439984192700b69bc549ebfca15ff35142e54ed253ff7e5189a89bf33de28ddb95a40cbf8e89fbfaae18c11b5e10fa4a9b252df66d1a3fe4a41b14a61473dfb70ed6ab7367c383a33f81e35b40e2b3c4cc9ec45bb18bbf2f27073261de7c2c1a408eec6fb836646f9e7cebbed3acb38c9c5cee03dda20e1598a53a9f5d250d67845064e4fdd73e2d4675f9101651c171ee4708d3a9f7b023ae0a6a59606ba59ac95680988ce41179bbeab</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">年级大会，毕业相关事项</summary>
    
    
    
    <category term="⓽ 其他内容" scheme="https://blog.slks.xyz/categories/%E2%93%BD-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS系列——DFS多种形式变体整理</title>
    <link href="https://blog.slks.xyz/2022/02/26/3e00524469fb/"/>
    <id>https://blog.slks.xyz/2022/02/26/3e00524469fb/</id>
    <published>2022-02-26T03:06:19.000Z</published>
    <updated>2022-02-26T02:48:09.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-080.-含有-k-个元素的组合"><a href="https://leetcode-cn.com/problems/uUsW3B/">剑指 Offer II 080. 含有 k 个元素的组合</a></h4><p>​ 给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="解题思路">解题思路：</h5><p>​ 该题是最经典的无限制的DFS，注意剪枝来降低整体的时间复杂度。</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">permute</span>(tmp,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> curr,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//curr代表当前 轮到的数字</span></span><br><span class="line">        <span class="comment">//count代表当前已经 放入集合中的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(curr == n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                <span class="comment">//这轮完结了，将tmp添加进入curr中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历两种情况 ： 要不要这个数字</span></span><br><span class="line">        <span class="comment">//Case1: 要这个数字</span></span><br><span class="line">        tmp.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case2: 不要这个数字</span></span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-081.-允许重复选择元素的组合"><a href="https://leetcode-cn.com/problems/Ygoe9J/">剑指 Offer II 081. 允许重复选择元素的组合</a></h4><p>​ 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>​ candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。</p><p>​ 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-1">解题思路：</h5><p>​ 相比于上一题而言，该题允许重复选择元素，大致框架类似，但是在DFS的过程中，分支的选项需要改变，同样也是选择当前元素和不选择当前元素两条分支，之前无论选不选当前元素，下一轮递归的时候都会去判断下一个元素，而在本题中，如果选择当前元素，那么下一轮递归还应该是本元素。</p><h5 id="解题代码-1">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">        <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-082.-含有重复元素集合的组合"><a href="https://leetcode-cn.com/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合</a></h4><p>​ 给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>​ candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">    [1,1,6],</span><br><span class="line">    [1,2,5],</span><br><span class="line">    [1,7],</span><br><span class="line">    [2,6]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解题思路-2">解题思路：</h5><p>​ 本题跟上题不一样的点在于：本题每个元素都只能使用一次，但是可选的元素数组中会出现重复的元素，这也就意味着如果按照正常的DFS下来，是会出现重复的组合的。此处，我们按照如下思想来处理：</p><p>​ 我们先将它提供的整数数组进行排序，使其成为有序的数组。</p><p>​ 每一轮DFS的时候，记录上一轮有没有选择元素</p><ul><li><p>如果上一轮没有选择元素，并且当前元素和上一轮元素一样：那么该轮也只能选择 “不选择当前元素”，原因是如果两轮元素一致，"上一轮没选这一轮选了"，那么势必会和 "上一轮选了，这一轮不选"，这种情况产生重复。</p></li><li><p>如果上一轮选择了元素，那么该轮就可以正常操作：可以选择当前元素，也可以不选择当前元素。</p></li></ul><h5 id="解题代码-2">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr,<span class="keyword">bool</span> choose)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= <span class="number">1</span> &amp;&amp; candidates[curr] == candidates[curr<span class="number">-1</span>] &amp;&amp; !choose)&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-083.-没有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/VvJkup/">剑指 Offer II 083. 没有重复元素集合的全排列</a></h4><p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同</code></pre><h5 id="解题思路-3">解题思路：</h5><p>​ 本题跟直接求1-n这n个数的全排列是一样的思想，基本就是每一轮确定第curr个数是什么，如果<code>curr==nums.size()</code>就输出该种可能。并且我们需要一个<code>hasInclude[]</code>数组记录，某个数有没有被访问过。</p><h5 id="解题代码-3">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-084.-含有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/7p8L0Z/">剑指 Offer II 084. 含有重复元素集合的全排列</a></h4><p>给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-4">解题思路：</h5><p>​ 084这题相对于083而言，就像是082相对于081而言，多了一个重复元素。我们就需要排除重复的信息。一种朴素的想法是，用hash表记录每一个全排列的情况，然后每产生一个全排列就去Hash表里找有没有一样的，这是一种方法，但时间复杂度肯定较高。</p><p>​ 比较优化的方法思想其实和082相似，也是需要先对数组进行排序，得到有序的nums.</p><p>​ 我们在DFS的时候，如果当前元素和前面元素一样，并且前面的元素还没有被选择，那么该元素也不在本轮被选择。原因也和082一致，如果前面的元素没被选，而当前元素被选了，势必会和正常流程中，"前面元素选了，当前元素未选"的排列造成重复。所以只有当前面的元素已经被使用了，确定好位置了，后面的相同的元素才有机会被使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !hasInclude[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">//前面元素和当前一样，并且前面的元素还没用掉，直接不选跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-085.-生成匹配的括号"><a href="https://leetcode-cn.com/problems/IDBivT/">剑指 Offer II 085. 生成匹配的括号</a></h4><p>正整数 <code>n</code> 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><h5 id="解题思路-5">解题思路：</h5><p>​ 这是一道比较有趣的DFS的题目，DFS分支的条件比较难想，整体代码较为简单。</p><p>​ 要想清楚，为什么此处我仅用两个Case就可以完成DFS分支的遍历，在最终输出的时候又做了哪些操作。</p><h5 id="解题代码-4">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,n,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left_curr,<span class="keyword">int</span> right_curr,<span class="keyword">int</span> n,string tmp,vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left_curr当前加到第几个（了，right_curr 代表已经加了几个 ）</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right_curr;i&lt;n;i++)&#123;</span><br><span class="line">                tmp += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 仅加左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr &lt; n) <span class="built_in">dfs</span>(left_curr+<span class="number">1</span>,right_curr,n,tmp+<span class="string">&quot;(&quot;</span>,res);</span><br><span class="line">        <span class="comment">//Case2: 加一对右括号</span></span><br><span class="line">        <span class="keyword">if</span>(right_curr &lt; left_curr &amp;&amp; right_curr &lt; n) <span class="built_in">dfs</span>(left_curr,right_curr+<span class="number">1</span>,n,tmp+<span class="string">&quot;)&quot;</span>,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含几道经典DFS类型的题目，难度都不是很高，可以用于练手</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="DFS" scheme="https://blog.slks.xyz/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图系列——重建序列</title>
    <link href="https://blog.slks.xyz/2022/02/26/16bfad4011e0/"/>
    <id>https://blog.slks.xyz/2022/02/26/16bfad4011e0/</id>
    <published>2022-02-26T02:50:19.000Z</published>
    <updated>2022-02-26T02:57:50.418Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode-cn.com/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h4><p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p><p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 10^4。重建 是指在序列集 seqs 中构建最短的公共超序列，即 seqs 中的任意序列都是该最短序列的子序列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3]]</span><br><span class="line">输出: false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= n &lt;= 10^4org 是数字 1 到 n 的一个排列1 &lt;= segs[i].length &lt;= 10^5seqs[i][j] 是 32 位有符号整数</code></pre><h5 id="解题思路">解题思路：</h5><p>​ 本题与<a href="https://blog.slks.xyz/2022/02/25/4e6244e39183/">[外星文字典](https://blog.slks.xyz/2022/02/25/4e6244e39183/)</a> 相似，都是通过序列seqs获取拓扑排序信息，然后依据拓扑排序，观察是否与org一致，从而达到题目要求目的。具体可以参照官方思路，本题因为已经过了一刷测试点，仅在此记录</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; org, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 边集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 记录seqs中的结点，可能有不在org里的这时候就要停了返回false</span></span><br><span class="line">        <span class="comment">// org 是一定是数字 1 到 n 的一个排列， 但seqs很自由</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>; </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 不再org范围了</span></span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">0</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 记录出现结点数</span></span><br><span class="line">                <span class="keyword">if</span> (++nodes[seq[i]] == <span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                edges[seq[i - <span class="number">1</span>]].<span class="built_in">push_back</span>(seq[i]);</span><br><span class="line">                inDegree[seq[i]]++;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结点数不同</span></span><br><span class="line">        <span class="keyword">if</span> (cnt != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 用队列和栈都可</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 队列中有2个以上结点，就有2种以上可能不唯一了</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (org[index] != node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            index++;   </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edges[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[edges[node][i - <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(edges[node][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，图的综合应用。一刷已过所有点，只是题目比较经典且综合，里面也有一些较坑的测试点，值得二刷，故在此记录</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="topological sort" scheme="https://blog.slks.xyz/tags/topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——值和下标之差都在给定范围内</title>
    <link href="https://blog.slks.xyz/2022/02/26/994b03ade281/"/>
    <id>https://blog.slks.xyz/2022/02/26/994b03ade281/</id>
    <published>2022-02-26T02:09:19.000Z</published>
    <updated>2022-02-26T02:22:32.934Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-057.-值和下标之差都在给定的范围内"><a href="https://leetcode-cn.com/problems/7WqeDu/">剑指 Offer II 057. 值和下标之差都在给定的范围内</a></h4><p>​ 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。</p><p>​ 如果存在则返回 true，不存在返回 false。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 2 * 10^4-2^31 &lt;= nums[i] &lt;= 2^31 - 10 &lt;= k &lt;= 10^40 &lt;= t &lt;= 2^31 - 1</code></pre><p>参考官方题解：https://leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</p><p><strong>解题思路</strong>：</p><p>​ 对于序列中每一个元素x左侧的最多k个元素而言，如果这k个元素中存在一个元素落在区间<code>[x-t,x+t]</code>中，那么就可以找到一对符合条件的元素。<strong>注意到对于两个相邻的元素而言，它们左侧的k个元素中有k-1个是重合的，所以可以考虑滑动窗口的思路，维护一个大小为k的滑动窗口，每次遍历到元素x的时候，滑动窗口中包含x前面的k个元素，我们只需要检查窗口中是否有元素满足要求即可。</strong></p><p>​ 此时，问题就来了：<strong>如果使用队列维护滑动窗口内的元素，由于元素是无序的，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。</strong>如果数组的长度为 n，则使用队列的时间复杂度为 O(nk)，这样跟暴力求解没有区别了。所以我们需要一个数据结构能够来用于维护滑动窗口，该容器需要满足：</p><ul><li>支持添加+删除元素</li><li>内部元素有序，我们可以快速判断是否有满足条件的元素。（具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间 <code>[x - t, x + t]</code>中，只需要判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于 x+t 即可。</li></ul><p><strong>注意</strong></p><p>​ 如果当前有序集合中存在相同元素，那么此时程序将直接返回 true。因此本题中的有序集合无需处理相同元素的情况。</p><h5 id="官方解题代码">官方解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">利用滑动窗口 + 有序集合的思想，优化一道数组系列相关的题目，加深对滑动窗口的理解，不仅仅局限于单一形式。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>图系列——外星文字典</title>
    <link href="https://blog.slks.xyz/2022/02/25/4e6244e39183/"/>
    <id>https://blog.slks.xyz/2022/02/25/4e6244e39183/</id>
    <published>2022-02-25T10:11:19.000Z</published>
    <updated>2022-02-25T10:16:13.611Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-114.-外星文字典"><a href="https://leetcode-cn.com/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h4><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 "" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p><p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p><ul><li>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。</li><li>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 还是比较容易想到 建图 + 拓扑排序的。整体而言复杂度较高，但是思路应该比较清晰，主要过程就是分为两步：1、建图，从相邻的单词之间获取信息 2、拓扑排序，得到结果。</p><p>​ 其中两个工具函数比较重要：<strong>一个是常见的transform函数</strong>，能够以O(1)的时间复杂度，用哈希表给每个字符赋予一个ID，方便后续进行拓扑排序。<strong>另一个就是getInfo函数</strong>，其接受两个字符串s1和s2，已知s1&lt;s2的情况下，返回一个<code>vector&lt;char&gt;</code>，第一位代表状态，第二三位代表其能够从中得到的字符字典序信息。具体见代码注释：</p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; char2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; int2char;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(char2int.<span class="built_in">find</span>(c) == char2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            char2int[c] = char2int.<span class="built_in">size</span>();</span><br><span class="line">            int2char[char2int.<span class="built_in">size</span>() - <span class="number">1</span>] = c;</span><br><span class="line">            <span class="keyword">return</span> char2int.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> char2int[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isVisited</span><span class="params">(<span class="number">26</span>*<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//先把所有字符添加进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="built_in">transform</span>(words[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; t = <span class="built_in">getInfo</span>(words[i],words[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) <span class="keyword">continue</span>;  <span class="comment">// 仅长度不一样，无信息</span></span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//直接不需要后续的操作了，因为已经违反规则了</span></span><br><span class="line">            <span class="comment">// t[1] &lt; t[2] , 构建图 , t[1] -&gt; t[2]</span></span><br><span class="line">            <span class="keyword">int</span> idx1 = <span class="built_in">transform</span>(t[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> idx2 = <span class="built_in">transform</span>(t[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[idx1 * <span class="number">26</span> + idx2])&#123;  <span class="comment">//用于记录 idx1-&gt;idx2这个关系有没有添加过</span></span><br><span class="line">                isVisited[idx1 * <span class="number">26</span> + idx2] = <span class="literal">true</span>;</span><br><span class="line">                graph[idx1].<span class="built_in">push_back</span>(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拓扑排序：</span></span><br><span class="line">        <span class="keyword">int</span> n = char2int.<span class="built_in">size</span>(); <span class="comment">// 节点个数</span></span><br><span class="line">        <span class="comment">// 如果图中有环，则不存在合理的情况 拓扑排序会失败。节点数不=n</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//遍历每一个节点，计算入度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于所有入度为0的节点入队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res += int2char[curr];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[curr].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[curr][j]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[graph[curr][j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(graph[curr][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">getInfo</span><span class="params">(string &amp;s1,string &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 该函数用于返回从字符串s1&lt;s2这个信息中获得的有用信息，第一位为状态判断位，供函数调用者判断状态</span></span><br><span class="line">        <span class="comment">// 0 - 代表排序有误：该状态代表 s1比s2长，且公共部分内容相同，但是却判断s1&lt;s2，调用者遇到此状态上层可直接返回不合理即可。</span></span><br><span class="line">        <span class="comment">// 1 - 代表有可用信息: t[1] 在 t[2] 前面</span></span><br><span class="line">        <span class="comment">// 2 - 代表无可用信息，代表 s1&lt;s2 仅因为长度不同导致，无法获取字符的前后顺序</span></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> min_len = <span class="built_in">min</span>(len1,len2);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;min_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);   <span class="comment">//第一位为状态判断位 1-代表有可用信息</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            <span class="comment">//如果s1比s2长，且在公共部分没找到内容的话，已经就不可能了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">//第一位为状态判断位 0-代表有信息：这个信息告诉我们排序已经不可能了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt;= len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">//第一位为状态判断位 2-代表无有用信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道困难难度的LeetCode算法题，图的综合应用。一刷已过所有点，只是题目比较经典且综合，里面也有一些较坑的测试点，值得二刷，故在此记录</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="topological sort" scheme="https://blog.slks.xyz/tags/topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>BFS系列——单词演变(困难)</title>
    <link href="https://blog.slks.xyz/2022/02/24/64f7eff00abc/"/>
    <id>https://blog.slks.xyz/2022/02/24/64f7eff00abc/</id>
    <published>2022-02-24T15:09:19.000Z</published>
    <updated>2022-02-24T15:37:00.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-108.-单词演变"><a href="https://leetcode-cn.com/problems/om3reC/">剑指 Offer II 108. 单词演变</a></h4><p>在字典（单词列表） wordList 中，从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><pre><code>序列中第一个单词是 beginWord 。序列中最后一个单词是 endWord 。每次转换只能改变一个字母。转换过程中的中间单词必须是字典 wordList 中的单词。</code></pre><p>​ 给定两个长度相同但内容不同的单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= beginWord.length &lt;= 10endWord.length == beginWord.length1 &lt;= wordList.length &lt;= 5000wordList[i].length == beginWord.lengthbeginWord、endWord 和 wordList[i] 由小写英文字母组成beginWord != endWordwordList 中的所有字符串 互不相同</code></pre><p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/om3reC 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 题目本身还是比较好理解的，最开始的思路也比较好想，就是将一个个单词赋予ID（使用Hash表），然后根据邻居关系建图，在知道起点与终点的情况下进行BFS即可。值得注意的点是：该题目作为一道困难的题目，时间限制卡的还是比较紧的。我们来看一下上述过程中可能耗费时间比较长的步骤：</p><ul><li>1、在建立图的时候，要判断单词与单词之间是不是邻居，就需要比较每个单词和每个单词是否只相差一个字母，时间复杂度为O(n^2 * C) , n为单词数量，C为单词长度。</li><li>2、在BFS搜索的时候，由于wordList长度上限为5000，整体来说还是比较大的一个图，需要耗费一定的时间。</li></ul><p>​ 针对上述两个点，都有对应得优化算法，比较经典的就是用于替代单向BFS的<strong>双向BFS</strong>，可以大大缩短BFS的搜寻时间。<strong>我最开始就是做了双向BFS的优化，但是还是超时了。超时代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNeighbor</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">        string str1 = int2str[idx1];</span><br><span class="line">        string str2 = int2str[idx2];</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] != str2[i]) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,end))&#123;</span><br><span class="line">            graph[begin].<span class="built_in">push_back</span>(end);</span><br><span class="line">            graph[end].<span class="built_in">push_back</span>(begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//对于每个word均判断其和begin 或是 end是不是邻居，以及判断其和前面的wordList中的word是不是邻居</span></span><br><span class="line">            <span class="keyword">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,wordIdx))&#123;</span><br><span class="line">                graph[begin].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(begin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(end,wordIdx))&#123;</span><br><span class="line">                graph[end].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> wordIdx2 = <span class="built_in">transform</span>(wordList[j]);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(wordIdx2,wordIdx))&#123;</span><br><span class="line">                    graph[wordIdx2].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                    graph[wordIdx].<span class="built_in">push_back</span>(wordIdx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;graph.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[idx] + res[graph[idx][i]] + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ 针对于另外一个可优化的点，其实先前博客中也记录过，针对于这种仅差一个字符的字符串相似的情况，我们叫做“字符串的广义邻居”，在该文章中提及过：<a href="https://blog.slks.xyz/2022/02/08/4ccc50ba5a4e">奇妙应用—字符串的广义邻居</a></p><p>​ 在建图阶段，依据朴素的思路，就是像上面的代码一样枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以<strong>优化建图</strong>。</p><p>​ <strong>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点<code>*it、h*t、hi*</code>，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</strong></p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constructNode</span><span class="params">(<span class="keyword">int</span> wordIdx, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构建字符串word的广义邻居（虚拟节点），让其和自己的真实节点相连</span></span><br><span class="line">        <span class="comment">//例如 word = dog ，那么构建广义邻居节点 *og,d*g,do*,让这三个节点和 dog节点相连</span></span><br><span class="line">        string word = int2str[wordIdx];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;word.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//将每一位变成*，形成虚拟节点,和当前节点连接</span></span><br><span class="line">            string tmp = word;</span><br><span class="line">            tmp[j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpIdx = <span class="built_in">transform</span>(tmp);</span><br><span class="line">            graph[tmpIdx].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">            graph[wordIdx].<span class="built_in">push_back</span>(tmpIdx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将所有的原始字符串加入Hash表中</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        <span class="comment">// 按照最坏情况分配空间</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>() * (wordList[<span class="number">0</span>].<span class="built_in">length</span>() + <span class="number">1</span>));   </span><br><span class="line">        <span class="comment">// 构建图，对于每一个节点，构建其的广义邻居以及自己的节点连接关系</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">constructNode</span>(begin,graph);</span><br><span class="line">        <span class="built_in">constructNode</span>(end,graph);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]); </span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;  <span class="comment">//如果是beginWord或endWord就不需要处理了，已经处理过</span></span><br><span class="line">            <span class="built_in">constructNode</span>(wordIdx,graph);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;str2int.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; int2str[i] &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="built_in"><span class="keyword">return</span></span> (res[idx] + res[graph[idx][i]] + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，结合了字符串与BFS的优化技巧</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    <category term="字符串系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>则观云资源需求与分析</title>
    <link href="https://blog.slks.xyz/2022/02/24/8386be03d737/"/>
    <id>https://blog.slks.xyz/2022/02/24/8386be03d737/</id>
    <published>2022-02-24T13:52:19.000Z</published>
    <updated>2022-03-11T12:47:51.774Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="92a676e4bf82b4ce655ae5f31439de166224bfa67d2018f3a6874d694d565ab8">873f131ca1ff7e2c43970aa30a8cbe91558e1bd1b27fe5e295778a23f5da27616d05821cace9112a2c38b7c04f815fdea3db87b6c532f12ef5353821928ce95ac46291d124793317a1f1f9e02ad583463dbd72bc42dfcb0dde2aa116c317c374b95af43dc0935a8acaf6d034d929b1b7594462dcf6fa52d4553b14de2d3dd99ecc7bf7cfcfe66ae8227f5201a9b0126e951c2374f9588b69f2b6e1bf8d26c5470daa021e03c63b1e825c82cb726e502b8bf4865e61bfb182c9be8b992d2d4ecae5de513bb443eaeed4c1ea4f27ba47e21b9fe58c7382ba60b6f988c903c1ae425c57c4c5d583868a3089d70c066a51be942b2e1d3dfd12b50072ae4dab1e1cd122b16a98b0069b2686874c965fe50567aa0115165fc1ca8b81f85e0a873902fce98586721b39b70ae4e8d274587deed909ca01a60cba498eb87db0aec31ec2f5e5f6dcca1d5ed6780f161f04704c592a841b86cd31bcd6e418455b1558ded93dd06581723a84a4ba49a8329d223d19ceecc8ce049322d2f5e629e47cddfbeff725497cfa6498c0968a033b8fc81f9db4f44606928ce91ff31c63b3110a6cab3aeff483b580bf04b914f9da79e787ba3198e9a7e0cf4894fb492e20cd779d8de600ae5ad178bd6688972a5771ab2d37111ba213bd466b2374a3c26805179b4db8c01e31881c09c959e0358cc3deff75bc12e77efc791719c1cf14a04ed8f1fc6367af8511d0b8d8a1611e25e312c6a05d9b2252d24860514e891a8c525345e7d0be49c9ce48d80364e9ec7bca02aa3cc45045b4e94b3d68d988f79b8ea11ed962fac772fb31fcdb991dcdb7efcdbe65f92b2e7d600f238208b3385937c0fcba710c0c137b265b290b92a2e50ffe435dcb23f2eb35f008362d0ea1b11fe500af633a47fa783220c440f67937ef136458ddcaa8989b974c8281419d7a5bd5169bcde03a6f64d6f9108dcd5e57cdec12cfee9de517141001a79ad2d2cdcf031939d641bef46ad2b27be8c48bd0f29cebcc340076dd567f4d5ef0e7cf533677b9c3dd54003184c89a5ae13278ffb81ab042065214e0a48c1e6c9b3ccd155d82ac4c6a63c3eab2667c95780c35656ae31f83589fa4212a300d27a2005dadb3c19c78ab75658c0833529f47d49474baa2c3c19f0bdb1f612292a7c4cfcb9d7c010fc692b257f4d492a81c81ed28db371613550211f14ba52b58a01f8d19a3c1a74a4b7c9987f00f611059b7fe54729851c1cac332b90089ac8269cd0b1c1312ae8448242cfcb154d85e4f379910119d1c385b81298a76d706e6cc654eccedec5e27ff29270c21a57368275bd89b7066a2bc0ee283103eef6e62821a01476b0a5c27f3c8d16f637715b9827596af8970d74df3e2f7a514ee651f9a42459c89188f8f956f67fc778bd5205a06fee0197c73e56745d0a2ebc66dab2789eb6bd927502043bd05423d7067c8481d349302cfae8a15551fc1f79a4a8553ee8e2564e656bcf4b4edd5dbf5af1b077a6e0b1b2981020f0922a9a26dd8a547bb74b13d1718b207020ed0563835e6bf01c8f68ba29b495c0ad495d505f3ae34dfd71e31740db77328c1faa3d8d900b824ecfd5416c433d0d700ce548f78095f9134a9cffe30dd1aa3b4aeaa76361447df9afb81a231a33c721f74ee744ae85ed883865c52c7f8e1bfa2b7541d765baa36750faef20463697922be08aa9240a8ce6b80b67eb0ee665cb92020ace19a19ba4baa0dc98a72acfefa32e20453c37e475689befb16b1c047e2b7e52cb4d1af4da83743c2ce21ec89634557eb9d3b1e0839511a1642a419df0e6b72c6b5c1c59eec789df90f33e775a0128e4cdff0e453883b6f8d2cca077a699d29d8da9026d46680a2d37165dd30bd02b5de4266fb7f3c32de224b7b1874e41a48d97512cb003f1712a26b13d94b2fdb0c004d96b664033d979f38c17166fc10c5ac6d1437239f8d611081b541dcb4db6f1e0a24fcc9f89666efccf5489505a99714987c0864e07ceef35de5d3ee84dcc5b38e6c597ed9beb928e9f166d7890698337575cf68793bf2390450826ba4257e801a55f06bda72cad153d6979b559da47a157010945f781f68b898b096a2f6579b1c7af14731d4d56b87ee3d07f41393c1466b8c0af3c72dfd0491b1fd5e9aa02b30f67780100939a0ce49a7074c92103cdfb83cda5be43ce6baf0c9e68851ef68dd9a0f6bbf84343a919a43ebb81c29ea4a989a5ac1eca1224e9ff2d359b10e2e2c4dcdb5bdea7affe21ac86378640de6629ef9426b739c9a21f0b27169babfe159d4335ccd4d9dcdbf457bb488bacd1a50809a2c55f24ec8e14f29b45fd9ba94212c5f2fb75625a1bc0008749771c952dbfe0cefa46803da0f40b2b65d73af109ba08795412e7dcf5b1d67b33868877afa5c15231f6f1faea4c2f165cb699aee503b83f3161bbf1e40d933b588e30f776dca0a65fcccb46b82b0a3c74abb2d3b8b85355fca879b4fe4bfca44bbcfc0f33af54a3e73350c0c78e5edbbb69f18ffa62afe1a6cbba26a7853eab94456fb8f4502fd6b0f5989cd8976b5ea73784311798608edfb5d42901fbd4234b050aa8736f6446a4ada332d4d680df973f816fecff2b0cad0720982471482a87583c05b0704c0dd7985910a4c0cd520238304e0f010b6640831f4698226f6c69a89c716c429184ff9de624211214fe617d7f75c723fd95f38272614817abf97c7c8813f6c2ad13b9374f58070c7be87bef0857ea5c643bed7b8e04dc9c4dbe7cff866d20102bef69df0e063ed4dd7bfcba78c57d6ee3a2d0d35ad4e1deb66d0a20394daa2e4b513ddbf1da224b1102cbb0c96ae634047b374bb6fa757722f40e6a4c132efb4e18c203d9ad2efc8e021d8e5cac3fb94fdb664171b5da57161800650859b4a47eb66450cdb50df7ef29877529905030821faecd7d1c73b772e782d86b659005aabc848b56a5f2749e4989786b2e0827e864b9cd6fc554b5a4b5cf346b5b5dfb5a83e74d1aefaba9cbcbf4cde7f22a4dce57c4a45a86f5c49f1fdfe1666771871bf5fae6c1f02b8526c27facf71067318ddda88e722acbd99fd631b6623f459edceecf24da5a9bf53519d4f3cf7b8bb3b6613ae862c585ccb286835363a574206fdecdc64b64240d4063af3abc9a1baf0b715556e7f4913a79da06d8d54554acc2bf0112fc77d402a5544d3bf3f3828d746b82c13983f74b398d5065aeff96a3eb6c039388f7b1c4c251b86c2d0bec7bc29d175abeda5fa0b414085d54fd9dfa96a18fd4a613806f5759a87d844d076a8f252fa04ab1be068b280c4527b2a932f800485736134a5cb6cee5e6e36319742ed6662b07939c81bb95d5b7e4bea40028f9fc045cdb832dc02c024d1f4b1d645faf95da4161cd887e1fd137fbccfd413d57e9c9d160ba4bf792af8fb829225d60237ae0ad20537f54204b574b4f41bc46a8c86eb6f9c830b5938e67566451bf32ec916d18a6199137b21e4416934e0ea3a78fdfb3722b9d9b8bbf1554254eb0f5c61858bd8a005a7a92e6e660054f30beef9027a3e0cbf251fc20970f28f2d304cd871fd405fda40310c19d6eb39a6d4af4f5eca4b9795426cf81128f8c12cdbf5a3b1f14955f6d36b33337fdd97d3901c08145e646163d20cfad67ac63120fffc59223a70ec6fe3c8ea90bc1665d3cade844fc245ae0157fa7c5fc539ef97f60cc05f2793dcd9170c6b8a0ce88301b86553c452679e38920425a7562471b4dad1e90c2595670f97cba295dcb4b65540cb7228b14a9260f18e5867ed46769d870e29522faf503267cc6c34279488c262ba8ef3b780fa51538fa5090cf1988ea3fe1c35761274a9052dff48e5cf2eec46b5536443e140572f39666ad08baf65eeaa5f7692b417773882d8855e17b2562ffe85f8ecbbd599fdb49731e673cb6fa057ab3b348bb97e43957d109dd896425e12c72a5ff594c5f0f22825e53ad672d3e03e4d72643fdbba60787be88c04aa78124a73927ebe7e10795370cb7f3462f6ee64733fafe7b7410ebfbdda4ca331e50b334a9e3bce9d332e3975b3b6e158886a67d6feea681c8b754cf66f51e1eb88b8af996bf2dea22f0326f736f01a1690fa6e0a3112987fb58e64389667fbf7847bae15cb972a1d10c183aeb23dfbf4393633fcd04fcd65d8da4718c1db9f6a6bc567c42dd38a6bfa34bf2d7319548f05267f393f2dede0e4ffa7f353c6ac0b56962eb67120696618ef12922d9ea6840c2550dd2ed1b7ca194e388e836588a35b6f7d4e51d04d5489f0e1d92eaa2a4cbe9284f74054cb9951c40c8833287bbf8c0cfa3172bf8a18b92c77d9525f4fd24359efe0fa1fe3fb6b22e5dbc0780ea5b1c51d162f347f99bd9fbf231e2fddc668fb50aeb747c5b3a5ed07e27e2b4982a0d909fbe784ceddbadab9a416d9bfc68c286d19c90556bf11caa409d4c29a5aa0b6371b7e0a3d85202edf78396b06335790ecb8c65e221f1b15c0f52ab81e42df7ecfe6abae83de28616f1b69d6e1dd36fe045f841bf3b70024ec2fdb139d383609ddade7d3061ebc8ebc69c10d758b014636979d0c244838e89b5fb49f180fff652675871c6fa348fc7151570f7c0f43409a5fec7b4d9c302181099f779e34ff2121b4f6d3d767f8673186a14d4506c68a41cb0d8fd2d66bdae89e2b17c23b2a2ffa13704a89c5c144cca8c5088115ed57f9a12a5c11ed2c4d54e59564a86f65ad0ea3c77302a33a350e539630e33c84eea5c2b5890ce21146e6036db5ab588fb6f2f2aa7b3b9df7042f6583e610228133f4450b9e7d98296e412e63ac08ca42f81d3f94c51d3554152eebb60c9c986b80a2867d58a539beb2333386190154df83ae35798c45e3923c4816eadd4a23478ed30fd0c5f6d90cabf2b7228c1e653b13b706383140b61fc17a6fd11a3b9f8c84fab9e6e7670306fe7f1b01819fac5e4fb0dd537769ffd55a932d7cd8252ce14087b3acf206b10668f4f539f2c9a3766aba8c483356f6c52112a43e1b0941b76813ce2fcc7af998c6a5ee7a2599478bcd947550bbff8c7237d23954036e624e3c09d960944b484568412de86d8a9893519ad07cb5fd55cc25eee31b4b2d6440d5622b0d633391cc94ac02bd9b26113b043fe3cb00de4aa0b9c953eba043d424e796e1bac8aed59dcc74961898be29e8d7548588dd7bef59e0d8dfa99bd0500aee2d227a34105937f32c0b081a00cd66cffe4fc5fbd646f6961e936658145f74ebe1d8e0291030f673c589ee6193f909f10ac088ca51fe06bb77a1fdd4c38b8018a71c17f520120f329f19bfdc6b7b4f107e15d053dc0dd8ff80cda16aa04737f857eaef575ee7e6a47d8f2b4f881ccabdbb8fc9ca649943528ac01715673e4f95172b65b600271d509e03ccb7b57a22bec7ecf391f1724b59c63f28be0e9f51fa774dad7481a7e6d3dcdc62e00193754765bb7422ca9f57f2d08f5164b5afc5112c5d4734bc29162d4d404bf72a784332c533a817df841b2ac7965e07552351e3f78c54ea9b737f0948eef8e70b71a169268152d0dbfc75b77165284afc13f49c1bb6534d5266083724606d2c958aa4bd81a10e62bfcf3efb97a07e51efaba9dfde7245b8ea257adddee0326c90d5c50e62d4ddfb7f0f966ff7ce756cc72ab533594967d0ea2d55721bbe67d16a77535891c05152201206c560a1805a7ecf93d90e1760aa77a71461d72050ad444888865f5e26101c8a027f525b158c16117a62705289f373c00762e7cf4a163422f63ee805c2b532bfad5f3374eed2c6373b89b76c3ee0fc4e5bab6c1c70f63a12c89536d0f465fefb9f838a68405d9bc7771bc1b3b693c8d3b894850548159172e597b15225d6f86cb8b458431c8827b4c87aabb348ce874457001daf13be779c80bd592a25e25891c6c05a8b0e405e148fe7e0bfa8b16363e4e9b27099385d3dd39fe6b008a238376fc314b9adae78c4507c76d85c01e66d71b53e629bafd846b145e6b8375b817365d81de1a8798e7a10af8d6801841688cd5950bfe98a050e45082b0d762bce01cba872ec1ccc6be21732089b36110b5cad6dbb2fafff77298cc750b3a0204261fbe9a96e59f5176c25097d4ba72b771d2d0b35f273cb016c6cb623af3f93c4b0167c44beba87faa5d17fb97c6be91aba036feb60e9e305a8a8e35db085d75ff89fa6c87b96811db51bafad3b55de9a99afa7c970e105390259dbff2b606a5e437c2ba36313985919b19fc23425462d88b445cf18138fc959ddef95226669092b926ac1712088aa0e6550e56964190cc75d2b3cb547d06fb105a08c7cc2ecceaecd86bb0040e66b8957e28f7974535161101b27c75cca694447042f979dc1a70cb284cfaae9d9b5fe729753b281f5e627cf8a7366b88fd44df035065795a926c99cf49b3792cf83791c744042d849e0c6d59de0c1d4a41f051a82e570c448f23500d5d062639cc38c983b12d11baadb347adf5cf1d47b3ce5dcf8584fa8814e2dc1604fa67ddd4d92ac907b8c7cfde7c29b10b3da5deb0b764fae2fa850f96a1824e088299cfb8cbfc1f356cb01a21a66c50af52ddcf15439ab41a05f267611b61f89cfa383c0121527a7c9f1aba3a13ff1075ca75feea3d065dbc37bc42a3bb9f84c1e014e44a2b8200605c92b9d02433d8ccddf2ed257ccfd8ae16ba857f6e28da65e1280bb26252fcc6f5ffab20e82d3268ab2e2ef11370b5798cbce10388fe97607462fc43ea6878b0623c8f5581dcf631e1fd2a997fbfa5f886e98731b1192b226951980290e1349ed9438c68a0f263b4188945eb5b39899e5e6b878d0d01ec870bbe75fcc73491214f1e38e5b3874b628d9e079941bac25b782799dcf3e99032e9ea9502fefe00e94cc01038319df57d817d5ee612f5bb598115c0b9785dbd178549b9e62f483a473bfeafff88e08effaf446c526e54cd7ca713c5e23369261ef364dd0c16544c06c461bf060253454e2826a991fb17c78e1a54390cd1e5b683d8f9df11c9b53f56b1f5d9495b38ed1f9243e1809ed1dfb4d7eb5b3c2ba8e195127c1939d6524f27c30d8db4ba3968c9fbd03fb5b2334a5a989e2233760637be322a95d225c9c2808602efe99e7fa8eaf2c38121b23325ae85d89f2f8691d46a37d5d7a84b89c37f0c9f628933522af088a109865cf2566b0372ad560b8887237090613d1fca3ee391d227d1fe0fb25a28459456d03cb7e9a9d19ef1beca4d691ec87c839b47ca777bf9619418e991fe5ae9d764e196687fc66d766c60971dc7efd8764dd930c461d581b9be912b07a38e0d2d980195750d752c261d966f0d94397d93ebd9c1288dc30475973d16b69c2aa01a3a9c5f944e8aa2cad8ac12eac353fa6868ebce391a02abf6d44e076416730f0762ce29f018a5f1b903814cefda3f7920a23447090cdc2d5a8702146f309581fc313700f0a60fe6417f3af9f8fa06309ec81df232319ad84835b6d4393c784bc2618b6389a4abbed1613a6678bd68c48e69f3a4428edf11feef8931a7a55381687a3b4c77836cb043ddec2013e79f74299f743b250665b7280f722aa2dd14a5eb389839ccfd1210d3081b5771e409d272298e7b5fc90be5d035f981653dc7a258266327473be1067bb49aeeb75f2ee7b2eb995def2dfd3dfcba0dba5ffe56d71624b683f92aed94fa1cc9ba08a4edd2c948ace096ffe6bd1e7af1a84342afd538cd3de75bab499979f0c338c47688a3c7f9bb001791aa2542705822883bab8c12d7f5d42ae3141839623c6e2ca84992c2565a34fe491de807db7bc6cde59da9f3c6550cac998db2da05419aff8a6a013db12d7219b3684439e290b59582b40cd288e5ef5f105e29bd97f2bb8aa8621cc0dd817bc9341c2dc23eda8cd0bd33ed3bcc0d63d27f6782781eba2f26da0f822941ab43c4551933b448c3cef2198811f638d8842d0f8a375cb979a83afd53e9bc1ebb7681eb69f04db4c846e201193445eb291a6355b42d7107d8ee4805e52cd9bd79a5ad2b3191aa532367ded99cc6d386083592a797074bf269cea9c4b6f1b265e2976b67aa50bfce88a296a5631bf90582a8c65df31ff3b1dde07a5907866079fe3efc1f0ae7a64fe6d92d21d2542f64cf315798834e2060cd6a4b4e2c1c75a7d28d43bdf85675d4d9e3c7ec769f08c9d83fef1c8b2ef86857a53f8072f6f8d8a963b678009d8b124874c2f3ac4c57bd8654dd587d73f61eb7e30b0f8e38dafe8b09ea63c7f55cbb87891f308441b6d75315a43982ecf3fd3bf71e798579012ca2ed00406b816330ba1018f1a3220728b2a4f25723a515fe8f85160705e8d09743233148a4f1109eef97a43a957e46babeb58f0778293a00f1554aa87c6b924acae3054e516356ca7b5c66a7c8c98312ef4f4fdf9160f1c2b2fca92fae0bf75d8e20b1d9fa6cd37de9a9a98b556a170c8a927ed2d30ebd054a79410a604668dbdc22d3124a684a33d54ad85e45a54730a62be947d922d201caaaaa744d52087a061e6dbb239dd4e7fdc7cb12fa05567145d1dbb8ed4ca5953615f60a2f9395e883c9792d8465344345ecef77e4274b2e4bc8473652338c5d6520d91e5681d6ffafe2aa3102375a1f877dc9af288c65787c60a25c93eb676081a8c0cf112de250d583ac887c39a1c617537297e94787fa28eb6e66d7370d8e694252167dbe35dfcab35479c60c42eb32ba583ac3a720d50048f230eaf77d6321c7afe96300ea3103031ab2664ac521bb9224b6d51e888a2823a0280bd3eaed2a12ff6ed7212592f43830e803581b7807849795c84bba68d1b9c23bda9d751beb0d838eed68ff2b4b4f43db35c008267df2ccb079419aa4c42870d9e7a01937cd02ce0e2036921b48456b12f1fd01dac36ea931a7009c7f03b63f1186c230e44426964893b3b05a10c5d2d8bb7fccaae958ec31b65eb27fe10a8c16b4e47d97a3b2bb30e81530bbbb97e5895e996c762b9c29c4754b3a67cfcee8b1b5bea9dcf35a6cc84191e7bd530487f06a09b3d36b06ddb9505ef738526f61ffdd51f18334c127f361135187d455ddbaf08dabb051c97d11f75f80873d3b7513ecbb37edf97afb0733e61b4b5bd0312be0e4e8499947be5373c5964f33b34630d5e688d13cb5ecdd981d6eb2ebb91e149e1058b696f860a22ed7b58285e2746fdd27d3ab67d2d904d76b089208a21226eca6061e70a0f3cbca8f287e16690c0fd9003485667a097e91e8e16d02242f0e905ad8295dd4d4ccf8bff1a278a519808e60820125a6cedfee846415fe16dda42fc01c8804dfdd5e1f66f4cb78c2d90b39636810f4b47927608f721b28b346691cfbb600db9ac2a2711aee7b1c3ce24a1906bb63923bbed14d40a39a7cc8e81729c3e29ae5f46fb92b4520f59fab28ea1c66dddfb164f16a12405cfecf0822d163fe41c2968cd4ccccf0bd109fe385f03f31d52f5160aad5ca4c50e001db25e783a7c4ae0cb673596c3ee9d317d5199c75115f101c023b61651f3815a8a0a0f9e355e034ea976ced619dfe1e1040f25f62be02d329a544234106a1a851936458bd5a913b56ee8b021fc916cc15cde6cef4383c456f76705189c65692473b6b241b4955ccf6399512d21d26373faff804d66d2c0aea6f7fb20d6b9d25b5b1e9ac394d972a1329cfa925f18e3e6f039f5c8a4c5c0d518f219191679f84db673157f3943eb0632eee3aff6614a93154b72e1137e1f269144826c73222e0602106ce47d559c515c2e9d53e4a743260789fe05ae11ba212cd504d2d59e5605a34f30942b1973a82c04cbbf21efe4dc58a6c8f2b6cd4fc620ee42e41cb98aa43559b8a22d58823fa9edf5a5f8f50112909a52e1c11e533a17d60743fe7dac25e038537a15b36e8caf8cc69b8a79de52d9bf72cbc90eccecbed9e7dc7b1d6cd6c14f3498668e20fbd1cfac8341da461ff07232d999e0fc11aae6debac9e4c1a4d023043b7ceabc4daf1404e277918e044e86fe522a03990adb549812753c9994569ef4ea74dab38bff83e68feeaaf7c3287f23ecc1fcffa0f2a88fdf792bcf74a43131a977d89de0fbb51601f2fc30ab882ad4c241c602993d0a2df4113e486e83652f8f658e84f6f48d8ac23dcdf94982b540508831fe53059f764269520411adf501c4f7ccd30df30d920c6ebb8e69a60ebe23ee4932fa10dffc48ba081d1b850d03f4234ee6816621c8efd5390523eef7726fff343124a3eee829b233fa29a803f47314d12ebe2d08f78cda78e81c8909fdc0e66326c27bb76a03fe9354282b1427f2d32fc28991086d25975e3d619f6fa38535f63d03dcd80feaa5325222f15acda4d5d43d46c121cda6e118edf563317e17b758e90639dbd034fcde5796d93e3800fdaacd7d51fbb78c30a51c10ea8aa3ec062893d20a738812c35b79a6eb613a2f3ad0fbed059dedab8483c53ff159d47a6516c1f7b2e7c83b1dda424adc9f969059e511dd3cc18fb81da657bf801bdbf1d12e7f5997cea3e552373beb2ae1418a27a22dfc83ad4271e1fa1676eaaca43f2e3b5fddb5cd8aba589c2c4a4f64e427dec490c00664c3dc74b7d205f2c8f21ebc753c7d712ac4d7808ef3a6e05714ef52882d8070848a395419505e3e87925faf3e20d5eba6ec8f15740e2f47d039fedfabdabf7753fac76c1e2631a672f4b4928dded96e8b50da7e6bb6b6c5574dd6d09443d0947ac3fe46742b49ae520e767cda9f943b88ddc8fe05ede0a359cfd86f164e3e793d287216c465786c8de6a66a06c6b55e9c6a2c9b9e83c2b835916ceef0cb1e10acf482da2044b7d76142c1da8e01442a62a9bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">内部文档，则观云资源需求与分析</summary>
    
    
    
    <category term="⓽ 其他内容" scheme="https://blog.slks.xyz/categories/%E2%93%BD-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划——背包问题应用</title>
    <link href="https://blog.slks.xyz/2022/02/24/46f0b3257e29/"/>
    <id>https://blog.slks.xyz/2022/02/24/46f0b3257e29/</id>
    <published>2022-02-24T01:40:23.000Z</published>
    <updated>2022-02-24T15:31:21.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-102.-加减的目标值"><a href="https://leetcode-cn.com/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值</a></h4><p>给定一个正整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式：</p><ul><li>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1"</li></ul><p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">sum</span>(nums[i]) &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= target &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 在本题的背景下，<strong>一开始的错误思路：</strong>利用动态规划的思想，定义二维数组res，<code>res[i][j]</code>代表前<code>i</code>个数，按照题目所给规则，计算得到<code>target = j</code>的方法数目。然后状态转移方程如下 <code>res[i][j] = res[i-1][j-ele] + res[i-1][j+ele]</code>，<code>ele</code>是第<code>i</code>个元素。这个思路基于的思想就是：第<code>i</code>个元素，我们可以给它添加<code>+</code>或者<code>-</code>号，这样的话和为前<code>i</code>个元素计算得到<code>target</code>为<code>j</code>的方法数只有两种可能的路径，就是前<code>i-1</code>个元素。</p><p>​ 但是代码写着写着，发现一个不太对的地方，那就是target目标是有可能负的，也就是说，我们需要初始化的<code>j</code>的维度需要代表从<code>-1000~target</code>，但是这样还不能解决问题，因为有可能<code>j-ele</code>是比<code>-1000</code>小的，小多少无从可知，所以我们就没有办法进行比较高效的动态规划。</p><p>​ <strong>正确思路</strong>： 我们可以将上述问题转化为，从前<code>i</code>个数字中，选取一定的数字，使得和为<code>j</code>，可能的方法数量。这个和上面的区别在于，我们不再考虑添加正负号，而是直接把上述问题转换为了一个背包问题。因为我们知道，如果正数和为<code>j</code>，那么剩余的负数和为<code>sum-j</code>，<code>sum</code>为<code>nums</code>数组中所有元素的和。那么最后只需要满足如下公式：<code>2 * j - sum = target</code>，就可以得到我们需要的对应方法的数量。也就是说，我们如果定义二维数组<code>res</code>，代表前<code>i</code>个数，选取一定数字，得到和为<code>j</code>的方法数目，那么我们最后<code>res[nums.size()][(sum + target) / 2]</code>即为我们所需要的答案。（注：如果<code>sum+target</code>是奇数，那么必定不存在任何一种方法）。</p><p>以下为动态规划的几个重要内容：</p><h5 id="动态规划思想"><strong>动态规划思想</strong>：</h5><pre><code>`res[i][j]`，代表前`i`个数，选取一定数字，得到和为`j`的方法数目</code></pre><h5 id="初始化状态"><strong>初始化状态</strong>：</h5><pre><code>`res[0][0-target] `都置为0，且 `res[0][0]` 置为 1</code></pre><h5 id="状态转移方程"><strong>状态转移方程</strong>：</h5><p>​ <code>res[i][j] = res[i-1][j] + res[i-1][j-ele] (if j - ele &gt;= 0)</code></p><p>​ <code>res[i][j] = res[i-1][j] (if j - ele &lt; 0)</code></p><p>​ <code>ele = nums[i-1]</code></p><h5 id="代码如下"><strong>代码如下</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((sum+target) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> need_size = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(need_size+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//初始化状态： res[0][0-target] 都置为0，且 res[0][0] 置为 1</span></span><br><span class="line">        <span class="comment">//状态转移： res[i][j] = res[i-1][j] + res[i-1][j-ele] 前提是 j-ele 存在</span></span><br><span class="line">        <span class="comment">//如果j-ele 不存在 res[i][j] = res[i-1][j] </span></span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ele = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=need_size;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j-ele];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[nums.<span class="built_in">size</span>()][need_size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-103.-最少的硬币数目"><a href="https://leetcode-cn.com/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a></h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><h5 id="解题思路-1"><strong>解题思路</strong>：</h5><p>其实本题就是一道完全背包问题，稍加转换即可：</p><h5 id="定义"><strong>定义</strong>：</h5><pre><code>前`i`个硬币，构成金额`j`，所需要的最少的硬币个数为 `res[i][j]`</code></pre><h5 id="初始化状态-1"><strong>初始化状态</strong>：</h5><pre><code>`res[0][0-amount] = -1  res[0][0] = 0`</code></pre><h5 id="状态转移"><strong>状态转移</strong>：</h5><pre><code>`res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )`</code></pre><p>需要注意的是，因为我们初始化不存在解的值为-1，所以在后续状态转移判定的时候，情况较多，具体见代码：</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前i个硬币，构成金额j，所需要的最少的硬币个数为 res[i][j]</span></span><br><span class="line">        <span class="comment">// 初始化状态： res[0][0-amount] = -1  res[0][0] = 0</span></span><br><span class="line">        <span class="comment">// 状态转移： res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(coins.<span class="built_in">size</span>() + <span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(amount+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ele = coins[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    <span class="keyword">int</span> r1 = res[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">int</span> r2 = res[i][j-ele];</span><br><span class="line">                    <span class="keyword">if</span>(r1 == <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 不存在 , r2 存在，那么参照r2 + 1</span></span><br><span class="line">                        res[i][j] = r2+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>)&#123; <span class="comment">// r1 存在 , r2 不存在，那么参照 r1</span></span><br><span class="line">                        res[i][j] = r1; </span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 存在 , r2 存在，那么参照min(r2+1,r1)</span></span><br><span class="line">                        res[i][j] = <span class="built_in">min</span>(r1,r2+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;   <span class="comment">// r1 不存在 , r2 不存在，那么也不存在  = -1</span></span><br><span class="line">                        res[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录两道LeetCode算法题，思路上需要拐一个脑筋急转弯。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记3——优化器类的代码实现（上）</title>
    <link href="https://blog.slks.xyz/2022/02/23/c051c3782dfb/"/>
    <id>https://blog.slks.xyz/2022/02/23/c051c3782dfb/</id>
    <published>2022-02-23T04:17:19.000Z</published>
    <updated>2022-02-28T03:00:00.587Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 优化器的理论部分以及各种常见的优化器可以参见如下博客：<a href="https://blog.slks.xyz/2022/02/11/ced858ce48dc/">机器学习基础系列笔记16——常见的梯度下降优化器整理</a></p><p>本文所讲的是如何使用Python搭建优化器类，从而帮助实现整个机器学习的训练过程。</p><h4 id="一在不封装优化器的时候如何在计算图上执行梯度下降法">一、在不封装优化器的时候，如何在计算图上执行梯度下降法？</h4><p>当我们还没有明确提出优化器这个概念的时候，我们遵循如下过程去在计算图上执行梯度下降来优化损失函数：</p><ul><li>1）对结果节点的上游变量节点(Variable)赋值或初始化【包括输入向量节点和训练参数节点】</li><li>2）在结果节点上调用forward，计算出它的值，数据前向传播</li><li>3）在所有需要训练的变量节点( Variable, trainable = True )上调用backward方法，梯度反向传播，计算出结果节点对该节点的雅可比矩阵。【仅包括训练参数节点】</li><li>4）根据变量节点的jacobi属性中的值，从变量节点的当前值中减去 用学习率 * 梯度的值即为更新后的值。</li><li>5）清除所有节点的value和jacobi属性，回到第2步</li></ul><h4 id="二优化器的封装">二、优化器的封装</h4><p>​ 其实，优化器所实现的功能就是上述训练过程中对可训练的变量节点的值进行优化的过程。但是由于，可能存在各种多种多样的优化器，为了便于外层用户使用，代码的整洁，我们需要将优化器的功能封装起来，然后进行使用。</p><p>​ 抽象而言，整个更新计算图中变量的普适流程可以抽象为3步：</p><ul><li>调用Loss节点的Forward方法，这会递归调用所有上游节点的forward方法进行前向传播</li><li>对于计算图中需要更新的变量节点，利用Backward方法，计算出Loss节点对他们的雅可比矩阵</li><li>使用雅可比矩阵，根据梯度下降法更新参数节点。</li></ul><p>​ 当然，在理论部分已经知道了，会有不同形式的梯度下降方法，那么在实现中，自然而然的解决方案就是：**将上述流程封装进入一个抽象类：Optimizer中，然后将不同的算法封装进不同的子类里面，实现各自个性化的部分。</p><h4 id="三优化器基类optimizer类">三、优化器基类（Optimizer类）：</h4><h5 id="part1构造函数">Part1：构造函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Optimizer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化器基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        优化器的构造函数接受计算图对象，目标节点对象(往往就是Loss函数损失值节点，为了方便期间，该框架只支持优化一个目标节点，且我们暂时假设该目标节点最终结果为标量)以及学习率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(target, Node) <span class="keyword">and</span> <span class="built_in">isinstance</span>(graph, Graph)</span><br><span class="line">        self.graph = graph</span><br><span class="line">        self.target = target</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为每个参与训练的节点累加一个Mini Batch的全部样本的梯度（具体作用见后）</span></span><br><span class="line">        self.acc_gradient = <span class="built_in">dict</span>()</span><br><span class="line">        self.acc_no = <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="part2核心函数">Part2：核心函数</h5><h6 id="核心函数1forward_backward">核心函数1：forward_backward()</h6><p>​ 该函数抽象了先前我们所说的优化器普适流程中的前两步，完成前向传播计算结果节点target的值，然后遍历所有的计算图中的节点，找到那些<strong>需要训练的变量节点</strong>，然后对它们执行backward，求出结果节点对这些变量节点的雅可比矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_backward</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       前向传播计算结果节点的值并反向传播计算结果节点对各个节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 清除计算图中所有节点的雅可比矩阵</span></span><br><span class="line">       self.graph.clear_jacobi()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 前向传播计算结果节点</span></span><br><span class="line">       self.target.forward()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 反向传播计算雅可比矩阵</span></span><br><span class="line">       <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">               node.backward(self.target)</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 我们会得到 目标节点对参数节点的雅可比矩阵，将其转置以后即为目标节点对某变量节点的梯度</span></span><br><span class="line">               <span class="comment"># 目标节点（如果是标量的话）对节点值的雅可比是一个行向量，其转置是梯度（列向量）</span></span><br><span class="line">               <span class="comment"># 这里将梯度reshape成与节点值相同的形状，好对节点值进行更新。</span></span><br><span class="line">               <span class="comment"># node 节点的 shape 应当是一个矩阵，矩阵中元素为 N 个。</span></span><br><span class="line">               <span class="comment"># 从 目标节点 对 node 节点的雅可比矩阵相当于是 N维 -》 1维的变换</span></span><br><span class="line">               <span class="comment"># 故而 jacobi 的 shape 应该是 1 * N 维，所以要将其Reshape成Node节点形状，才方便对Node节点中的各个值进行梯度的累加。</span></span><br><span class="line">               gradient = node.jacobi.T.reshape(node.shape())</span><br><span class="line">               <span class="comment"># 如果该节点不在acc_gradient里面，就新建一个key-value</span></span><br><span class="line">               <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.acc_gradient:</span><br><span class="line">                   self.acc_gradient[node] = gradient</span><br><span class="line">               <span class="keyword">else</span>: <span class="comment"># 如果该节点已经在acc_gradient里面，就将梯度进行一个累加</span></span><br><span class="line">                   self.acc_gradient[node] += gradient</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="核心函数2update">核心函数2：update()：</h6><p>​ 该函数封装了优化过程的第三步，参数更新。在Optimizer类中，update方法调用_update这个抽象方法，其具体的方法由具体的子类覆写。执行完参数的更新以后，我们需要将先前累积的梯度给清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, var_gradients=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="comment"># 该部分作用暂时还未解释，用于分布式训练，该处暂时无用，可以忽略</span></span><br><span class="line">      <span class="keyword">if</span> var_gradients <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self.apply_gradients(var_gradients)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 执行更新</span></span><br><span class="line">      self._update()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 清除累加梯度</span></span><br><span class="line">      self.acc_gradient.clear()</span><br><span class="line">      self.acc_no = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      抽象方法，执行具体的梯度更新算法，由子类实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="part3入口函数">Part3：入口函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_step</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算并累加样本的梯度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.forward_backward()</span><br><span class="line">    self.acc_no += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="part4-其他辅助函数">Part4: 其他辅助函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_gradients</span>(<span class="params">self, node_gradients_dict, summarize=<span class="literal">False</span>, acc_no=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此处暂时先不提这个函数，用于分布式训练</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span>(<span class="params">self, node</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回样本的平均梯度</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">assert</span> node <span class="keyword">in</span> self.acc_gradient</span><br><span class="line">       <span class="keyword">return</span> self.acc_gradient[node] / self.acc_no</span><br></pre></td></tr></table></figure><h4 id="四bgd和sgd和mbgd的数学表达">四、BGD和SGD和MBGD的数学表达：</h4><h5 id="bgd">1、BGD</h5><p>​ 计算所有样本的平均损失值对参数的梯度，由于求梯度的过程是线性运算，所以<strong>所有样本的平均损失值对参数的梯度就等于每个样本的损失值对参数的梯度的平均：如下公式所示</strong> <span class="math display">\[\grad(\frac{1}{N}\sum_{i=1}^Nloss{(w|x_i)} ) = \frac{1}{N}\sum_{i=1}^N \grad(loss{(w|x_i)} )\]</span> ​ 所以，在实现中，我们可以以此计算出训练集中每个样本的损失值对参数的梯度，然后再求这些梯度的平均值。这也是为什么在Optimizer的基类中，我们需要设置<code>self.acc_gradient</code>用于累加每个样本的梯度，然后设置<code>self.acc_no</code>记录累加的样本的数量。</p><h5 id="sgd">2、 SGD</h5><p>​ 每计算一个样本的损失值，然后就进行参数的更新。</p><h5 id="mbgd">3、MBGD</h5><p>​ 以一部分样本的损失之进行计算。</p><h5 id="总结">总结：</h5><p>​ 所以，其实针对于以上三种，在代码实现泛化的时候，我们可以用批大小来进行泛化。batch size = 1即为SGD，反之极端为BDG。在代码中，其实就是 调用 <code>batch_size</code> 次 <code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p><h4 id="五matrixslow优化器mbgd实现-其他框架实现方式">五、MatrixSlow优化器MBGD实现 &amp; 其他框架实现方式：</h4><h5 id="优化器mbgd实现">1、 优化器MBGD实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientDescent</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梯度下降优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        朴素梯度下降法</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                <span class="comment"># 用朴素梯度下降法更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 按照上述非常简单好理解的代码实现，我们可以将整一个优化训练代码的过程简化如下：就是像上一段中描述的那样，调用 <code>batch_size</code> 次 <code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">optimizer = ms.optimizer.Adam(ms.default_graph, loss, learning_rate)</span><br><span class="line"></span><br><span class="line">mini_batch_size = <span class="number">8</span></span><br><span class="line">cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练执行50个epoch</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的前4列（除最后一列的所有列），构造3x1矩阵对象</span></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的最后一列，是该样本的性别标签（1男，-1女），构造1x1矩阵对象</span></span><br><span class="line">        l = np.mat(train_set[i, -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将特征赋给x节点，将标签赋给label节点</span></span><br><span class="line">        x.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器执行一次前向传播和一次后向传播</span></span><br><span class="line">        optimizer.one_step()</span><br><span class="line">        cur_batch_size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当积累到一个mini batch的时候，完成一次参数更新</span></span><br><span class="line">        <span class="keyword">if</span> (cur_batch_size == mini_batch_size):</span><br><span class="line">            optimizer.update()</span><br><span class="line">            cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line">        x.set_value(features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        pred.append(predict.value[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 模型的预测结果：1男，0女</span></span><br><span class="line"></span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span>  <span class="comment"># 将1/0结果转化成1/-1结果，好与训练标签的约定一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断预测结果与样本标签相同的数量与训练集总数量之比，即模型预测的正确率</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印当前epoch数和模型在训练集上的正确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他框架对于minibatch的实现方式">2、 其他框架对于MiniBatch的实现方式：</h5><p>​ 其实，上述MatrixSlow实现MiniBatch梯度计算的方式，并不是工业上最佳的。但是我认为是在学习的过程中比较好的方式。其把 MiniBatch样本和计算图完全分隔开，概念很清晰。<strong>那么在一些工业级的框架中，一般是怎么做的呢？</strong></p><p>​ 在其他一些框架中（比如<strong>Pytorch</strong>），可能会用一个变量节点来存储整批样本，<strong>比如样本为n维向量，批大小维m，那么就用一个<span class="math inline">\(m \times n\)</span>的矩阵来存储。</strong>后续计算节点的计算都是对存储数据矩阵的每一行进行的，<strong>然后这一整批的数据都会在计算图里像前面流动，直到损失值节点</strong></p><p>​ 总结来说，就是以下几步：</p><ul><li>添加一个维度，用一个变量节点存储整个minibatch的样本</li><li>前向传播对整个batch的样本计算</li><li>以平均损失值节点为目标节点</li><li>以平均损失之节点对参数的梯度更新参数。</li></ul><p>​ 这样子的好处在于什么呢？<strong>这种方法所进行计算的性能更好，可以在高效率的利用GPU的并行计算能力，并且能够支持高阶的张量。</strong></p><p>​ 以下代码是书中，对于先前的AdaLine的寻阿联例子，如果使用工业框架的方法，应当是如何训练的，给出了一个示例（没有进行封装）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;../..&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matrixslow <span class="keyword">as</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造训练集</span></span><br><span class="line">male_heights = np.random.normal(<span class="number">171</span>, <span class="number">6</span>, <span class="number">500</span>)</span><br><span class="line">female_heights = np.random.normal(<span class="number">158</span>, <span class="number">5</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_weights = np.random.normal(<span class="number">70</span>, <span class="number">10</span>, <span class="number">500</span>)</span><br><span class="line">female_weights = np.random.normal(<span class="number">57</span>, <span class="number">8</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_bfrs = np.random.normal(<span class="number">16</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">female_bfrs = np.random.normal(<span class="number">22</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_labels = [<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line">female_labels = [-<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line"></span><br><span class="line">train_set = np.array([np.concatenate((male_heights, female_heights)),</span><br><span class="line">                      np.concatenate((male_weights, female_weights)),</span><br><span class="line">                      np.concatenate((male_bfrs, female_bfrs)),</span><br><span class="line">                      np.concatenate((male_labels, female_labels))]).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱样本顺序</span></span><br><span class="line">np.random.shuffle(train_set)</span><br><span class="line"><span class="comment"># 批大小</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># batch_size x 3矩阵，每行保存一个样本，整个节点保存一个mini batch的样本</span></span><br><span class="line">X = ms.core.Variable(dim=(batch_size, <span class="number">3</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 保存一个mini batch的样本的类别标签</span></span><br><span class="line">label = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 权值向量，3x1矩阵</span></span><br><span class="line">w = ms.core.Variable(dim=(<span class="number">3</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 阈值</span></span><br><span class="line">b = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 全1向量，维数是batch_size，不可训练</span></span><br><span class="line">ones = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">ones.set_value(np.mat(np.ones(batch_size)).T)</span><br><span class="line"><span class="comment"># 用阈值（标量）乘以全1向量</span></span><br><span class="line">bias = ms.ops.ScalarMultiply(b, ones)</span><br><span class="line"><span class="comment"># 对一个mini batch的样本计算输出</span></span><br><span class="line">output = ms.ops.Add(ms.ops.MatMul(X, w), bias)</span><br><span class="line">predict = ms.ops.Step(output)</span><br><span class="line"><span class="comment"># 一个mini batch的样本的损失函数</span></span><br><span class="line">loss = ms.ops.loss.PerceptionLoss(ms.ops.Multiply(label, output))</span><br><span class="line"><span class="comment"># 一个mini batch的平均损失</span></span><br><span class="line">B =  ms.core.Variable(dim=(<span class="number">1</span>, batch_size), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">B.set_value(<span class="number">1</span> / batch_size * np.mat(np.ones(batch_size)))</span><br><span class="line">mean_loss = ms.ops.MatMul(B, loss)</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">learning_rate = <span class="number">0.0001</span></span><br><span class="line"><span class="comment"># 训练，这个步骤之后没啥区别</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的特征</span></span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的标签</span></span><br><span class="line">        l = np.mat(train_set[i:i + batch_size, -<span class="number">1</span>]).T</span><br><span class="line">        <span class="comment"># 将特征赋给X节点，将标签赋给label节点</span></span><br><span class="line">        X.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line">        <span class="comment"># 在平均损失节点上执行前向传播</span></span><br><span class="line">        mean_loss.forward()</span><br><span class="line">        <span class="comment"># 在参数节点上执行反向传播</span></span><br><span class="line">        w.backward(mean_loss)</span><br><span class="line">        b.backward(mean_loss)</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        w.set_value(w.value - learning_rate * w.jacobi.T.reshape(w.shape()))</span><br><span class="line">        b.set_value(b.value - learning_rate * b.jacobi.T.reshape(b.shape()))</span><br><span class="line">        ms.default_graph.clear_jacobi()</span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        X.set_value(features)</span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        <span class="comment"># 当前模型对一个mini batch的样本的预测结果</span></span><br><span class="line">        pred.extend(predict.value.A.ravel())</span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文记录使用Python搭建深度学习框架，实现其中优化器类的代码，包含优化器基类的抽象和需要执行的任务，以及最基本的MBGD优化器的实现，还跟Pytorch的实现方式进行了比对。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
</feed>
