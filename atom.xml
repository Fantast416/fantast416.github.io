<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-02-16T03:24:01.359Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>动态规划——经典最长公共子序列问题</title>
    <link href="https://blog.slks.xyz/2022/02/16/LeetCode%E7%AC%94%E8%AE%B0/LCS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.slks.xyz/2022/02/16/LeetCode%E7%AC%94%E8%AE%B0/LCS%E7%BB%8F%E5%85%B8%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-16T03:02:19.000Z</published>
    <updated>2022-02-16T03:24:01.359Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-095.-最长公共子序列"><a href="https://leetcode-cn.com/problems/qJnOS7/">剑指 Offer II 095. 最长公共子序列</a></h4><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 公共子序列 的长度。如果不存在 公共子序列 ，返回 0 。一个字符串的 子序列 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，"ace" 是 "abcde" 的子序列，但 "aec" 不是 "abcde" 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><ul><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><p><strong>解题思路</strong>：</p><p>​ 最长公共子序列问题是典型的二维动态规划问题。</p><p>​ 我们设定一个二维数组 res, <span class="math inline">\(res[i][j]\)</span> 代表text1的前i个字符和text2的前j个字符的最长公共子序列。当i = 0或j=0时，均初始化为0，然后我们写出递归表达式： <span class="math display">\[res[i][j] = res[i-1][j-1] + 1  \ \ \ \ \ (if \ \ \ \ text1[i-1] == text2[j-1])\]</span></p><p><span class="math display">\[res[i][j] = max(res[i-1][j],res[i][j-1])  \ \ \ \ \ (if \ \ \ \ text1[i-1] != text2[j-1])\]</span></p><p>​ 然后按照动态规划规则，进行循环求解即可。</p><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len_1 = text1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> len_2 = text2.<span class="built_in">length</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(len_1 + <span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(len_2 + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=len_1;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">1</span>;j&lt;=len_2;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(text1[i<span class="number">-1</span>] == text2[j<span class="number">-1</span>])&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>; </span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = <span class="built_in">max</span>(res[i<span class="number">-1</span>][j] , res[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[len_1][len_2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>C++代码技巧注意</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始化二维数组的方法</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m + <span class="number">1</span>, vector&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>));</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为经典的动态规划问题——最长公共子序列问题。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记18——常见的位置编码Position Encoding方法</title>
    <link href="https://blog.slks.xyz/2022/02/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B018%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95/"/>
    <id>https://blog.slks.xyz/2022/02/15/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B018%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84%E4%BD%8D%E7%BD%AE%E7%BC%96%E7%A0%81%E6%96%B9%E6%B3%95/</id>
    <published>2022-02-15T01:33:19.000Z</published>
    <updated>2022-02-16T06:31:47.627Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一固定的绝对位置编码">一、固定的绝对位置编码：</h3><p>​ 在Transformer中使用的就是绝对位置编码，我们会将输入的序列首先通过Linear Embedding的形式，编码成 $ n d_{model}$ 的形式，<span class="math inline">\(n\)</span> 代表token的数量，<span class="math inline">\(d_{model}\)</span> 代表一个token的维度。</p><p>​ 然后我们会生成位置编码，绝对位置编码是固定值，其能够支持较长的序列，我们假设支持最长的序列长度为5000，那么就应当先生成一个维度为 $ 5000 d_{model}$ 的矩阵，具体公式如下：（不唯一）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220215094001163.png" /></p><p>​ 使用如上所述的公式，代表不同频率的正弦和余弦函数进行表示：pos代表 第1个维度，也就是5000那个维度， i代表<span class="math inline">\(d_{model}\)</span>那个维度，对于一个固定的<span class="math inline">\(i\)</span>而言，我们会发现，其就是关于pos的正弦或余弦函数，对于不同的i而言，就是不同的频率而已。这样子预先计算好一个 $ 5000 d_{model}$ 的矩阵以后：</p><p>​ 等到要使用了，我们检测到token的数量是n，那么就直接取前整个矩阵的前 $ n d_{model}$切片就可以，然后与序列的Linear Embedding相加即可。</p><h3 id="二可学习的绝对位置编码-learned-positional-embedding">二、可学习的绝对位置编码 Learned Positional Embedding：</h3><p>​ <strong>直接对不同的位置随机初始化一个postion embedding</strong>，加到word embedding上输入模型，<strong>作为参数进行训练。</strong>使用Learned Positional Embedding编码，位置之间没有约束关系，我们只能期待它隐式地学到，是否有更合理的方法能够显示的让模型理解位置的相对关系呢？见后：</p><h3 id="三相对位置编码-rpe">三、相对位置编码 RPE：</h3><p>​ 在Swin Transformer中，使用的就是相对位置编码，使用绝对位置编码，不同位置对应的positional embedding固然不同，但是位置1和位置2的距离比位置3和位置10的距离更近，位置1和位置2与位置3和位置4都只相差1，这些关于位置的相对含义模型能够通过绝对位置编码get到吗？并不太行。</p><p>​ 在Swin Transformer中，这种相对位置编码在计算Attention的时候进行应用：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120718204.png" /></p><p>​ 相对位置偏差是怎么确定的呢？如下所示，假设我们的特征图是左侧的2*2的格子，下方是我们熟知的绝对位置索引，相对位置索引如右侧上面一排所示，其实就是当前计算格子的绝对位置索引减去其他格子的绝对位置索引。然后将四个像素的相对位置索引展开后拼接在一起形成一个新的矩阵。这个矩阵就是二维的相对位置索引矩阵。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/iiioio.png" /> 在作者的源码中，其使用的是1维的的相对位置索引矩阵，我们不能简单的将x,y相加，不然可能导致不同位置的相对位置索引一致，导致出现问题。所以作者在源码中经过了一个简单处理。我们先把所有的行列标加上M-1，然后再将行标乘2M-1，然后再将行列标相加，得到的矩阵。</p><p>​ 然后我们需要把Relative Position Index通过一张Bias Table映射成relative position bias才是用于计算Self-Attention最终用于计算的Bias值，也就是公式里的矩阵B。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220115120814669.png" /></p>]]></content>
    
    
    <summary type="html">整理了三个常见的位置编码方法，包括绝对位置编码、相对位置编码、可学习的位置编码。</summary>
    
    
    
    <category term="深度学习笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Position Encoding" scheme="https://blog.slks.xyz/tags/Position-Encoding/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记17——常见的Loss损失函数整理</title>
    <link href="https://blog.slks.xyz/2022/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B017%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84Loss%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/"/>
    <id>https://blog.slks.xyz/2022/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B017%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84Loss%E6%8D%9F%E5%A4%B1%E5%87%BD%E6%95%B0%E6%95%B4%E7%90%86/</id>
    <published>2022-02-11T14:18:19.000Z</published>
    <updated>2022-02-16T06:31:45.376Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一分类任务常用损失信息熵交叉熵相对熵的概念与应用">一、分类任务常用损失：信息熵、交叉熵、相对熵的概念与应用</h3><h4 id="信息熵">1、信息熵</h4><ol type="1"><li>随机变量 <span class="math inline">\(x\)</span> 的自信息 (self-information)，描述的是随机变量的某个事件发生所带来的信息量。</li></ol><p>​ <span class="math inline">\(I(x) = -log(p(x))\)</span></p><ol start="2" type="1"><li><strong>信息熵</strong>即所有信息量的期望,其中<span class="math inline">\(n\)</span>为事件的所有可能性。</li></ol><figure><img src="https://www.zhihu.com/equation?tex=H%28X%29%3D%E2%88%92%E2%88%91_xp%28x%29log%28p%28x%29%29%3D%E2%88%92%E2%88%91_%7Bi%3D1%7D%5Enp%28x_i%29log%28p%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><h4 id="相对熵">2、相对熵</h4><p>​ KL散度，如果对于同一个随机变量x有两个单独的概率分布 <span class="math inline">\(p(x)\)</span>和 <span class="math inline">\(q(x)\)</span>，可以使用相对熵来衡量这两个分布的差异。</p><figure><img src="https://www.zhihu.com/equation?tex=D_%7BKL%7D%28p%7C%7Cq%29%3D%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28%5Cfrac%7Bp%28x_i%29%7D%7Bq%28x_i%29%7D%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ K-L散度其实是<strong>数据的原始分布p和近似分布q之间的对数差值的期望</strong>。</p><p>​ K-L散度<strong>并非距离，其不满足对称性</strong>，即 $D_{KL}(p||q) $ <span class="math inline">\(!=\)</span> $D_{KL}(q||p) $</p><h4 id="交叉熵">3、交叉熵：</h4><figure><img src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 在机器学习中，往往用 <span class="math inline">\(p(x)\)</span> 用来描述<strong>真实分布</strong>， <span class="math inline">\(q(x)\)</span> 用来描述模型<strong>预测的分布</strong>。</p><p>​ 计算损失，理应使用相对熵来计算概率分布的差异，然而由相对熵推导出的结果看：</p><p>​ 由于信息熵描述的是消除 p (即真实分布) 的不确定性所需信息量的度量，所以其值应该是最小的、固定的。那么：<strong>优化相对熵也就是优化交叉熵，所以在机器学习中使用交叉熵就可以了</strong></p><h4 id="为什么使用交叉熵">4、为什么使用交叉熵：</h4><p>​ 在机器学习中，我们希望模型在训练数据上学到的<strong>预测数据分布</strong>与<strong>真实数据分布</strong>越相近越好，上面讲过了，用相对熵，但是为了简便计算使用交叉熵就可以了。</p><p>在二分类中，交叉熵损失函数如下：<span class="math inline">\(y\)</span>是实际标签，<span class="math inline">\(\hat y\)</span> 是预测值z经过sigmoid函数之后的预测概率。</p><figure><img src="https://www.zhihu.com/equation?tex=L%3D-%5Bylog+\hat+y%2B(1-y)log+(1-\hat+y)%5D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>Sigmoid函数如下：</p><figure><img src="https://www.zhihu.com/equation?tex=\sigma(z)+%3D+\frac%7B1%7D%7B1%2Be%5E%7B-z%7D%7D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 交叉熵损失函数一般用来代替均方差损失函数与sigmoid激活函数的组合：对于sigmoid函数，当 <span class="math inline">\(x\)</span> 的取值越大或越小，函数曲线变得越平缓，意味着导数<span class="math inline">\(\sigma(x)&#39;\)</span> 越趋近于0。以单个样本的梯度下降为例子：</p><figure><img src="https://www.zhihu.com/equation?tex=z%3D+wx%2Bb" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\hat%7By%7D%3D+a+%3D\sigma(z)" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=L_1(y%2Ca)%3D\frac%7B1%7D%7B2%7D(y-a)%5E2" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=L_2%28y%2Ca%29%3D-%28ylog%28a%29%2B%281-y%29log%281-a%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 前两个公式是前向传播过程中线性的部分，和非线性的部分。L1是MSE损失函数，L2是交叉熵损失函数。然后我们分别用L1和L2对参数w和b，利用链式法则求解梯度。</p><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+w%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)x" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_1(y%2Ca)%7D%7B\partial+b%7D%3D-%7Cy-\sigma(z)%7C\sigma&#39;(z)" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+w%7D%3Dx%5B\sigma(z)-y%5D" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><figure><img src="https://www.zhihu.com/equation?tex=\frac%7B\partial+L_2(y%2Ca)%7D%7B\partial+b%7D%3D\sigma(z)-y" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ 可以看出，<strong>均方差</strong>对参数的偏导的结果都<strong>乘了sigmoid的导数</strong> <span class="math inline">\(\sigma(z)&#39;\)</span> ，而之前看图发现sigmoid导数在其变量值很大或很小时趋近于0，所以偏导数很有可能接近于0。反观<strong>交叉熵</strong>对参数的偏导就<strong>没有sigmoid导数</strong>，所以不存在这个问题。<strong>这就是选择交叉熵而不选择均方差的原因。</strong></p><p><strong>分类任务的学习过程：</strong></p><p>​ 用神经网络最后一层输出的情况，来看一眼整个模型预测、获得损失和学习的流程：</p><ol type="1"><li>神经网络最后一层得到每个类别的得分<strong>scores（也叫logits）</strong>；</li><li>该得分经过<strong>sigmoid(或softmax)函数</strong>获得概率输出；</li><li>模型预测的类别概率输出与真实类别的one hot形式进行交叉熵损失函数的计算。</li></ol><h3 id="二回归任务常用损失">二、回归任务常用损失：</h3><h4 id="l1-loss-平均绝对误差">1、L1 Loss 平均绝对误差</h4><p>​ <strong>目标变量和预测变量之间绝对差值之和</strong></p><p>​ MAE曲线连续，但是在<em>y</em>−<em>f</em>(<em>x</em>)=0处不可导。而且 MAE 大部分情况下梯度都是相等的，这意味着即使对于小的损失值，其梯度也是大的。这不利于函数的收敛和模型的学习。但是，无论对于什么样的输入值，都有着稳定的梯度，不会导致梯度爆炸问题，具有较为稳健性的解。</p><p>​ MAE有个优点就是，对于离群点不那么敏感。因为MAE计算的是误差<em>y</em>−<em>f</em>(<em>x</em>) 的绝对值，对于任意大小的差值，其惩罚都是固定的。<strong>针对带有离群点的数据，MAE的效果要好于MSE。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_15_642.png" style="zoom:50%;" /></p><h4 id="l2-loss-均方误差mse">2、L2 Loss 均方误差MSE</h4><p>​ MSE的函数曲线光滑、连续，处处可导，便于使用梯度下降算法，是一种常用的损失函数。 而且，随着误差的减小，梯度也在减小，这有利于收敛，即使使用固定的学习速率，也能较快的收敛到最小值。</p><p>​ 当<span class="math inline">\(y\)</span>和<span class="math inline">\(f(x)\)</span>也就是真实值和预测值的差值大于1时，会放大误差；而当差值小于1时，则会缩小误差，这是平方运算决定的。MSE对于较大的误差（&gt;1）给予较大的惩罚，较小的误差（&lt;1）给予较小的惩罚。也就是说，<strong>对离群点比较敏感，受其影响较大。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_11_35_12_56.png" style="zoom:50%;" /></p><h4 id="smooth-l1-loss">3、Smooth L1 Loss</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_04_33_822.png" style="zoom: 50%;" /></p><p>​ 从下图种中可以看出，该函数实际是一个分段函数，既解决了L1不光滑的问题，也解决了L2容易产生梯度爆炸的问题。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_12_12_05_00_718.png" style="zoom:50%;" /></p><p><strong>Smooth L1的优点</strong></p><ul><li>相比于L1损失函数，可以收敛得更快。</li><li>相比于L2损失函数，对离群点、异常值不敏感，梯度变化相对更小，训练时不容易跑飞。</li></ul><p><strong>参考：</strong></p><p>https://zhuanlan.zhihu.com/p/35709485</p><p>https://www.zhihu.com/question/336677048/answer/761385679</p><p>https://www.cnblogs.com/wangguchangqing/p/12021638.html</p>]]></content>
    
    
    <summary type="html">整理了一些不同任务中常见的Loss损失函数\信息熵、交叉熵、相对熵以及相关的基础知识内容。</summary>
    
    
    
    <category term="深度学习笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Loss Function" scheme="https://blog.slks.xyz/tags/Loss-Function/"/>
    
  </entry>
  
  <entry>
    <title>博文复习日志1</title>
    <link href="https://blog.slks.xyz/2022/02/11/%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%8D%9A%E6%96%87%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%971/"/>
    <id>https://blog.slks.xyz/2022/02/11/%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%97/%E5%8D%9A%E6%96%87%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%971/</id>
    <published>2022-02-11T13:52:19.000Z</published>
    <updated>2022-02-14T13:44:24.246Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="9302e26568693389befc2e812a989979b388c13de4e3eae4e1ea6628aaba32fe">0b64cd3abe5b0a0a039a37d86c66d75eaeb9cde5c6dadc3c6d4d424e956e68e5859de93c067c256c245d75df485065102f6e2903c24acc225d3947c06b46eb863dd4b5852f98aab38803012f003c6c5ce6fff79afb10e1792ca7214d925987e0c717d406814885b789fb91e2e91f62e79489c1eb338c6615f677769d830ccf190fb9bbb686abd703322115c45664a457c7196ebc5128f0dbc61fa90adc2470af75105015c70e866cf9e65b8431b286f91724aada9a9fd5965d62719e3af60032aa7a2f77ed452eac7ab39f33c601c5d6de7df46cb4de25570ccbf95f141c0967a7b34c72683919d199358e5f05f83fc8af0d4a187180a67e0dfe958e0af9d66d33ab8d086e02df177e615e8042752039b5aa8ebbbf03fd595157a16f93e9d8aa7f0b856ccb5a1ec0ac5a77b1362d12bdc9c4ff39d2127ba4fa1a34736ed266b04fafccd0a982584b7e617ef2c7abee5c2cc4fbc96fa0391fe18bb0613a55fbdf71d01cafec27c0e41772b97d10dd173daa0e0dc1b05aa7b9d97e8244f9fba4f4018e4818e86e70f34c862bd69d9675ed15877d5449c4b7e8a6d6bc656ea82eba26ae72ad6ef75be44700be429e708bf43289740b82d67832194999149db733dd79f9775627aca1553102949d134429a4b5ec014c19965b51aacdd0b8af88faa8f0dd23ee465a91973610403e7f7015e27c4ca73425c835a103746324927ac9961a1fbbfa364ec6f09dca400884a8cd26d49df0e797f917bf5e1ddd4ce84f68c180d01f4a2b8fa7ffb12c378c27f7d149c0574024f6c7d997926a562382a75b7df0671abdb0741935b21dd625401ae2c8d83fe10f25ad46985c2442617293a87fa44bbe23878f5f0a341dd752b7d2f22ca0c80b746b4da56555f586c5ff770b6bc47b247939fd87fd97df54dee143d09a3572eb4097e5f0acb6a7c82b3d0bd31f0a92cb99e2c8c3cab16ed7b365b2a600a5fa080289d1d865a6b4c227ecbbb2fd1d2fdfd66082ef6074198a5aaa6aba8d4829da5c094a86176a0841491ccf4dc7ee545dd7a034ee8259f5f0011b7db9e433b4673050c085dd734b2e70a09f2866709876a15e124d99989ea943727a984ca6d5fc822e64d93de977821ab9d78a78ef14d4567d09ff69b40b6e6c01fc6b8680b5e704e23e00aedbcbea610a97288743de8f574fb680a2444d1c9d3f94bab3288a3ad504535c89a6c20f7dc83354a56877fb4beb4518dfce2d32f5293c16af8aa7f66eb6226c5fa93f423ffb44e166affdca16f9a05ffbdb05f1f2538680745a068f73f4f030afaf58b008316ecabc4bf15eeeed12b2a52f68c9ea007ac8768c5c6369f545833605181f6bac06257a122e6ffbee6c14cf2560e5a3b90604789144a509dcffc9236565ac7c26ffdac2199fbd3f470921f9c58fce79be41fd174f513de5530a298d2163c94cb7367570c6d709e3c6eedf24bc7f3e257d899a37ee636ba4fe04cb801f41d3c5b0716f199f23245ae06122c75a258215886896d8e941bf301108f3462f67f73121ea5b0aa5cabb8acfc32b4daa04a6014d2b05523627fb55d8b62b8565d6f2742035f260619cdae288d7b95e305a7b63421ceea761a047995e93ac206cdbf1fe479b687041f30d9083acd89f42d977a9257aa6f25950b3aeb3f06861ce31b9a0be69af54e637cb197c1238eb3fadd76adb0a97a323c64e2a34f9bdd00d779740449a5558edfc0187cd35c7a2ee95e0c21a0d27cd826e9416d9c405093e796a880a3a0cc20dec018e9c71f66aab54c8ebc7b2080498895a41512129103fa751121bd758cbd12e794685d1087a2844eb0494812bd86a5ca45157ca56a8e9451ea285e0f4c4aa3fcf8ea8af6c5021bba6fd67f9c2e3fc9aa5ac9f3c02a1cb57ce09b545d81b93cf3a9ed1c9cea76e5f2c8324a405e21bec4f37dd50b47d82cf68e0be38d9c8abcb3dfdf7086e46fe9a474e8253fc2d4a50b1ea681c53f39eb8051d3d1d7100b6184437a37ff53f34faf3f2b2e76e117ce47273c0fe4f75873df7fc377e1c3b7e8a180207ec326f2caaa79e5e672744f6795f10a78abef27b27e0953f29e2feb01fd6200284d0fb97e16534f8a234e4cc3134f5a103d2143b40523d277cda610eb3ebb53cce25b589fb3202da36018584b201f0efa38ec2d614a655cf21a56a0cbf67f439514f3445a07592f65ade23ac22f420830df90c395561b29e21156abd5e8af33cfd468013c1f04c0e3220820eeb86cc17d45798140c744c786b738ba23ae99675f189ee70dcf02cf5744c19b5c1084f3400caf5fc6b6456c8832e41d92cb1b664fd0297157d64629fd388961ee389a5226b60068a0eb0a78d48af553412d2e0866a1acbb5fb1f1754dd617e9f97b7c8f52cf8f2e76ec50e6c35ab04a5db2145b09344ec548405ca26274d6ac8471a1cb6dfbb1b616c26b2e45c85e87bd1a542563eb2b0c0d8f1ba79af341c4734c93cda4e93e05a8e1963c7ed0d320281388e552965dd33ac8f4e7ab0e38b7eb506e41b123c270fba5731b62372f40e5a4723155543790496c3e13e8999601978f9b51cfeffd3384b131367ea10bf445e905999513d0fae7f1293d91824a27fd8ebac8a0d614838ffbeb5d96f92522291435daba7c4fd34641136cc74009ce4da35484a180b2cf738d560196729705a95fc6e4a0a131e7ad1f6e58c6a5509fc0d193db3581f1529c91ba368f33d8d436d1c57eeb9efc2222b43f9c05ef45ef9cc7af5d44d73b8eee95061490f3755d80b7401f215ed7d358736f9e39b8664b73b50b8f6928a09bb3e3ec9f7f0b12dcb33638e684fb1ea23e182002d69213033ff32081f3677d4da9f4da9a6200d32af6345611f43a811b90c14b113e7efe51db0ffa66c63d8c7ef4b8f8c4c18346de3ebc2904386dc5909f3fcf87c3e538f98362ebc9ce8a2b9a3f1ee4e98c79ffe505049bf3ecb03d052e3c9005687ce224189a0a7b2cad32cd6e833f8d5bb900d08735398e5b930bce023d6700a90d05ee7774743910920e9e3127b35043485ca0fba788a988c514c45f8771f704a5c934f4ea0f6bee0a9dd76d8b493f470fb2e321558b3ef19151eb97ea08471a0b12c6ecadf139849d1609986cb0dafe576df189a60085cd29ade011e7cf9c7b63c5f4ed81c9bd40c26fef4b225d8b26ed8ec94338e3a651d4f2573204f1488c488aed9af338a630e02ee8b4ab8727adfc060d3c1dd2ae37f8c589666037a6718cccae93b8f3b976b4b5a17affd40008cae1689ee249ef445d8a5315cd21a1b957efffd6524bf3645cdc95869f2a43dfce4d6bb71ba4008f2ae005ecdb12f9bea4722ad836b1f6abd424ad3f02a02c048567c3bdcf7f489566d44c5f3a21877698bf9163989c22dcc3647e3340e114266381801df786c6fde82b052c4a521fb2b26565c0c5ccb2569dde84414de256a78df1118cbb08cfdb14bb87ec1ded2f0b7e718e31e7288850d76205ab005d98a8374a0b8f55645919e7cc4380538b0079f8f97a3568c338015907111df6c0e490ee582677d72b80b33f01aac61326d41897a9d56dff2b683c7624b4bb4e71cd22e78f8d73d7a99607cef2ad26379416f969a7aa52ad973121799a09771d8c6e53787477eb859168e7a1b0705df97724abce2aba5d1b56616715438c4340e26268622e3b36c0fcd21b2fd51b0ef6b9489a6abc6299b6589ac3b59bcd182369968bce00bc7499b75faba475e52194c0d7351be37c8b220308c3aa04af599c19818cf275ff8409f84d3ed6846706f63b57c0520e3d3914f32bf9daceed10d3923508aad66e5468cdef671d6521c001af5d1056db3a104ad7eda6df050b83fdb74b20ccb7d2e55d060e3e13e41bfc5c1768305bfcf8b2a2e42eedb1f7d4c36b3ec4e182c858f6935e0659eef7cb687f654e27c4194c9690f8913e66a1df9f524b93faf1789c017e752fce9b3c19d5ba755c8281bc003aa07b1537b42ebf5c7c72e175537947c719b4174ae642709e174a24dc783d8683a86b46ae911f18b8624a7ce3ce95e5ebfdb0762630f91e112c550b181670b270e448fd8137c1286d169687cfa238160af723dfdf68ac2c08121fe171ddf04398b89572e89d310ce51cca6d0e3e83ef651f5803a25b76bf1e56714ea20a2d59262c0c79fae0c5f8c1142849dc71846453e3e44d3ca15dd957b7ff142ea7515ffc29746edd2b3b7f2123e99351d57dd389ee95aea4c95a5daca51ec908af60f0f874e7d1dd5ea16b45b0a08438ae03934832a57b4eb05d5d45b9aded03aadd4c4355e547ed8e6712fa77a593e4348256e43cf9c457ed43e71f682c2b2560c05a07b4a58b185cd8841e6ba6fd67d73653cb75a48ce953e442b7d8aded7820d8ad88c01738d53840eb97fa0170aa906d3a3d19251eb62c7d5cefad20534e842ab6a6f8833652eb7fe3d2a8434a1bb608a641d8305d8fe0ffd82afa4e05bb49274dd2f25bc06f0e5709430546677a16ee2895516a3b1566ed871465b757d96de519b66a0fedba63db1e6a7f8acde51799a6899fadac2739c9db87554366ae78a214d0e7fc5b1129016e43191b9498e6b706b6a7d5cb2f722ce1fc92de85b086801bcad477e878ed54a806f8fa75e181d622b6144d2a7d9f324cf12b4742d0f2ffd709e76eb43bfa5f3aadfda1ebda7b42163ea30c25dcd6e63bfec70856506ad61d1131b967c31b80799d5b1f174815681a7619a1dac6e829c40052212c2c706a22aa0d97b4501a30dd95969bef0ca547ce06c332515949848406f745aac58e55d105aed8ebac0e48d0de5c13d59bc2909123bf0bf5371f9435eae0de5e914b59526064dae66e3cbf3a60068d931a9aecbf3a1b4f79212599d2430a2df08635001b0d8af82069cce9a8797a9790124dab8a9ee89f17cefbbb6acc2e32e41be790b6ae96d8c393ba11679e8ce1a63b0bb000c229e7751a61ea81d3c3c44d59268df8f596a139e3aa88f84b017848bc8a7baa43d82ee951c3ec3224dcb1e45cc25c25c16a9587c7c8c9b33d6eb9230c28a5c0171ecb5cbca8437d0c4448528817ebf1fdd49db23f435a0025729d5f1aedb81ab0c639f04f338b71cc21ee452eafb906a1c79caf96312012dafbab3a8755fc12970690469552f5010579bbc402ae9d5a9a4407424c7540a3a8ae24d023fe4ad81d46af4fcf9df075f031610f35aa8bfead9604d261440b1769cbbe8ab0057a4d2d73851178129b53fd4acd7c9b73607c5fd45f2c7a4297821cecca8af303eb2afc662c59178fe52b831febcfe43132f774f1812bd70a9d56f3cc0df29eaa992f9bb86ebef276a755324c5cf95836ea035123f7fbbdb36544a01e102abde77101208ccc39b0af8418344850da76b3eb59b86e15b366314f4e2ff9c42355b709a2844b8a98334c5b2e0cea421883bcabb3e2f6ae7f7c0eaf6f03580a27b2b436174a0ebb503670369e0b988e67007180cfb2eb2eaec83caaa4c46a9686e9faeed294c8becf3165104e3b064fb035fb1c0420522d0759860c332627cf5962f1f0fda9af38b9db4ecc9ffd789b7a6a6c192d59c8b53987b5bb122476f3f449aaf8276157489a208b70996a2922d8232653023c76a1fe8f5a06bfef453f40fecda9443320ef22569e2d2461e5ec13843ea71cf3e258459a925bf0a9d72e43b0f38f0220874d00d62e07d94d5dad15363a425d4ef140af91c28933402c929beb533ac6b41a332e80709c98f3a1772b8bac58a052869d4e81dcf934671b64d7d87b44253871f36e19902c967d817feeb6f110c2797484558ebe99686f4eef432e8c0a0647722f5222ac07d54beb61e54d9026ac50bafcabbfb150a5c844505447aa493a3af104a7c81ef4f2d962eb59ad4ca45a6486f8275ba762330256ecf3d18b9bc9de8ebdc6dfcbc30ae36e92cc23e8cccbc8932f5badb98e22e73eca1b3deeac4aafc894ec75b8680da83f90ba4980bb87cfa143178358e87ef71e67bcf0fda2dd7663e017a68888bdbb313fca84af6bd5bd8e4202cec5353e0deedb691c9c23f960ae4f233f08dffe709819d4aeaee7f25ee6ed4aecf8262174f70af94761b1037263c79beae37e46559457362fd0f12daaaa4d32bd43e1b7895a83d16908f516c6ae2ec25649de85b0af6b66c7c75cdc9ec41cfb5149216efc7b672a866b4438a88ec482e9105f33cd089f93023fd6cbb9187dd7ee42ed9b63a5490b96375e9508f76c5c74343f62059cd73c0fde414cfd63fd858290690e21f7c4ebc362a69df4b3708e6d98e4f80248ef85311e8eb147afb15f5b5c96ceb722e89c2d3a0c4cd6cbf9ac7fb399bfc89b76c14a39dae6e2845ceb683b70d1723f9e7ab09781ac5649dd87f7c9c4d1dc9e8d2df19584c9a5f21428e2137a6e0316dde4416713ceff517cb6e89992fe7f7acd745e11497124a6d9e8465bc0fa0ceb929dc40aa6229abd9bd168d0602daa4c054543ea57077b2c91c0bf1d3103bb99b6603de692e63d09e9e6257dbb154fa08889799fae347bf2d07c7cc27cceb41a0c06af9117c6a3e633efc93da74eaeabcce0648dbe3cc3ee6ecc16873173c4ce32afbf16ec12a5685ea550eac95b70c6b02a72703e5816a20b9ad34c30ba5226aee205db72fddf7e61808c25b7ee0678e155700500d71ce017c6afbfabb9799b454f2b4775dbfdcc3e2b7aa20483308d08cbb2ba948dcaeb823378ce8b68ccd71fe1f8774c7668f0da538b3eafa624d7e811971f7f513c5f6ef455d842da042a0c10f977e9411a926fd6296e2ba00cb389d67ad0c36bd4d954ffcc42d288b31e7f20ed18ccb4123a9dbc5221cca7811ec5dde15ce32ad946a82e7faa9fd9ad4b425dad0cbc588ebecd762cdd43d1543fbe567c51e58a176439c9a772ac264568a6333d8ab7867ba6c693ad2cfe0cc4cfc649e926387478823374e4078a8780e4d2c87246a1ea7387bb70ffef67347c3f0bbfe54f24316d6b59c266b1326b9b3ff73808833e1bf25f2bc889e7759007240325601a29035899d63f4881bc4e3c62b6fe09cef51e725385fa33c9e06d656c70f2261d44b319fbb8fcdc888a95f2bfdf21d87c216f9d292e84f1b466d005e4b2c5736d94689a4c21bf349e36180643b30909e8430ea26612d280ee580346148324faed3ea840fa417fdf0703f5e0b8405262e9a09718a12071721c24594ee13ff6a3edbf159b689ca4b35332a7772c717ad25c227ccff14dfd4bd880fb97335657c63c72fd1ca9ea131b3b302ab7f984a425caecd5c6196a4b88886b6916dd47e5bc66d8afe0da82a5f20b51b132423a40de2c61c1890c41d0a110292ee9484e2e9d5c65b6dc1d54f21f6d60b68f444c6e6f982e40d78e758de92777d345eb0803422375692569da02caccb397975f2040b7b50651d392c1f4427f5483d78e5f59d2b3aae224f53f74505212b83e0ff7385fca16cf73ec3d93da06446b2291da85385253fd5b73ae1fd9f4d1284f590c07c107d9e385c82efb4d6d84ae14522c1991524bebae8986916c7ea8555655a3f1c59885589f8683a41af368b697f313bbf7a44b3636bcbc57c0cca1b70c3916036aa7fa7030950faa938c5fb48b6354fe585a754360065c3c840f7b623c8f2f21a19b2c014cdca135d864d9aae702aec3f3d8f8185656f4cb0e5b37d02edb63040f7ea52a2d40f00e861f66cd17a52c1d42468640c2bc128454c41c131b6b0e2189b48830fcd59259b774bba1e2a900763fd6161473b2b4fdec459405e530018e81aafabe8ae90d4d2f33d1d3d3fea72c82b6a13032c3b2ea5171ce003062356d967f4651be94556aa392373d4b65434076457c1dd077126ec92d4ebfda7761f7fa7853a4229b745249ef5682bdbf096a52941f25fe2ed3c7897ae0ceead54471ed255eac598ecc245dba0f3d287f5f13a5e5311e0d752555c0331ab49736ca13916970522e5d7932354a48903e5dd577584abacdf2fa393de0a30090c29e7eaca41c9a001d84fd6d51da85eb118593963c9b46b0326e3c514de8c80af84725fb6ca5db7aeef29404eaa1ada76df748cd32cf2f30e8d64cad27e09345fbbb27fcbad4adddc9523eba92598c259ab8f98664db9210fad73a14a491e6c99354b89669d085199b3949a0e010a3e812ee0170aee3feb00c5ad23a40439e0f650e451a57a8c62d176254e95972b47281f526708e0c8804840d9356e5bb0a71429d89f234334a724a9f5e99b2b4079721caa6722c308fef24431950bcbe41c4efdb367cde5e829b8957e284c041b780e4fddb25c56cd69cb2765d3c2ad05b507bad2caa0523a752bd87a64467e932c4be501acc2f258a32f55886e21d18ea47590a9cf8d7a1c522c7e9cb2aff8fbb1ad42b9d3494c32656752449ecfad18b7f060c58b70ff850344cc0cf96542d7bdbda1e7cb9bb67610bb318edad18b6cebcea779e65db59b28824e320a5877b6b799f4f4a42ff5382ff0cd3b0fa8f132ce1bdedf24e0b3951bd633da9e1f00cbf48ba4076bd455d01d7084560526d8192841a6da6ce5d169b11586ab95655fc52f80279103529529ecbc16f5df283cd44464d29991fcafcc08b7a10bd59d927f6709ebee3cf7e03cd077e3e4fb5500cf95d1985b231bd5bb64dfb2ff46d70fc265facb15e5cdf24b0a318783f30332ffb49f3ee60894944a0b86dc188c6d725c9102f992caa8a0ed48</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">ML课程笔记复习 + 机器学习基础系列笔记复习 + 论文阅读笔记复习 + Transformer系列笔记复习 + GAN系列笔记复习</summary>
    
    
    
    <category term="博文复习日志" scheme="https://blog.slks.xyz/categories/%E5%8D%9A%E6%96%87%E5%A4%8D%E4%B9%A0%E6%97%A5%E5%BF%97/"/>
    
    
    <category term="Review" scheme="https://blog.slks.xyz/tags/Review/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记16——常见的梯度下降优化器整理</title>
    <link href="https://blog.slks.xyz/2022/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B016%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E4%BC%98%E5%8C%96%E5%99%A8%E6%95%B4%E7%90%86/"/>
    <id>https://blog.slks.xyz/2022/02/11/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B016%E2%80%94%E5%B8%B8%E8%A7%81%E7%9A%84%E6%A2%AF%E5%BA%A6%E4%B8%8B%E9%99%8D%E6%B3%95%E4%BC%98%E5%8C%96%E5%99%A8%E6%95%B4%E7%90%86/</id>
    <published>2022-02-11T08:54:19.000Z</published>
    <updated>2022-02-16T06:31:41.036Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一批量梯度下降法bgd">一、批量梯度下降法BGD：</h4><p>​ 更新每一参数都用所有样本去进行更新，在下面例子中，总共有n个参数，m个样本，我们如果想要更新参数$ _j$ ，就需要遍历所有的m个训练样本，然后将所有的梯度累加起来取平均，然后再进行更新。</p><p>​ <img src="https://pic2.zhimg.com/80/v2-890e5ab2843f3b22467a5e6aeef58b59_720w.png" /></p><h4 id="二随机梯度下降法sgd">二、随机梯度下降法SGD：</h4><p>​ 由于BGD每跟新一个参数的时候，要用到所有的样本数，所以训练速度会随着样本数量的增加而变得非常缓慢。随机梯度下降正是为了解决这个办法而提出的。它是<strong>利用每个样本的损失函数</strong>对θ求偏导得到对应的梯度，来更新θ：</p><p><img src="https://pic1.zhimg.com/80/v2-65566b643790ca6c89919fd970f34e2c_720w.png" /></p><p>​ 随机梯度下降是通过每个样本来迭代更新一次，对比上面的批量梯度下降，迭代一次需要用到所有训练样本（<strong>往往如今真实问题训练数据都是非常巨大</strong>），一次迭代不可能最优，如果迭代10次的话就需要遍历训练样本10次。<strong>但是，SGD伴随的一个问题是噪音较BGD要多，使得SGD并不是每次迭代都向着整体最优化方向。</strong></p><p>​ 但是可以并行化计算。</p><h4 id="三min-batch小批量梯度下降法-mbgd">三、<strong>min-batch</strong>小批量梯度下降法 MBGD：</h4><p>​ 我们假设每次更新参数的时候用到的样本数为10个</p><p><img src="https://pic2.zhimg.com/80/v2-9d473c89948f1ddc8c4f294c55123f59_720w.png" /></p><p>​ <strong>随机取batch个样本，</strong>而不是1个样本，然后对参数进行更新即可。</p><h4 id="四冲量优化器momentum">四、冲量优化器（Momentum）</h4><p>​ 在Gradient Descent + Momentum的算法如下：最开始第一步和原来的一样，从<span class="math inline">\(\theta^0\)</span>开始计算梯度，然后沿着梯度反方向移动下降，达到<span class="math inline">\(\theta^1\)</span>时，此时和原先就会发生不同了，其现在的移动会结合前一步的movement（即<span class="math inline">\(m^1\)</span>）以及当前点的梯度<span class="math inline">\(g^1\)</span>，计算出一个新的下降方向<span class="math inline">\(m^2\)</span>，然后进行更新。如图所示：<span class="math inline">\(m^2\)</span>是由 <span class="math inline">\(m^1\)</span>和 <span class="math inline">\(-g^1\)</span>两个向量相加所得到的。从公式上来讲就是$m^1 - g^1 $，两者都有自己的参数，来控制影响整个梯度下降方向的比例。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113022761.png" style="zoom:50%;" /></p><h4 id="五adagrad优化器auto-learning-rate">五、AdaGrad优化器（Auto Learning Rate）</h4><p>​ 如果Loss函数在某个方向上比较平坦,梯度比较小，那么我们希望Learning Rate比较大，快速的走过这一片平坦的区域。如果在某个方向上比较陡峭，我们希望Learning Rate比较小.</p><p>​ 将原来的学习率η修改成 $  <span class="math inline">\(, 这个\)</span>_{it}$既跟参数相关又跟训练步骤（不同点所在的梯度）相关。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121170754841.png" /></p><p>​ 以下是σ的计算方式，通过计算每次更新得到的参数空间所在点的梯度的Norm值的平方的平均，即RMS来计算每步中σ。</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113547513.png" alt="image-20220114113547513" style="zoom:25%;" /></p><h4 id="六rmsprop优化器">六、RMSProp优化器</h4><p>​ <strong>AdaGrad的进阶版本：</strong></p><p>​ 它在计算每一步的σ的时候，结合了上一步的σ以及该步的梯度g，同时还有一个超参数α，可以进行调整。如果我们调整α比较大的话，代表其参考当前的梯度较多，也就是说如果梯度突然产生较大变化，其就能快速的反应过来，对LearningRate进行快速的调整。相较于前RMS所有先前的梯度都平均权值考虑的做法，这一做法能够更快速的对梯度的变化进行响应。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114113634056.png" alt="image-20220114113634056" style="zoom:25%;" /></p><h4 id="七adam优化器">七、Adam优化器：</h4><p>​ 综合了RMSProp和Momentum技术的优化</p><p>​ Adam可以理解为加了Momentum 的 RMSprop</p><p><img src="C:\Users\14012\Desktop\d50735fae6cd7b891692d4d0b34087a1d8330e56.jpeg" /></p><p>参考资料：https://zhuanlan.zhihu.com/p/25765735</p>]]></content>
    
    
    <summary type="html">整理了一些常见的梯度下降优化器，相关的基础知识内容。</summary>
    
    
    
    <category term="深度学习笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Gradient Descent" scheme="https://blog.slks.xyz/tags/Gradient-Descent/"/>
    
    <category term="Optimizer" scheme="https://blog.slks.xyz/tags/Optimizer/"/>
    
  </entry>
  
  <entry>
    <title>科研方法经验整理帖（待更新）</title>
    <link href="https://blog.slks.xyz/2022/02/11/%E7%A7%91%E7%A0%94%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/"/>
    <id>https://blog.slks.xyz/2022/02/11/%E7%A7%91%E7%A0%94%E5%9F%BA%E6%9C%AC%E6%96%B9%E6%B3%95%E6%95%B4%E7%90%86/</id>
    <published>2022-02-11T08:27:23.000Z</published>
    <updated>2022-02-11T08:25:51.436Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="78aebff3f21474859eea069c0aa5c0a529296882e8f50aa3379a7d94bcebd625">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b65856d18f3658e019a32f1894ad03d5b43cd3328e3f66535cd458efc00fced97588ae5b90ce7a87482e304e348cff487d0a7f8bcf0295640ec945ed8d5e406b374abc5bba690c86f2886f3362d4f623c32b36c4f794256435eceb4da718881a9e7c2533b6e6d91c809af5f27331ed2f2fb22cacb3965452f407d7f6ae923d408cd92a4317a17f49af58f77d2f15111feffb8148525f76b08d07e6251bb129a663faf652a3bc98809d7ff7a3a14ee27d9be1abd84c0104ec8f806657a52f5a1daf5f07adc5bc057b952c3cf5900f7c35b9ab8fbf98132dcdfa00cf47b1a443e11718700d2a517a2241b256ee3a4a95b58c9e4a629c6ecf96a067648570369f958143547c21c4af91b3be855606102efe201b16ad62f39df0eaee7cd71768b33debb3582eeb31d8f45ac2724fa746620ea8194315003e007ef9f18c12f9f05b78ab4221720ec308f2063f7395464c5e5d6be0979f7fa163b0151d8bb77f8bdb49f32509359e981d66fc81cc21e3d91ef38867369f64baf096500ad895b2d105eae48d7b0cb9a86bef3ce31b1a09b6d4b95fb7567de9080fad3fe9ea80e88d2b1629c435bdd3de51ae48d7bf4db692f075853f10bf0db1699d57a0bc772d5a63ea25b31c57a72b12977dd4ccf35dd254570a3ca4b3529af585f4669945095193c0ee7c5b0aa041d22ed94103bb8e5b1e06fe05a85be94ab2cf23c7a3cbac506f1b441ef822b5d1e5b956a769f8916c5aa01aa09680bb95a37dc6a937977735c703e44c51e3c901fbada4748c2abc33d52aa2160be9bd3cdfad2de9bd9243b1843c51901bc2e43c71769bd8148fb7e7d85bd3a6d3f7d93dedd1cc52ae971a3edd5ce0675801ed8a11a68b088d418db3aecaf80125ad0f5d0e3b824eb9a359473df6910f49944b68599c952462f781673563c867c7198b46b14b582e74c0f919a1f8e19a57229942155d146417e8baa7074448898c65e11ff73087e94a1537bf7ae94a281174267459ec4f005a2fd9e37a7385fd6afc35343c6af7298e741af541d397f5123ecf7d2a1565cee5a38c9ebf15707d94a789a52b0b02890595cccc15541502d70d731693976b0c03d28de438a60775cdf1084e9c853e7d9e28ee351a2d8337611940f1ddf52d68cc97a118372c54f26c7fd8d74df21b2015e105a365d57c981561924e559ddc2c5a1d167f55ece4106df2802653517880f2ee2fb37b05883456e5d5de7a1e05acdf5504788352f28d03a810b24f8b7ac309d1d1b024d487d53a58cf6a6d14ec244986531e432edcee36fb0b41d8ae26399f14178133b01c5c7373d1cc8d06b49541e361dd45bdbd090446979781b3d6e9727b6ac2d3eb5e7391af68646cd0a5523d446835f88907509129abe9af4dabb6de925f8b616bbcb533e6d96dfc0abf900ebf282e0a65086da1f96b03c71565d32d230988996215f0152b87d73248e1b6ac0af8dab915818</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">科研方法笔记整理</summary>
    
    
    
    <category term="经验整理" scheme="https://blog.slks.xyz/categories/%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记15——探究深度学习框架底层(使用Python搭建简单的深度学习框架)</title>
    <link href="https://blog.slks.xyz/2022/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B015%E2%80%94%E6%8E%A2%E7%A9%B6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82(%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6)/"/>
    <id>https://blog.slks.xyz/2022/02/10/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B015%E2%80%94%E6%8E%A2%E7%A9%B6%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6%E5%BA%95%E5%B1%82(%E4%BD%BF%E7%94%A8Python%E6%90%AD%E5%BB%BA%E7%AE%80%E5%8D%95%E7%9A%84%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E6%A1%86%E6%9E%B6)/</id>
    <published>2022-02-10T04:19:19.000Z</published>
    <updated>2022-02-16T06:31:41.969Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一深度学习训练逻辑框架梳理">一、深度学习训练逻辑框架梳理：</h3><p>​ 我们以解决一个简单的问题的深度学习训练逻辑为例，梳理一下在框架内部发生的整体步骤：</p><ul><li>1、构建模型函数 F（此步其实就是对应着用户传入的<strong>构建的深度学习模型model，深度学习模型model中又可能含有许多层layer</strong>）</li><li>2、确定损失函数 L （用户传入的损失函数，常见的有交叉熵、L1、L2等损失函数，还可能是混合损失函数）</li><li>3、依据 F 和 L 构建<strong>计算图 Graph</strong>（ 框架内部完成 ）</li><li>4、在each update中，干如下两件事情<ul><li>将输入的数据，<strong>根据计算图</strong>进行前向传播计算，得到Loss值</li><li><strong>根据计算图</strong>，进行反向传播计算，获得 损失函数L 对 模型参数 w 的 梯度向量（具体采用的技术就是<strong>自动微分</strong>）</li></ul></li><li>5、将 梯度向量信息与 每个模型参数w 信息 传入<strong>优化器</strong>中，更新参数，然后回到步骤4，循环往复。（优化器往往也是框架在内部提前写好的，几个比较通用的优化器：Adam，Adagrad等）</li></ul><p><strong>注意</strong>：实际上，如果对于一些简单的模型函数，比如 wx + b , 我们是可以不定义计算图的，只要我们人工的实现了该模型的forward函数，以及该模型的backward函数，框架应当就会在前向传播和反向传播的过程中，调用这两个函数来进行计算。</p><p>​ 那么，计算图和自动微分的作用是什么呢？我们知道，在pytorch中，我们在一个模型中只需要定义forward函数即可，是不需要定义backward函数的，那么模型又应当怎么去定义反向传播的过程呢？这个时候就是计算图和自动微分起作用了。因为现在的模型函数F都非常复杂，人工求导是不现实的，所以我们就需要依据前向传播过程和损失函数，构建计算图，然后依据自动微分技术，用反向传播的形式，计算损失函数L 对 模型参数 w，最终实现梯度下降优化。</p><h3 id="二计算图反向传播自动微分详解">二、计算图、反向传播、自动微分详解：</h3><h4 id="最基本的计算图">1、最基本的计算图：</h4><p>​ 计算图是用来描述运算的有向无环图，有两个主要元素：节点 (Node) 和边 (Edge)。节点表示数据，如向量、矩阵、张量。边表示运算，如加减乘除卷积等。</p><p><img src="https://pic2.zhimg.com/80/v2-464ea7ee4475f3c7f08c389f65fd3e89_1440w.jpg" alt="img" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line">w = torch.tensor([<span class="number">1.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line">x = torch.tensor([<span class="number">2.</span>], requires_grad=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># y=(x+w)*(w+1)</span></span><br><span class="line">a = torch.add(w, x)     <span class="comment"># retain_grad()</span></span><br><span class="line">b = torch.add(w, <span class="number">1</span>)</span><br><span class="line">y = torch.mul(a, b)</span><br><span class="line"><span class="comment"># y 求导</span></span><br><span class="line">y.backward()</span><br><span class="line"><span class="comment"># 打印 w 的梯度，就是 y 对 w 的导数</span></span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br></pre></td></tr></table></figure><p>​ 在上面的例子中，x 和 w 是叶子节点，其他所有节点都依赖于叶子节点。叶子节点的概念主要是为了节省内存，<strong>在计算图中的一轮反向传播结束之后，非叶子节点的梯度是会被释放的。</strong></p><p>代码示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看叶子结点</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;is_leaf:\n&quot;</span>, w.is_leaf, x.is_leaf, a.is_leaf, b.is_leaf, y.is_leaf)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看梯度</span></span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;gradient:\n&quot;</span>, w.grad, x.grad, a.grad, b.grad, y.grad)</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">is_leaf:</span><br><span class="line"> True True False False False</span><br><span class="line">gradient:</span><br><span class="line"> tensor([5.]) tensor([2.]) None None None</span><br></pre></td></tr></table></figure><h4 id="区分静态图和动态图">2、区分静态图和动态图：</h4><p>​ PyTorch 采用的是动态图机制 (Dynamic Computational Graph)，而 Tensorflow 采用的是静态图机制 (Static Computational Graph)。</p><ul><li><p><strong>动态图</strong>是运算和搭建同时进行，也就是可以先计算前面的节点的值，再根据这些值搭建后面的计算图。优点是灵活，易调节，易调试</p></li><li><p><strong>静态图</strong>是先搭建图，然后再输入数据进行运算。优点是高效，因为静态计算是通过先定义后运行的方式，之后再次运行的时候就不再需要重新构建计算图，所以速度会比动态图更快。但是不灵活。TensorFlow 每次运行的时候图都是一样的，是不能够改变的</p></li></ul><p>​ 所以，其实在pytorch中，比如你定义的一个继承自nn.Module的网络类中，你会重载这个类的forward函数，然后在网络训练运行的过程中，其就会根据你的forward里面张量的计算过程来搭建动态的计算图，并且依据此计算图，在反向传播的时候使用自动微分计算梯度。</p><h4 id="什么是反向传播和自动微分">3、什么是反向传播和自动微分？</h4><h5 id="训练时自动微分在哪里应用">1）训练时自动微分在哪里应用？</h5><p>​ 自动微分用于反向传播的过程中，依据计算图计算<strong>损失函数对参数的梯度</strong>。在Pytorch常见的训练步骤中，应当就是封装在 .backward() 函数中的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">batch_loss = criterion(outputs, labels) <span class="comment"># 通过损失函数，计算本次损失值</span></span><br><span class="line">batch_loss.backward()  <span class="comment"># 损失反向传播，计算梯度</span></span><br></pre></td></tr></table></figure><p>​ 举一个更简单明了的例子：考虑最简单的一层神经网络，输入 x，参数 w 和 b，以及一些损失函数。 它可以通过以下方式在 PyTorch 中定义：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"></span><br><span class="line">x = torch.ones(<span class="number">5</span>)  <span class="comment"># input tensor</span></span><br><span class="line">y = torch.zeros(<span class="number">3</span>)  <span class="comment"># expected output</span></span><br><span class="line">w = torch.randn(<span class="number">5</span>, <span class="number">3</span>, requires_grad=<span class="literal">True</span>)</span><br><span class="line">z = torch.matmul(x, w)+b</span><br><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure><p>pytorch在上述运算进行的过程中，就会搭建好如下的计算图。</p><figure><img src="https://pytorch.org/tutorials/_images/comp-graph.png" alt="avatar" /><figcaption aria-hidden="true">avatar</figcaption></figure><p>​ 然后，调用如下函数,即可计算梯度。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">loss.backward() // 计算梯度</span><br><span class="line"><span class="built_in">print</span>(w.grad)</span><br><span class="line"><span class="built_in">print</span>(b.grad)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">tensor([[0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359],</span></span><br><span class="line"><span class="string">        [0.2175, 0.0032, 0.1359]])</span></span><br><span class="line"><span class="string">tensor([0.2175, 0.0032, 0.1359])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>​ Pytorch 这边其实实际上隐藏了非常多的内部细节，从外表函数调用来看，根本看不到计算图、自动微分的逻辑，这是因为Pytorch都已经将其封装在了底层中。实际上，Pytorch的计算图是什么时候搭建的呢？其就是在每一个Tensor张量参与计算的时候进行搭建的：</p><p>例如，执行如下代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">z = torch.matmul(x, w)+b</span><br></pre></td></tr></table></figure><p>计算图中，关于x、w、b、z节点之间的DAG就已经搭建好了</p><p>再当执行如下代码的时候：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)</span><br></pre></td></tr></table></figure><p>​ Pytorch又将loss和z、y的节点关系加入计算图中了。</p><p>​ 同时，截至此时，x,y,w,z,loss 的值都已经计算出来了，也就是说已经完成了一遍前向传播，这时候这些值都被记录在这一个个Tensor中。（下图是torch.Tensor内部的成员变量，我们可以看到，其内部是记录了非常多东西的，前向传播的值就是记录在Tensor.data中，也就是其表现出来的值）</p><figure><img src="https://pic2.zhimg.com/80/v2-3bc1ff0ab920582a3491111b81a32fe5_1440w.jpg" alt="img" /><figcaption aria-hidden="true">img</figcaption></figure><p>然后当我们在外层调用如下函数的时候:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">loss.backward()</span><br></pre></td></tr></table></figure><p>​ Pytorch 内部实际上就是开始反向传播，利用自动微分引擎，链式法则计算loss对参数w的梯度值。对于我们人而言，是如下的一个过程：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dsa98uyc89dsahkj.jpg" alt="dsa98uyc89dsahkj" /><figcaption aria-hidden="true">dsa98uyc89dsahkj</figcaption></figure><p>​ 那么，这个时候我们就需要思考了，对于电脑来说我们根本没有告诉它，loss对参数w的导数怎么求啊？即使是按照上述靠链式法则去求，但是我们也没告诉它链式法则中的每一项的导数是什么（比如说loss对z的导数，z对w的导数），那怎么求呢？其实，这个时候Pytorch内部就是利用其带的自动微分引擎，去解析函数，然后进行计算的。从外层看来，我们只知道只要设定一些参数，调用backward()函数，就能够获得loss对某个参数w的梯度，外层完全不用关心内部的事情。我们再详细的先拓展一下反向传播的具体数学原理，随后会记录自动微分。</p><h5 id="反向传播的数学原理扩展">2）反向传播的数学原理扩展：</h5><p>​ 反向传播写成上面的链式传播导数的形式十分好理解，但是不仅仅是上述这样子。我们应该需要知道，上面我们都默认所有的字母都只是一个常量，而不是一个变量，就比如说 w 是一个值， x 也仅是一个值，这些节点，我们通常称之为变量节点，它们没有父节点，它们的值不是被计算出来的，而是被赋予的。但其实，节点的值可以是一个数，也可以是一个向量，我们可以用一个节点保存输入向量(x1,x2,x3)，再用一个节点保存权值向量(w1,w2,w3)。</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" alt="图2-1" /></p><p>那么也就是说，其实计算图中每一个节点都是多个值到多个值的映射，也就是向量 到向量的映射，自变量是父节点，因变量是子节点。虽然一个子节点可能拥有多个父节点，但是我们在计算子节点对某一个父节点的梯度的时候，可以把其他的父节点视为常量。</p><p>​ 举例如下：比如我们从n维向量( w )，计算出m维向量的映射就可以视为m个标量函数：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_15_14_456.png" /></p><p>​ 我们可以知道，每一个<span class="math inline">\(f_i(w)\)</span>对 <span class="math inline">\(w\)</span>来说，应该都有一个梯度 <span class="math inline">\(\nabla f_i(w)\)</span> ,而每一个梯度都是一个n维向量（因为自变量是n维向量）。</p><p>​ 以m个梯度作为行，每个梯度都是一个n维向量：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_19_20_861.png" alt="屏幕捕获_2022_02_10_15_19_20_861" /><figcaption aria-hidden="true">屏幕捕获_2022_02_10_15_19_20_861</figcaption></figure><p>​ 这个<span class="math inline">\(J_f(w)\)</span> 叫做映射 <span class="math inline">\(f(w)\)</span>在 w 处的雅可比矩阵。因为<span class="math inline">\(f(w)\)</span>是从n维到m维的映射，所以雅可比矩阵是一个$ m n$的矩阵。</p><p>​ 故而，我们知道，<strong>对于计算图中的每一对父子节点，都可以计算出子节点对父节点的映射的雅可比矩阵。 雅克比矩阵其实也就是映射的每个分量对输入向量的每个分量的偏导数。</strong></p><p>​ 在上述图2-1中的内积节点x = (x1,x2,x3) ， w = (w1,w2,w3)，它们的子节点 对 他们的映射，就是一个 n维(n=3)到1维的映射，故而，子节点到父节点的雅可比矩阵应当是 $ 1 n$矩阵。</p><p>​ <strong>至此为止，我们已经能够知晓计算图中每一对父子节点的雅可比矩阵怎么求解了，可是，我们最终要求的是损失函数对参数w的雅可比矩阵</strong>。仍然如2-1所示，w节点是h节点的祖先，它必须要经过 内积节点、+节点、*节点后，才会最终到达h节点。 这个时候，我们就可以利用链式法则： 复合映射的雅可比矩阵式组成复合映射的多个映射的雅可比矩阵的乘积。</p><p>​ 即复合映射<span class="math inline">\(f(g(h(w))\)</span> 在w处的雅可比矩阵是 <span class="math inline">\(J_f\)</span> 、<span class="math inline">\(J_g\)</span> 、<span class="math inline">\(J_h\)</span>三个雅可比矩阵的乘积。</p><p>​ （我们先假设一个父节点只有一个子节点）<strong>那么所谓反向传播：就是从计算图中作为结果的节点开始，依次从后向前，每个节点都将结果对自己的雅可比矩阵和自己对父节点的雅可比矩阵传给自己的父节点，然后这个父节点再将 结果节点对自己的雅可比矩阵和 自己对父节点的雅可比矩阵传给父节点，再前面的父节点会将两矩阵相乘，得到结果对自己的雅可比矩阵，一直这样子到我们的 变量节点</strong>。</p><p>​ 所以“反向传播”传播的是结果节点对自己的雅可比矩阵，同时也将自己对父节点的雅可比矩阵传给父节点。父节点将这两个矩阵相乘，就得到最终结果对自己的雅可比矩阵。</p><p>​ 接下来就剩最后一个问题了，<strong>如果一个父节点有多个子节点，它应该如何得到结果对自己的雅可比矩阵呢？</strong>在数学上能够证明，其实就是先按照上述方法，将结果节点 对 各个子结点的雅可比矩阵 和 各个子节点对自己的雅可比矩阵分别相乘，然后再相加即可。如下所示：</p><p>​ $ J_f = <em>s J</em>{rs}J_{sf}$</p><p>​ <span class="math inline">\(J_f\)</span>是最终结果对父节点的雅可比矩阵。</p><p>​ <span class="math inline">\(J_{rs}\)</span>是最终结果对某个子节点的雅可比矩阵。</p><p>​ <span class="math inline">\(J_{sf}\)</span>是某个子节点对父节点的雅可比矩阵。</p><p>【附：最开始的时候，结果节点对自己的雅可比矩阵是啥？ 回答：是一个单位矩阵，即对角线元素为1，其余元素都为0】</p><h5 id="自动微分的工作原理解析">3）自动微分的工作原理解析：</h5><p>​ 在上述描述的反向传播过程中，我们有一个核心的地方还没有细说，那就是如何让计算机计算 一对子节点和父节点 它们之间的雅可比矩阵，也就是它们之间的导数关系，如何计算？【此处留有陷阱，请继续往下看】</p><p>​ 让计算机实现微分功能有以下几种微分方式，</p><ul><li>手工计算出微分，然后编码进代码中</li><li>数值微分 (numerical differentiation)</li><li>符号微分 (symbolic differentiation)</li><li>自动微分</li></ul><figure><img src="https://pic4.zhimg.com/80/v2-4c305dc170d7a165aec1b5d7017828c7_1440w.jpg" alt="四种微分方式的对比。 手工微分、符号微分、 自动微分得出的都是精确解， 而数值微分得出的只是近似解。" /><figcaption aria-hidden="true">四种微分方式的对比。 手工微分、符号微分、 自动微分得出的都是精确解， 而数值微分得出的只是近似解。</figcaption></figure><p>我们简单的先介绍以下前三种方式，然后再着重介绍自动微分：</p><ul><li><p><strong>手工编码</strong>：故名思意，自己计算函数的导数然后编码入计算机代码中。</p></li><li><p><strong>数值差分</strong>，其分为两种方式—前向差分、中心差分</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_17_31_03_38.png" /></p><p>​ 一般我们使用中心差分来对神经网络的反向传播进行 <strong>梯度检验</strong>， 前向差分很少使用， 因为前向差分的误差是 <span class="math inline">\(O(h)\)</span> , 而中心差分的误差是 <span class="math inline">\(O(h^2)\)</span> , 使用泰勒公式将上面的 <span class="math inline">\(f(x+h)\)</span> 和<span class="math inline">\(f(x-h)\)</span>展开，就能得出前向差分和中心差分的误差</p><ul><li><p><strong>符号微分：</strong></p><p>​ 类似于我们人的手工计算，它是计算机根据规则进行微分的方式。符号微分的明显的缺陷是容易产生 <strong>表达式膨胀</strong> (expression swell)。</p><figure><img src="https://pic3.zhimg.com/80/v2-fb2923b77c6a8cbed2716e58e44f191e_1440w.jpg" alt="符号微分的微分结果不一定是最简的形式" /><figcaption aria-hidden="true">符号微分的微分结果不一定是最简的形式</figcaption></figure></li><li><p><strong>自动微分：</strong></p><p>​ 自动微分将符号微分法应用于最基本的算子，比如常数，幂函数，指数函数，对数函数，三角函数等，然后代入数值，保留中间结果，最后再应用于整个函数。因此它应用相当灵活，可以做到完全向用户隐藏微分求解过程，由于它只对基本函数或常数运用符号微分法则。</p><p>​ 自动微分有前向模式和反向模式两种，<strong>当输出的维度大于输入的时候，适宜使用前向模式微分；当输出维度远远小于输入的时候，适宜使用反向模式微分。</strong>一般在神经网络中使用的都是反向模式。因为神经网路的输入通常 &gt;&gt; 输出，</p><p>​ 细节上来说，自动微分是将复合函数分解为输出量（根节点）和一系列的输入量（叶子节点）及基本函数（中间节点），构成一个计算图（Computational Graph），并以此计算任意两个节点间的梯度：</p><ul><li>加法法则：任意两个节点间的梯度为它们两节点之间所有路径的偏微分之和；</li><li>链式法则：一条路径的偏微分为路径上各相邻节点间偏微分的连乘。</li></ul></li></ul><p>​ <strong>看到这里，会觉得很熟悉，诶等等！这不就是反向传播干的事情吗，一摸一样！</strong>然后我就发现自己一开始理解错概念了，我一开始以为反向传播过程中计算一对父节点和子节点的雅可比矩阵 这边的过程用的是自动微分，其他都是反向传播的过程，其实从某种意义上来说，反向传播就是在计算自动微分的过程，而计算一对子节点和父节点它们之间的雅可比矩阵，其实就已经是分解到最基本的算子了。在后面的代码实现环节，会更清楚明了一些。</p><p>​ 总结一下，计算图的变量节点被赋值或初始化后，在结果节点（比如损失值节点）上调用 前向传播 ，递归计算路径上各个节点的值，信息沿着计算图向前传播，最终得到结果节点的值。之后，在需要更新的节点上调用 反向传播 方法，该方法会递归计算<strong>结果节点对路径上各个节点的雅可比矩阵，信息反向传播</strong>。如果有多个节点需要更新，比如权值向量节点和偏置节点，就在这些节点上分别调用 反向传播 方法。<strong>由于中间节点的雅可比矩阵（如果已经被计算）已经保存在了 节点的 jacobi 属性中，所以在多个节点上多次调用其 反向传播 方法时并不会增加额外的计算负担。</strong>这其实就是“反向传播”的精髓，它执行的无非就是复杂复合映射的求导链式法则，保存中间结果，从而以空间换时间。具体的内容会在下一节的实现中详解</p><h4 id="利用代码实现计算图构建反向传播自动微分过程">4、利用代码实现计算图构建、反向传播、自动微分过程：</h4><p>​ 首先，我们看完理论以后，应该需要知晓在上述过程中，我们需要在代码中实现的最核心的节点相关的类如下所示：</p><ul><li>Node类（基类-非抽象类）<ul><li>普通中间节点（直接使用Node类即可）</li><li>变量节点（继承Node类，无父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识）</li><li>Op操作符节点（继承Node类，抽象类，然后根据不同的运算符定义类来继承它，其他运算符类需要实现两个方法：compute 和 get_jacobi，分别用于根据父节点的值计算本节点的值，以及计算本节点对某个父节点的雅可比矩阵）。</li></ul></li><li>Graph计算图类</li></ul><p>​ 上述几个就是底层计算自动微分机制的核心内容，我们一个个来看：</p><h5 id="graph计算图类-一些基本函数">1）Graph计算图类 （一些基本函数）</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nodes = []  <span class="comment"># 计算图内的节点的列表</span></span><br><span class="line">        self.name_scope = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nodes.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        清除图中全部节点的雅可比矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.clear_jacobi()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重置图中全部节点的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.reset_value(<span class="literal">False</span>)  <span class="comment"># 每个节点不递归清除自己的子节点的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_count</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.nodes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 全局默认计算图</span></span><br><span class="line">default_graph = Graph()</span><br></pre></td></tr></table></figure><h5 id="node类基类---非抽象类">2）Node类（基类 - 非抽象类）</h5><ul><li><strong>Part1：构造函数</strong><ul><li>此部分较好理解，做一些初始化，将节点添加到计算图的list里，然后将该节点添加到父节点的子节点列表中。</li><li>需要注意的是：构造函数需要传入两个参数，第一个参数是父节点列表，第二个参数是一些参数列表</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图节点类基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *parents, **kargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图对象，默认为全局对象default_graph</span></span><br><span class="line">        self.kargs = kargs</span><br><span class="line">        self.graph = kargs.get(<span class="string">&#x27;graph&#x27;</span>, default_graph) <span class="comment"># 节点所属的计算图，默认为 全局计算图default_graph</span></span><br><span class="line">        self.need_save = kargs.get(<span class="string">&#x27;need_save&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 是否需要被保存</span></span><br><span class="line">        self.gen_node_name(**kargs)     <span class="comment"># 依据参数生成节点名称</span></span><br><span class="line"></span><br><span class="line">        self.parents = <span class="built_in">list</span>(parents)  <span class="comment"># 父节点列表</span></span><br><span class="line">        self.children = []  <span class="comment"># 子节点列表</span></span><br><span class="line">        self.value = <span class="literal">None</span>  <span class="comment"># 本节点的值</span></span><br><span class="line">        self.jacobi = <span class="literal">None</span>  <span class="comment"># 结果节点对本节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到父节点的子节点列表中</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            parent.children.append(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到计算图中</span></span><br><span class="line">        self.graph.add_node(self)</span><br></pre></td></tr></table></figure><ul><li><strong>Part2: 常见函数</strong>:<ul><li>此部分也是Node类中一些基本的工具型函数，其中gen_node_name就是在构造函数中生成节点名称用的。</li><li>dimension 和 shape 函数是用来返回节点值的维度的</li><li>reset_value 递归重置该节点 + 该节点下游的节点的值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parents</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的父节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.parents</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_children</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的子节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.children</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">gen_node_name</span>(<span class="params">self, **kargs</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       生成节点名称，如果用户不指定，则根据节点类型生成类似于&quot;MatMul:3&quot;的节点名，</span></span><br><span class="line"><span class="string">       如果指定了name_scope，则生成类似&quot;Hidden/MatMul:3&quot;的节点名</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.name = kargs.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">           self.__class__.__name__, self.graph.node_count()))</span><br><span class="line">       <span class="keyword">if</span> self.graph.name_scope:</span><br><span class="line">           self.name = <span class="string">&#x27;&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.graph.name_scope, self.name)</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       清空结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.jacobi = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">dimension</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值展平成向量后的维数</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape[<span class="number">0</span>] * self.value.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值作为矩阵的形状：（行数，列数）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self, recursive=<span class="literal">True</span></span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       重置本节点的值，并递归重置本节点的下游节点的值</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> recursive:</span><br><span class="line">           <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</span><br><span class="line">               child.reset_value()</span><br></pre></td></tr></table></figure><ul><li><strong>Part3：虚函数</strong>：<ul><li>这两个函数，是等会儿 操作符节点需要重载的函数内容，在forward和backword中有用到。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，根据父节点的值计算本节点的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，计算本节点对某个父节点的雅可比矩阵的计算，因为计算父节点的雅可比矩阵可能需要该父节点以及其他父节点的值，所以只能够在子节点中完成。父节点调用子节点的getjacobi方法，就可以得到子节点对自己的雅可比矩阵。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Part4：核心函数</strong>：<ul><li>forward() 和 backward() 函数, 都是以递归的形式进行计算，请注意这边的两个函数的含义和pytorch库中的同名函数含义相差较大，不要搞混。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> node <span class="keyword">in</span> self.parents:</span><br><span class="line">          <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">              node.forward()</span><br><span class="line"></span><br><span class="line">      self.compute()</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  属性jacobi用于保存最终结果对自己的雅可比矩阵，在代码一开始先判断自己的jacobi属性是否为None,如果不是说明最终结果对自己的雅可比矩阵已经计算过了（因为一次反向传播中，某个节点可能被多次访问）。</span></span><br><span class="line"><span class="string">  result参数传进来的是最终的结果节点。</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, result</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      反向传播，计算结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> self.jacobi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">if</span> self <span class="keyword">is</span> result:  <span class="comment"># 如果本节点自身就是最终的结果节点</span></span><br><span class="line">              self.jacobi = np.mat(np.eye(self.dimension()))  <span class="comment">#构造一个维度正确的单位矩阵即可</span></span><br><span class="line">          <span class="keyword">else</span>:   <span class="comment"># 如果本节点不是最终的结果节点，而是正常的一个节点</span></span><br><span class="line">              self.jacobi = np.mat(  <span class="comment"># 先构造一个维度正确的全为0的矩阵</span></span><br><span class="line">                  np.zeros((result.dimension(), self.dimension())))</span><br><span class="line"><span class="comment"># 然后遍历所有子节点</span></span><br><span class="line">              <span class="keyword">for</span> child <span class="keyword">in</span> self.get_children():</span><br><span class="line">                   <span class="comment"># 如果子节点的值不为空，说明它在本次的计算路径上，因为对于某些复杂的计算图而言，有些节点可能不在某次前向传播的计算路径上，它们是无关的节点。</span></span><br><span class="line">                  <span class="keyword">if</span> child.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                      <span class="comment"># 递归调用child的backward()方法，得到最终结果对子节点的雅可比，再乘上 子节点对该节点的雅可比，就得到了最终结果对该节点的雅可比，将其累加到之前初始化好的全为0的矩阵中。</span></span><br><span class="line">                      self.jacobi += child.backward(result) * child.get_jacobi(self)</span><br><span class="line"><span class="comment"># 返回雅可比矩阵即可</span></span><br><span class="line">      <span class="keyword">return</span> self.jacobi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="变量节点继承自node类">3）变量节点（继承自Node类）：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    变量节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, init=<span class="literal">False</span>, trainable=<span class="literal">True</span>, **kargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        变量节点没有父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Node.__init__(self,  **kargs)</span><br><span class="line">        self.dim = dim</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果需要初始化，则以正态分布随机初始化变量的值</span></span><br><span class="line">        <span class="keyword">if</span> init:</span><br><span class="line">            self.value = np.mat(np.random.normal(<span class="number">0</span>, <span class="number">0.001</span>, self.dim))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 变量节点是否参与训练</span></span><br><span class="line">        self.trainable = trainable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为变量赋值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判定赋值的值matrix 是不是和dim一致</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(value, np.matrix) <span class="keyword">and</span> value.shape == self.dim</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 本节点的值被改变，重置所有下游节点的值</span></span><br><span class="line">        self.reset_value()</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><h5 id="运算符操作子节点继承自node类需要覆写compute和get_jacobi两个函数">4）运算符操作子节点（继承自Node类，需要覆写compute和get_jacobi两个函数）</h5><p>抽象类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义操作符抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>定义 Add操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    （多个）矩阵加法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">## 根据父节点的值计算本节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># assert len(self.parents) == 2 and self.parents[0].shape() == self.parents[1].shape()</span></span><br><span class="line">        self.value = np.mat(np.zeros(self.parents[<span class="number">0</span>].shape()))</span><br><span class="line"><span class="comment"># 把所有的父节点的值相加，就是正向传播计算的值</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            self.value += parent.value</span><br><span class="line">            </span><br><span class="line"><span class="comment">## 计算本节点对某个父节点的雅可比矩阵的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.mat(np.eye(self.dimension()))  <span class="comment"># 矩阵之和对其中任一个矩阵的雅可比矩阵是单位矩阵</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 比如说： 父节点为矩阵 A，B(维度为 3 * 2)，子节点为矩阵 A + B（维度为3 * 2）</span></span><br><span class="line"><span class="comment">## 子节点为 Add操作符节点</span></span><br><span class="line"><span class="comment">## 那么这样一个映射函数就是 6维向量 -》映射到-》 6维向量 的映射函数</span></span><br><span class="line"><span class="comment">## A 展平 [ a1 a2 a3 a4 a5 a6 ] B 展平 [ b1 b2 b3 b4 b5 b6]  均为6维向量</span></span><br><span class="line"><span class="comment">## A+B 展平 [a1+b1 a2+b2 a3+b3 a4+b4 a5+b5 a6+b6] 6维向量</span></span><br><span class="line"><span class="comment">## 最终得到的雅可比矩阵是 6 * 6 的单位阵</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [d(a1+b1)/d(a1) d(a1+b1)/d(a2) d(a1+b1)/d(a3) d(a1+b1)/d(a4) d(a1+b1)/d(a5) d(a1+b1)/d(a6)  ]</span></span><br><span class="line"><span class="string">   [d(a2+b2)/d(a1) d(a2+b2)/d(a2) d(a2+b2)/d(a3) d(a2+b2)/d(a4) d(a2+b2)/d(a5) d(a2+b2)/d(a6)  ]</span></span><br><span class="line"><span class="string">    ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">   [d(a6+b6)/d(a1) d(a6+b6)/d(a2) d(a6+b6)/d(a3) d(a6+b6)/d(a4) d(a6+b6)/d(a5) d(a6+b6)/d(a6)  ]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [1 0 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>定义Matmul操作符：结论如下，推导可以见书：</p><p>定义矩阵A： 形状为 M x N</p><p>定义矩阵B： 形状为 N x K</p><p>矩阵乘法得到的结果C： 形状为 M X K</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_51_51_228.png" /></p><p>​ 我们将矩阵乘法视为多到多映射，如下：以左矩阵A为自变量，以右矩阵B为常量，将映射的结果矩阵C视为 M x K维的向量。如下所示：</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_56_22_981.png" style="zoom: 50%;" /></p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_56_29_570.png" style="zoom:50%;" /></p><p>​ 最终获得的雅可比矩阵的第一行，就是C矩阵的第1个元素，分别对A的mn个元素求导：得到的如下所示：</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_58_05_680.png" style="zoom:50%;" /></p><p>​ 第二行同理，如下所示：</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_58_34_369.png" style="zoom:50%;" /></p><p>​ 一直到雅可比矩阵的第K行，都是这样的规律。然后接下去雅可比矩阵的K+1行是这样的：</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_15_59_42_707.png" alt="屏幕捕获_2022_02_11_15_59_42_707" style="zoom:50%;" /></p><p>​ 我们会发现一个规律，如下所示，也就是最终的结论：C对A的雅可比矩阵如下所示：</p><p><img src="C:\Users\14012\Desktop\屏幕捕获_2022_02_11_16_00_40_821.png" style="zoom:50%;" /></p><p>​ <span class="math inline">\(B^T 是 B的转置\)</span>，我们把 m 个 形状为 <span class="math inline">\(k \times n\)</span>的<span class="math inline">\(B^T\)</span>矩阵放在对角线上，得到一个<span class="math inline">\(mk \times mn\)</span> 的矩阵。以下代码就是干了这样一个事情。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatMul</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    矩阵乘法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">2</span> <span class="keyword">and</span> self.parents[<span class="number">0</span>].shape()[</span><br><span class="line">            <span class="number">1</span>] == self.parents[<span class="number">1</span>].shape()[<span class="number">0</span>]</span><br><span class="line">        self.value = self.parents[<span class="number">0</span>].value * self.parents[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将矩阵乘法视作映射，求映射对参与计算的矩阵的雅克比矩阵。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        zeros = np.mat(np.zeros((self.dimension(), parent.dimension())))</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> fill_diagonal(zeros, self.parents[<span class="number">1</span>].value.T)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            jacobi = fill_diagonal(zeros, self.parents[<span class="number">0</span>].value)</span><br><span class="line">            row_sort = np.arange(self.dimension()).reshape(</span><br><span class="line">                self.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            col_sort = np.arange(parent.dimension()).reshape(</span><br><span class="line">                parent.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            <span class="keyword">return</span> jacobi[row_sort, :][:, col_sort]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>定义ReLU操作符：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对矩阵的元素施加ReLU函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    nslope = <span class="number">0.1</span>  <span class="comment"># 负半轴的斜率</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt; <span class="number">0.0</span>,</span><br><span class="line">            self.parents[<span class="number">0</span>].value,</span><br><span class="line">            self.nslope * self.parents[<span class="number">0</span>].value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(np.where(self.parents[<span class="number">0</span>].value.A1 &gt; <span class="number">0.0</span>, <span class="number">1.0</span>, self.nslope))</span><br></pre></td></tr></table></figure><h3 id="三优化器optimizer">三、优化器Optimizer</h3><h4 id="在不封装优化器的时候如何在计算图上执行梯度下降法">1、在不封装优化器的时候，如何在计算图上执行梯度下降法？</h4><pre><code>当我们还没有明确提出优化器这个概念的时候，我们遵循如下过程去在计算图上执行梯度下降来优化损失函数：</code></pre><ul><li>1）对结果节点的上游变量节点(Variable)赋值或初始化【包括输入向量节点和训练参数节点】</li><li>2）在结果节点上调用forward，计算出它的值，数据前向传播</li><li>3）在所有需要训练的变量节点( Variable, trainable = True )上调用backward方法，梯度反向传播，计算出结果节点对该节点的雅可比矩阵。【仅包括训练参数节点】</li><li>4）根据变量节点的jacobi属性中的值，从变量节点的当前值中减去 用学习率 * 梯度的值即为更新后的值。</li><li>5）清除所有节点的value和jacobi属性，回到第2步</li></ul><h4 id="优化器的封装">2、优化器的封装</h4><p>​ 其实，优化器所实现的功能就是上述训练过程中对可训练的变量节点的值进行优化的过程。但是由于，可能存在各种多种多样的优化器，为了便于外层用户使用，代码的整洁，我们需要将优化器的功能封装起来，然后进行使用。</p><p><strong>参考资料：</strong></p><p>代码实现参考：https://github.com/zc911/MatrixSlow</p><p>1、《用python实现深度学习框架》张觉非、陈震</p><p>2、https://zhuanlan.zhihu.com/p/191648279</p><p>3、https://zhuanlan.zhihu.com/p/61103504</p><p>4、https://blog.csdn.net/aws3217150/article/details/70214422</p><p>5、https://zhuanlan.zhihu.com/p/53506221</p>]]></content>
    
    
    <summary type="html">本文是最近回顾深度学习的基础概念时，想要更深一步的了解框架内部的实现方法的实践，文中首先记录了一些之前不太深入了解过的概念，比如自动微分在计算机中是如何计算的，然后将深度学习中各个部分的内容做了梳理，参考一些资料，解析用python实现一个深度学习的框架。</summary>
    
    
    
    <category term="深度学习笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——字符串比较中广义邻居的应用</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E2%80%94%E5%B9%BF%E4%B9%89%E9%82%BB%E5%B1%85/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E2%80%94%E5%B9%BF%E4%B9%89%E9%82%BB%E5%B1%85/</id>
    <published>2022-02-08T11:02:19.000Z</published>
    <updated>2022-02-08T15:48:01.422Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-064.-神奇的字典"><a href="https://leetcode-cn.com/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a></h4><p>​ 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p><p>实现 MagicDictionary 类：</p><ul><li>MagicDictionary() 初始化对象</li><li>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同</li><li>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]</span><br><span class="line">inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, false, true, false, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MagicDictionary magicDictionary = new MagicDictionary();</span><br><span class="line">magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);</span><br><span class="line">magicDictionary.search(&quot;hello&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True</span><br><span class="line">magicDictionary.search(&quot;hell&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;leetcoded&quot;); // 返回 False</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= dictionary.length &lt;= 1001 &lt;= dictionary[i].length &lt;= 100dictionary[i] 仅由小写英文字母组成dictionary 中的所有字符串 互不相同1 &lt;= searchWord.length &lt;= 100searchWord 仅由小写英文字母组成buildDict 仅在 search 之前调用一次最多调用 100 次 search</code></pre><p><strong>解题思路</strong>：</p><p>​ 一开始看到这道题，想到前缀树，但是经过尝试，发现前缀树没法使用，判定两个字符串只差1个字符，非常非常绕，并且当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,hallo。我们查找hello，我的前缀树算法因为找到了完全匹配的hello，就会返回false，而忽略了字典中存在的hallo。</strong></p><p>​ 然后，我们发现，如果想要采用先前的方法，用一个vector(26)来统计字符串字符出现的个数，然后利用相差1个字符来进行判定也不可行，当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,我们查找llohh，在vector统计中，两者确实只在h的个数上有不同，但是问题是两个单词顺序完全不一样，vector统计会将单词的顺序信息丢失。</strong></p><p><strong>故而：这题需要一个全新的概念叫做 广义邻居：</strong></p><p><strong>思路引用</strong>：https://leetcode-cn.com/problems/US1pGT/solution/offerii064shen-qi-de-zi-dian-by-logilong-4hmn/</p><p><strong>广义邻居：</strong>也就是一字只差的单词，比如说【*pple, a*ple, ap*le, app*e, appl*】，这几个单词互为广义邻居。</p><p>然后，我们这道题就可以按照如下的步骤进行求解：</p><ul><li><p>初始化字典： 生成字典中所有单词的广义邻居，例如 apple 就生成上述五个广义邻居。将所有字典词的广义邻居都以 <code>&lt;广义邻居，个数&gt;</code> 保存到 <code>HashMap</code>。</p></li><li><p>查找：当我们需要在字典中查找是否有一个单词和 word 只有一字只差，那不就是查找第二步中 HashMap 中是否存在 word 的广义邻居吗？这时候我们就只要生成 word 所有的广义邻居，然后在 HashMap 中查找是否存在其中的一个就可以了。</p></li></ul><p><strong>关键疑问</strong>：为什么需要记录所有字典词的广义邻居数量？</p><p>​ <strong>这是为了防止字典中出现和查找词一摸一样的词，如果出现上述情况，则会找到符合条件的广义邻居，但是其实并不是邻居，而是它自己！</strong></p><p>所以，刚才的查找不是很完整，<strong>完整正确的查找应当如下</strong>：</p><p>​ 生成待查找词 word 的所有广义邻居。每个广义邻居都到 HashMap 中查找出现的次数，根据出现次数分为3种情况。</p><ul><li>广义邻居数 &gt; 1 ，则说明字典中肯定存在两个不同的字符，这两个字符互为广义邻居，且和查找字符也是广义邻居，由于字典中的单词是不重复的，所以此时满足条件。</li><li>广义邻居数 == 1 , 说明字典中可能存在一个广义邻居，也可能存在查找字符串本身，如果是广义邻居就满足条件，如果是查找字符串本身的话就不符合条件。</li><li>广义邻居数 == 0 , 说明不存在广义邻居，则继续遍历下一个广义邻居。</li></ul><p><strong>代码如下</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MagicDictionary</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; neighbors;</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; dictionary;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">MagicDictionary</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">generateNeighbors</span><span class="params">(string word)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = word;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>()) neighbors[new_word] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> neighbors[new_word]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">buildDict</span><span class="params">(vector&lt;string&gt; dictionary)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="built_in">generateNeighbors</span>(dictionary[i]);</span><br><span class="line">            <span class="keyword">this</span>-&gt;dictionary[dictionary[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string searchWord)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;searchWord.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string new_word = searchWord;</span><br><span class="line">            new_word[i] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(neighbors.<span class="built_in">find</span>(new_word) == neighbors.<span class="built_in">end</span>())&#123;&#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="comment">//可能存在广义邻居，需要看searchWord在不在dictionary种</span></span><br><span class="line">                <span class="keyword">if</span>(dictionary.<span class="built_in">find</span>(searchWord) == dictionary.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    res = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(neighbors[new_word] &gt; <span class="number">1</span>)&#123;</span><br><span class="line">                res = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MagicDictionary object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MagicDictionary* obj = new MagicDictionary();</span></span><br><span class="line"><span class="comment"> * obj-&gt;buildDict(dictionary);</span></span><br><span class="line"><span class="comment"> * bool param_2 = obj-&gt;search(searchWord);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为字符串的差值比较，但是无法用简单的Hash表统计解决，提出了一种新的概念，叫做广义邻居，通过广义邻居来对不同的字符串进行相似性比较。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="string" scheme="https://blog.slks.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>C++ 优先队列 PriorityQueue 容器使用</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-08T07:53:19.000Z</published>
    <updated>2022-02-08T09:55:42.094Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>​ Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，<strong>默认是大顶堆</strong></p><ul><li>1、一般情况：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><ul><li>2、如果内部的元素是Pair的话，其也自带了比较函数,比较规则是先比较第一个元素，第一个相等比较第二个。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>3、内部为自定义元素：一个是通过重载自定义struct的 &lt; 规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="keyword">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> tmp1&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">priority_queue&lt;tmp1&gt; d;</span><br></pre></td></tr></table></figure><ul><li>另一个方法是通过定义一个比较类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优先队列存放 Node* 时优先级的比较方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare_Node_Pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Node::priority 大的优先 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node* &amp;a, Node* &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;priority &lt; b-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法 */</span></span><br><span class="line">std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Compare_Node_Pointer&gt; my_queue;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-061.-和最小的-k-个数对"><a href="https://leetcode-cn.com/problems/qn8gGX/">剑指 Offer II 061. 和最小的 k 个数对</a></h4><p><strong>题目描述</strong>：</p><p>​ 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。</p><p><strong>解题思路</strong>：</p><p>​ 遍历nums1 和 nums2 ，然后将所有的组合push进入自定义的优先队列中，然后按照顺序，出队前k个元素或将队列出空即可。但是这样子的话，时间复杂度会达到O(mn)，也就是nums1和nums2的长度的乘积。其实，因为提供的数组是有序序列，所以我们只需要进队列 nums1的前k个和nums2的前k个的组合，也就是O(K^2)即可。</p><p><strong>解题代码</strong>：（熟悉priority queue的操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v1 = v1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeCompare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node* &amp;a,Node* &amp;b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;v1 + a-&gt;v2 &gt; b-&gt;v1 + b-&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;Node*,vector&lt;Node*&gt;,NodeCompare&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k &amp;&amp; i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k &amp;&amp; j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(nums1[i],nums2[j]);</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node* tmp = q.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;tmp-&gt;v1,tmp-&gt;v2&#125;);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录PriorityQueue C++中的使用，主要是其的一些构造函数以及额外排序规则如何确定。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——&quot;动态数据流+第k大的数值&quot;相关问题优化</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%B5%81+%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%B5%81+%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</id>
    <published>2022-02-08T03:20:19.000Z</published>
    <updated>2022-02-08T03:30:08.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a href="https://leetcode-cn.com/problems/jBjn9C/">剑指 Offer II 059. 数据流的第 K 大数值</a></h4><p><strong>题目描述</strong>：</p><p>​ 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p>​ 请实现 KthLargest 类：</p><pre><code>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</code></pre><p><strong>解题思路</strong>：</p><p>​ 我对于这类没有设计类实现的题目，数据结构的敏感度不够高，基本上想起来都只能用最暴力的方法去解决。此题目，我一开始是想要在内部维护一个Vector，但是我发现，维护有序向量的成本太高了，虽然通过了测试点，但是时间复杂度等方面可以优化的内容实在太多了。</p><p><strong>优化思路</strong>：</p><p>​ 比较重要重要的信息点是 <strong>动态插入</strong>、<strong>第K大</strong>，这两个关键信息，应当能够导向一个动态的数据结构，也就是优先队列——堆。可以维护一个优先队列（最小堆），然后在其内维护最大的K个元素。这样的话，每次插入完需要返回第K大的元素的时候，直接返回堆顶的元素（堆顶的元素是堆中最小的那个元素，但是是所有数组中第K大的那个元素）即可。</p><p>​ 故而，在单次插入的操作中，我们首先将元素 val 加入到优先队列中。如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 k。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">             <span class="built_in">add</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为动态数据流+第k大的数值，利用内置数据结构优化解题思路。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——日程表类的设计优化思想</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%97%A5%E7%A8%8B%E8%A1%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%97%A5%E7%A8%8B%E8%A1%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T02:50:19.000Z</published>
    <updated>2022-02-08T03:02:25.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-058.-日程表"><a href="https://leetcode-cn.com/problems/fi9suh/">剑指 Offer II 058. 日程表</a></h4><p><strong>题目描述</strong>：</p><p>​ 请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p><p>​ MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。</p><p>​ 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p><p>​ 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>​ 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>提示：</p><pre><code>每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。0 &lt;= start &lt; end &lt;= 109</code></pre><p><strong>我的解题思路</strong>：一开始看到每个测试用例，调用.book函数不超过1000次，我就使用了较为暴力的算法，使用成员变量记录先前所有的日程，然后新来一个日程以后，去判断和先前的有没有区间重复，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; calendar;</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIsCollision</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;calendar.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_start = calendar[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tmp_end = calendar[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!(start &gt;= tmp_end || end &lt;= tmp_start))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">checkIsCollision</span>(start,end))&#123;</span><br><span class="line">            calendar.<span class="built_in">push_back</span>(&#123;start,end&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar* obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>优化思路</strong>：按照上述方法做的话，其实是比较浪费时间的，因为每新来一个日程，我们就需要去和先前所有的日程比较，从理论上来说，大部分的比较都是无效比较，我们其实只需要和最近的两个区间进行比较就可以了，因为已知先前的日程都是不重叠的，所以我们每次只需要查询最近的时间段的前后，看看起止时间有无冲突即可。</p><p>​ 此时，我们会想，那我们不是需要维护日程vector，让它变得有序就可以了。思路没错！但是我们可以不用vector了，直接使用map。map是有序的key-value键值对，底层使用红黑树建立，更加方便而且高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; calendar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = calendar.<span class="built_in">lower_bound</span>(start);</span><br><span class="line">        <span class="comment">//第一个大于等于插入元素的时间段。这个时间段的起始时间不能小于插入时间的终止时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">end</span>() &amp;&amp; iter-&gt;first &lt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//迭代器往前走一步就是小于等于当前时间段的最大时间段。这个时间段的终止时间不能大于插入的起始时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">begin</span>() &amp;&amp; (--iter)-&gt;second &gt; start)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        calendar[start] = end;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考：https://leetcode-cn.com/problems/fi9suh/solution/c-hong-hei-shu-map058-ri-cheng-biao-by-d-f7q9/</p><p>附录：</p><ul><li>map中的lower_bound和upper_bound函数：<ul><li>map::lower_bound(key): 返回map中第一个大于或等于key的迭代器指针</li><li>map::upper_bound(key): 返回map中第一个大于key的迭代器指针</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录日程表类的设计优化思想，合理利用C++内置的数据结构，能够大幅加快运行时间。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="red black tree" scheme="https://blog.slks.xyz/tags/red-black-tree/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——求解直方图最大矩形面积 &amp;&amp; 矩阵中最大的矩形求解</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%B1%82%E8%A7%A3%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%B1%82%E8%A7%A3%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</id>
    <published>2022-02-08T01:30:19.000Z</published>
    <updated>2022-02-08T02:50:40.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-039.-直方图最大矩形面积"><a href="https://leetcode-cn.com/problems/0ynMMM/">剑指 Offer II 039. 直方图最大矩形面积</a></h4><p><strong>题目描述</strong>：给定非负整数数组 <code>heights</code> ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例1</strong>：<img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>题解参考：https://leetcode-cn.com/problems/0ynMMM/solution/jian-zhi-offer-2-mian-shi-ti-39-shu-zhon-qzaw/</p><p><strong>解题思路</strong>： 本题如果采用暴搜的方法，O(n^2)复杂度，是比较简单易懂的，但是时间耗费太长，会超时。所以此篇博客要记录的是一个叫做 <strong>“单调栈”</strong>的解决方案：</p><ul><li><p><strong>基本思想</strong>：<strong>保证存在栈中的柱子的高度是递增的。</strong>基础操作为，从左往右扫描数组内的柱子高度，若当前柱高大于栈顶柱高，那么该柱子下标入栈；反之，将栈顶柱子出栈，并计算栈顶的柱子高度为顶高的最高矩阵面积，直至可入栈。</p></li><li><p><strong>核心问题</strong>：如何确定以栈顶柱子高为顶的最大矩阵面积呢？</p><ul><li>该矩阵的宽度一定是，<strong>从栈顶柱子的两边出发直到遇到比该柱高矮的柱子所夹成的宽度</strong>。因为单调栈中保存的柱高是递增的，所以<strong>栈中位于栈顶柱子前面的柱子一定比栈顶柱子矮，同样当前扫描到的柱子也矮于位于栈顶的柱子</strong>，所以顶柱子为顶的最高矩阵的宽度就确定了，那么面积也就确定了。</li></ul></li><li><p><strong>操作示例</strong>：下面以 [2, 1, 5, 6, 2, 3] 为例说明，过程如图所示</p><ul><li><figure><img src="https://pic.leetcode-cn.com/1629450891-DTWpaG-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure></li><li><p>可以发现，最后栈中除了为了处理方便而加入的初始化的 -1 以外，还有 1, 4, 5 三个元素，说明以 1, 2, 3 柱高为顶的最大矩阵还未计算。这时候只要多想一步，它们未被计算是因为还未出现比它们矮的柱子。若假设最后再加入一个高度为 0 的柱高，那么栈中除了 -1 以外，所有的元素都会出栈，那么所有的柱子均被计算，计算完毕，继续的过程如下</p></li><li><figure><img src="https://pic.leetcode-cn.com/1629451413-pOKglw-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure></li></ul></li><li><p><strong>解题代码</strong>：</p><ul><li>以下代码是理解了上述所说以后书写的，和上述所说的细节部分有所不同，它是先往栈里面push了一个-1，保证栈不会空。而我没有这么干，我是在pop完了以后，在计算宽度的时候，会判断栈空了没有，如果空了则 new_top_idx = -1 ，如果没空就是 s.top();</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">//先把第一个元素push进去</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="剑指-offer-ii-040.-矩阵中最大的矩形"><a href="https://leetcode-cn.com/problems/PLYXKQ/">剑指 Offer II 040. 矩阵中最大的矩形</a></h4><p><strong>题目描述</strong>：给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。</p><p>注意：此题 matrix 输入格式为一维 01 字符串数组。</p><p><strong>示例</strong>：<img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [<span class="string">&quot;10100&quot;</span>,<span class="string">&quot;10111&quot;</span>,<span class="string">&quot;11111&quot;</span>,<span class="string">&quot;10010&quot;</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 本题可以用结合上一题的思路进行求解：</p><p>​ <strong>我们循环每一行，将每一行都看作是上一题中的一系列直方图。然后，某行某位置的高度，如果该位置是1，那么它的高度是上一行的该对应位置的直方图的高度+1.如果该位置是0，则该位置的直方图高度就直接清0.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即利用一个数组rectangular来记录直方图高度</span></span><br><span class="line"><span class="comment">//遍历每一行每一个位置，更新rectangular中的数值</span></span><br><span class="line"><span class="comment">//然后调用上一题中的方法，进行求解</span></span><br><span class="line"><span class="keyword">if</span>(nums[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line"> rectangular[j]++;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;string&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; rectangular;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string row = matrix[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;row.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) rectangular.<span class="built_in">push_back</span>(row[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        rectangular[j]++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新好了以后，计算改行的maxValue</span></span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue,<span class="built_in">largestRectangleArea</span>(rectangular));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录一下两道神奇的题目，非常巧妙的利用栈的思想进行求解。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="stack" scheme="https://blog.slks.xyz/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>树系列——二叉树的序列化与反序列化（如何更好的用线性方式记录二叉树的结构）</title>
    <link href="https://blog.slks.xyz/2022/02/07/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%9D%E6%83%B3%E6%89%A9%E5%85%85/"/>
    <id>https://blog.slks.xyz/2022/02/07/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%9D%E6%83%B3%E6%89%A9%E5%85%85/</id>
    <published>2022-02-07T03:58:19.000Z</published>
    <updated>2022-02-07T04:32:17.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-048.-序列化与反序列化二叉树"><a href="https://leetcode-cn.com/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树</a></h4><p><strong>题目描述</strong>：</p><p>​ 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>​ 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>解题思路</strong>：</p><p>​ 我们都很清楚，<strong>一个前序序列（后序/层序序列）+中序序列可以确定恢复一颗二叉树结构。</strong>在这个题目里的话，我一开始的思路是记录前序+ 中序序列，将它们变成字符串，然后反序列化的时候，再通过前序和中序序列重构即可。思路整体而言也较为清晰，但是当我写完所有代码的时候，发现了一个令人窒息的问题：</p><p>​ <strong>这个题目中树节点的值是可能重复的</strong>，这就会导致如果只记录节点的值，树的重构是会出问题的。如果，需要克服这个问题，我们还要给每个节点加上index，并且利用一个hash表记录节点index和值的对应关系。这是比较麻烦的。</p><p>​ 此Blog就是为了记录另一种解题思路：<strong>在特定条件下，我们可以仅凭借树的前序序列就能够确定恢复一颗唯一的二叉树</strong>。</p><p>​ <strong>如果想要达到上面的效果，那么我们的前序遍历序列是需要记录为Null的节点的，示例如下</strong>：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img" style="zoom:33%;" /></p><p>​ 对于上述二叉树，普通的前序序列应当为:</p><p>​ <strong>1 2 3 4 5 </strong></p><p>​ 而如果我们想要用来恢复树结构，前序序列应当为：</p><p>​ <strong>1 2 None None 3 4 None None 5 None None</strong></p><p>​ 具体如何操作，以及如何恢复见如下代码：先序遍历和正常的类似，只不过如果碰到了为NULL的节点，我们不是直接return，而是会将其记录入序列中。</p><p>​ 在重建操作中，我们将序列存入一个队列中操作较为方便，然后如果碰到None就返回NULL，否则就新建一个节点，利用递归的形式，确定左右子树节点，然后返回新建节点。最终就能完成一整颗树的重建。这种方法从时间复杂度和代码复杂度上都优于前一种通过两个序列进行重建的方法。但是局限就是，前序遍历得到的序列需要是你自己形成的“特殊”的前序遍历序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root,string &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            res += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//需要一棵树的前序(P) + 中序遍历序列(I)才能够进行重构</span></span><br><span class="line">        <span class="built_in">preOrder</span>(root,str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">preOrderReverse</span><span class="params">(queue&lt;string&gt; &amp;q)</span></span>&#123;</span><br><span class="line">        string tmp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&quot;None&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        root-&gt;left = <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        root-&gt;right =<span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先把string转成序列的形式</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// i = 0 是第一个数字的起始位置，i = data.lenth()-1 是 I前面那个逗号的位置</span></span><br><span class="line">            string tmp_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(data[i]!=<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                tmp_str += data[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            q.<span class="built_in">push</span>(tmp_str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后再通过序列重建树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录一下二叉树的序列化与重构方式的扩展，如何更好的用线性方式记录二叉树的结构。我们都知道一个前序序列+中序序列可以确定恢复一颗二叉树结构，但在特定条件下的一个前序序列也能够确定恢复一颗二叉树。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="tree" scheme="https://blog.slks.xyz/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>树系列——当二叉树需要以层为单位计算时层序遍历的优化版本</title>
    <link href="https://blog.slks.xyz/2022/02/06/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.slks.xyz/2022/02/06/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-06T13:02:19.000Z</published>
    <updated>2022-02-07T03:57:57.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-045.-二叉树最底层最左边的值"><a href="https://leetcode-cn.com/problems/LwUNpT/">剑指 Offer II 045. 二叉树最底层最左边的值</a></h4><p><strong>题目描述</strong>：</p><p>​ 给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。假设二叉树中至少有一个节点。具体信息请点击链接查看。</p><p><strong>题目解答</strong>：</p><p>​ 思路是很简单的，一个层序遍历，然后最后一层层序遍历的第一个值返回即可，但是整个过程中还是有很多步骤可以优化的。以最简单的思想来讲，我们需要先来一遍层序遍历，确定总共有多少层，然后再来一遍层序遍历，当知道到最后一层的第一个节点的时候记录返回。但是其实可以只用一次层序遍历完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;TreeNode*&gt;&gt; v;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);  </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(size--)&#123;          <span class="comment">// 最精妙的在于此</span></span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(t);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[v.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ 上述层序遍历中，最为精髓的部分就是在while(!q.empty())中，加入了一个while(size--)的循环，而每次在这里面进行循环的，必定是同一层的节点。这一点尝试以后就会发现是正确的，如此一来就大大缩减了整个层序遍历的过程。如果这道题目需要找到每一层的最大值，也就不需要两次遍历了，我们只要在内循环中每次找到一个最大值，就是在每一层里找最大值。</p><p>​ 此篇博客就是为了记录这样一个小的Trick。</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要以层为单位计算一颗树的性质，我们可以不需要非常复杂的记录每个节点的层级信息，然后遍历完后再去遍历节点获取level信息，而是可以在层序遍历的过程中将每一层的遍历区分开。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="tree" scheme="https://blog.slks.xyz/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——LRU最近最少使用缓存的容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T11:02:19.000Z</published>
    <updated>2022-02-08T15:52:45.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指-offer-ii-031.-最近最少使用缓存"><a href="https://leetcode-cn.com/problems/OrIXps/">剑指 Offer II 031. 最近最少使用缓存</a></h3><p><strong>题目简要描述</strong>：</p><p>​ 运用所掌握的数据结构，设计和实现一个 LRU (Least Recently Used，最近最少使用) 缓存机制 。</p><p><strong>实现 LRUCache 类：</strong></p><ul><li><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</p></li><li><p>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</p></li><li><p>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li></ul><p><strong>类模版</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ <strong>使用 双向链表 与 Hash 表</strong>，实现 LRU：将新插入的元素放在链表头部，或将最新访问的节点放在链表的头部。如果容量到达上限，去除链表最后的元素。在此期间，<strong>为了保证访问链表的头部和尾部都是O(1)时间，我们需要维护一个Head和一个Tail节点，分别指向双向链表的头部和尾部，这两个头部和尾部的节点中是不存放数据，留空的，仅为了进行指示。</strong>并且为了保证<strong>在O(1)时间内能够获取任意一个元素</strong>，我们还需要建立一个HashMap，将key值与对应的链表节点关联，以方便以O(1)时间进行访问。</p><p><strong>代码</strong>：以下代码我并没有做任何的优化，比如说合并一些可复用的函数，因为这样看上去更简单明了一些，其实比如说像一些将Node插入到链表前方的操作，以及删除链表最后一个元素的操作，都是可以写成函数封装起来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Node* prev;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;key = key;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">int</span> curr_size;</span><br><span class="line">Node* head; <span class="comment">//链表头节点</span></span><br><span class="line">Node* tail; <span class="comment">//链表尾巴节点</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, Node*&gt; key2Node; <span class="comment">//key - Node 的转换</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;curr_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">head-&gt;next = tail;</span><br><span class="line">tail-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) == key2Node.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">Node* curr = key2Node[key];</span><br><span class="line"><span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">Node* prev = curr-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line"><span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">curr-&gt;prev = head;</span><br><span class="line">head-&gt;next = curr;</span><br><span class="line">curr-&gt;next = next;</span><br><span class="line">next-&gt;prev = curr;</span><br><span class="line"><span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) != key2Node.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="comment">//修改值并将该元素插到最前面</span></span><br><span class="line">Node* curr = key2Node[key];</span><br><span class="line">curr-&gt;value = value;</span><br><span class="line"><span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">Node* prev = curr-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line"><span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">curr-&gt;prev = head;</span><br><span class="line">head-&gt;next = curr;</span><br><span class="line">curr-&gt;next = next;</span><br><span class="line">next-&gt;prev = curr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curr_size == <span class="keyword">this</span>-&gt;capacity) &#123;</span><br><span class="line"><span class="comment">//如果容量满了,丢掉最尾巴的那个，然后插入到最前面</span></span><br><span class="line"><span class="comment">//丢掉最尾巴那个</span></span><br><span class="line">Node* prev = <span class="keyword">this</span>-&gt;tail-&gt;prev;</span><br><span class="line">key2Node.<span class="built_in">erase</span>(prev-&gt;key); <span class="comment">//抹除key2Node里</span></span><br><span class="line"><span class="keyword">if</span> (prev-&gt;prev) prev-&gt;prev-&gt;next = tail;</span><br><span class="line">tail-&gt;prev = prev-&gt;prev;</span><br><span class="line">prev-&gt;prev = prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//插入该元素到最前面</span></span><br><span class="line">Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">temp-&gt;prev = head;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;next = next;</span><br><span class="line">next-&gt;prev = temp;</span><br><span class="line">key2Node[key] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果容量没满，元素插入到最前面，并加载入map中</span></span><br><span class="line">Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">temp-&gt;prev = head;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;next = next;</span><br><span class="line">next-&gt;prev = temp;</span><br><span class="line">key2Node[key] = temp;</span><br><span class="line"><span class="keyword">this</span>-&gt;curr_size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_06_11_41_37_32.png" /></p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要针对 LRU最近最少使用缓存 设计一个容器。使得其获取与插入的方法时间复杂度都为O(1)</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——前缀树容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%BC%80%E6%A0%91%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%BC%80%E6%A0%91%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T11:02:19.000Z</published>
    <updated>2022-02-08T15:37:13.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-062.-实现前缀树"><a href="https://leetcode-cn.com/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h4><p><strong>题目描述</strong>：</p><p>​ Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如<strong>自动补完和拼写检查</strong>。****</p><p>请你实现 Trie 类：</p><pre><code>Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</code></pre><p><strong>解题思路</strong>：</p><p>​ Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 childrens。在本题中，这可以是一个动态的vector，也可以是一个大小定为26的vector，因为本文中的字符限定为小写字母。两者各有好处，动态的vector节省一些空间，静态的vector在查找和插入时节省一些时间，实现起来也较为方便一些。</li><li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li></ul><p>下面是一张比较清晰的图：非常明了</p><figure><img src="https://pic.leetcode-cn.com/1632672370-gVXuKM-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong>代码实现（动态vector版本，我写的）</strong>：</p><p>​ Search操作和startsWith其实就是差一个判定字符串结尾的操作，所以我将两个函数合并成了一个，用一个形参来控制，使得代码尽量简介。Insert操作其实和Search操作也有大量的重复代码，循环判定都是一致的，就是判定后操作逻辑不太一样，但为了不混在一起，我还是将其分开写了。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_08_168.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="keyword">char</span> character,<span class="keyword">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(word,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(prefix,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mySearch</span><span class="params">(string word,<span class="keyword">bool</span> includePrefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续找下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span> &amp;&amp; !includePrefix)&#123; <span class="comment">//如果是最后一个自符，还需要判定下一个r-&gt;isEnd</span></span><br><span class="line">                    <span class="keyword">if</span>(!r-&gt;isEnd) res = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码实现（静态vector版本，引自LeetCode题解）</strong>：</p><p>​ 可以看到，其本身代码简洁程度较高，并且它将Trie直接视为一个节点了，没有建立额外的TreeNode类。运行时间上和我的算法类似，差别不是很大。但是其内存消耗是远大于我的算法的，</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_59_414.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/QC3q1f/solution/shi-xian-qian-zhui-shu-by-leetcode-solut-un50/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>再记录一道上述数据结构的应用题：</p><h4 id="剑指-offer-ii-063.-替换单词"><a href="https://leetcode-cn.com/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h4><p>​ 在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p><p>​ 现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。需要输出替换之后的句子。</p><p>​ 示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">输出：&quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure><p><strong>代码（Author: Fantast）</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_18_14_35_668.png" /></p><p>​ 主要思路就是实现一个前缀树，其中和上题不一样的是，上题是前缀找单词，这题是单词找前缀，反了反，所以我将startsWith改成了searchRoot函数，大体搜寻逻辑一致。然后再应用该数据结构解题即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="keyword">char</span> character,<span class="keyword">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查询字典中是否有该单词的词根，如果有返回词根，如果没有，返回原单词*/</span></span><br><span class="line">    <span class="function">string <span class="title">searchRoot</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = word;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，观察其是否是一个词根</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                res += r-&gt;character;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;isEnd)&#123; <span class="comment">//如果是一整个词根，直接返回</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sentence.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sentence[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res += t-&gt;<span class="built_in">searchRoot</span>(word) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                word += sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += t-&gt;<span class="built_in">searchRoot</span>(word);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再记录一道上述数据结构的拓展应用题：</p><h4 id="剑指-offer-ii-067.-最大的异或"><a href="https://leetcode-cn.com/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a></h4><p>给定一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><p><strong>解题思路</strong>：</p><p>​ 将整数视为二进制字符串 0 / 1，此题目的字典树孩子仅有0和1，然后遍历所有数组中的元素，对于任意一个元素ai来说，通过字典树找到和它异或最大的那个值。遍历元素O(n)复杂度，通过字典树找到每个元素的异或最大的值为log(C)，故而总的时间复杂度为O(nlog(C))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* left;  <span class="comment">// 0 </span></span><br><span class="line">    MyTreeNode* right; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* root;</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;left)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;right)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没找到这个节点，进行插入</span></span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">                <span class="keyword">if</span>(bit == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//插入左侧</span></span><br><span class="line">                    r-&gt;left = c;</span><br><span class="line">                    r = r-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//插入右侧</span></span><br><span class="line">                    r-&gt;right = c;</span><br><span class="line">                    r = r-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMax</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">int</span> multi_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且有1，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且有0，那么直接往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; !r-&gt;right &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且无1，则往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; !r-&gt;left &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且无0，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> multi_val ^ val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal,t-&gt;<span class="built_in">calculateMax</span>(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前缀树 是一种树形数据结构，又称字典树，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。本文用于实现该数据结构，以及一道应用题目。当题目涉及到字符串寻找前缀，或者是字符串是否含有某字符串的任务，可以采用该数据结构，能够大幅降低算法时间复杂度</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——插入、删除和随机访问都是 O(1) 的容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/O(1)%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/O(1)%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T01:02:19.000Z</published>
    <updated>2022-02-08T15:52:38.962Z</updated>
    
    <content type="html"><![CDATA[<h3 id="剑指-offer-ii-030.-插入删除和随机访问都是-o1-的容器"><a href="https://leetcode-cn.com/problems/FortPu/">剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</a></h3><p><strong>题目简要描述</strong>：</p><p>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：</p><pre><code>insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。</code></pre><p><strong>类模版</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 首先，题目要求插入和删除都需要是O(1)的时间复杂度，在我们熟知的数据结构中，<strong>只有Hash表能达到这个效果</strong>。但是，Hash表显然不能满足随机取getRandom这一操作，随机取的操作，<strong>底层应当是数组，而且最好是紧凑的连续存放内容的数组</strong>，这样才方便进行随机取的行为，并且概率一致。</p><p>​ 综上所述，我们应当设计这样一个数据结构，利用数组保存元素，然后利用哈希表保存元素值（key）和 该值在数组中存放的index（value），这样子就能实现上述的要求了。</p><p>​ 同时，我们还需要注意的一个细节就是，<strong>当我们删除元素时，不能直接将该元素在它的位置上删除</strong>，如果这样的话，就会导致数组存储元素的idx不连续，从而后续随机取元素的时候，各个元素的概率不再相等。我们应该用数组最后的那个元素将我们要删的元素进行替换，然后把数组最后的那个元素删除，最后更新哈希表中的idx即可。</p><p>​ 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[val] = v.<span class="built_in">size</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = m[val];</span><br><span class="line">        <span class="keyword">int</span> max_idx = m.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        m[v[max_idx]] = idx;</span><br><span class="line">        m.<span class="built_in">erase</span>(val);</span><br><span class="line">        v[idx] = v[max_idx];</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">rand</span>() % m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> v[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要设计一个插入、删除和随机访问都是 O(1) 的容器。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>链表系列——链表问题的常见技巧</title>
    <link href="https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-04T05:52:19.000Z</published>
    <updated>2022-02-05T01:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一剑指-offer-ii-022.-链表中环的入口节点">一、<a href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></h3><p><strong>题目简单描述</strong>：</p><p>​ 给定一个链表，需要返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>​ 进阶：是否可以使用 O(1) 空间解决此题？</p><p><strong>解题思路</strong>：</p><p>​ 本题本身想要解答十分简单，将其放入博客中整理是想记录我们应该如何利用O(1)空间去解决这个题目呢？</p><p>​ <strong>快慢指针法</strong>，我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>​ 如下图所示，即可非常好的理解如下：那么，又该如何判断入环点的位置呢？我们先上结论：经过数学推断可以得知：</p><p>​ <strong>假设快慢指针相遇时，fast指针已经走完了环的n圈，那么</strong></p><p>​ <strong>从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</strong></p><p>​ <strong>根据此结论，我们只需要在快慢指针相遇时，再加一个ptr指针，让其指向链表头部；随后，它和 slow 指针每次向后移动一个位置。最终，它们会在入环点相遇。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-04 下午2.06.49.png" alt="截屏2022-02-04 下午2.06.49" style="zoom:33%;" /></p><p>​ <strong>结论证明</strong>：设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 <span class="math inline">\(a + n \times (b+c) + b\)</span> ,而此时，slow指针走过的总距离为 <span class="math inline">\(a + b\)</span>。</p><p>​ <strong>【此处需要解释一下：为何fast与slow相遇时，slow必定还在走第一圈？】</strong>（我们假设fast和slow如果同时从入环点出发，由于速度是2倍的关系，slow走完1圈的时候，fast刚好走完2圈，他们会在起点相遇。但是现在，fast比slow先入环，也就是说slow入环的时候，fast不管在环的哪里，肯定能在slow走完一圈前，将其追上。）</p><p>​ 由于fast指针走的速度是slow指针的2倍，那么可以得到以下等式：$ a + n (b+c) = 2 (a + b)$ 所以可以得到如下结论： $ a = c + (n-1) (b+c)$ ,这也就意味着，最开始说的， 从相遇点到入环点的距离 + (n-1) 圈环的距离，等于链表头到入环点的距离。</p><p>​ 那么为什么说，如果相遇的时候，ptr从链表头出发，ptr和slow必定在入环口相遇呢？因为a的距离是c加上许多圈环的距离，所以当ptr到达链表入环口的时候，时间经过了a，此时slow必定出现在入环口处。所以我们可以根据此来判断，入环口的位置是哪一个节点。</p><h3 id="二剑指-offer-ii-023.-两个链表的第一个重合节点">二、<a href="https://leetcode-cn.com/problems/3u1WK4/">剑指 Offer II 023. 两个链表的第一个重合节点</a></h3><p><strong>简单题目描述</strong>：</p><p>​ 给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。详细见原网址</p><p><strong>解题思路</strong>：</p><p>参考：https://leetcode-cn.com/problems/3u1WK4/solution/liang-ge-lian-biao-de-di-yi-ge-zhong-he-0msfg/</p><p>此题难点在于设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p><p>​ 我们可以考虑双指针的方法对两个链表进行求解，但是双指针的难点在于，两条链表的长度不同，无法做到一一对应。我们先给出<strong>解决方案</strong>：</p><p>​ 当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB ，初始时分别指向两个链表的头节点 headA和 headB ，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><ul><li>每步操作需要同时更新指针 pA 和 pB。</li><li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</li><li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li><li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</li></ul><p>​ <strong>乍一看，其中有一个非常奇怪的点</strong>，就是如果指针pA为空，那么将指针pA移动到链表headB的头节点。但其实仔细一想，这样子是没问题的。也正是因为这个操作，我们才能够得以解决两个链表长度不一致导致的不对应问题。较为详细的证明如下：</p><p>​ 我们先考虑<strong>两链表相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达某一个节点。</p><p>​ 如果两链表长度不一致，这样子的话，我们假设链表A、B长度为m和n，A、B的不相交部分节点数为a，b，相交部分节点数为c，那么m = a + c , n = b + c. pA和pB第一遍遍历完各自的链表后，他们不是同时到达尾部节点的，但是当pA遍历完 a + c + b个节点，当pB遍历完b + c + a个节点的时候，两者就会同时到达相交的节点。</p><p>​ 再证明<strong>两链表不相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达最终的NULL节点。</p><p>​ 如果两链表长度不一致，这样子的话，我们假设链表A、B的长度各位m和n，当pA 遍历完 m + n个节点，pB遍历完 n + m个节点的时候，必定同时到达尾部的NULL节点。</p>]]></content>
    
    
    <summary type="html">链表问题的解题技巧与常见优化思路，比如快慢指针法以达到O(1)空间复杂度、双指针以缩减空间复杂度等。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="linked list" scheme="https://blog.slks.xyz/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——回文字符串相关处理技巧</title>
    <link href="https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-04T05:30:19.000Z</published>
    <updated>2022-02-06T13:37:11.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一剑指-offer-ii-020.-回文子字符串的个数">一、<a href="https://leetcode-cn.com/problems/a7VOhD/">剑指 Offer II 020. 回文子字符串的个数</a></h3><p><strong>题目描述：</strong></p><p>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 1000s 由小写英文字母组成</code></pre><p><strong>解题思路</strong>：</p><p>​ 引用：https://leetcode-cn.com/problems/a7VOhD/solution/jssan-jie-bao-li-shuang-zhi-zhen-zhong-x-qqq0/</p><ul><li><p>思路1: 暴力搜索</p><ul><li>搜索所有的子串，并分别判断是否为回文串</li><li>时间复杂度：O(n^3)</li><li>空间复杂度：O(1)</li></ul></li><li><p>思路2: 双指针，思路1的优化版本：</p><ul><li>先使用双指针 i 和 j 枚举所有子串的起点和终点，同时分别按顺序和逆序累加所有遍历过的字符得到字符串 s1 和 s2，判断是否回文只需对 s1 和 s2 判等即可。这里将回文判断的时间复杂度从 O(n)优化到 O(1)，但整体空间复杂度从 O(1)升到 O(n)，算是空间换时间。</li><li>但此思路的时间耗费仍然会较高，因为字符串的拼接操作都较为费时</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string s1,s2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                s1 += s[j];</span><br><span class="line">                s2 = s[j] + s2;</span><br><span class="line">                <span class="keyword">if</span>(s1==s2) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>思路3: 中心扩展：</strong></p><ul><li><p>枚举所有可能的回文中心 s[i] 或 s[i]、s[i + 1]，若回文子串长度为奇数则其中心为 s[i]，回文子串长度为偶数则其中心为 s[i]、s[i + 1]；</p></li><li><p>以中心向左右两边扩展，即</p><ul><li>左边界 l 减 1</li><li>右边界 r 加1</li><li>如果 s[l] 与 s[r] 相等则回文数加1。</li></ul></li><li><div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> Solution <span class="op">&#123;</span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span>string s<span class="op">)</span> <span class="op">&#123;</span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>s<span class="op">.</span><span class="fu">length</span><span class="op">();</span>i<span class="op">++)&#123;</span></span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i<span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span><span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">&#125;</span></span><span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> count<span class="op">;</span></span><span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">&#125;</span></span><span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;;</span></span></code></pre></div></li></ul></li></ul>]]></content>
    
    
    <summary type="html">与回文字符串相关的题目的解题技巧与常见优化思路</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记13——Maven基础介绍（更新中）</title>
    <link href="https://blog.slks.xyz/2022/02/04/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94Maven%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.slks.xyz/2022/02/04/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94Maven%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-02-04T00:54:19.000Z</published>
    <updated>2022-02-16T06:37:28.350Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于Maven相关的内容。</summary>
    
    
    
    <category term="编程语言类笔记" scheme="https://blog.slks.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
</feed>
