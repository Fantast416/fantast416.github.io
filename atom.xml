<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-04-15T04:43:57.456Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2.3.2 经典问题（生产者-消费者等）</title>
    <link href="https://blog.slks.xyz/2022/04/15/ef402168a5bd/"/>
    <id>https://blog.slks.xyz/2022/04/15/ef402168a5bd/</id>
    <published>2022-04-15T03:43:00.000Z</published>
    <updated>2022-04-15T04:43:57.456Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=19</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.3.2节的内容，含生产者-消费者等经典问题</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>2.3.1 进程同步与进程互斥及信号量机制</title>
    <link href="https://blog.slks.xyz/2022/04/13/c34143b1b4b5/"/>
    <id>https://blog.slks.xyz/2022/04/13/c34143b1b4b5/</id>
    <published>2022-04-13T03:43:00.000Z</published>
    <updated>2022-04-14T13:29:47.670Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=18</p><h3 id="一进程同步与进程互斥">一、进程同步与进程互斥</h3><h4 id="进程同步">1、进程同步</h4><p>​ 同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>​ 例如：必须按照写进程然后再读进程的数据进行。</p><h4 id="进程互斥">2、进程互斥</h4><p>​ 我们把一个时间段内只允许一个进程使用的资源称为临界资源。多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>​ 对临界资源的访问，<strong>必须互斥地进行。</strong>互斥，亦称<strong>间接制约关系</strong>。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><h4 id="对临界资源的互斥访问">3、对临界资源的互斥访问：</h4><p>在逻辑上分为4个部分：</p><ul><li>进入区<ul><li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</li></ul></li><li>临界区<ul><li>访问临界资源的那段代码</li></ul></li><li>退出区<ul><li>负责解除正在访问临界资源的标志（可理解为“解销”）</li></ul></li><li>剩余区<ul><li>做其他处理</li></ul></li></ul><h4 id="进程互斥需要遵循的原则">4、进程互斥需要遵循的原则：</h4><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><p>​ 1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p><p>​ 2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p><p>​ 3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</p><p>​ 4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><h3 id="二进程互斥的软件实现方法">二、进程互斥的软件实现方法：</h3><h4 id="单标志法">1、单标志法：</h4><p>​ <strong>算法思想：</strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412173137552.png" /></p><ul><li>这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是Po，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li><li><strong>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</strong></li></ul><h4 id="双标志先检查法">2、双标志先检查法</h4><p>​</p><h4 id="双标志后检查法">3、双标志后检查法</h4><h4 id="peterson算法">4、Peterson算法</h4>]]></content>
    
    
    <summary type="html">包含王道课程第2.3节的内容，含进程同步与进程互斥及信号量机制等内容</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>字体生成论文研究进度</title>
    <link href="https://blog.slks.xyz/2022/04/01/f225f383e158/"/>
    <id>https://blog.slks.xyz/2022/04/01/f225f383e158/</id>
    <published>2022-04-01T15:09:19.000Z</published>
    <updated>2022-04-15T04:41:33.315Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="e5f8302770d3f1196df660bd60337269870ebb072b770ba66fa0c63ba1ee5e80">1557a4d06c41b8b7cb942a6d0525c027cbeeadc10caf98a45705387558304bb469290ed727bac22c14368bef657fb469dfaa63f24918c0cff3b2760cd4c7e41d903d1a82d66af59312cac4cac46cf8eb876b40a6bca879a6bb5005f2de6cb7700621bad9f290d26f23d98ad7d10aad36bec4e6306e0626ed5b58ff9d6c87b6b9fb9358b7c8663eb4e3f6b73813f33f206cb37ad8174d4a8dec552525d1b17d29a7ff9a69af1c0464d7be2cd47663a8511470a8a9ecf52a3eea3d24def5ef2b867aabfebd01f658d97f48cb62241de8f7a8c19ea8bc92d6c680ec59bc38b048d4a308976e00455157f8a76e5752968a6174c53a18015c2119da1a8f5280dcf70183b2495d28a1d76e15b379546a0b06e6c839ea238fcb28047afe3dbcacff26df81b06af343458ecd208b948b39a2492d48e9642b072c9bfd16ed0cb71ea14f37e75cb08f32c613696c7c4972cb0fb4485bb76c8cb0dc4c3fbbe9c93126e4390a2a8229559bd2c2c6faefceff46203914f2f00652d29fdf010b422e23724088772c9e745cd32593876376cb0a53a040c9e196fe2656eeb704b771fe5475057384f386bb027c4bd1b217ed7001f15d3fdc29fd5181f1fae8ffa2f44c6cc11c2da8959c32fd4a9b3c0062bff9e56396df306d32b348c6e64d0b170d30e8171e18b2d78255d4316693b62691fdfb6a817fe61b1693106c28fccd5ce62b0b0125fd859a8258a078430b4bf7405a514b7773dc08b831140d4f0cc87c8e063d316d264ea95ee263bb9f5cdc91bf30aad5e5a1d714e08baf6f04e7616de3524e57801f1baf7f97870c992a9f3cc3039df01ec0c4275296352a568c1d5321bd4843983cb072df677d45118fd9088bf3b8c00c472d7e46e51154b7b36f57d63fbdc81195af5534e5499fcccc06b591d8eb3371ed5276b41be66ea5f3dbf82a1719259f9120d62d7c013d933d885af7abb62f1705cf99d3bc3c8eee7c175125d4294da1d2de0c91d1631818b17f86b632119fc811c2490464e9f89cbc4e1dac8ad70517617c9d655ec2c5415ff660a847cebc2ebaf0c2f4693bed730c76f1ca6d70b339d56e1fd5d5e150726649ebac0365e0c394a17575fd76323fc5a6d553f5e3d3f52eefb45c116dcb30419816c1d6b4ac4896a2e849da415f1838ec5d74b4be3ec15478e3e590da1d7f06abb166b4dfc49c73e51feaef3fd53fd26fe316a72329ac6238e88d36e3c992b15da7d62c45d062c5c311017e73f99e448c0da49b84864ffe06a036ca0fb7172589beca077aaebccadcd25496b882cab1c263f67cdc4eac7ab3c15ed9dbac2535f179ebb6370202e2d7fa4bcd6365cb7530f584ba62b638770ad3763b47a0ff39d83cfe2054775997d73c6c75314a92f83b0b778ee3cf57f61cf05ebd869e150b5479a50d977b841aace68aecb4e4d02a9f6fd867ea3a88cded5d22d37a0f71ec4938f53af0606d12b7968460ffa2d7801d0880f8cb30457c2f73d5c5038c266274ce360c7c5103f6fa25146e69305beee1ac301138c71e0e639e7bb9acc9740bd36975d389f6604ea7438f567fecf87729acebbf702768cb8835f6c12e2253da46311fccf07f84b3fab625eccfdb951b3a5468167187abbb22765f386d211a15cae350818a718337d26898b29a6c87f9847e439f4c8112741d9d3a4e27cf2393c37b62abe18b2a3f881c4dc0b3234517ab82511ae01c67d5913f66bda910f490ea66d8b886aeac33f6c8cf3915da55d83781dc1662ac812e7f858cef06fcdcc2f460f3fb3d67c962a0fab772ef53eaf175371588430819597cab00f6169595c2cc0086913bebc6797bc8b731164c89ef5ac37e48e364791b430543690cce71dd6bfabf7099c5dee72eef76edcdae324c62c904ac8ad8fcd501cb61a47935b65411a3af7cc8517bc422547f12c508d21c5f4cd1a674a7c5a23e5ab205630e81260ea6929dadca1b04aeefc45c36228d5cf94e1b64ac238173c0378bd3789c08263b90fe69d83ce5125b7d66a580a9116932bd48c79c391de8312844eb1a9648cdbf02e37c2df098ba7e8926d5c71339aed403f4b8089931147eba889298b1c7caa4b25577910adfde5a7259308891f58b7849a6218af1306efa4fb9a9677945003231551e5b209869d416341f7e48e29150fa0b654230c959c521623cec881abd1714c7de102d513817649f0180c315fb06aaa4457e78105cb3b9373c957176dde511e9befd544541b57841635e3c8a367510d575350c85d09b82607e765a03a22b1eea7ef693d775ead21e33b83a6676460e3510cdef839548b3027329d6f8bc2f76e36de3fa3d1700f7172772379d8743fc2eda0bcd44d616f0bd20cbe2791802761a56f994cf9a7446b7856a993fc08d1f888344a5ab76d59c152327c64d2fbe44a4c9bb2db0259b4871255b8e4be4b14e1d4e9ce61525cfeea2e156548c3e4b989e6dfb16c5287af6db48b73332c19583ae24a18e05968ca12b51afa53f5a3e57edd8783a52e5580f9ea2a666a43fbd326b3c488f5a1172fb06476e92d5b96ed9f9cf53f960170030fc010866ace85b70aac65e5db2d48faa0105215e60dbac4df3de47f665a31df0ed079e88bd9a53ae9af23312b301f7c99cd480c750905851ee4cb49b4c758c4edd40b737d475470e9a01250c8935d9dcbb9e5d7507d2344ac31fd87d917531cc7833b60e0e67bb44f70bf25f9d2e4ec2e043978075c7bbdb4c0f74764664da79f7a9304a108323a7fb113ffab07b81e11064e55fa7ccda7942d5422c4660bfdc9dadb08a1019ad532368bed99500b74e377d798237efc64dd25ad571ad4951b7bfa4454b00873e7a20e6b7620db72732ea446d66048d708cb60aa006ba6eb916cde421695a256daf741621fdc13dfa6d9cdc925d21238d051be3413ab06eb6eb7a798cb4b8175b67ef797e78ce75552960cc7cc8f969c079fa0513016d317d539b03fccc2e42c6dfcc5a4776f75fd5b16bacb03d726c5c519beb5a538b7bf34c262e192f314ce264d1decb06a4fa63e2da13628bf57ab2b304f9283245687b3cc8d153ad643f0faf982c76e38089672c7d4bc5aa7787efd0f3178234470c4167d2e0b3296954d4cf0d00a9de0f38573e760062c676dbdef597fe42c577619ac5357b0c4f4c0fe6e46710a93f752c841b8e4af23a96b6fdcb09075bdffbacb2e2d8c2b87fe2a02c50096d42717e737f1c0f1213a8ffeddc0de60d95513f5fb6d3e5fc1b4b2bfa66849a6f33ce04f58feb4dfdac842ec4f66c21873ee61613042083140c6625b7caeb0fef6f42b702150538e3b5dfdaade1166028b94f27007b5323cd30e6ff90fbd179521c42104f7eb9761d6e6904c4c86a6e806b7385cb4ca6c0511ee6ea298dbe9eb45b34ea50a05412af4459250a4fab5e5d148957c6b5ed047b7e3291d4bbbf4c9f43a63707b474fcf87134537f73f1761f02ffcf67e5355000802691b61bb4a27f5b4e306370f9013a86d950bc8517d7ca30f1286854dc00a41478c21bb6ac28c217851b0e477507d5685991a5de31b24827bf6c005af7e8af26e51e820d29e535e9b2d6fb8d15ac9d2fd7c2cb612d00ce229f604f8e09a7a80896da84e88dd51c46f77f6600127a8ce16046516dc5472e3e5ed714c90f691c94150f974ea47e4779dd4b19c5f66aceadb4b66a0886d7801dbc01fa171591c3fa0f67696ee1192665e0c3a1805f3dba44b69c8ac1784abde6f86f131defc3cc13bc9ae540acf17d1a76a0e4adb1efe598e6274f58f64e5072d3e172e6647023b64faf12ed9996d22d371148511e45a4768c2b41c6fc0c1be4c36cd07ee15137e6c401c1bc26f3fc6436e3f1c9ecfdb2a18649ad0006c91621abf05a7c3391188634ae0ca51726ff7c624768a12a285c300474c1b2b662a841d8f4f3792422d22dda890972b6b4f4679638678342f686ba0f59afcb865920073c9efb87991e2b521aa0c83c5bfc364bb5e4d16d26eaaa67841c2d6843c992267a97b56ee7049f0088e42619585d1b554bf563ae787646fbe963064a095bc6151c49a10622844ba56eb3f29035d3aa4a038ff64d5b1db16a222f9f62d903715b430cccb7787fa53707ee76fd83858e21ca9b89d00a68c64639be659078d45c67fccf27f7d17ee72698da26745bbbd8a22701246a0c6dd329816f84a52963305b054909d5ad55dc64175e32c7236473e9289c7af7714d884247bb091ab3370a526108a42f31c4614a35168228351e53fe53603e79e9b5f920b24fd0aa89b9429a5eb6602b98986bc9c7c867f690b0b641ba5acd519e274716d59d5d46f5af19e1e7f5316b24593c4d54bda29b6378bb7949d667b45c0d63abb1b2d916dc7d9ef283feb20f27daee2e9022385df43183a2d4b498dbf7eee4258bf630095c1d9ad4e1f27dba951422a06847b43fe828047efe6edbd671a1f62b085a5f42cdd7fb687addbd30c65eadd08c65678e65a5916b24c01ef30cced172e2b0ccad8424ba12f1e72ad46d8433e1c738a5e64ec189255151a551c844b8d14e763c8369581f81a1bd41234c98b8aeb89b3e1f15385ef3614670ee22168499704c05469e03c421a81537b052c19e282582235965abad795ba0f7ea388b5002508c5f3e4bde89fe1809a3bd834e1429ccb2aa0855a040bf31c7f904b5793ce82b23501e4b4502980a84097346f33e47bef6a81b9eb823511e9ccbdba995f1a977dba75069e8ffca38c251761fcf1dbf0e44f6497b9d54ad40be2e7e772ca8c8b2a0fc5e22e4c338023ec592cf9078d103669c0b82cd6393a7044d0dd1543d8c2962706f8f9ad12f29078e0d438486f29c299d78aee4577f82c92504e32d7ae425c778eded66fba0d1e2dec420bc65ba19a08f2145c17bd5b363d638a5ede1922971eebf013e20304b29db4f25d69c71065ba6ff157b6c4bb0c5b455def3defecbcb00913d7acc6f01fd86179e0229150745ce74dd707a5f23c05e4d9e0031380fdbb806fbdc25dbb32add3252104b7c8c8ab7a03c72c7e90e3cc14f7cdcacdc3b853e606bc40798b574bed25c8dde9943ed62f1f20a8e350270ea816501e1821414344a968faf118480c8dd20c9c25a28d4531494b4adcc4c95b8d8aa93652c87a7af070bf76a1df6672656db1e1955b2b7be033ea3556ab84a936a868e10cbdcb69ce1245cbb181457e63a8ce2dbbe384c2e94ea9b9315c438b2f5ba355e7b97984483414d30105af960fd60fa66ba713cb442990ba46fd8a67edb06a610f2070a2880c717b721a401309b7e4f3d8be69d3a464411ca2903daa4da20beddb0f73966205cd125cea7f6e86732b684dee1058fab67195999994a4b4e680f96b78c5e96d0ce9dd098183da7487623bc996cdf699f982d07f2f6ef1dac852c6ddfc9070e630f0d0d62e293c1f1a10419a56a3ee88d3b8836e6e9944d967d5741a18e68268688802fc6873813437eff3724a6b9d45a47c4441fff5af6b5b3919402d0d57c98007acdd61f5c8d6bf9a9e203defac6bd7f016d663ccf4dac401064d0a648b5d0e772566323c2e7fff9d51d51336ac98eccc175a7575e84a744f957c6492ad76708ad18921d6b1d73978ce763ecf36e61c32bf7a6f183b19e278e1dcd532541cc0bb986a397ac83930dd464e78e3cf21759dc2e4c4ebd815da48656e0e45a83036cd1225abc5bdd346246b365df179c447a414b0780bc9b96489dc186b7c9778263718b26e724de9b35c0075308ffcb8535a04074d83129c2935aaffb611a60657af65524be4534e263485c7bc2db440525a76b824c78bfe79c28adb3ffbd88ceab7539f338bae63a5e799145785295d7bd77bc2a1570dbd99e8ebe73030a683d943c4f2797b0377726a7ab08556e5ec482cad66e3bc24a84a7cffb29896107db7dabc075c7de36cd4688892c086dead71f0b7d76c6d5afe2f9b9c52c02f038b926723c6f4e08bd6abab0526d7539eb4839034f8ee6a93cf7d4c69bcab7dcf661d8a1f18df2dce91d378a6285ca85b4c951e85ec74e2a66f6ff145da79952ea8f1923b0acf56d65f4b750e45e56a8bb1a5f13a0a4adb7557e3706556c668e0794e9d5cc11722de458e7f0d4c1b3b8ec6820476595adf78e052d79e005a53d0ae0397e1bdad14107b29c6a2f88c03d6c1dd8cbdc01c518b1df19cfdd4f5d9ff311b5689551b8e8d47a26bf26091db9d3e0b940eb7a87069fc7fdeb76e1c473b58b99af5898a48fbbdc88b2875129d5802cf210126c082c1fd051c58374e16388ba197a6d4f444bd623718fc5028c835d182be3ce5c14f279c63082238102afb69f8b738755516dccaa902994da04de646bad28f7bc2d72ca5e2d45872d81561f2b8b2c08d8b61ce3a75e78bed293d3282a495927c1d9e656dd7e5d507d7f8ff798a4456943e1d9366710eb0bc3e8767661986e9df77e923d85ec7ecaf599fa8a323258bd73f34d6ea21b48f834ec35f92129115d65657b53bb4d36c0eb66533bb6f4fc05440edd66a3a5d3609c590a624a88916a26949a14615cfc596498ab811c8e62e6c69713bb4373ac1083937c4b80cbbc9064b7c93e5edefc808be91a1d289de244a5bf9a15a15d05c59ce98f5032879a01d74eb87608d4315c2718608ca6da160672895474800adddef16c0d472fa9c9e93a206080f89b4b9e5f55d9dd89e9a984f64c3d273d00985adb296e8306b34e136309d8ff058eab20a3f2dfa701f1e93a8c5056b51854ca99d9828f90b48c7ccc8c700c7dc54b684a445de51cad1f91d14bedec404e4cc84f2b8b3d26fdf27e988b37f8a3cd484ba0d3902933fe61ab331256f4662d306518b5240217ae0864d128e95912477da8f19cde2610c6e7c58e710a33c0615c11b51b56a6234f4c4cc6a96f2b1f03d3e3ae205b9bb412a72d60516d70a26a6b0a2c3977a8e669044585f4d8e1714b693bc9caf07be9fd9455911ed8e7dd3055a9fbfc338b203a5cb4858077b3ec3f119904babb12ee64d107e468669ca4128260f537cfb761694dbc26fd094a68b4d11aabcfce4f77d440f383b7efe5f89731a9387cd8e1d3027b36ddc9e6b2d59f0ed4e167ef5a7eaef03dbd508090f8795bf2eedd3d3155dd641229f8b456fe945351ae4b8f4367b73b76f8f1aa9f8c438c89c2567d60cbf700c84b13d94824e213efe5f9e108ec29c89daa6980df2ef73bf45f349ce1b0745a3d9785fc14369ea2ed626d00ce96d5860847291e2d64c68c1344fec51188bbcf3675b6f201441255fe9b080a4baba2de6a05816479d3668e7e02be0d69c7172aa772cf1bb0b358768ee353c0c93ee181c6df0d24ff593e842d6c344882a0c41d0a66bbbfe4c314474d1b41e75c20b03cebdbaea8d2aa1effaabaaa175c1b8f0a1fe76b84fb0eb080d5184cbe3fff09dee31bb787d066d99411c76e9f6e7428a767b9265a4859a882b920d9f7b8edb0fc1a8a56bf1bc79077296ec9944db2eb04e18af87e1ad47f59ca80b4d2d6b8c2fd07add1fcd783495ad5c36aebad38bd324dce3bad4975e0563edc2863dcadedf071fa6e14a06e2afb6bd29ec09e1d1e27f26eba064d29cff609c40f1b122460ad981c751ae375166de7f1d749ff43f58c2779dbcd5883b2ae69f2fc861b85e540c6ec2afc391ea1b4d1874ec579087ff9ae2238be3b1cfe9eeb711f24db8fdbec953c421d3272ad866da84e2011cfa5f8330f1b5fb861f29b884c195c6887501d7be8bf375b53e77f4acc9bd964b2b073207d9e3aeddbc099aa620723e7fe2a94fe3d5e67b5a0bd4ece7855d726493216962ab255a46a84bf1d18022eb79b4ed952c7242077882a14ec7948fc2c2ae6657e1f02673d59bfb69d3120c70fc53196f28437e7c0962b0e6721d4a1d46ec8a230091b52c48b40248f3b3eb6b00d6152953df24fd77b35310d910bef8ac0448ec8d2d57f39387c66828d5663aafd753ff94c06c4626b2a396712889a2d067ac3c2acd15a0ae0aca53b54e38a46bd4d057b9ededf2c19a2cf0f0125e6610a33fda2659e4ea5fa2f118d36b31812bb2a7d51cbc656d783b297f120c3358f1c4163abf2da269c696c3c50d85307d7d0df16938ced5b378e5a061e2a28d8de43f31153fde807b9a93296288c2b251df8137661a4d0a85c09366e9aded2481a50a2319087c124bbd25b789f0e202c649fcf66de537e896fa0175161bc5e98e5783716515f118fa1cbc9e7c53e936c338a62e8c34d34354ac900a16e5593f92eb1b35fe21f976b16d06d1ac2de547b3ed63d99c74724282a84403f219056a68be4cb490806fbaf7676bf6ab1c4ff8c7beed62fb6cc02f6e4bfc0fab1ddfb095e1508035147178d35a28d13b481603d148ac96f55b5fce7f0cdb5896c3b64fa859cff3900b4a6427a13c98aa93cb5ad3feece366a4c017827bb7a7555b856c7f9e27e9785cc004b7f0cb65f41d0010547d45e5c5e5b08134ec00bc5a0605929e464024c636b796d38f554803f1ff5d22dc14c7d14bae188b5a3c00f45d1199bf778864ef979904073d1980213520f2b84f7eca2d3cec5e9de5ce7befa67950c133347ae38539ea01013bd9dd58368ca64e15a92fc73579a504afbad0105f04fd7c3b51d1c389ae68be8dbb51e6e9128b485f0e59c2a442ab6198264595aebceb702fd606788f8cb038d9b69214668a31bccb57dd85e67ce53c79b14123d400ca12324439268bb258ef47c1cb9ecdc2e571cbd2f9d0df1c8e83214023dd682cb3152f9b7d0a232d9c019993a3336598d4bbe20f35b8c85599749acb41eff48d1be4971576757e0d7e3d5fb92a3eea7e9797c1c4a59a5111a2e7c29506f76e021d45b8b7992eb33f63187b074067f43a4c2454f5eea14908e501ba942035515460eff9671d55baf64c730165d06c501137ccb01fddbb169f4e10678bb8948cab6bfb10b3a6fbc954b484aa94c4249fbb50e0a0748643b3da7a8fb74f7d7380d98d4e835ff2579e07a30538022a7f89420ddaae350f4eb1de3fb55ea4ef60287abadd82508dccb2fd772ed47e7969204b9f2b94f95f068a76c107c8593fadbd1347d89a6f928c64b6887c0e5d82d61e4075e83960668902c1249acc1e2be9f7c67a413f8aa8af329b821a9470f75c1ad868b30f497e52fa5b22059537a12de4c2713a7392df03b74f7e7629c85e8366edc52d6f3ed8d23e0645ee0f45b6ee30353d444b52bd28971a376c1ff05982643e59f679d17cf57d0965cdaf19c11cbde5a28e9b6e59d208661a164a76bfcfe1a030ca9bee379420adaa559a0bdc997e8dfd84ab51d9b8106994f904c59fdf34a5ff90f6f49cda92dbe789ea76ddb79d16cdaafb49911c484a49dd57a3b5556c80ccfd566fd813547af9c0e2bc48c23687d1101082e38b98c79c96aeb6c6e0a957012290f2d98f07e8586bc1bc69bf1097af9af1fc91148fa5302367226ca93a32aef0d9f6257db88e44453d701a07cf40e36a6af7fdcaca21cb817000da33a6e455813358546dd1204e7f11cc088672d26a60b2ad4aa00afa75711d455ac3e56df4402fc223f6b6eeeae8f90f90e166fb6c653fa84f933605db5980fd48e0775d0d9b98ac5a64bed75763712cd396e528d04481d46d59fd3ed898dabc23eb57b5e6b218a8ced69b3aa73aa9823e1d27dfcb1630de213db96efad0b3c3c7a431d59c58db928f7fc2ffdd64025f726beeeb01825236b0fe86e45aba00b0ea373d695318175ba1fee01cd06b523</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">里面包含了字体生成毕业论文研究进度及讨论进展记录</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
  </entry>
  
  <entry>
    <title>GPU占用清除</title>
    <link href="https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/"/>
    <id>https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/</id>
    <published>2022-03-30T13:47:19.000Z</published>
    <updated>2022-03-30T15:27:05.866Z</updated>
    
    <content type="html"><![CDATA[<p>当服务器上的显卡如果被奇怪的进程占用了，但是nvidia-smi并没有显示的时候，可以使用如下命令清除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">描述了GPU占用清除的命令</summary>
    
    
    
    <category term="⓺ 工具使用类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BA-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="GPU" scheme="https://blog.slks.xyz/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记12——分布式DDP基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/29/5a94914aa20a/"/>
    <id>https://blog.slks.xyz/2022/03/29/5a94914aa20a/</id>
    <published>2022-03-29T08:48:19.000Z</published>
    <updated>2022-03-29T12:47:42.430Z</updated>
    
    <content type="html"><![CDATA[<h4 id="node">1、Node</h4><p>​ 物理节点，就是一台机器，节点内部可以有多个GPU(一台机器有多卡)。</p><h4 id="rank-local_rank">2、Rank &amp; Local_Rank</h4><p>​ 用于表示进程的序号，用于进程间通信。每一个进程对应了一个rank。rank=0的进程就是master进程。</p><p>​ rank是指在整个分布式任务中进程的序号；local_rank是指<strong>在一台机器上(一个node上)进程的相对序号</strong>，例如机器一上有0,1,2,3,4,5,6,7，机器二上也有0,1,2,3,4,5,6,7。local_rank在node之间相互独立。</p><h4 id="n_nodes">3、n_nodes</h4><p>​ 物理节点数量</p><h4 id="node_rank">4、node_rank</h4><p>​ 物理节点的序号</p><h4 id="nproc_per_node">5、nproc_per_node</h4><p>​ 每个物理节点上面进程的数量</p><h4 id="world-size">6、world size</h4><p>​ 全局（一个分布式任务）中，进程的数量</p><p>​ 每个node包含16个GPU，且nproc_per_node=8，n_nodes=3，机器的node_rank=5，请问world_size是多少？</p><p>​ 答案：world_size = 3*8 = 24</p><p><img src="https://img-blog.csdnimg.cn/20210811144558161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h4eGp4dw==,size_16,color_FFFFFF,t_70" /></p>]]></content>
    
    
    <summary type="html">PyTorch 中，关于多卡多服务器进行分布式训练的一些基本概念</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Pytorch系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Pytorch%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记19——EMA指数滑动平均原理</title>
    <link href="https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/"/>
    <id>https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/</id>
    <published>2022-03-27T01:44:19.000Z</published>
    <updated>2022-03-17T02:36:22.859Z</updated>
    
    <content type="html"><![CDATA[<p>​ 在训练神经网络时，通常会使用一个叫 Exponential Moving Average (EMA) 的方法，中文名叫指数滑动平均。它的意义在于利用滑动平均的参数来<strong>提高模型在测试数据上的健壮性</strong>。</p><h4 id="一什么是滑动平均">一、什么是滑动平均？</h4><p>​ 滑动平均(exponential moving average)，或者叫做指数加权平均(exponentially weighted moving average)，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。</p><p>​ 首先我们假设一个训练参数a，它在不同的epoch结束后的值分别为： <span class="math display">\[a_1,a_2,a_3,……,a_t\]</span> ​ <span class="math inline">\(a_1\)</span>代表第1轮epoch迭代结束后，可训练参数a的值，以此类推。</p><p>​ 然后，我们假设不同的epoch结束后，滑动平均的值分别为： <span class="math display">\[ mv_1,mv_2,mv_3,……,mv_t\]</span> ​ <span class="math inline">\(mv_1\)</span>代表第1轮epoch迭代结束后，滑动平均mv的值，以此类推。</p><p>​ 滑动平均计算的递推式如下： <span class="math display">\[mv_t = decay * mv_{t-1} + (1-decay)*a_t\]</span> ​ 其中，decay为衰减率，用于控制模型更新的速度。递推式中其实就是利用加权的思想，把新的a和先前的平均，做了一个相加。我们可以发现，再很多轮之后，有些离<span class="math inline">\(a_t\)</span>很远的a,它已经乘了很多遍decay，相当于权重为0，也就是不影响最新的<span class="math inline">\(mv_t\)</span>的值了。</p><p>​ 从直观意义上来看，我们可以把<span class="math inline">\(a_1,a_2,a_3,……,a_t\)</span> 看作是t个位置，然后想象有一个长度为k的窗口，从最前面开始向后滑动。为了方便说明，我们先假设k=3。最开始的时候，窗口把<span class="math inline">\(a_1\)</span>涵括在内，然后一个epoch过后窗口右移，现在窗口内有<span class="math inline">\(a_1,a_2\)</span>，再一个epoch过后窗口再右移，现在窗口内有<span class="math inline">\(a_1,a_2,a_3\)</span>，再一个epoch过后窗口再右移，此时由于窗口长度为3，所以<span class="math inline">\(a_1\)</span>就不在窗口内了，窗口内的元素为<span class="math inline">\(a_2,a_3,a_4\)</span>，从公式上来讲就是在此时，由于<span class="math inline">\(a_1\)</span>已经乘了较多遍数的decay衰减系数了，所以其的系数接近于0了，不会再影响窗口内计算的值了。</p><p>​ 故此称为滑动平均。</p><h4 id="二更为公式化的解读">二、更为公式化的解读：</h4><p>EMA 在实现时如下所述：</p><p>​ Exponential Moving Average 对每一个变量（ <span class="math inline">\(variable\)</span> ）会维护一个影子变量（ <span class="math inline">\(shadow\_variable\)</span> ），这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会更新为： <span class="math display">\[shadow\_variable = decay * shadow\_variable + (1-decay) * variable\]</span> ​ 其中：<span class="math inline">\(variable\)</span>为每一轮结束时，训练参数的值；<span class="math inline">\(shadow\_variable\)</span>为影子变量；<span class="math inline">\(decay\)</span>为衰减速率。</p><p>​ decay 决定了影子变量的更新速度，decay 越大影子变量越趋于稳定。在实际运用中，decay一般会设成非常接近 1 的数（比如0.999或0.9999）。</p><p>​ 为了使得影子变量在训练前期可以更新更快，Exponential Moving Average 还提供了 num_updates 参数动态设置 decay 的大小。如果在初始化 Exponential Moving Average 时提供了 num_updates 参数，那么每次使用的衰减率将是： <span class="math display">\[decay = min\{decay,\frac{1+num\_updates}{10+num\_updates}\}\]</span></p><h4 id="三什么时候用到ema">三、什么时候用到EMA？</h4><p>请注意：</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ 在训练过程中，EMA只是以一个记录者的身份，在进行记录。实际的实现中，如果你在正常训练的网络是network['C']，那么你可以再实例化一个新的网络，叫做network['C_EMA'],其最初和network['C']一模一样，但是network['C_EMA']并不参与实际记录，其里面的参数只是用来记录滑动平均！！！<strong>（这就是DG-Font代码中，network['C_EMA']的作用）</strong></p><p>​ EMA作用是<strong>使得模型在测试数据上更加健壮，有更好的鲁棒性。或者是最后save模型时存储ema的值，取最近n次的近似平均值，使模型具备更好的测试指标(accuracy)等，更强的泛化能力。</strong></p><p>参考：</p><p>https://zhuanlan.zhihu.com/p/51672655</p><p>https://zhuanlan.zhihu.com/p/343210667</p>]]></content>
    
    
    <summary type="html">整理了EMA指数滑动平均的原理，以及pytorch训练中的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="EMA" scheme="https://blog.slks.xyz/tags/EMA/"/>
    
  </entry>
  
  <entry>
    <title>2.2 处理机调度及相关算法</title>
    <link href="https://blog.slks.xyz/2022/03/25/9887f629bb62/"/>
    <id>https://blog.slks.xyz/2022/03/25/9887f629bb62/</id>
    <published>2022-03-25T12:40:19.000Z</published>
    <updated>2022-04-12T03:42:14.890Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=13</p><h3 id="一处理机调度-概念与层次">一、处理机调度 概念与层次</h3><h4 id="调度的基本概念">1、调度的基本概念：</h4><p>​ 当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>​ 在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</strong></p><h4 id="调度的三个层次高级调度作业调度">2、调度的三个层次—高级调度（作业调度）：</h4><p>​ <strong>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</strong></p><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度是辅存（外存）与内存之间的调度。</li><li>每个作业只调入一次，调出一次。</li><li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li></ul><p>​ <strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</strong></p><h4 id="调度的三个层次中级调度内存调度">3、调度的三个层次—中级调度（内存调度）：</h4><p>​ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。</p><p>​ 等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量。</strong></p><ul><li>暂时调到外存等待的进程状态为挂起状态。</li><li>PCB并不会一起调到外存，而是会常驻内存。</li><li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中。</strong></li></ul><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</strong></p><p><strong>注意：</strong>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p><h4 id="调度的三个层次低级调度进程调度">4、调度的三个层次—低级调度（进程调度）</h4><p>​ 低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>​ 进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><h4 id="三层调度的联系和对比">5、三层调度的联系和对比：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326111647450.png" /></p><h3 id="二进程调度的时机切换过程与方式">二、进程调度的时机、切换过程与方式</h3><h4 id="何时需要进行进程调度">1、何时需要进行进程调度？</h4><ul><li>当前运行的进程主动放弃<ul><li>正常终止</li><li>发生异常而终止</li><li>进程主动请求阻塞</li></ul></li><li>当前进行的进程被动放弃<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><h4 id="何时不能进行进程调度">2、何时不能进行进程调度？</h4><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难 做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区</strong>中不能进行进程调度。（但是进程在普通临界区中是可以进行调度、切换的。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ul><p><strong>注：什么是临界资源？</strong></p><p>​ 临界资源：一个时间段内只允许一个选程使用的资源。各进程需要互斥地访问临界资源。</p><p>​ 临界区：访问临界资源的那段代码。</p><p>​ <strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p>​ <strong>内核程序临界区</strong>访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p><h4 id="进程调度的方式">3、进程调度的方式</h4><p>​ 有的系统中只允许进程主动放弃处理机，有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><h5 id="非抢占方式">1）非抢占方式：</h5><p>​ 只允许进程主动放弃处理</p><h5 id="抢占方式">2）抢占方式</h5><p>​ 当有更紧急的任务需要处理时，会强行剥夺处理机（被动放弃）。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操停系统、实时操作系统</p><h4 id="进程的切换与过程">4、进程的切换与过程</h4><h5 id="狭义的进程调度与进程切换的区别">1）“狭义的进程调度”与“进程切换”的区别：</h5><ul><li><strong>狭义的进程调度</strong>：指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，</li><li><strong>进程切换</strong>：是指一个进程让出处理机，由另一个进程占用处理机的过程。广义的进程调度包含了选择一个进程和进程切换两个步骤。</li></ul><h5 id="进程切换的过程主要完成了">2）<strong>进程切换的过程主要完成了：</strong></h5><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p><strong>注意：</strong>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h4 id="调度算法的评价指标">5、调度算法的评价指标</h4><h5 id="cpu利用率">1）CPU利用率：</h5><p>​ CPU利用率 = 忙碌时间 / 总时间</p><h5 id="系统吞吐量">2）系统吞吐量：</h5><p>​ 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间</p><h5 id="周转时间">3）周转时间：</h5><p>​ 周转时间，是指<strong>从作业被提交给系统开始，到作业完成为止的这段时间间隔。</strong></p><p>​ 它包括四个部分：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li><li>进程在就绪队列上等待进程调度（低级调度）的时间、</li><li>进程在CPU上执行的时间、</li><li>进程等待I/0操作完成的时间。</li></ul><p>后三项在一个作业的整个处理过程中，可能发生多次。</p><p>​ 平均周转时间 = 各作业周转时间之和 / 作业数</p><h5 id="带权周转时间">4）带权周转时间：</h5><p>​ 带权周转时间 = 作业周转时间 / 作业实际运行的时间</p><ul><li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多， 带权周转时间更小，用户满意度更高。</li><li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</li></ul><h5 id="等待时间">5）等待时间：</h5><p>​ 等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><h5 id="对于进程来说等待时间就是指进程建立后等待被服务的时间之和在等待i0完成的期间其实进程也是在被服务的所以不计入等待时间">对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/0完成的期间其实进程也是在被服务的，所以不计入等待时间。</h5><p>​ <strong>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326114401542.png" /></p><h5 id="响应时间">6）响应时间：</h5><p>​ 响应时间，指从用户提交请求到首次产生响应所用的时间。</p><h4 id="调度算法-1">6、调度算法 1</h4><p><strong>调度算法的重点</strong>：</p><ul><li>算法思想</li><li>算法规则</li><li>用于作业调度还是进程调度</li><li>抢占式还是非抢占式</li><li>优点和缺点</li><li>是否会导致饥饿</li></ul><h5 id="fcfs-先来先服务非抢占式算法">1） FCFS 先来先服务（非抢占式算法）</h5><p>​ 主要从公平的角度考虑，按照作业/进程到达的先后顺序进行服务。</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li><li>非抢占式算法<ul><li>优点：公平，算法实现简单</li><li>缺点：排在长作业后的短作业需要等待很长时间，带权周转时间很大. FCFS算法对长作业有利,对短作业不利.</li></ul></li><li>不会导致饥饿</li></ul><h5 id="sjf-短作业优先算法-非抢占式算法">2） SJF 短作业优先算法 (非抢占式算法):</h5><p>​ 追求最少的平均等待时间,最短的作业或进程优先得到服务(指 要求服务时间最短)</p><p>​ <strong>[每次调度时选择当前已到达且运行时间最短的作业/进程]</strong></p><ul><li>用于作业调度时，称为 短作业优先算法</li><li>用于进程调度时，称为 SPF 短进程优先算法</li><li>SJF和SPF是非抢占式算法,也有抢占式的算法: 最短剩余时间优先算法SRTN<ul><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li>可能导致饥饿,如果有源源不断有短作业来</li><li><strong>示例1:</strong> SPF 算法<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092135300.png" /></li></ul></li><li><strong>示例2:</strong> SRTN 算法( 最短剩余时间优先算法 ): 每当有进程加入就绪队列改变时就需要调度，<strong>如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，</strong>当前运行进程重新回到就绪队列。另外，<strong>当一个进程完成时也需要调度</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092403526.png" /></li></ul></li></ul><h5 id="hrrn-高响应比优先非-抢占式-算法">3） HRRN 高响应比优先:(非 抢占式 算法 )</h5><p>​ 综合考虑作业和进程的等待时间和要求服务的时间,在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务. <span class="math display">\[响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}\]</span></p><ul><li><p>既可以用于进程调度也可以用于作业调度</p><ul><li>优点: 综合考虑了等待时间和运行时间,对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题</li><li>缺点:</li></ul></li><li><p>示例1:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104029587.png" /></p><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104019832.png" /></li></ul></li><li><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104148079.png" /><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104351880.png" /></p></li></ul><h4 id="调度算法-2">7、调度算法 2</h4><h5 id="时间片轮转算法抢占式算法常用于分时操作系统更注重响应时间">1）时间片轮转算法：（抢占式算法）【常用于分时操作系统，更注重响应时间】</h5><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>一般只用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li><li>由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到。<ul><li><strong>优点：</strong>响应快，适合分时操作系统，不会导致饥饿</li><li><strong>缺点：</strong>由于高频率的进程切换，因此有一定开销</li></ul></li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412111910996.png" /></li></ul></li></ul><p>​ 如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>​ 另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h5 id="优先级调度算法抢占式非抢占式版本都有常用于实时操作系统">2）优先级调度算法：（抢占式、非抢占式版本都有）【常用于实时操作系统】</h5><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/0调度中<ul><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。<strong>另外，当就绪队列发生改变时也需要检查是会发生抢占。</strong></li></ul></li><li><strong>优点：</strong>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li><li><strong>缺点：</strong>若源源不断地有高优先级进程到来，则可能导致饥</li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412112408359.png" /></li><li></li></ul></li><li>通常：<ul><li>系统进程优先级高于用户进程会得到提升</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好I/o型进程（或称I/o繁忙型进程）</li><li>注：与I/0型进程相对的是计算型进程（或称CPU繁忙型进程）</li></ul></li></ul><p>【由于I/o设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p><ul><li>可以从追求公平、提升资源利用率等角度考虑<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul><h5 id="多级反馈队列调度算法抢占式算法可能导致饥饿">3）多级反馈队列调度算法：【抢占式算法，可能导致饥饿】</h5><ul><li>对其他调度算法的折中权衡<ul><li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li><li>用于进程调度，抢占式算法<ul><li>在k级队列的进程运行过程中，<strong>若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，</strong>原来运行的进程放回k级队列队尾。</li></ul></li><li><strong>优点：</strong>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/0密集型进程（拓展：可以将因l/O而阻塞的进程重新放回原队列，这样I/o型进程就可以保持较高优先级）</li><li><strong>示例：</strong><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113638505.png" /></li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li><li>被抢占处理机的进程重新放回原队列队尾</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113856291.png" /></p><p>​ 注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）*</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.2节的内容，含处理机调度的概念、层次，进程调度的时机、切换和过程，调度算法的评级指标，FCFS、SJF、HRRN调度算法以及时间片轮转、优先级调度、多级反馈队列算法等调度算法</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>《StyTr2 Unbiased Image Style Transfer with Transformers》</title>
    <link href="https://blog.slks.xyz/2022/03/21/5a98629a4dd3/"/>
    <id>https://blog.slks.xyz/2022/03/21/5a98629a4dd3/</id>
    <published>2022-03-21T10:12:19.000Z</published>
    <updated>2022-03-22T03:14:40.247Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称stytr2-unbiased-image-style-transfer-with-transformers">论文名称：《StyTr^2 Unbiased Image Style Transfer with Transformers》</h4><h4 id="论文地址-httparxiv.orgabs2105.14576">论文地址： http://arxiv.org/abs/2105.14576</h4><h2 id="关键词">1、关键词：</h2><p>​ Image Style Transfer、Transformer</p><h2 id="摘要">2、摘要：</h2><p>​ 由于CNN的局部感知域性和空间不变性，输入图像的全局信息难以提取和维护。因此，传统的神经网络风格传递方法通常是有偏差的，对于同一幅参考风格图像，<strong>通过多次运行风格迁移过程可以观察到内容泄漏。</strong>为了解决这个关键问题，该文提出了一种基于Transformer的方法，即StyTr2，将输入图像的长期依赖关系考虑到无偏风格传输中。 ​ 与用于其他视觉任务的视觉转换器不同，我们的StyTr2包含两个不同的转换器编码器，分别为内容和样式生成特征序列。在编码器之后，采用多层Transformer解码器，根据样式序列对内容序列进行风格化。</p><h2 id="领域背景style-transfer">3、领域背景—Style Transfer：</h2><p>​ 经典的基于深度学习的图像风格迁移，样式转换方法使用多层cnn来学习样式和内容表示。由于卷积层的接收域有限，CNN无法处理长距离依赖关系。输入图像难以获得全局信息，这是图像风格传递任务的关键。将Transformer应用于计算机视觉的魅力在于:</p><ul><li><ol type="1"><li>它具有较强的表示能力，可以通过自注意机制自由地学习输入的全局信息，从而使每一层都能轻松获得整体的理解。</li></ol></li><li><ol start="2" type="1"><li>Transformer不包含局部性和空间不变性引起的归纳偏差，可以避免风格传递任务中的内容泄漏</li></ol></li></ul><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 在StyTr2框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。此外，针对自然语言处理中提出的位置编码方法，提出了两个方面的考虑:</p><ul><li><ol type="1"><li>不同于按逻辑顺序排列的句子，图像序列符号是通过图像内容的语义信息进行关联的;</li></ol></li><li><ol start="2" type="1"><li>对于风格迁移任务，目标是生成任意大小的风格化图像。输入图像大小的指数增长会导致位置编码的剧烈变化，从而导致较大的位置偏差和较差的输出质量。一般来说，视觉任务所需的位置编码应以输入内容为条件，而不受图像尺度变换的影响。</li></ol></li></ul><p>为此，该文还提出了<strong>基于图像语义特征的位置编码</strong>，并根据图像大小动态扩展位置编码。</p><p><strong>总结：主要贡献</strong></p><ul><li><ol type="a"><li>一个基于Transformer的风格转换框架，即StyTr2，以减少内容泄漏并实现无偏的风格化;</li></ol></li><li><ol start="2" type="a"><li>一种内容感知的位置编码机制，该机制是尺度不变的，适用于视觉生成任务;</li></ol></li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321190212987.png" /></p><h3 id="图像分割为patches-linear-embedding与vit类似">1) 图像分割为Patches + Linear Embedding【与ViT类似】</h3><ul><li><strong>输入：</strong><span class="math inline">\(I_c \in R^{H \times W \times 3}\)</span> 和 <span class="math inline">\(I_s \in R^{H \times W \times 3}\)</span></li><li><strong>输出：</strong>一个特征序列：$ L C<span class="math inline">\(，\)</span>L = $ ，<span class="math inline">\(m\)</span>是PatchSize，<span class="math inline">\(L\)</span>是特征序列tokens长度，<span class="math inline">\(C\)</span>是单个Token的维度。</li></ul><h3 id="位置编码content-aware-positional-encoding">2) 位置编码（Content Aware Positional Encoding）：</h3><ul><li><p><strong>想法：</strong>当使用基于Transformer的模型时，需要在输入序列中加入位置编码(PE)以获取结构信息。此论文提出了基于图像语义的位置编码，这一改进基于以下两个想法：</p></li><li><p>在传统的位置编码中：两个patch之间的位置相对关系仅仅与它们之间的距离有关。而对于图像生成任务，在计算位置编码时，我们应该考虑图像的语义</p></li><li><p>当输入图像的尺寸呈指数增长时，传统的正弦位置编码是否仍然适用于视觉任务? 如下所示当调整输入图像的大小时，相同语义的patches (blue blocks)之间的相对关系会发生巨大的变化，这可能不适合视觉任务中多大小的输入。</p></li><li><p><strong>主要做法：</strong>提出了内容感知的位置编码(CAPE)，该编码具有<strong>尺度不变特性</strong>，更适合于风格迁移任务。与正弦PE只考虑Patches的相对距离不同，CAPE以图像内容语义为条件。</p></li><li><p>首先假设<span class="math inline">\(n \times n\)</span> 可以足够用于表示每幅图像的语义位置。</p></li><li><p>假设输入图像为：<span class="math inline">\(I \in R^{H \times W \times 3}\)</span> ，我们将<span class="math inline">\(n \times n\)</span>的位置编码（依据实验结果，一般情况下<span class="math inline">\(n=18\)</span>），放缩至<span class="math inline">\(L = \frac{H}{m} \times \frac{W}{m}\)</span>的大小，这样就可以使得位置编码不受图像尺度的影响。即对于两个Image Patches而言，它们直接的位置关系不会受到图像尺度的影响。如下图所示：假设有两个不同分辨率的图像，在PatchSize大小一样的情况下，左图分辨率小，被分割后，成为<span class="math inline">\(2 \times 2\)</span>的Patch块，右图成为<span class="math inline">\(4 \times 4\)</span>的Patch块。当位置编码会进行放缩以适应的时候，其就可以自己匹配不同尺度的图像。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210140364.png" /></p></li><li><p><strong>公式化表达</strong>：</p><ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210523455.png" /></li><li><span class="math inline">\(P_{CA}(x,y)\)</span>代表第<span class="math inline">\((x,y)\)</span>坐标的Patch的位置编码值</li><li><span class="math inline">\(F_{pos}\)</span>是一个可学习的编码函数</li><li><span class="math inline">\(P_L\)</span>是一个可学习的位置编码，是基于图像的token序列的</li><li><span class="math inline">\(a_{ij}\)</span>为插值权重，<span class="math inline">\(s\)</span>是邻居的数量，其是由周围邻居加权差值计算得到的。</li><li>对于token序列<span class="math inline">\(\epsilon\)</span>中的第i个Patch块，假设这个Patch块的坐标是<span class="math inline">\((x,y)\)</span>，那么我们将计算得到的<span class="math inline">\(P_{CAu}\)</span>值加到<span class="math inline">\(\epsilon_i\)</span>中，形成最后的序列。即，如果原来的token序列<span class="math inline">\(\epsilon\)</span>形状是<span class="math inline">\(L \times C\)</span>，那么新的也应当为<span class="math inline">\(L \times C\)</span></li></ul></li></ul><h3 id="transformer-encoder">3) Transformer Encoder：</h3><p>​ StyTr2有两个转换Encoder来编码特定于风格（内容图像 &amp;&amp; 风格图像）的特性，这些特性用于在下一阶段将序列从一个风格转换到另一个风格。</p><h4 id="part1-content-image">Part1: Content Image</h4><ul><li><strong>输入：</strong>Tokens 序列 <span class="math inline">\(Z_c \in L \times C\)</span></li><li><strong>输出：</strong>$Y_c L C $</li><li><strong>网络结构：</strong>每个transformer encoder layer包含一个MSA和一个FFN，与Transformer结构一致，输入序列被编码至Q，K，V。<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215744833.png" /></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215804639.png" /></li><li><span class="math inline">\(W_q,W_k,W_v,W_o\)</span>是可学习参数矩阵。</li><li>然后使用残差连接结构，每个模块后有LN归一化</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321220112862.png" /></li></ul></li></ul><h4 id="part2-style-image">Part2: Style Image：</h4><p>​ 按照Content Image那样子进行处理，但是对于Style Image我们<strong>不需要进行位置编码，因为我们不需要保持它的图像结构。</strong></p><ul><li><strong>输入：</strong>风格图像Tokens 序列 <span class="math inline">\(Z_s \in L \times C\)</span></li><li><strong>输出：</strong>$Y_s L C $</li></ul><h3 id="transformer-decoder">4）Transformer Decoder：</h3><ul><li><strong>输入：</strong>$Y_c L C $ ， $Y_s L C $ （<span class="math inline">\(\hat Y_c\)</span>是<span class="math inline">\(Y_c\)</span>增加了CAPE位置编码后的序列）</li><li><strong>输出：</strong><span class="math inline">\(output \in \frac{HW}{64} \times C\)</span></li></ul><p>​ 根据参考的风格序列，用回归的方式来生成内容序列。和传统NLP任务不一样，我们使用序列中的所有Patches一次性输入来预测结果。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321224013009.png" style="zoom: 80%;" /></p><p>​ 由两个MSA和一个FNN模块组成。第一个MSA模块的K、V来源于Style序列，Q来源于Content序列。每个模块后面都有一个LN归一化。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232914140.png" /></p><ul><li><p>公式化表达：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232959747.png" /></p></li></ul><h3 id="decoder">5）Decoder：</h3><p>​ 论文使用了一个三层的CNN解码器来细化后面的Transformer解码器的输出，而不是直接对输出进行上采样来构造结果。</p><ul><li>输入：<span class="math inline">\(input \in \frac{HW}{64} \times C\)</span></li><li>输出：<span class="math inline">\(I_{out} \in H \times W \times 3\)</span></li><li>网络结构组成：<ul><li>$3  $ 卷积层</li><li>ReLU</li><li><span class="math inline">\(2 \times\)</span> 上采样操作</li></ul></li></ul><h2 id="采用的损失函数">7、采用的损失函数：</h2><h4 id="content-percepture-loss-感知内容损失-style-percepture-loss感知风格损失">1）Content Percepture Loss 感知内容损失 &amp;&amp; Style Percepture Loss感知风格损失</h4><p>​ 优化结果应保持原有的内容结构，同时传递参考风格的模式。VGG提取的特征图可以作为内容特征来表示图像结构。<strong>Gram</strong>矩阵是两两向量的内积组成,所以<em>Gram</em>矩阵可以反映出该组向量中各个向量之间的某种关系。特征图的Gram矩阵可以作为风格特征来表示颜色、纹理等信息。因此，论文构建了<strong>感知内容损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_c\)</span>之间的内容差异，构建<strong>感知风格损失</strong>来衡量生成图像<span class="math inline">\(I_{cs}\)</span>与参考风格图像<span class="math inline">\(I_s\)</span>之间的风格差异。</p><ul><li>Content Percepture Loss：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103100728.png" /></p><ul><li>Style Percepture Loss:</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103340777.png" /></p><p>​ 因为神经网络各层的统计量(如均值和方差)包含了不同领域的特征。<span class="math inline">\(\phi_i\)</span>代表使用预训练的VGG19网络，其第i层提取出的特征。<span class="math inline">\(\mu()\)</span>代表特征的均值，<span class="math inline">\(\sigma()\)</span>代表特征的方差。风格的感知损失可以书写如上。</p><h4 id="identity-loss">2) Identity Loss</h4><p>​ 自监督学习可以利用PreText从大规模的非监督数据中挖掘其监督信息。网络可以用这种构造的监督信息进行训练，以学习下游任务的有价值表示。 论文采用一个辅助的<strong>自我风格迁移任务</strong>来学习更丰富、更准确的语义和风格表达。<strong>该任务具体操作如下：</strong></p><p>​ <strong>注</strong>：Pretext任务可以进一步理解为：<strong>对目标任务有帮助的辅助任务。</strong></p><p>​ 论文在StyTr2中输入两个相同的<span class="math inline">\(内容/风格\)</span>图像，生成的图像<span class="math inline">\(I_{cc}/I_{ss}\)</span>应该与输入图像<span class="math inline">\(I_{c}/I_{s}\)</span>相同。因此，<span class="math inline">\(Identity Loss\)</span>模拟<span class="math inline">\(I_{c}/I_{s}\)</span>与<span class="math inline">\(I_{cc}/I_{ss}\)</span>之间的差异:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104028070.png" /></p><h4 id="最终loss">3）最终Loss</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104224116.png" /></p><p><span class="math inline">\(\lambda_c\)</span>、<span class="math inline">\(\lambda_s\)</span>、<span class="math inline">\(\lambda_{id1}\)</span>、<span class="math inline">\(\lambda_{id2}\)</span> = { 10 , 7 , 50 , 1 }</p>]]></content>
    
    
    <summary type="html">提出了StyTr2，该框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Style Transfer" scheme="https://blog.slks.xyz/tags/Style-Transfer/"/>
    
    <category term="CNN" scheme="https://blog.slks.xyz/tags/CNN/"/>
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>关于文献综述、开题报告写作逻辑记录</title>
    <link href="https://blog.slks.xyz/2022/03/21/70cfb7bd8141/"/>
    <id>https://blog.slks.xyz/2022/03/21/70cfb7bd8141/</id>
    <published>2022-03-21T08:27:23.000Z</published>
    <updated>2022-03-21T06:47:52.216Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="7b9f124314e793a8ea4b25367429819e4db42db95545ee66f18eecfe80e01d16">0b64cd3abe5b0a0a039a37d86c66d75ed031bee0799e8ec352d0d5180826a0a50691d982f2be0c5f85267e748633a6bf94990a16c95008190a889750cecd7480a14477abc4a295eb514b8297cd2924e002a1c70812d056bcf0409e6fb92de26df0950a25ddafaeb99d1c3cf682cce4fc1226e9d0e6fb11561e2b615fc0eb9bac9ce2ad086a04463456aa373ccbe45d294bf436c7ac973af9bea0f2b9e447d448246d7c64ec3314b5e4baaaac014f5f2ff018c4ec4935ca0aa91b2bed76a66bf8a610827cb51bb660dc08067cfa0df4ba59f9bae520f9ce17fd1ff0a34505b0cc01663191ed701004f91d60e3605d8f50be8345dfd6f40431d3a6925178b63dd5331af544a52e572dbeb5ca133211a94a51b31273c2a07dad3a65d09f31bf7d650e8ff0228317ee19a107fadd4adaeea132918d286444c05aef91c1ef031637e1f1cb36e60e2f36b1cd22b684ebcbd44eebee5071662672485493e50a4f15ae933ab9734632c986e21d2323a20d60cac9c397fb888867c5e5b0c43a9c569457ab8bd5ec7619615cef9345aa701544e87d246731c9ffa9c07940386b29b0b14990f742cae9a254ad440ffe76d913bae62bc5f5418644c2d0f41f0c6593a5a4bf10577f9e2a01bf76eec279423298e44ba9a1aa3dd944ec6209d6b366bd5970d5693a0a3de247211917e24bf74a3a8649917f9725fef0a84c4751c9f17a47e06502b7e8eb94a0e3eb761ddb31cc04827bffbd071de865d5003de59ec9565d58b0bac3eeb984d2776667d4fdcec04b05fc0ef623774fce69b9e6c13f9bed5a33d948f4b7fe2e32c3ec9df3be76b1ec78510b0a165ef2f6d88e61d966361b5d2794c32ee337c0eb688febc00f6cd3231acfd239287d3a34eefe95c8385993f64a332688b73527f6e0a857b490df293cf96a4722e2d1457cf2f77024347da5650d24d691502e5103557e9fe814e44474ce09b015f2194eb312d794f1e416e394b2bad4c42786594b64076adf8d9451bcad12d8b31a005f2bc23788a5e937865336c6ddf4c2df44d3c0b2edd0348e31067bbb232d9b6e6eb582fe62b2a123aa1b5654da6507da228086736c76841e52d5c32f432331b58d64f2cb94ae874adfb2f663ba85a3c033064f95aa5e47daa60353de46c8b908b0824c61b76069a398f259c9cf350c583236e7c5d2af891445c2d16c01ed8d20da0ab66880c2fe32947625191ebeba3e3a65ee9397451cef6cc861c8367ad0f73980c8a5f937803f2f495374f1563c4720161c585394f17dcaf71e7788f13b9bfb55a7dde3ac31e10768d2cb175f40fe8257ead6a1564b24cf8519889cf65efcbab43d72a0876f2daf700aac7db122f60b919c7bf7d2cc127285295eed7393f1d4a57c94a6390ae0155af3bd93f203a540b0f5125c096841ea3f58cdc467f6d8aaf70da00df7b8dba5ab04d117e6cfe2a5ef9a371104e6674a85af50dd97aa17472e7bd367ee4ca1ce860d6cf234cad3ecbfacd08e09fcff12aa50e9935a77494daaa99d9a4faa4f89c18afa34767723858c4a707fea61f9030befb9e2d0108aaa9c052ada705d5b34ff28d03cace480a1776688cbafd1e00ae59947d163f1f28aa89e1ed3c6f4907e672919d214bf4973a4ea8249aa62924c9b34534a3736fecd73d94afd8982e569f2b953ebc005d6595bb943fb472dce2ffa324ab185bd8fa8153a1e600e3c1f628168917b25749094d0751a9be544414a7748cf4ac700167632441eafe1d761d6c29326cdfceefea229753b38072b01e23685570ac2b6d842cd00abd7e5a5ed0cf892388d2de0470e0aafbef91f53a85f63ddfc14d2eb45f4409d2cd946b5cca3089b211f302dbbf64410ddd9fea56e20f4ad5f794ad716d90badf1cbb8ad31adb765eb1330273e441ec0a2fa45e15016ea0f86b5c47ca451fa7b0af20c170d12408c424b761bc5a982a46d70ed005c692f322b36326d3bb3fdc9d7faacd1182155d9b3d1fb3ef4a4d38e1ff0370cbd2b1a339426c4a793a3819589017b566a8eacc3931253e5234822718fa3bbf34d5244fab4ee2fe9dd49d9c8e5a748179dad9f66e84a2595d69caa128908565b49c3b58bc60afc88660724b36e5394db0d37c2ebcb73bdf4d7669dc20e4c03a80aded961abfc88c1c6fce85b5a70f23ff4737e2d7f36b0dec664b376cfecf91468a064067227f0d9b00b329e7f2459787fe84ba1f8c311cffe8008e11eb8c579743bb21e2456fec4ddb031fdd6eed0d8f7b4dbb6f2696b086d3b6cf6afc4ea196f8f47e309f2dc00c62c53515656a4732c2f6185adfb39e876f87ecadc8ebb670d67afd160785568a4d8c3f4bb9cda58e6010755abb9ed12290e11ffa5daf4304b97c801d07faa4d4491444fcf9f1f784b4fdf8efc49a9ce02dd3735b3ff131fc7cd33c75549ffaaa492630fa0079a7af76b0abcf760d4d53162e870d99de380bbd17cc7d8267d365d67234f83834e628ff2e892a7e73c59205938a436b903464b6c34c68ed3147dd4980d6cfb64c57cec2b63afde06de5316aa9ce2b9e5c133f5272e38a3f5be02cec438e7ee77b6619152ae6c5a8337feac865895c5833741cef808f8503248e773fb841200c27d4861ec3f525fb6290c6ba054b7b14a34fc6bd7b316071ceacfb268006488b1472fc72dedfc5b50552ac56476a31b3078d2bb20d76a428bf28193ad47d653e53870b8f2e8b80e8cb767da78dac9ef6313947cd73785902df23cc9cbd0436a82a43eca7a9bd3aba83ae17aa5b9c7663ee3e17ec026272421598b372954c1fc5cfb3fab4b2c1d2c6c9c044c9a78026e5c03af1e25963cdd366d3de839428db45ac950d6a4f123a0c018e1c5137aa35836cbb9bd54c44d33039b16b9c7cb8283ef7084a9696c464a477488da63a4eeba06cc8616b55fa8d9ac5fe180451646d68317cccadb344092f8c2ad4d4ab45e4943b4900aa123afb0aa7f9dda7db168c047f3ce8b5b5e680cadc41bc7196e8249467563e711ace43d5f86ecb83eb300a4829af28cc2bd0a4572ed6c3dff507c035f269221967fc9b71b96d16f7ad2266f9b0e93b578cd31704c5213496e605701af575626a1b30aeb474d67f7b05215260c328c9880fbdeb24846e597ade1e0bfb77ef2842fb97321f8a2aee5d82bcf9fe9b000748a86f67a5e9188f6dc4f63bbf918f285276d2ed0ea7d3ce4db430db35026d168ad3833616e25b8335570fe70ebe90cb7baa3d5e34bed7d78eb868eec2786ed2dda6debb1fce6b0fb8d3e3258a247548f94eb235dd0cdf58c901dcfc011f9c098a90a18b08105758b267cafb815e07fad19680b1f044c88daa23e8a6b3294c83891068a5da5bee776bd26b36e390d37ac44cf978ffd90bc23a6924fd89e7657bcd3c92ad3dad42dab02cffd3b135dfed9329d17811c36fa405b343485ef7df2bf1dc9dd826c8ead29b2bb03a90738bcb76fec7146bcb1b6b65fc34c85c2b3dd6044ee4c47f55b35e3bca952bda7b3c2ae10a4f3eb21626427580c6739063636106e3b2c0eece813974a3bd1e05db9944e3e090d3370e247014144d5bc041bdf57fddd77a037197992368a942de5671b102f5fc971ff154e80c64760ec77af5b8284e9192e5bdeb77ab74f665b5b913d8f5f02b6b0a952dabd42ecbcf6ccd6ed450e7754b57eba01907a3aa26082454fb57cd8469b8fe0082395d5294b02d3085d1c587cd18c9bf69836167db4a28f56f3af972598624f71440f388a9be38548ebb9c0af3fc054be2f51e30e4857256f6751a4e77f719264b993dd8df596d84ff7a8720db0df392d260f38a34fab9151e2c7ec5f374fc5638c2cd30052f18cbfbfe015ae4585b3570f3864b09d55f8b190c4bd2723283ee1eec406f7c14efc72915942ffa919a9263f096819c121093373470192cfdceb17f255b3bb0b5c4c9add58997abf7fc6f17e35ea1110c4edb25972bfa22b3c9ec2ac31d01c038b34386edcb5e16270ea59924d22216789a8db2156998b900a1a6638cbf47d4dbc3a9d86b0ce8591538d50ffdd0a4c26de3902daff219a81f5ee1b4038adc81929dd7e6b480bd3e97ee6c5b848fa5c28fa59e688f6126f14146db0afe1fa483e61e6cc2b63217f0a0f877ee53ba39409eb170e157496fd93201d728b9d5a689e126a13ee418aec16c2ffa2d7d4f186d34fad2177312d427681abb6db88b4099ba681de508fd688732f969b69676a4f6627970c9e92726bfa927ffd25bb08cbc2795242ef852d0d2b6e1d792e96eee2566116859e66b7c80d55f635f6dd45b84bc5234b21e2f567be75b6ce77f62ea408a3f278dd768f6b80b4d00a61ffc4bc3daa67c253df340c229695de17f8fbe35310759d54fb87afd2c3c93e7e6a5a46911b6c2eed4305f25d4f4da6437a48e8ec468f5bfde5fac6fba9a64667d260173a83a3701334078e5378b13d4500df9861dde390ad3d9db23b516e9444849ea0e7acdd738832fd25c8153efb762e905619d7122ac271ad5f9450471a464060fe25fc2df8584b7282b16d3bc06678b3d05250d797b9c6e0328bd2e83e9943e0b1217a60a9e4ab2ca8b0ae0bced2211661ec7fd6cc1e0398245d5f9442a73abddd17328c3dfc2dccc73ea2c41af541379f15b436289e429f77ecc8859d645b56b5f78e0a8d264271eddaa26c02e1f9b013a7b230a7cda4b4c6b931688a6e4cc92b6ebd4692c7ca049e8e9b6c6ad8ae5e730c9bf2cf9acf86813cec873920c8d68ed3c0582a0fdc0c15ff15ad06381afe5a97d4f63217e4e17bedcaa6b78951c1beabf2baa573c54c7c0facde6ca71ee604047aa4a1f50e488d43a4b61bf42a8f00459ec7f77d2daf0a35ee3ca308c0c3b476fb0aac042456a90fe1c63fb1ee594e5fcd6e771dbf42710d6e6a993ad77313d99e5792489abd837d6efef5a6d008f5226f05493b722a363a1417097054719d6b5196efec818d05895ed5dee5ebd61d55cf5e5a27ea5a7d0ad9bcb1ec80137702f651572f16eae83c6c61cb618c37c5048e6ddffb087d6b8242e5d95bb290b805b8acfb65262d39cea1bbb681052723006f009743f09cc8bec11f1a34526141b597700bbac962d9101bb5bf5e065ad752a31b789ff79773bc2394c460fefe9574c63786523a4a8533334c7a1bfd71c0791c78e7285a57e4a326d65de7339a471de53aced40d41856542fd7bf643ea5fa11bee26a901ae11882ee7092584a4f4fad694a45e2ef255627b71bc917f1ec0926fea89fa4180936b5eb11a692bdffa4f1109e3852fc9579631c6e2c714c4dc73fbcf62a781585dace8d4996a0c4682ed8a818bef1aa79bcdbe759d1fd8f7942da22f467436eae82b5eddf296c5eb57adb8728d5cd2f2e9b0ef4f0741a00d36866725aa17d9b4a59b05614cf9ec8106ee199068bd3e9a3e903d16c49669cf674203cf72083b49ec0482c37b5c815c639c7a596f9cac3875385b2f54895b6986f5b7d1800c4fb6ebe29d3b1d1ec1ec131b3a8de10083239f3ee2d50a13f67f5639d65c6893c12fc652f3dfa51580ccbdaabe06b6d59c1f76c98cbbd890533097ecf3275aef692a4b7c851541d840c3b2207853f390fd4ba077df695714d4a9a799956aa972e6e1e9351768b0b8079cd367b60f0ff572e911f3b0e647bebc2ca659e2f896d8ab98d8af58430d1222a684b94b8b2d769467a653d57776b74509e8bcfa4997c084af3d9dd97b01c721b9abfa83c008ace7e694b8c272d5f75b99dfb230b2e2529ca51cb82482546bd4fdcbe9e086dac96d848a3ed9a462c6a654e6b1163f1097f853021a2e280d59e1463b0c4f6723902492fd28f298e61ba4d1994eb7df7ceec29dc2e6e99926bc410940720cf5d0e084a2347b5ce7dd0e97671ab00dfb61e672224f3f474ce3ac5b43cb64df3504a7c27de9f4bfcc8318e6056731a2855fe2eceeb5595f8f0a751f3114a1498a6911f1d257607c590eb6fe6b9ce03544ac89cf386507f17410ea9cfb891e0b922427ecd3db892f7336b8f62e2b68b6544b68a8805404cf0d6d4c660e336ace9011e92fdbea12e914204037cbe1f5f9e492268a2b28396d6be93cccb1d942abf28ae8d55f74005bb945645b9b88bccfadc16945237ec46c6a416bc5c7fe4114264eb6f3cab16bb5287fd0e3709717af8122725e651c0b9ebe236badfa5431d8c55c01b48c9b5f4530d3238d35b42e16cb2c9cc3d0bbe50307cb63cc2f42bf1cdc53678915cdb0a60430f86ca8c5dede3a8e3b53079e0c67199e48ba5b3ada36880f1c03d324702cebff44f6df34dbcf92100e91ff24d0188861bd38d63d80801b89fa99d0484cbadadd05a783a88eb414df17aa2090bec6f3c6d6948eca65ed46b1148bcbb2313b1889dd6f4b0295e4d18c0a89afcae26e699cd4964b39970f1d0da25b25d307ad922c069abebef70939528c604b2aeeb1c85b225f18ad2ac4cc0d88f2403ad293c50bc4a1f333b8a146d58294cf8c77bd9dc60a9393b4dd3bc4c701af5180545bbaa99d187b6488f5fbe91c1a8bb70f858dbd40e07a791e96c730a2d748566a8d370d029b37a7d66d5064a5c4f7e38a3c02c5526025350da91c5d87dc1917a91a04e3bab4a12464e1e75df43beaa15ce591f16272191203ce1da3208f59d178320f8a88484ab98c2708c3dce496c2ef0d1beb97c496ca2919840ba56a5323b8b944129ed4ce93bc96657e148895813418dbb3e6778fe15a0f5936cbcfedbfd1e49a1f3fb817cab6f750df2c923494c995b7efe49d0c8d0c2ca02e8708b8ebaee8abd65b69d65422343de2f76519b7bcb3f13a8b843ad41eb5b7f6c28aac1f12d2a42296103155958886246d873a67640542de79c44d8d13869dacd2cc2eeda1562f147484d71efd87d6e6007bc9bfbb6cc6b809d1c2af45a36531bd89a2e05043126727d9eb9dee274dad43ec6d87d49a9fc35c7ba47b2cac122328b7dfe55deda3eb49f1ff26407360d9b41cc8cbd034b9b8beefb6dced522b30e32850b33794a59a708bab7db1568b48b6fba45a7712551b8aed5d2ce5203ba1507eb0b05d00e4aac9af344df2a5fecd49508b1b484cd081c30b4e00639e56a28335294bb25e157e2c47e99a231c66035ef2cdf93ddd512356748bf1fa9ea2d33ce38fb8ba3440eb87278a657c2369e77c7835928f2a7047669fc3f96746c04980c386a1d7adc1570db205a39b1b9d189aaf0b1f931c2511df4c32c36797b5cfaa31c0ba3440ab4d0ed6187914fb18d7de428ee1112ac1091f6f3a109277d8efa9d9d43dd7333eaac2290941ef474099e2936e591dc70ee251f4fae13b88dbb8a5e4a4d34e0b1afb804cff093f527db478f12807c7f126affcddac2610733014e640d0ab411215cc954ed9fbf61455c5fe0235bd46759d7892d43b67d87037f6f51167a820f319e36533cf98dc5340e003d725939ca5f364d2c402393c3ef9cee8fc1e7161308b313db05f0d894d2ade0e9d54ef929b9e0e3a1089882e2f609bb56423b22a3809c91baca2d1b57583592951cf083b911a889f73cfeca0a0a29944242d90e2687aaa796f8893b4afb213e7991e6b28100b8c9e22844ccd7e59e15093e70c6b59c03c1729489a8e06de021351e505a70bf6d1a93835c64bd198777d9bad928078d54d7939b582a1a5fe88195b993e3db6f8480728df5695c80ddc89715488813aca7a6b15b4012605759e23f6dcb239b1409bc9f6a917c93ea23f9b89020e5d851889f6cff97a4a12a0480ce882def3e729f23019bc441ccf3e3989ef0aa435d7f79f3e6d4c89a705fbe2afb7e6b02f6e47ddc59fa6432cd2c9eedcb43677afcee3773d5b20cc7b589910d22a0556a8f4f4797287bbcfb40570ddc85f0940fbc413d8bf19871d74f4e1c7dd74bcc3b695191fd993304b69bd9eab9d58baaae577fc8ee20ab37477dfe90191da74a37125e57edacf62151965fe65b5a507d415bb4f72b06a8f2a8124160a57488ee7a3383a9b353b7cf8bb5b8f88720f937436c396f42443837487e3595a32856614443adb3f5a0b828e4330dee563ebeea67ba0bdbe5cb4e4eae2af8ed1351394c42340665a5bac091010fc917c3a0892e954284a791f24c7b7134efc6bb5f18c283ae7d588334fd81b4277508adccabdc728278cf736421a11e4d2d847f472e7eecebb284b223bf02f17f40b0eb250e54c24b6a90ce56625fcab1de720a09ff2988da4fa0c95d2a711363fb56700c3711349b4db7b1506dbf015085a6962d66b91e8df37454d485f3b08478c0fa7071a5365be3a1ea43810ae4d00c78e59e1ed11d4e99c5587c07997adfec4c54af8e7a5695fa4c668ed3cc6a71fcd16082118da0b0e2dd5d4c7dfbd691e35d4a2621b25b927a53702338e692c8a4969cf59e54f56881c4e17bb56e1b9c3549f33f29dc13c25cf2fd5d186a766de89b42c5d36da6be53ccdd6f24ba98d1036f6038dd2b6e967614e76556d57564fa80325df86f0e6eda66194dfbc47ce7c8b8a2e5013a7dcf49da870ed122d582be18707f81205127995cb44f58e1c8a98bda265c4fb7a40bb79feb8d460f584b1ccf829f995d8cbd13b9ef1ec6516b9c069e169a1f5bbeb73c549ccc717d47e913b3a0050d87d4f2c0d77ddc448453aaeba00e2b8dc06b3d2cf38b2b9478cb377631bd0fc842eed6753f0648eade71ee7a11faf10f2a842d78e0b954ec31c2069e511884e8f1a0328316a89a9429f1431455d2ec0d25a6054d33625406e3ed9af7e01358eb93c037cd4c4e41af4b8f96195f658d54a9a0af232a8cf94241bd90cdaf8f09617df75fe626b15819920a9f4ef7fc85e2d638e20f8a7d0d1e722a27a9178f1b1caed25a794defb7b930c38792aa5c6983c0f31b09e458ff144a013de56914a14b4f836ddc7242c7dc72e9605c921b4e174dfc2dfb42aff7c53307914d943915df708bc9900e9f4270d11f0571f089f6d5d7cc42fa721bdcf65046e96a121a2dbdd4a2166d99ca0ec0450cd290c909bc7838e14844af97d7b57d4e20dd9da248a7c38bee53d0ed0749e9f2675b82eb4015262900f063aedbc4657db9a27163b047a4d8f4ca3752b7ad5dcbaab94e5d9e4c8f59d348d7441fc4c39cc1a24093d83ac92ca38746bf4022f592385b82e625f7f5bae034f7b6283b49bc67d44e1e1810547fa0459b3c72b1f4aea59510e5264f03dabf077a425cf09483a425dd6e0a0089ed8b464f6c287b71a05d2316d732176cbac74e588547f21cbf037c2bccc93ea53b035964970a19ccde09b61e597bd5445993f3121cbfca2bc0cabe2f0f31ea75d851adf64d95ccb23b1a9ab8d8b008d69326936ee38262cd7c5f8e8adde4835d1f3d090590b6808b7d6398f2ed36ccac0389c813866847defb0c462c48d2c3e4a63d69aca1ef4ac580385d7b041f90af6dcbe7988d1a97eccdf4827b589b5417cd9a9ecf0ed7a14669430b49e2f3f74633267</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">关于文献综述、开题报告写作逻辑记录</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>SCI EI 核心期刊以及计算机领域CCF会议等级分类文件</title>
    <link href="https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/"/>
    <id>https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/</id>
    <published>2022-03-17T01:27:23.000Z</published>
    <updated>2022-03-17T01:39:19.818Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一sci">一、SCI：</h4><p>​ 美国《科学引文索引》，SCI(科学引文索引 )、EI(工程索引 )、ISTP(科技会议录索引 ) 是世界著名的三大科技文献检索系统，是国际公认的进行科学统计与科学评价的主要检索工具，其中以SCI最为重要。</p><p>​ 一般SCI<strong>侧重科学前沿理论</strong>，审核标准严格，发稿周期也比较长。</p><h4 id="二ei">二、EI：</h4><p>​ 《工程索引》（The Engineering Index, 简称EI）是供查阅<strong>工程技术领域文献</strong>的综合性情报检索刊物。</p><p>​ EI的主要特点是摘录质量较高，文摘直接按字顺排列，索引简便实用</p><h4 id="三核心期刊">三、核心期刊</h4><p>​ 在国内简单地说，核心期刊是学术界通过一整套科学的方法，对于期刊质量进行跟踪评价，并以情报学理论为基础，将期刊进行分类定级，把最为重要的一级称之为核心期刊。</p><ul><li>（1）北京大学图书馆“中文核心期刊”，这个的认可度一般最高。</li><li>（2）南京大学“中文社会科学引文索引（CSSCI）来源期刊”。</li><li>（3）中国科学院文献情报中心“中国科学引文数据库（CSCD）来源期刊”。</li><li>（4）中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”）。</li><li>（5）中国社会科学院文献信息中心“中国人文社会科学核心期刊”。</li><li>（6）中国人文社会科学学报学会“中国人文社科学报核心期刊”。</li></ul><h4 id="四中国计算机学会ccf推荐中文科技期刊目录">四、中国计算机学会CCF推荐中文科技期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%B8%AD%E6%96%87%E7%A7%91%E6%8A%80%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐中文科技期刊目录PDF</a></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1123qwdsa.jpg" /></p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_3](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_3.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_4](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_4.jpg)</p><p>![中国计算机学会推荐中文科技期刊目录(1)_页面_5](https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_5.jpg)</p><h4 id="五中国计算机学会ccf推荐国际学术会议和期刊目录">五、中国计算机学会CCF推荐国际学术会议和期刊目录</h4><p>​ <a href="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载 中国计算机学会推荐国际学术会议和期刊目录 PDF</a></p><p>参考：https://zhuanlan.zhihu.com/p/57932081</p>]]></content>
    
    
    <summary type="html">SCI EI 核心期刊的区别以及计算机领域CCF会议等级分类文件整理</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
  <entry>
    <title>字体生成效果评价指标</title>
    <link href="https://blog.slks.xyz/2022/03/16/827639831232/"/>
    <id>https://blog.slks.xyz/2022/03/16/827639831232/</id>
    <published>2022-03-16T13:09:19.000Z</published>
    <updated>2022-03-21T05:01:33.410Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一intersection-over-unioniou">一、Intersection-Over-Union（IOU）</h4><p>​ 计算两个矩形的交并比，通常在检测任务里面可以作为一个检测指标。往往可用于目标检测和语义分割。将预测框与ground truth框之间的交集比上两者的并集。</p><p>​ 应用到字体生成任务中，如下所示：img1和img2是参考字体图和生成字体图。由于生成的字体图像像素值很纯粹，所以我们认为 像素值&lt;127的为黑字部分，像素值&gt;=127的为白底部分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_iou</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1_change = np.where(img1 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">1</span>)  <span class="comment"># 黑字部分保留，白底部分变为-1，黑字部分统一为0</span></span><br><span class="line">    img2_change = np.where(img2 &lt; <span class="number">127</span>, <span class="number">0</span>, -<span class="number">2</span>)  <span class="comment"># 黑字部分保留，白底部分变为-2，黑字部分统一为0</span></span><br><span class="line">    black_num1 = img1_change[img1_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    black_num2 = img2_change[img2_change==<span class="number">0</span>].shape[<span class="number">0</span>] <span class="comment"># 黑字部分的像素数</span></span><br><span class="line">    intersection_num = img1_change[img1_change == img2_change].shape[<span class="number">0</span>] <span class="comment"># img1 和 img2 黑字部分交叉的像素数</span></span><br><span class="line">    total_num = black_num1 + black_num2 - intersection_num <span class="comment"># 总像素数（img1 和 img2 黑字部分并集的像素数）</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&#x27;compute_iou:&#x27;</span>, total_num, intersection_num, black_num1, black_num2)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> intersection_num / total_num</span><br></pre></td></tr></table></figure><h4 id="二rmse">二、RMSE</h4><p>​ 均方根误差亦称标准误差, 用 真实值-预测值 然后平方之后求和平均,最后再开根号。 <span class="math display">\[\sqrt{\frac{1}{m} \sum_{i=1}^m(y_i - \hat y_i)^2  }\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_rmse</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    mse = np.mean((img1 - img2) ** <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">return</span> np.sqrt(mse)</span><br></pre></td></tr></table></figure><h4 id="三l1-loss">三、L1 Loss</h4><p><span class="math display">\[\frac{1}{m} \sum_{i=1}^mabs(y_i - \hat y_i)\]</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute_l1_loss</span>(<span class="params">img1, img2</span>):</span></span><br><span class="line">    img1 = img1 / <span class="number">255</span></span><br><span class="line">    img2 = img2 / <span class="number">255</span></span><br><span class="line">    <span class="keyword">return</span> np.mean(np.<span class="built_in">abs</span>(img1 - img2))</span><br></pre></td></tr></table></figure><h4 id="四structural-similarityssim">四、<strong>Structural Similarity</strong>（SSIM）</h4><p>​ 结构相似性，是一种衡量两幅图像相似度的指标。SSIM使用的两张图像中，一张为未经压缩的无失真图像，另一张为失真后的图像。</p><p>​ 给定两个图像x和y , 两张图像的结构相似性可按照以下方式求出：</p><p><img src="https://bkimg.cdn.bcebos.com/formula/cdebeba369b6159f2e3fa5364412f4ff.svg" /></p><p>​ 其中<span class="math inline">\(u_x\)</span>是<span class="math inline">\(x\)</span>的平均值，<span class="math inline">\(u_y\)</span>是<span class="math inline">\(y\)</span>的平均值，<span class="math inline">\(\sigma_x\)</span>是x的方差，<span class="math inline">\(\sigma_y\)</span>是y的方差，<span class="math inline">\(\sigma_{xy}\)</span>是x和y的协方差，</p><p><span class="math inline">\(c_1=(k_1L)^2\)</span> 和<span class="math inline">\(c_2=(k_2L)^2\)</span>是用来维持稳定的常数。<span class="math inline">\(L\)</span>是像素值的动态范围。<span class="math inline">\(k_1=0.01\)</span>,<span class="math inline">\(k_2=0.03\)</span></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> structural_similarity</span><br><span class="line"></span><br><span class="line">structural_similarity(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="五peak-signal-noise-ratio-psnr">五、Peak Signal Noise Ratio( PSNR )</h4><p>​ 峰值信噪比，是一种评价图像的客观标准，它具有局限性，一般是用于最大值信号和背景噪音之间的一个工程项目。在图像处理中，要对图像进行客观的评价，常常需要计算<em>PSNR。PSNR</em>是衡量图像失真或是噪声水平的客观标准。2个图像之间的PSNR值越大，则越相似。普遍基准为30dB，30dB以下的图像劣化较为明显。</p><p>​ 定义： <span class="math display">\[PSNR = 10log_{10}(\frac{MAX^2}{MSE})\]</span> ​ MAX表示图像颜色的最大数值，8bit图像最大取值为255</p><p>​ MSE为均方差，定义为如下内容： <span class="math display">\[MSE = \frac{1}{mn}\sum^{n}_{i=1}\sum^{m}_{j=1}||K(i,j)-I(i,j)||^2\]</span> ​ 其中，<strong>I</strong>和<strong>K</strong>分辨是原始图像和处理后的图像，<strong><em>m*n</em></strong>为两图像的大小。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> skimage.metrics <span class="keyword">import</span> peak_signal_noise_ratio</span><br><span class="line"></span><br><span class="line">peak_signal_noise_ratio(output_img, target_img)</span><br></pre></td></tr></table></figure><h4 id="六frechet-inception-distance-score-fid">六、Frechet Inception Distance Score( FID )</h4><p>​ Frechet Inception 距离得分（Frechet Inception Distance score，FID）是计算真实图像和生成图像的<strong>特征向量之间距离的一种度量</strong>。</p><p>​ FID 分数被用于评估由生成性对抗网络生成的图像的质量，较低的分数与较高质量的图像有很高的相关性。 <span class="math display">\[FID = ||u_r - u_g||^2 + T_r(\sum_r + \sum_g = 2(\sum_r\sum_g)^{1/2})\]</span> ​ <span class="math inline">\(u\)</span>为经验均值，<span class="math inline">\(\sum\)</span> 为经验协方差，<span class="math inline">\(T_r\)</span>为矩阵的迹，<span class="math inline">\(r\)</span>代表真实数据集，<span class="math inline">\(g\)</span>代表生成数据集。</p><p><strong>FID的计算过程为：</strong></p><ul><li><p>对目标数据集的N张图片使用InceptionV3生成N*2048的向量，取平均值，得到<span class="math inline">\(u_r\)</span> 。</p></li><li><p>对生成的M张图片使用InceptionV3生成M*2048的向量，取平均得到<span class="math inline">\(u_g\)</span>。</p></li><li><p>通过<span class="math inline">\(u_r\)</span> 和 <span class="math inline">\(u_g\)</span> 得到 <span class="math inline">\(\sum_r\)</span>和<span class="math inline">\(\sum_g\)</span>最后得到FID。</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> fid</span><br><span class="line"></span><br><span class="line">fid_value = fid.calculate_fid_given_paths([output_dir, target_dir], <span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>FID优势：</p><blockquote><p>1、生成模型的训练集和 Inception V3 的训练集可以不同。 2、计算 FID 时同时用到了生成的数据和真实数据，比起 IS 来更灵活。可以理解成，IS 判断真实性与否，是把生成数据和 ImageNet 数据做比较，而 FID 是把生成数据和训练数据做比较，因此更 reasonable。 3、以优化 FID 为目标，不会产生对抗样本。因为优化的是 lantent space feature，不是最终的输出图片，不会导致最终的生成图片失真。</p></blockquote><p>FID 问题：</p><blockquote><p>1、FID 只是某一层的特征的分布，是否足以衡量真实数据分布与生成数据分布的距离？同时，提出 FID 公式计算的是多元正态分布的距离，显然神经网络提取的特征并不是多元正态分布。 2、针对同一个生成模型，不同框架下预训练的 Inception V3 算出的 FID 差别是否可以忽略？ F3、ID 无法反映生成模型过拟合的情况，如果某个生成模型只是简单拷贝训练数据，FID 会非常小，认为这是一个完美的生成模型，因此，使用 FID 时同时也要通过别的手段证明生成模型没有过拟合。</p></blockquote><h4 id="七四象限评估">七、四象限评估：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/%7B58D5EE05-1CD3-1E12-45C6-0A5D78F53358%7D.png" alt="四象限评估准则" /><figcaption aria-hidden="true">四象限评估准则</figcaption></figure><p>​ <strong>D1：</strong>已知内容、已知风格</p><p>​ <strong>D2：</strong>未知内容、已知风格</p><p>​ <strong>D3：</strong>已知内容、未知风格</p><p>​ <strong>D4：</strong>未知内容、未知风格</p><p>参考：https://zhuanlan.zhihu.com/p/99375611</p>]]></content>
    
    
    <summary type="html">里面包含了目前我们用于衡量字体生成效果的一些指标的介绍以及代码实现，同时也包含字体生成领域的四象限评估。</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
    <category term="Evaluation" scheme="https://blog.slks.xyz/tags/Evaluation/"/>
    
  </entry>
  
  <entry>
    <title>2.1 进程与线程的基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/14/32aa5a2632ac/"/>
    <id>https://blog.slks.xyz/2022/03/14/32aa5a2632ac/</id>
    <published>2022-03-14T13:04:19.000Z</published>
    <updated>2022-03-15T10:22:09.094Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=12</p><h3 id="一进程的定义组成和组织方式">一、进程的定义、组成和组织方式</h3><h4 id="进程的由来">1、进程的由来：</h4><p>程序本身其实就是一个指令序列。</p><p>早期的计算机只支持单道程序，程序运行时，内存中会分配两块区域：</p><ul><li>程序段：程序的代码放在程序段内</li><li>数据段：程序运行过程处理的数据放在数据段内</li></ul><p>​ 引入多道程序技术后，内存中需要存放多道程序：</p><p>​ <strong>为方便操作系统管理，完成个程序并发执行</strong>，故而操作系统为每个运行的程序配置一个数据结构，被称为<strong>进程控制块（PCB）</strong>，用于描述进程的各种信息（比如该进程程序代码存放位置等）。</p><h4 id="进程的定义">2、进程的定义：</h4><p>​ <strong>PCB、程序段、数据段</strong>三部分构成了<strong>进程实体</strong>。<strong>所谓创建进程，实质上是创建进程实体中的PCB；</strong>而撤销进程，实质上是撤销进程实体中的PCB。</p><p>​ PCB是进程存在的唯一标志。</p><p>​ 引入进程实体的概念后，可把进程定义为：<strong>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</strong>注：严格来说，进程实体和进程并不一样，进程实体是静态的，进程则是动态的。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314212804178.png" style="zoom:50%;" /></p><h4 id="进程组成">3、进程组成：</h4><h5 id="进程由以下三部分组成">1）进程由以下三部分组成：</h5><ul><li>PCB：进程的管理者所需的数据都在PCB中</li><li>程序段：存放要执行的代码</li><li>数据段：存放程序运行过程中处理的各种数据</li></ul><h5 id="pcb结构体中包含如下内容">2）PCB结构体中包含如下内容：</h5><ul><li>进程描述信息<ul><li>进程标识符PID</li><li>用户标识符UID</li></ul></li><li>进程控制和管理信息<ul><li>进程当前状态</li><li>进程优先级</li></ul></li><li>资源分配清单<ul><li>程序段指针</li><li>数据段指针</li><li>键盘、鼠标</li></ul></li><li>处理机相关信息<ul><li>各种寄存器的值</li></ul></li></ul><h4 id="进程的组织多个进程间">4、进程的组织：（多个进程间）</h4><h5 id="链接方式">1）链接方式</h5><p>按照进程状态将PCB分为多个队列，操作系统持有指向各个队列的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221020998.png" alt="进程组织的链接方式" style="zoom: 50%;" /></p><h5 id="索引方式">2）索引方式</h5><p>​ 根据进程状态的不同，建立几张索引表，操作系统持有指向各个索引表的指针</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314221055019.png" alt="进程组织的索引方式" style="zoom:50%;" /></p><h4 id="进程的特征">5、进程的特征：</h4><ul><li><strong>动态性（最基本特征）</strong>：进程是程序的一次执行过程，是动态地产生、变化和消亡的</li><li><strong>并发性：</strong>内存中有多个进程实体，各进程可并发执行</li><li><strong>独立性：</strong>进程是能独立运行、独立获得资源、独立接受调度的基本单位</li><li><strong>异步性：</strong>各进程按各自独立的、不可预知的速度向前推进，操作系统要提供“进程同步机制"来解决异步问题。异步性可能会导致并发程序执行结果的不确定性。</li><li><strong>结构性：</strong>每个进程都会配置一个PCB。结构上看，进程由程序段、数据段、PCB组成</li></ul><h3 id="二进程的状态和转换">二、进程的状态和转换</h3><h4 id="进程的三种基本状态">1、进程的三种基本状态：</h4><h5 id="运行态占用cpu并在cpu上运行">1）运行态：占用CPU，并在CPU上运行。</h5><p>​ 注意：单核处理机环境下，每一时刻最多见有一个进程处于运行态。（双核环境下可以同时有两个进程处于运</p><p>行态）。</p><h5 id="就绪态已经具备运行条件但由于没有空闲cpu而暂时不能运行">2）就绪态：已经具备运行条件，但由于没有空闲CPU，而暂时不能运行</h5><p>​ 进程已经拥有了除处理机之外所有需要的资源，一旦获得处理机，即可立即进入运行态开始运行。 即：万事俱备，只欠CPU即：万事俱备，只欠CPU</p><h5 id="阻塞态因等待某一事件而暂时不能运行">3）阻塞态：因等待某一事件而暂时不能运行</h5><p>​ 如：等待操作系统分配打印机、等待读磁盘操作的结果。CPU是计算机中最昂贵的部件，为了提高CPU的利用率，需要先将其他进程需要的资源分配到位，才能得到CPU的服务</p><h4 id="进程的另外两种状态">2、进程的另外两种状态：</h4><h5 id="创建态进程正在被创建操作系统为进程分配资源初始化pcb进程正在被创建操作系统为进程分配资源初始化pcb">1）创建态：进程正在被创建，操作系统为进程分配资源、初始化PCB进程正在被创建，操作系统为进程分配资源、初始化PCB</h5><p>​ 操作系统需要完成创建进程。操作系统为该进程分配所需的内存空间等系统资源，并为其创建、初始化PCB（如：为进程分配PID）</p><h5 id="终止态进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb进程正在从系统中撤销操作系统会回收进程拥有的资源撤销pcb">2）终止态：进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB进程正在从系统中撤销，操作系统会回收进程拥有的资源、撤销PCB</h5><p>​ 进程运行结束（或者由于bug导致进程无法继续执行下去，比如数组越界错误），需要撤销进程。操作系统需要完成撤销进程相关的工作。完成将分配给进程的资源回收，撤销进程PCB等工作</p><h4 id="进程状态的转换">2、进程状态的转换：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223023656.png" alt="进程状态转换图" /><figcaption aria-hidden="true">进程状态转换图</figcaption></figure><ul><li><p>运行态→阻塞态是一种进程自身做出的<strong>主动行为</strong></p></li><li><p>阻塞态→就绪态是不是进程自身能控制的，是一种<strong>被动行为</strong>。</p></li><li><p>注意：<strong>不能由阻塞态直接转换为运行态</strong>，<strong>也不能由就绪态直接转换为阻塞态</strong>（因为进入阻塞态是进程主动请求的，必然需要进程在运行时才能发出这种请求）</p></li></ul><h3 id="三进程控制">三、进程控制</h3><h4 id="什么是进程控制">1、什么是进程控制：</h4><p>​ 进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。</p><h4 id="如何实现进程控制">2、如何实现进程控制：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314223828760.png" style="zoom:50%;" /></p><ul><li>创建进程：需要初始化PCB、分配系统资源</li><li>创建态→就绪态：需修改PCB内容和相应队列</li><li>就绪态→运行态：需恢复进程运行环境、修改PCB内容和相应队列</li><li>运行态→阻塞态：需保存进程运行环境、修改PCB内容和相应队列</li><li>阻塞态→就绪态：需修改PCB内容和相应队列。如果等待的是资源，则还需为进程分配系统资源</li><li>运行态→就绪态：（进程切换）需保存进程运行环境、修改PCB内容和相应队列</li><li>运行态→终止态：需回收进程拥有的资源，撤销PCB的资源，撤销PCB</li></ul><p>​ 为了使得进程状态切换中，数据具有一致性（类似于事务的概念），用<strong>原语</strong>实现进程控制。原语的特点是执行期间不允许中断，只能一气呵成。</p><p><strong>这种不可被中断的操作即原子操作。</strong></p><p><strong>原语采用“关中断指令”和“开中断指令”实现，如下所示</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220314224013167.png" alt="" style="zoom: 67%;" /></p><p>​ 当在关中断指令执行后，如果系统收到外部中断信号，此时会将该信号转至开中断指令结束后再进行处理，即再开中断指令执行结束后，才会启动中断处理程序。如此，原语部分的代码就不会被打断执行。</p><p>​ 显然，<strong>关/开中断指令的权限非常大，必然是只允许在核心态下执行的特权指令</strong></p><p>​</p><h4 id="原语的具体操作">3、原语的具体操作：</h4><h5 id="进程控制会导致进程状态的转换无论哪个原语要做的无非三类事情">进程控制会导致进程状态的转换。无论哪个原语，要做的无非三类事情：</h5><ul><li>1.更新PCB中的信息（如修改进程状态标志、将运行环境保存到PCB、从PCB恢复运行环境）<ul><li>a.所有的进程控制原语一定都会修改进程状态标志</li><li>b.剥夺当前运行进程的CPU使用权必然需要保存其运行环境</li><li>c.某进程开始运行前必然要恢复期运行环境</li></ul></li><li>2.将PCB插入合适的队列</li><li>3.分配/回收资源</li></ul><h5 id="创建原语无创建态就绪态">1）创建原语：（无→创建态→就绪态）</h5><p>申请空白PCB、为新进程分配所需资源、初始化PCB、将PCB插入就绪队列</p><h5 id="能够引起进程创建的事件如下">能够引起进程创建的事件如下：</h5><ul><li>用户登录：分时系统中，用户登录成功，系统会建立为其建立一个新的进程</li><li>作业调度：多道批处理系统中，有新的作业放入内存时，会为其建立一个新的进程引起进程创建的事件 l引起进程创建的事件</li><li>提供服务：用户向操作系统提出某些请求时，会新建一个进程处理该请求</li><li>应用请求：由用户进程主动请求创建一个子进程</li></ul><h5 id="撤销原语就绪态阻塞态运行态终止态无">2）撤销原语：（就绪态/阻塞态/运行态→终止态→无）</h5><p>​ 从PCB集合中找到终止进程的PCB，若进程正在运行，立即剥夺CPU，将CPU分配给其他进程。终止其所有子进程，将该进程拥有的所有资源归还给父进程或操作系统。删除PCB</p><h5 id="能够引起进程撤销的事件如下">能够引起进程撤销的事件如下：</h5><ul><li>正常结束</li><li>异常结束</li><li>外界干预</li></ul><h5 id="阻塞原语运行态阻塞态">3）阻塞原语：（运行态→阻塞态）</h5><p>​ 找到要阻塞的进程对应的PCB，保护进程运行现场，将PCB状态信息设置为“阻塞态”，暂时停止进程运行，将PCB插入相应事件的等待队列。</p><p><strong>能够引起进程阻塞的事件如下：</strong></p><ul><li>需要等待系统分配某种资源</li><li>需要等待相互合作的其他进程完成工作</li></ul><h5 id="唤醒原语阻塞态运行态">4）唤醒原语：（阻塞态→运行态）</h5><p>​ 在事件等待队列中找到PCB，将PCB从等待队列移除，设置进程为就绪态，将PCB插入就绪队列，等待被调度</p><p><strong>能够引起进程唤醒的事件如下：</strong></p><ul><li>正在等待的事件发生（因何事阻塞，就应当由何事唤醒，需与阻塞原语成对使用）</li></ul><h5 id="切换原语运行态阻塞态就绪态-或-就绪态运行态">5）切换原语：（运行态→阻塞态/就绪态 或 就绪态→运行态）</h5><p>​ 将运行环境信息存入PCB，PCB移入相应队列。选择另一个进程执行，并更新其PCB，根据PCB恢复新进程所需的运行环境</p><p><strong>能够引起进程切换的事件如下：</strong></p><ul><li>当前进程时间片到</li><li>有更高优先级的进程到达</li><li>当前进程主动阻塞</li><li>当前进程终止</li></ul><h3 id="四进程通信">四、进程通信：</h3><h4 id="什么是进程通信">1、什么是进程通信？</h4><p>​ 进程通信就是指进程之间的信息交换。进程是分配系统资源的单位（包括内存地址空间），因此<strong>各进程拥有的内存地址空间相互独立。</strong>进程1可以访问进程1的地址空间，但不能直接访问进程2的地址空间。</p><p>​ <strong>为了保证安全，一个进程不能直接访问另一个进程的地址空间，但是进程之间的信息交换是必须实现的，为了保证进程间的安全通信，操作系统提供了一些方法就是进程通信</strong></p><h4 id="进程通信共享存储-方法">2、进程通信——共享存储 方法</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171055164.png" alt="共享存储" style="zoom: 67%;" /></p><p>​ 两个进程对共享空间的访问必须是互斥的（互斥访问通过操作系统提供的工具实现）。</p><p>​ 操作系统只负责提供共享空间和同步互斥工具（如P、V操作）</p><p>​ <strong>其又有两种方式</strong>：</p><ul><li><p>基于数据结构的共享</p><p>​ 基于数据结构的共享：比如共享空间里只能放一个长度为10的数组。这种共享方式<strong>速度慢、限制多，是一种低级通信方式</strong></p></li><li><p>基于存储区的共享</p><p>​ 基于存储区的共享：在内存中画出一块共享存储区，<strong>数据的形式、存放位置都由进程控制，而不是操作系统。</strong>相比之下，这种共享方式<strong>速度更快，是一种高级通信方式。</strong></p></li></ul><h4 id="进程通信管道通信-方法">3、进程通信——管道通信 方法</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315171447871.png" alt="管道通信" /><figcaption aria-hidden="true">管道通信</figcaption></figure><p>​ “管道”是指用于连接读写进程的一个共享文件，又名pipe程的一个共享文件，又名pipe 文件。其实就是<strong>在内存中开辟一个大小固定的缓冲区 </strong></p><ul><li>管道只能采用半双工通信，某一时间段内只能实现单向的传输。如果要实现双向同时通信，则需要设置两个管道。</li><li>各个进程需要互斥的访问管道</li><li>数据以字符流的形式写入管道，<strong>当管道写满时，写进程的write（）系统调用将被阻塞</strong>，等待读进程将数据取走。<strong>当读进程将数据全部取走后，管道变空，此时读进程的read（）系统调用将被阻塞。</strong></li><li><strong>如果没写满，就不允许读。如果没读空，就不允许写。</strong></li><li><strong>数据一旦被读出，就从管道中被抛弃，这就意味着读进程最多只能有一个，否则可能会有读错数据的情</strong></li></ul><h4 id="进程通信消息传递-方法">4、进程通信——消息传递 方法</h4><p>​ 进程间的数据交换<strong>以格式化的消息（Message）为单位</strong>。进程通过操作系统提供的<strong>“发送消息/接收消息”两个原语进行数据交换</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180227145.png" /></p><p>​ 消息头包括：发送进程ID、接受进程ID、消息类型、消息长度等格式化的信息</p><p>​ 每个进程都会有一个消息缓冲队列：消息传递有以下两种方式：</p><ul><li>直接通信方式: 消息直接挂到接受进程的消息缓冲队列上<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180138885.png" /></li></ul></li><li>间接通信方式：消息先发送到中间实体中<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180217571.png" /></li></ul></li></ul><h3 id="五线程概念和多线程模型">五、线程概念和多线程模型：</h3><h4 id="什么是线程">1、什么是线程？</h4><p>​ 在传统的机制中，<strong>进程是程序执行流的最小单位。</strong></p><p>​ <strong>有的进程</strong>可能需要“同时”做很多事，而传统的进程只能串行地执行一系列程序。为此，引入了“线程”，来增加并发度。</p><p>​ 一个进程中，被分为多个线程。CPU轮流为不同的线程服务。故而，引入线程后，<strong>线程是程序执行流的最小单位。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315180730244.png" style="zoom:67%;" /></p><p>​</p><p><strong>官方定义：线程是一个基本的CPU执行单元，也是程序执行流的最小单位。</strong></p><p>​ 引入线程之后，不仅是进程之间可以并发，进程内的各线程之间也可以并发，从而进一步提升了系统的并发度，使得一个进程内也可以并发处理各种任务</p><p>​ 引入线程后，<strong>进程只作为除CPU之外的系统资源的分配单元</strong>（如打印机、内存地址空间等都是分配给进程的），<strong>线程才是CPU的执行单元</strong>（而CPU是分配给不同的线程的）</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181019487.png" alt="引入线程后的变化" /></p><h4 id="线程的属性">2、线程的属性：</h4><ul><li>线程是处理机调度的单位</li><li>多CPU计算机中，各个线程可占用不同的CPU</li><li>每个线程都有一个线程ID、线程控制块（TCB）</li><li>线程也有就绪、阻塞、运行三种基本状态</li><li>线程几乎不拥有系统资源</li><li><strong>同一进程的不同线程间共享进程的资源（例如打印机等）</strong></li><li>由于共享内存地址空间，同一进程中的线程间通信甚至无需系统干预</li><li>同一进程中的线程切换，不会引起进程切换</li><li>不同进程中的线程切换，会引起进程切换</li><li>切换同进程内的线程，系统开销很小</li><li>切换进程，系统开销较大</li></ul><h4 id="线程的实现方式">3、线程的实现方式：</h4><h5 id="用户级线程">1）用户级线程：</h5><p>​ 用户级线程由应用程序通过线程库实现。</p><p>​ 所有的线程管理工作都<strong>由应用程序负责（包括线程切换）</strong></p><p>​ 用户级线程中，线程切换可以在用户态下即可完成，无需操作系统干预。</p><p>​ <strong>在用户看来，是有多个线程。但是在操作系统内核看来，并意识不到线程的存在。</strong>（用户级线程对用户不透明，对操作系统透明）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181528334.png" alt="用户级线程" style="zoom: 67%;" /></p><h5 id="内核级线程">2）内核级线程：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181555209.png" alt="内核级线程" style="zoom:67%;" /></p><p>​ 核级线程的管理工作由操作系统内核完成。</p><p>​ 线程调度、切换等工作都由内核负责，因此内核级线程的切换必然需要在核心态下才能完成。</p><h5 id="两者组合">3）两者组合：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315181640824.png" alt="" style="zoom:67%;" /></p><p>​ 在同时支持用户级线程和内核级线程的系统中，可采用二者组合的方式：将n个用户级线程映射到m 个内核级线程上（n&gt;=m）</p><p>​ 重点：<strong>操作系统只“看得见”内核级线程，因此只有内核级线程才是处理机分配的单位。</strong></p><p>​ 例如：左边这个模型中，该进程由两个内核级线程，三个用户级线程，在用户看来，这个进程中有三个线程。但即使该进程在一个4核处理机的计算机上运行，<strong>也最多只能被分配到两个核，最多只能有两个用户线程并行执行。</strong></p><h4 id="多线程模型">4、多线程模型：</h4><p>​ 在同时支持用户级线程和内核级线程的系统中，由几个用户级线程映射到几个内核级线程的问题引出了“多线程模型”问题。</p><h5 id="多对一模型">1）多对一模型：</h5><p>​ 多个用户及线程映射到一个内核级线程。每个用户进程只对应一个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182055006.png" style="zoom:67%;" /></p><p>​ <strong>优点：</strong>用尸级线程的切换在用尸空间即可完成，不需要切换到核心态，线程管理的系统开销小，效率高</p><p>​ <strong>缺点：</strong>当一个用户级线程被阻塞后，整个进程都会被阻塞，并发度不高。多个线程不可在多核处理机上并行运行</p><h5 id="一对一模型">2）一对一模型：</h5><p>​ 一个用户及线程映射到一个内核级线程。每个用户进程有与用户级线程同数量的内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182003606.png" alt="一对一模型" style="zoom:67%;" /></p><p>​ <strong>优点</strong>：当一个线程被阻塞后，别的线程还可以继续执行，并发能力强。多线程可在多核处理机上并行执行。</p><p>​ <strong>缺点</strong>：一个用户进程会占用多个内核级线程，线程切换由操作系统内核完成，需要切换到核心态，因此线程管理的成本高，开销大。</p><h5 id="多对多模型">3）多对多模型：</h5><p>​ n用户及线程映射到m个内核级线程（n&gt;=m）。每个用户进程对应m个内核级线程。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220315182148042.png" style="zoom:67%;" /></p><p>​ 克服了多对一模型并发度不高的缺点，又克服了一对一模型中一个用户进程占用太多内核级线程，开销太大的缺点。</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.1节的内容，含进程的定义、组成、组织方式、状态与转换，进程控制、进程通信、线程概念和多线程模型等内容</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>__call__方法</title>
    <link href="https://blog.slks.xyz/2022/03/12/6c6b30d1f672/"/>
    <id>https://blog.slks.xyz/2022/03/12/6c6b30d1f672/</id>
    <published>2022-03-12T06:20:19.000Z</published>
    <updated>2022-03-12T06:23:18.228Z</updated>
    
    <content type="html"><![CDATA[<p>​ Python的一个特殊的实例方法<code>__call__</code>，功能类似于在类中重载()运算符，使得类实例对象可以像调用普通函数那样进行使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CLanguage</span>:</span></span><br><span class="line">    <span class="comment"># 定义__call__方法</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span>(<span class="params">self,name,add</span>):</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;调用__call__()方法&quot;</span>,name,add)</span><br><span class="line">clangs = CLanguage()</span><br><span class="line">clangs(<span class="string">&quot;C test&quot;</span>)</span><br></pre></td></tr></table></figure><p>通过在 CLanguage 类中实现<code>__call__</code>方法，使得 clangs 实例对象变为了可调用对象。</p>]]></content>
    
    
    <summary type="html">本文讲解了Python的一个特殊的实例方法__call__，功能类似于在类中重载()运算符，使得类实例对象可以像调用普通函数那样进行使用。</summary>
    
    
    
    <category term="⓸ 编程语言类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python基础扩充笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B8-%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80%E7%B1%BB%E7%AC%94%E8%AE%B0/Python%E5%9F%BA%E7%A1%80%E6%89%A9%E5%85%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记11——torchvision图像数据预处理</title>
    <link href="https://blog.slks.xyz/2022/03/12/796f9da33963/"/>
    <id>https://blog.slks.xyz/2022/03/12/796f9da33963/</id>
    <published>2022-03-12T05:45:19.000Z</published>
    <updated>2022-03-12T06:18:42.221Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一torchvision简介">一、TorchVision简介：</h3><p>torchvision 是Pytorch中专门用来处理图像的库。这个包中有四个大类。</p><ul><li><p>torchvision.datasets 包含了很多提前处理好的数据集：如COCO、ImageNet等</p></li><li><p>torchvision.models 包含了已经训练好的模型，可以加载后直接用：如AlexNet、VGG等</p></li><li><p>torchvision.transforms 包含一般的图像转换操作类 如归一化、展平</p></li><li><p>torchvision.utils</p></li></ul><h3 id="二transforms的一些函数">二、Transforms的一些函数：</h3><h4 id="transforms.normalizemeanstdinplacefalse">1、transforms.Normalize(mean,std,inplace=False)</h4><ul><li>mean:各通道的均值</li><li>std：各通道的标准差</li><li>inplace：是否原地操作</li></ul><p>一般可以如下传入mean和std:代表我要将数据归约化至如下的均值和方差的分布</p><p><code>mean = (0.5,0.5,0.5) std = (0.5,0.5,0.5)</code></p><p>该函数就是通过以下公式，对图像3个通道分别依据输入的mean和std进行归约化。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = (x - mean) / std</span><br></pre></td></tr></table></figure><p>最终得到新的数据。整体过程如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">new_data = transforms.Normalize(mean, std)(data)</span><br></pre></td></tr></table></figure><p>可以看到：其实 transforms.Normalize(mean, std) 只是指定了一个函数，所以还可以如下操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line">mean = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>) </span><br><span class="line">std = (<span class="number">0.5</span>,<span class="number">0.5</span>,<span class="number">0.5</span>)`</span><br><span class="line">normalize = transforms.Normalize(mean=mean, std=std)</span><br><span class="line">new_data = normalize(data)</span><br></pre></td></tr></table></figure><h4 id="transforms.totensor">2、transforms.ToTensor()</h4><p>该函数有两个功能：</p><ol type="1"><li>是将输入的数据改变Shpae，图像数据本身是三维的： W，H，C ，该函数会将其变成 C，W，H的维度</li><li>将所有数除以255，将像素数据归一化到<code>[0,1]</code></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(data.shape)   <span class="comment">#（5，5，3）</span></span><br><span class="line">data = transforms.ToTensor()(data)</span><br><span class="line"><span class="built_in">print</span>(data.shape)<span class="comment">#（3，5，5）</span></span><br></pre></td></tr></table></figure><p>和Normalize函数一样：也可以按照如下方法使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">toTensor = transforms.ToTensor()</span><br><span class="line">data = toTensor(data)</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">PyTorch 中，关于torchvision库对图像数据预处理的函数记录</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Pytorch系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Pytorch%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>1.1 操作系统概念与基础</title>
    <link href="https://blog.slks.xyz/2022/03/11/b7e4aac04426/"/>
    <id>https://blog.slks.xyz/2022/03/11/b7e4aac04426/</id>
    <published>2022-03-11T12:48:19.000Z</published>
    <updated>2022-03-14T13:03:48.485Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一概念功能与目标">一、概念功能与目标</h3><h4 id="概念">1、概念</h4><p>操作系统（Operating System，OS）是指控制和管理<strong>整个计算机系统的硬件和软件资源</strong>，并合理地组织调度计算机的工作和资源的分配，以提供给用户和其他软件方便的接口和环境，它是计算机系统中最基本的<strong>系统软件</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220311205142106.png" style="zoom: 67%;" /></p><p>较为直观的例子：Windows的任务管理器</p><h4 id="功能与目标">2、功能与目标：</h4><h5 id="系统资源的管理者">1) 系统资源的管理者：</h5><p>提供4个功能：</p><ul><li>CPU管理</li><li>存储器管理（内存&amp;外存）</li><li>文件管理</li><li>硬件设备管理</li></ul><p>目标：安全 + 高效</p><h5 id="作为用户和计算机硬件之间的接口">2）作为用户和计算机硬件之间的接口：</h5><p>提供3个功能：</p><ul><li>命令接口<ul><li>联机命令接口（交互式命令接口）：用户说一句，系统做一句。比如win中的<code>cmd</code>命令解释器</li><li>脱机命令接口（批处理命令接口）：用户说一堆，系统做一堆。win中的<code>*.bat</code>文件执行</li></ul></li><li>程序接口<ul><li>如win中，程序员在程序中调用<code>*.dll</code>（该调用过程即为<strong>系统调用</strong>）可以实现某些功能。这类接口只能通过用户程序<strong>间接使用</strong></li></ul></li><li>GUI图形用户界面<ul><li>删除文件：拖拽至回收站</li></ul></li></ul><h5 id="作为最接近硬件的层次">3） 作为最接近硬件的层次：</h5><p>需要实现堆硬件机器的拓展，没有任何软件支持的计算机称为<strong>裸机</strong>。</p><p>通常把覆盖了软件的机器成为<strong>扩充机器</strong>，又称之为<strong>虚拟机</strong></p><h3 id="二操作系统的特征">二、操作系统的特征</h3><h4 id="并发最基本的特征之一">1、并发（最基本的特征之一）</h4><p>​ 指两个或多个事件在同一时间间隔内发生。<strong>这些事件宏观上是同时发生的，但微观上是交替发生的。</strong></p><p>​ 操作系统的并发性指<strong>计算机系统中同时存在着多个运行着的程序</strong>。</p><p>​ 一个单核处理机（CPU）同一时刻只能执行一个程序，因此<strong>操作系统会负责协调多个程序交替执行（这些程序微观上是交替执行的，但宏观上看起来就像在同时执行）</strong></p><p>​ 我们现在的4核CPU处理器，意味着同一时刻可以有4个程序<strong>并行</strong>执行，但是操作系统的<strong>并发性</strong>必不可少。</p><h4 id="共享最基本的特征之二">2、共享（最基本的特征之二）</h4><p>​ 资源共享，是指<strong>系统中的资源可供内存中多个并发执行的进程共同使用。</strong></p><ul><li>互斥共享方式：系统中的<strong>某些资源，虽然可以提供给多个进程使用，但一个时间段内只允许一个进程访问该资源。</strong>比如说：使用QQ和微信视频，<strong>同一时间段摄像头只能分配给其中一个进程。</strong></li><li>同时共享方式：系统中的某些资源，允许一个时间段内由多个进程<strong>“同时”</strong>对它们进行访问。比如说：使用QQ发送文件A，同时使用微信发送文件B。<strong>宏观上看，两边都在同时读取并发送文件，</strong>说明两个进程都在访问硬盘资源，从中读取数据。<strong>微观上看，两个进程是交替着访问硬盘的。</strong></li></ul><h4 id="虚拟">3、虚拟</h4><p>​ 虚拟是指<strong>把一个物理上的实体变为若干个逻辑上的对应物</strong>：物理实体（前者）是实际存在的，而<strong>逻辑上对应物（后者）是用户感受到的。</strong></p><h5 id="虚拟技术">1）虚拟技术</h5><ul><li><p>空分复用技术：如虚拟存储器技术</p></li><li><p>时分复用技术：如虚拟处理器</p></li><li><p>问题1：GTA5需要4GB的运行内存，QQ需要256MB的内存，迅雷需要256MB的内存，网易云音乐需要256MB的内存……而我的电脑只有4GB内存，这些程序同时运行需要的内存远大于4GB，那么为什么它们还可以在我的电脑上同时运行呢？</p></li><li><p>答：这是虚拟存储器技术。实际只有4GB的内存，在用户看来似乎远远大于4GB。<strong>即空分复用技术</strong></p></li><li><p>问题2：既然一个程序需要被分配CPU才能正常执行，那么为什么单核CPU的电脑中能同时运行这么多个程序呢？</p></li><li><p>答：这是虚拟处理器技术。实际上只有一个单核CPU，在用户看来似乎有6个CPU在同时为自己服务。<strong>即时分复用技术</strong></p></li></ul><h4 id="异步">4、异步</h4><p>​ 异步是指，在多道程序环境下，允许多个程序并发执行，<strong>但由于资源有限，进程的执行不是一贯到底的，而是走走停停，以不可预知的速度向前推进，</strong>这就是进程的异步性。</p><h3 id="三操作系统的发展与分类">三、操作系统的发展与分类：</h3><h4 id="手工操作阶段">1、手工操作阶段：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313105737330.png" alt="手工操作阶段" /><figcaption aria-hidden="true">手工操作阶段</figcaption></figure><p><strong>主要缺点：</strong>用户独占全机、人机速度矛盾导致资源利用率极低</p><h4 id="批处理阶段">2、批处理阶段：</h4><h5 id="单道批处理系统">1）单道批处理系统</h5><p>​ 引入脱机输入输出技术（用磁带完成），并由监督程序负责控制作业的输入输出。</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110520259.png" alt="单道批处理系统" /><figcaption aria-hidden="true">单道批处理系统</figcaption></figure><p><strong>主要优点：</strong>缓解了一定程度的人机速度矛盾，资源利用率有所提升。</p><p><strong>主要缺点：</strong>内存中仅能有一道程序运行，只有该程序运行结束之后才能调入下一道程序。CPU有大量的时间是在空闲等待l/0完成。资源利用率依然很低。</p><h5 id="多道批处理系统">2）多道批处理系统</h5><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313110759912.png" alt="多道批处理系统" /><figcaption aria-hidden="true">多道批处理系统</figcaption></figure><p><strong>主要优点：</strong>多道程序并发执行，共享计算机资源。资源利用率大幅提升，CPU和其他资源保持“忙碌”状态，系统吞吐量增大。</p><p><strong>主要缺点：</strong>用户响应时间长，没有人机交互功能（用户提交自己的作业（程序）之后就只能等待计算机处理完成，中间不能控制自己的作业执行）</p><h4 id="分时操作系统">3、分时操作系统：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111132639.png" alt="分时操作系统" /><figcaption aria-hidden="true">分时操作系统</figcaption></figure><p>​ 计算机以<strong>时间片</strong>（例如50ms）为单位<strong>轮流为各个用户/作业服务</strong>，各个用户可通过终端与计算机进行交互。</p><p><strong>王要优点：用户请求可以被即时响应，群决了人机交互问题。</strong>允许多个用尸同时使用一台计算机，并且用户对计算机的操作相互独立，感受不到别人的存在。</p><p><strong>主要缺点：</strong>不能优先处理一些紧急任务。操作系统对各个用户/作业都是完全公平的，循环地为每个用户作业服务一个时间片，<strong>不区分任务的紧急性</strong>。</p><h4 id="实时操作系统">4、实时操作系统：</h4><ul><li>硬实时系统：必须在绝对严格的规定时间内完成处理（如导弹控制系统、自动驾驶等）</li><li>软实时系统：能接受偶尔违反时间规定</li></ul><p>主要优点：能够优先响应一些紧急任务，某些紧急任务不需时间片排队。</p><p>在实时操作系统的控制下，计算机系统接收到外部信号后<strong>及时进行处理</strong>，并且要在严格的时限内处理完事件。实时操作系统的主要特点是<strong>及时性和可靠性</strong></p><h4 id="其他操作系统">5、其他操作系统：</h4><ul><li>网络操作系统：是伴随着计算机网络的发展而诞生的，能把网络中各个计算机有机地结合起来，实现数据传送等功能，实现网络中各种资源的共享（如文件共享）和各台计算机之间的通信。（如：Windows NT就是一种典型的网络操作系统，网站服务器就可以使用）</li><li>分布式操作系统：主要特点是<strong>分布性和并行性</strong>。系统中的各台计算机地位相同，任何工作都可以分布在这些计算机上，由它们并行、协同完成这个任务。</li><li>个人计算机操作系统：如WindowsXP、MacOs，方便个人使用。</li></ul><h3 id="四操作系统的运行机制">四、操作系统的运行机制：</h3><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313111750626.png" alt="“指令”和&quot;代码&quot;的区别" /><figcaption aria-hidden="true">“指令”和"代码"的区别</figcaption></figure><h4 id="两种指令">1、两种指令：</h4><h5 id="特权指令如内存清零指令不允许用户程序使用">1） 特权指令：如内存清零指令，不允许用户程序使用</h5><h5 id="非特权指令如普通的运算指令">2） 非特权指令：如普通的运算指令</h5><h4 id="两种处理器状态">2、两种处理器状态：</h4><p>用于判断当前是否可以执行特权指令</p><h5 id="用户态目态只能执行非特权指令">1） 用户态（目态）：只能执行非特权指令</h5><h5 id="核心态管态两种指令都可以执行">2） 核心态（管态）：两种指令都可以执行</h5><h4 id="两种程序">3、两种程序：</h4><h5 id="内核程序">1）内核程序：</h5><p>​ 操作系统的内核程序是系统的管理者，既可以执行特权指令，也可以执行非特权指令，运行在核心态。</p><h5 id="应用程序">2）应用程序：</h5><p>​ 为了保证系统能安全运行，普通应用程序只能执行非特权指令，运行在用户态</p><h3 id="五操作系统内核">五、操作系统内核：</h3><h4 id="内核总览示意图">1、内核总览示意图：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112448980.png" alt="计算机系统的层次结构" /><figcaption aria-hidden="true">计算机系统的层次结构</figcaption></figure><p>​ <strong>原子性</strong>指该程序在开始执行后，中间不能被中断。</p><p>​ 内核是计算机上配置的底层软件，是操作系统最基本、最核心的部分。实现操作系统内核功能的那些程序就是内核程序。</p><h4 id="操作系统的体系结构">2、操作系统的体系结构：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313112907278.png" /></p><h5 id="大内核">1） 大内核：</h5><p>将操作系统的主要功能模块都作为系统内核，运行在核心态</p><p>优点：高性能</p><p>缺点：内核代码庞大，结构混乱，难以维护</p><h5 id="微内核">2）微内核：</h5><p>只把最基本的功能保留在内核</p><p>优点：内核功能少，结构清晰，方便维护</p><p>缺点：需要频繁地在核心态和用户态之间切换，性能低</p><h3 id="六中断和异常">六、中断和异常：</h3><h4 id="中断机制的诞生缘由">1、中断机制的诞生缘由：</h4><p>​ 早期计算机各个程序只能串行执行程序，系统资源利用率会较低。为了解决该问题，就发明了操作系统，引入中断机制，实现了多道程序的并发执行。</p><p><strong>本质</strong>： 发生中断，就意味着需要操作系统接入，进行管理.具体如下:</p><p>​ 我们假设3个进程同时放入内存中进行执行,首先CPU执行进程1,一段时间后,CPU收到计时硬件发出的中断信号,就会切换至<strong>核心态</strong>,CPU知晓进程1的时间片已经用完了,就切换进程2运行.完成该系列操作后,CPU又会切换至<strong>用户态</strong>,然后开始运行进程2,在进程2运行过程中,进程2发出<strong>系统调用(内中断信号)</strong>,请求输出.<strong>(由于输入输出是特权指令,普通程序不能直接调用,只能通过向操作系统申请,即主动发出中断信号)</strong>,此时CPU将切换到<strong>核心态</strong>,<strong>由操作系统内核进行接管</strong>,负责执行输出内容,比如其让打印机IO设备开始工作,<strong>此时进程2就需要暂停运行等待IO完成,故而操作系统此时让进程3先运行</strong>.CPU重新切换为<strong>用户态,</strong>执行进程3.在CPU执行进程3的过程中,IO也在同步进行,当IO完成时,IO设备(打印机)就会向CPU发出中断信号,CPU收到IO设备发来的中断信号,又会切换至<strong>核心态</strong>,<strong>交由操作系统内核进行处理</strong>.此时,操作系统发现是进程2的IO结束了,就会让进程2恢复运行,CPU切换为用户态.进程2继续完成内容.</p><h4 id="中断的概念和作用">2、中断的概念和作用：</h4><ul><li>当中断发生时，CPU立即进入核心态</li><li>当中断发生后，当前运行的进程暂停运行，并由操作系统内核对中断进行处理</li><li>对于不同的中断信号，会进行不同的处理</li></ul><p>​ 发生了中断，就意味着需要<strong>操作系统介入，开展管理工作。</strong>由于操作系统的管理工作（比如进程切换、分配I/O设备等）需要使用特权指令，因此CPU要从<strong>用户态转为核心态</strong>。<strong>中断可以使CPU从用户态切换为核心态，使操作系统获得计算机的控制权。</strong> <strong>有了中断，才能实现多道程序并发执行。</strong></p><p><strong>用户态</strong>到<strong>核心态</strong>的切换是通过<strong>中断</strong>实现的，并且中断是唯一途径。</p><p><strong>核心态</strong>到<strong>用户态</strong>的切换是通过<strong>执行一个特权指令，将PSW标志位设置</strong>实现的。</p><h4 id="中断的分类">3、中断的分类:</h4><p>两者的本质区别： 信号的来源是CPU内部还是CPU外部。与当前的执行的指令是否有关</p><h5 id="内中断异常例外陷入-来源于cpu内部与当前执行的指令有关">1）内中断（异常、例外、陷入）： 来源于CPU内部，与当前执行的指令有关</h5><ul><li>指令中断：系统调用</li><li>强迫中断<ul><li>硬件故障</li><li>软件中断（如整数除0）</li></ul></li></ul><h5 id="外中断来源于cpu外部与当前执行的指令无关">2）外中断：来源于CPU外部，与当前执行的指令无关</h5><ul><li>外设请求：I/0操作完成发出的中断信号</li><li>人工干预：用户强行终止一个进程</li></ul><p>另一种分类：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130033093.png" alt="另一种中断的分类" /><figcaption aria-hidden="true">另一种中断的分类</figcaption></figure><h4 id="外中断的处理过程">4、外中断的处理过程：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313130249004.png" alt="外中断的处理过程" /><figcaption aria-hidden="true">外中断的处理过程</figcaption></figure><ul><li>Step1：执行完每个指令之后，CPU都要检查当前是否有外部中断信号</li><li>Step2：如果检测到外部中断信号，则需要保护被中断进程的CPU环境（如程序状态字PSW、程序计数器PC、各种通用寄存器)</li><li>Step3：根据中断信号类型转入相应的中断处理程序</li><li>Step 4：恢复原进程的CPU环境并退出中断，返回原进程继续往下执行</li></ul><h3 id="七系统调用">七、系统调用：</h3><h4 id="什么是系统调用">1、什么是系统调用：</h4><p>​ 操作系统作为用户和计算机硬件之间的接口，需要向上提供一些简单易用的服务。主要包括命令接口和程序接口。其中，程序接口由<strong>一组系统调用组成</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313141435648.png" /></p><p>​ “系统调用”是<strong>操作系统提供给应用程序</strong>（程序员/编程人员)使用的接口，可以理解为一种<strong>可供应用程序调用的特殊函数，应用程序可以发出系统调用请求来获得操作系统的服务</strong>。</p><p>​</p><h4 id="系统调用有什么作用">2、系统调用有什么作用？</h4><p>​ <strong>应用程序通过系统调用请求操作系统的服务。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、I/O操作、文件管理等），都必须通过系统调用的方式向操作系统提出服务请求，由操作系统代为完成。这样可以保证系统的稳定性和安全性，防止用户进行非法操作。</strong></p><p><strong>系统调用</strong>会使得处理器从<strong>用户态</strong>进入<strong>核心态</strong>。</p><h4 id="系统调用分类">3、系统调用分类：</h4><p>​ 系统调用相关处理涉及到对系统资源的管理、对进程的控制，这些功能需要执行一些特权指令才能完成，因此系统调用的相关处理需要在核心态下进行。</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142304849.png" alt="系统调用分类" /><figcaption aria-hidden="true">系统调用分类</figcaption></figure><h4 id="系统调用与库函数的区别">4、系统调用与库函数的区别：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142453847.png" style="zoom:50%;" /></p><p>从下层至上层如下：</p><ul><li><strong>裸机</strong></li><li><strong>操作系统</strong>：向上提供系统调用</li><li><strong>编程语言</strong>：向上提供库函数。有时会将系统调用封装成库函数，以隐藏系统调用的一些细节，使上层进行系统调用更加方便。</li><li><strong>普通应用程序</strong>：可直接进行系统调用，也可使用库函数。</li></ul><p>注意：有的库函数涉及系统调用，有的不涉及</p><h4 id="系统调用背后的过程">5、系统调用背后的过程：</h4><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220313142828536.png" alt="系统调用背后的过程" /><figcaption aria-hidden="true">系统调用背后的过程</figcaption></figure><p><code>int x</code>指令的参数x，指明了系统调用号。此处的int是interrupt的缩写，执行该指令后，权限就交给了操作系统来接管，切换至核心态处理系统调用相关代码。</p><p><strong>注意：</strong></p><p>1.陷入指令是在<strong>用户态执行的</strong>，执行陷入指令之后立即引发一个内中断，从而CPU进入核心态 2.<strong>发出系统调用请求是在用户态</strong>，而对系统调用的相应处理在核心态下进行 3.<strong>陷入指令是唯一一个只能在用户态执行，而不可在核心态执行的指令</strong></p>]]></content>
    
    
    <summary type="html">包含王道课程第1节的内容，含操作系统的概念、功能、目标、运行机制、中断异常和系统调用。</summary>
    
    
    
    <category term="⓻ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记5——逻辑回归中的损失函数节点</title>
    <link href="https://blog.slks.xyz/2022/03/02/c830e3a9e023/"/>
    <id>https://blog.slks.xyz/2022/03/02/c830e3a9e023/</id>
    <published>2022-03-02T12:42:19.000Z</published>
    <updated>2022-03-03T02:55:36.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一感知机损失与对数损失">一、感知机损失与对数损失：</h3><h4 id="原理及利弊">1、原理及利弊</h4><p>​ <strong>感知机损失</strong>在原点处有一个硬转折，该点不可导。同时，在x大于0的区间范围内，其函数值一直为0，但这并不太好，虽然此部分的模型分类正确，但是我们希望模型能够更正确，也就是x越大越好。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_45_52_846.png" style="zoom: 50%;" /></p><p>​ 介于上述情况，引入了<strong>对数损失函数</strong>，<span class="math inline">\(L(x) = log(1+e^{-x})\)</span>，处处可导，且在x&gt;0的时候，x越大，函数值越接近0，作了一定的区分。也就是说，对不那么正确的情况施加了一定的惩罚。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_03_02_20_46_33_157.png" style="zoom:50%;" /></p><h4 id="代码实现">2、代码实现：</h4><h5 id="损失函数抽象类">1）损失函数抽象类：</h5><p>​ 按照先前所述，损失函数也可以抽象为计算图中的一个节点，首先定义一个抽象类，继承Node类</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LossFunction</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义损失函数抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="实现感知机损失">2）实现感知机损失：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PerceptionLoss</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    感知机损失，输入为正时为0，输入为负时为输入的相反数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span> </span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line">        </span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 对父节点中每一个元素，执行上述操作</span></span><br><span class="line">        self.value = np.mat( np.where( x &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -x ) )  </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        雅克比矩阵为对角阵，每个对角线元素对应一个父节点元素。若父节点元素大于0，则</span></span><br><span class="line"><span class="string">        相应对角线元素（偏导数）为0，否则为-1。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        diag = np.where(parent.value &gt;= <span class="number">0.0</span>, <span class="number">0.0</span>, -<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())  </span><br><span class="line">    <span class="comment"># ravel 函数将 多维数组 扁平化展开</span></span><br><span class="line">        <span class="comment"># np.diag(array) 中</span></span><br><span class="line">        <span class="comment"># array是一个1维数组时，结果形成一个以一维数组为对角线元素的矩阵</span></span><br><span class="line">        <span class="comment"># array是一个二维矩阵时，结果输出矩阵的对角线元素</span></span><br></pre></td></tr></table></figure><h5 id="实现对数损失类">3）实现对数损失类：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LogLoss</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span>  <span class="comment"># 根据父节点的值，计算该节点的值</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">1</span>  <span class="comment"># 只接受一个父节点</span></span><br><span class="line"></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value </span><br><span class="line"></span><br><span class="line">        self.value = np.log(<span class="number">1</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))) <span class="comment"># 对于父节点的每个元素都依据公式进行运算，为了防止溢出，对指数进行了截断</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span> <span class="comment"># 计算本节点对某个父节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        x = parent.value</span><br><span class="line">        diag = -<span class="number">1</span> / (<span class="number">1</span> + np.power(np.e, np.where(x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, x))) <span class="comment"># 通过计算可以得到，其实就是对数损失的导数，放在对角线的每个元素上</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(diag.ravel())</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="二logistic函数">二、Logistic函数</h3><h4 id="原理及操作">1、原理及操作：</h4><p><span class="math display">\[Logistic(x) = \frac{1}{1 + e^{-x}}\]</span></p><p><img src="https://bkimg.cdn.bcebos.com/pic/f3d3572c11dfa9ec71464f3e60d0f703918fc1ab?x-bce-process=image/watermark,image_d2F0ZXIvYmFpa2U4MA==,g_7,xp_5,yp_5/format,f_auto" style="zoom:50%;" /></p><p>​ 我们可以对模型的线性部分施加这个变换，来代替原先的阶跃函数。</p><h4 id="logistic操作节点实现">2、Logistic操作节点实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Logistic</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对向量的分量施加Logistic函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        x = self.parents[<span class="number">0</span>].value</span><br><span class="line">        <span class="comment"># 对父节点的每个分量施加Logistic</span></span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            <span class="number">1.0</span> / (<span class="number">1.0</span> + np.power(np.e, np.where(-x &gt; <span class="number">1e2</span>, <span class="number">1e2</span>, -x))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(np.mat(np.multiply(self.value, <span class="number">1</span> - self.value)).A1)  <span class="comment"># 这个计算依赖于Logistic函数对x的导数，在化简后其实就等于 Logistic(x) * (1-Logistic(x))</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="三逻辑回归">三、逻辑回归：</h3><h4 id="二分类逻辑回归">1、二分类逻辑回归：</h4><p>​ 当我们将先前的AdaLine模型的阶跃函数替换成Logistic函数，得到输出。并且对线性部分施加对数损失，就可以得到逻辑回归模型。</p><p>​ 需要注意的是：由于我们的训练集男女标签为1/-1，但是使用Logistic函数输出的值是在0-1之间的，输出的内容是正类（男性）的概率值，而没有判定样本具体的类别。所以我们可以以0.5为阈值，进行判定。阈值大小也是可以根据具体情况自定义的。</p><p>​ <strong>故而，二分类逻辑回归模型只提供概率，选择阈值的决定权还是在人</strong></p><p>​ <strong>总结</strong>：</p><p>​ 用Logistic函数，得到<strong>最终的概率值输出</strong>。</p><p>​ 对线性部分施加<strong>对数损失，以用于训练</strong>。</p><h4 id="多分类逻辑回归">2、多分类逻辑回归：</h4><p>​ 我们一般采用SoftMax来代替“硬”的Max函数，将所有值归约至0-1之间，进而进行概率值的输出</p><h5 id="softmax节点实现">SoftMax节点实现：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SoftMax</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    SoftMax函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">softmax</span>(<span class="params">a</span>):</span></span><br><span class="line">        a[a &gt; <span class="number">1e2</span>] = <span class="number">1e2</span>  <span class="comment"># 防止指数过大</span></span><br><span class="line">        ep = np.power(np.e, a)</span><br><span class="line">        <span class="keyword">return</span> ep / np.<span class="built_in">sum</span>(ep)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        我们不实现SoftMax节点的get_jacobi函数，        训练时，不会通过SoftMax节点进行反向传播</span></span><br><span class="line"><span class="string">        训练时使用CrossEntropyWithSoftMax节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">raise</span> NotImplementedError(<span class="string">&quot;Don&#x27;t use SoftMax&#x27;s get_jacobi&quot;</span>)</span><br></pre></td></tr></table></figure><p>​ 一般使用交叉熵，来衡量SoftMax输出的分布，与真实标签的分布是否相似，具体的公式见常见的损失函数章节。</p><figure><img src="https://www.zhihu.com/equation?tex=H%28p%2Cq%29%3D-%5Csum_%7Bi%3D1%7D%5Enp%28x_i%29log%28q%28x_i%29%29" alt="[公式]" /><figcaption aria-hidden="true">[公式]</figcaption></figure><p>​ <span class="math inline">\(q(x_i)\)</span>是预测分布，<span class="math inline">\(p(x_i)\)</span>是标签的分布。交叉熵是符合直觉得，当样本属于第i类的时候，只有<span class="math inline">\(p(x_i)\)</span>为1，其他p的分量都为0，最小化交叉熵函数，其实就是在最大化<span class="math inline">\(log(q(x_i))\)</span>这一项的值，也就是在最大化<span class="math inline">\(q(x_i)\)</span>，及最大化模型输出的第i类概率。</p><h5 id="crossentropywithsoftmax-实现">CrossEntropyWithSoftMax 实现：</h5><p>​ 在上面实现Softmax节点的时候，并没有实现get_jacobi方法，原因就是它的输出会和独热向量一起被送给交叉熵。计算交叉熵对于线性部分的雅可比矩阵，比计算对Softmax输出的雅可比矩阵会更容易。Pytorch框架中也是这么干的。将Softmax操作附在了CrossEntropy损失函数中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CrossEntropyWithSoftMax</span>(<span class="params">LossFunction</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对第一个父节点施加SoftMax之后，再以第二个父节点为标签One-Hot向量计算交叉熵</span></span><br><span class="line"><span class="string">    self.parents[0] 为logit向量，也就是线性部分</span></span><br><span class="line"><span class="string">    self.parents[1] 为One-Hot编码的向量标签</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)      </span><br><span class="line">        self.value = np.mat(</span><br><span class="line">            -np.<span class="built_in">sum</span>(np.multiply(self.parents[<span class="number">1</span>].value, np.log(prob + <span class="number">1e-10</span>))))</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="comment"># 这里存在重复计算，但为了代码清晰简洁，舍弃进一步优化</span></span><br><span class="line">        <span class="comment"># 推导见下，参考《用Python实现深度学习框架》</span></span><br><span class="line">        prob = SoftMax.softmax(self.parents[<span class="number">0</span>].value)</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:</span><br><span class="line">            <span class="keyword">return</span> (prob - self.parents[<span class="number">1</span>].value).T</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">return</span> (-np.log(prob)).T</span><br></pre></td></tr></table></figure><h4 id="带交叉熵的多分类逻辑回归计算图示例">3、带交叉熵的多分类逻辑回归计算图示例：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/654F54B060F55AD5E7433929CC7A48B3.jpg" style="zoom: 25%;" /></p><p>​</p>]]></content>
    
    
    <summary type="html">本文介绍逻辑回归中常见的一些损失函数的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记4——优化器类的代码实现（下）</title>
    <link href="https://blog.slks.xyz/2022/02/28/d9d77f183b68/"/>
    <id>https://blog.slks.xyz/2022/02/28/d9d77f183b68/</id>
    <published>2022-02-28T02:59:19.000Z</published>
    <updated>2022-02-28T02:59:58.701Z</updated>
    
    <content type="html"><![CDATA[<h4 id="六momentum冲量优化器的实现">六、Momentum冲量优化器的实现：</h4><h5 id="公式">1、公式：</h5><p>​ 由于先前的梯度下降法的速度向量v只依赖于当前的梯度，而不参考历史梯度，很容易让优化器陷入Critical Point中。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/6E1655AA36BAFF6E77328731A966D476.jpg" style="zoom:33%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Momentum</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冲量法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, momentum=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 衰减系数，默认为0.9</span></span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 积累历史速度的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史速度，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.v:</span><br><span class="line">                    self.v[node] = - self.learning_rate * gradient</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史速度</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的速度</span></span><br><span class="line">                    self.v[node] = self.momentum * self.v[node] - self.learning_rate * gradient</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value + self.v[node])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="七adagrad优化器的实现">七、AdaGrad优化器的实现：</h4><h5 id="公式-1">1、公式：</h5><p>​ <strong>针对梯度的每个分量各自的历史，采用不同的学习率。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B02ADB3A208B90C7E30118C018E24361.jpg" style="zoom: 25%;" /></p><p>​ s 是 一个和梯度同维度的向量，<strong>其会在各个分量上累加历史梯度各个分量的平方</strong>。<strong>更新梯度时，求s各个分量的平方根,然后用学习率去除，得到自适应的一个向量，里面每个分量代表的就是各个分量对应的合适的学习率</strong>，将这个向量与梯度向量做内积，就可以得到一个合理的下降方向。从严格意义上来讲，这已经不是再向梯度的反方向下降了。<span class="math inline">\(\epsilon\)</span>是用于防止除数为0.</p><p>​ <span class="math inline">\(\bigotimes\)</span> 代表向量内各个分量分别相乘，将会得到一个和原来向量维度一致的新向量</p><h5 id="代码-1">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdaGrad</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    不同分量，自适应学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史的向量s，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史累积的向量s</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的历史累积的s</span></span><br><span class="line">                    self.s[node] = self.s[node] + np.power(gradient,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八rmsprop优化器的实现">八、RMSProp优化器的实现：</h4><h5 id="公式-2">1、公式：</h5><p>​ AdaGrad累积了全部的历史梯度，而我们其实应该更多地考虑近期地历史梯度。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/35459FAB3F235381D94DED311CECB887.jpg" style="zoom:25%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码-2">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSProp</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    RMSProp优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta = beta</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.s[node] = self.beta * self.s[node] + (<span class="number">1</span> - self.beta) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="九adam优化器的实现">九、Adam优化器的实现：</h4><h5 id="公式-3">1、公式：</h5><p>​ 集大成者，结合冲量与RMSProp的思想：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F34B46DEC057822E872DE8B45F0EDB3F.jpg" style="zoom:25%;" /></p><h5 id="代码-3">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Adam优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta1=<span class="number">0.9</span>,beta2=<span class="number">0.99</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta1 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        <span class="comment"># 衰减系数2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta2 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 积累历史速度向量的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                    self.v[node] = gradient <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 梯度累积</span></span><br><span class="line">                    self.v[node] = self.beta1 * self.v[node] + (<span class="number">1</span> - self.beta1) * gradient</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 各分量平方累积</span></span><br><span class="line">                    self.s[node] = self.beta2 * self.s[node] + (<span class="number">1</span> - self.beta2) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               self.v[node] / np.sqrt(self.s[node] + self.epsilon))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文续上半篇，实现一些常见的梯度下降优化器类。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>毕业相关事项</title>
    <link href="https://blog.slks.xyz/2022/02/26/84b3fb3c559e/"/>
    <id>https://blog.slks.xyz/2022/02/26/84b3fb3c559e/</id>
    <published>2022-02-26T15:52:19.000Z</published>
    <updated>2022-03-11T12:47:48.827Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5f2832a9d17d20fa058514dfe360c6848d2427e84c6d3c3633ffec46b45dcfec">f638d67e356a706b7b082748a96249a9c6215665973a817d195d1e1476666dda00dede9801ee74c82cd7a946d96afe739c132c3adadb052f1b3812d2e382bbb9b67d1a06443ab4b4344bdab2822da6341e5da18560a52307d2bd1f9203199afbad5f76870d7d90ee0f0f579250a59e5260dc5a69a54d8400868d9b23518d413782354b3de38bab4b3070fda0443c74e65d1fdbcd6cb6466819e1e93168ec312c4fc45b115b918b99551b1ea7fbda3ba7675bd17f0712586c6fb48ed4e4522899cf6be56698e6e1f00004f7f70c858b25a7fc069f6b29200a5de2f6af4e968f215dd55c10559179ee9b1a30a0639086c17c71ab66bcb52dbaab7ffdb0db4a0f4d87ce6f666fe844b0d79d0e6086cce4d8fa10c0ca4553fcb5a0e692dd03f89de648462e1bd956ba1cf3594d22f18f7ab30ca2e70ddb923b8c47ff1991b9dc7a622da4928712167ea7bdfffd4a3a3b6d7881816af969fe1f931207e670ceafc5094fa19d37d53928af10ba79a60e2f1f909825b2b27d67631c02abad89f95d6e5d5f62058ce0df2313939939a19fc8c1f8e04cfd3b4d162621e78202ed3a4d0a9aa47ec85024c209860a31e14cb6f381aeeb146312b7ce3f34dc65e73ecfcfc691bd2f1c8e813eacbad5bce3f67bceba55b8f2547385e9328e8ed8940118b478166d50a7ad26772190613862beafc6f28df47cd2a16ef84e28c309a5b3877b87000d80d53446cc58ce33de76b01342272398b60e5920be949aec0e359b7cee75fe804ec381aba268dbad9914313f55f0c4958349505d73c0c4524cfef4571be0d3bbc26edf818344066669e96fb9d7fc88bd57a3ace92ab8deff47ff3e1b97c8638ed459ce3cfd6f41001f206e3e138a829131ec361d90d715cbe1c7b4ed2d3bdb1b4e3062edf350bcf4bdacacaea4b7693b57be9b2fb355dbf3efb2cbc4cee80c69f90818de2c5adb41b868b1885e413694861b46236889809844971258ef964b9a9204eaaa2715ea9e59dfc02d75527ae5a8450e455c5e29a576a41f996eec58c60aaddf9b00799424aade3e2678fc24cdac0afab8e5079f49991f9731f59638d8c9c6b27d872b6012904a26f7b65618eb3edfa0bf09cb1fe0a48a7f857d26bc7bacb66db70470e407ad81abd0f98f46cd1d396f303d4b9d4ae1a1697623e9ea5be4fd695ff120fd7205d3e6beb8467eb68200d095a9c3eb24613784d4b94f8bb4816391543d9e1b551d9f4d87fff20379e8c4657b2a3af725a5c05bc9d296ce3d9293db93a1772f1b8289c3b63132694e483b529e90164171fd3f1065fd5f6fd63f5e906f4c0fb8a6c07f60e94024cdcb3fba85d00b71ecc625c873c111d652749ff9cb7050b24ab1d1b9b1a6037db5190804a4ced4e6f2df1f1f0b2a7f53f6f4365568ab7204ab023231312577b44fa05789372aec3583bd5868cc1092fb7082ce7882650af227712ae75835a13729a2fe99b2a7a1f0c5d63ffa63cbf2ea7a071317567f9a74766e930e27bcc4b62dd01a44ffdf42f6ecf60edf6269956e9ea6b7ac121dd16829b91f169935fa20a8b4e156eae8e0e41ceadbdc4396d0e069fd7aa9b58646ec9114fd4eb3eb2cf101c0b090cfa1ae1b81529658b882e65f8d08ab4c68339372320ec34ceb42e243b6500247dda22a14eb73dd54c032a3195fda6ab4f90c8382e41b2aa6d325daac9b62ed42cdc7c997312e0c76842ce02b3f4a0b026f9fed63297f05b0c91a7abff2df2aa0785a6533bde998fa03008ad2bc0cd733505ce99fcb7c2be7783fac7502a25ba5e7193dac54b76b143695634643fe7372c694c2b3b76fa0aa9b1256adaf420e9cf03891e89af3e2636bbf0aff4522c01e64936d0d9e473f102f3035cb89fa98cd880b0f404b266ef49ac2ffe83b846019eb9d2675fe90881ec4d33f0cd963c6989f8ff82481e64760c52ea84fee0f7007d47c7fb9907427736b35ecf13b61cc157b7a5591ed7fa0555639a214e19a7df206871d585987c892feb9c77dbd27fa1885706c103c5fda6796f576b41c97252a92ff78d8e2498514f6c468b99527dc6482a6a09f1a54e43a3f948ee74321317a3ea08841a8b49f8ba547c693e9c2876fd9e8bd29c037f23e0c84bd06c272e1452f92d9e9126d16667bff55dc0e4f2b2f0d83bdbd5bd34855f09bf177881d55e1c74591b8510fdad8c360ec38af037e5ebcc54f9b4545630aa0438ea671678eeb609a1f11546362233951006497d6abbe9921e4b8a55390edc2e15c03812f017d6edd0af0bf5752a62deab5b6bd6472215fdd960e07e02dbf19b5ed1e2cf7034455269300846de5d098d7b592d03659e37f03504689288620d7f4dbd8fe2876f88792ea41e5e8f98c29a527d14d6d4b3d4816ac2dcb62779febd26bf0c2ffba1314c0b4db5639f5979415eeb81647b6f575f7a9a4be691d01215133f3c5d791e25d03148e41ebfa6f9a92e26fad06fc0d7c4c7b006719edc26aed0137f2f5703d3157a8567a9d152c57c4dd7ea8132204959f2a229b9e622ac6bbb5942dc67a6e8893b7fb776bcd2a19f54ad22688e00dbbbba64e2bdc57d1213a3b15e44400280c916c79540e6e1d9af6dd9fcf94a2754767673edf83ba5fcb74d704bf954015c2c26b24c3b8c766a5e66f76b47688bfc8d84adecbeca41f41ae92496ca399033740fe753f54b8c35084815a6c07f16f61907ef5745f4a5d94ea2de53f8e364a15e6b6f36d43274ade41aa0657f5464b852c4133e67d9c73b8fe681b49fac00cfdd439366e26d31ee688fbda787b94d1f97337be345f87e563f11ffbd9f219ab1889dd8abfceef5ac897a2158cd6e65fa9738270143107d6195b33d7ca3ad530a1d05fb5b17a67cb8f62edd390e5bda8d90ece8c79dcfc85b571eeb475fdf96b601f534536d7daca9ff288c6f1d22766dd086900e01e563dc96ab764fb78687970c21cc4974c159d133d5899fd366f4ff8a00691074a4bd4c25e25905663916ef86c29079f6306bf847a67f7f5051a004f30167d50c6a3d1d94b49a26b7a3d0f7334da0079838eb79e7a5f7f416acfeda2192e43bc0e391eb7cb1a12810f5961c5020e3c18f99e18acefdbf5f5b90470226028eb831bd1739324b4dea4c84d787ac78aa0ecc071d6a77819c79990838b769427f2e401b4e688cb8eb962f53eea7e291238e6e28a81072e176de3d9eabdb0a1876613bb0a6a49d0ca6444eaa33fcda09908e9242d127cec62b64ca6ca23a906028191bfae9f0a3957c383a1a52d3d97c0ab3cea3a43e028ebea5dc474398c4e9cdcc4643dca947452d1e3a8c3ba1f1caa2f29c42a6f87da10596ffa09aea92e747ffe7d0007d034fc06cac216f0aca717949d139fe8397f29f54701a390c4e2fc564c6c1092b1b09d94367751b0800cb13c06030d77957e460da7029af2cbf22a51e29867123fd26fecbcdb48cf5eff8a32e3fd9385bc2afbf951beb9f4dacd5f1d97bb659ffe8225ff235e472a2e51ef2cafdbfba7ae921ad7a13d4af862144d31a74d58ad9b9cb98509152214d47df7180072a52441d94720f531113cbbdc068642a87f5c430d9103d1d36ab341d8cac98ff015507a232a9d63dc7175ac428baaa10b5798e0f90912bd461761c0d00614dbd2c98ed3899ec42b28962c8a30069bf100a22905156aea8940e66f963fca1ec02886da6147fdba2cfc66be484c1b486114988e8def18576bb92777d11494a9aa4ab12c26cac966750aa2e5639902667b945d509d25842cc260ee0efb5dd337292ee932c2598e25ce73f73b62f5be5200e74c347468cc7a2459de6a407f9add47f17518e2cfba3e976cc449b062aac66f2c0569cae0a1404d120ec8007e7353f592f138e8c6a3e7babb98ff73cf6c149036771c42319ab889822ef528c7944600071f13dea99f3d57df4894f27fa1882ac9f4f32950a14f0484d7470dc1bfb720cbb651fc0e51e950058effaf243b698663340c7554c14906eb10f806e7d31f8bf912ad104360fda7027a59ce9953448538bf23ebeb5536c1679b9f7f79e1e8eafc147e1231b8e14f4777f12d15c9b08683c91024ff2e01f98be0bae2c262552869ea621eae1556e499d2870a5c736364103dafdf47fc77a61f93f792389984055c0b8b5da40cf280c6cd132b88ed95955ffd8de5a705316cf2ae5ceddd8953e6df3ca009b0c5c67d0eb8311c15ce97ce02f067dc6a05444bae4d19ddbd2f93ffcb96a42e0223ffb839540b0f8f1dab8c08a47e398ef28348f21597c6a0011d71ac050e9604332125700823b950211ed0e9d28b5cebf64f7b15941e07377b04d061471918e8565dcd11b6f07a304b6860803553fe25065f21e940caf82003f1f5bcce082ffdc10bab7be503e71d832d77f31b7dc594ae1cce624cef2f3a918c017a36b2fbd74989632aa24bd4ea5e81c0fab473c28164375de5829d3a4c394a2cef1d3ce178e76b4c1aac73df5a462894a6d7582b07066c511ff5bdafe23f1f380ef8b2aed8525de165373c06a9663fe8162bf487009ec690137a9f4226db26094aaba2b39efa8a5e10987681e55190a3a61dc9e1d865ff946165f378cee366825721d9c536ed985e6ee0ff206bcbe2f23f253d94695ef8810b19b51031e06de4e6f18ae7cb82f4b7ee68e9a54c850dc706e99b51d871e89c5cb3fb6a9e9c90762f437edb11670d66ac07937f316019aed2426ea82cc73335a24c1845a9683a3f250b95f79316231370598781ee3cc5a3a10b574dd067928d89830847462b1f91020c9a3dc0d1332f49be77efcd18f14a6b5d3ee85c96c5098e33351b4af5cf8bc2ed3ee296ecf391057130b7e4b8e33213615600b3ce15b628a99535a22940fbacf4376651017abd461082f32af78baf941d5da55d30d403cd4bd3464550e81f3b2245e404e3aca506adce3205d97aab271c992594e76e55aedd69bd2cfbd2d646fc7d2ab0e585ab06335962c7bc4967064b62ef4747ea477189b931824c18920a6e456e1af5e4bd3fe15f678ee03934f4315ae1b7e576fcd3d7275b2207644abd59a173f4dd66d68def20257578820c2d446661cffa0104c9acda08d36f0e2aa8fee67c20854cda102e9b63667104286e11278a8a340264342a51030f89cc047f586b2dbffcd29ac2f8912282d022b35c20723b0ae7ab18278305ece8e6ed7784859b6100743f6c3874a6813ea9d2ad507e9811ae780c3acfe1531c7be180bce82b1d777d9b060e6d41fa8c3e76e43862c77a630dd7f55bd4f7a3cce71da38a4bb673b88335ef5724d8cd59bf414df7cc5697426fed0d38cee91243a0571a74a22b9f8fe77079ee415ed17f82ea78a746978eb57d5ac5b01ee1556172fee235f4704ab4006a0caf56750d3fd72d0f4fdd30d266d92f1efe5b8c8d74b81197dd7091b900c0ac700f1fc4462eb5890e4a31d1d6003d2251153420019323660a71890f6e5285588f704a4d175be012a8f706ae42ad3b4a8f2ca4b8b128e4240393012564a6a06fd3f6ffc7470d485dcc8a99fb92186fdc8f7baec952cff401e48b449824193c73114753db2134cda83e5052af80308daae1407b448a5d1d300c417e09e4bf079a3524351b1dcd99b9b768d4eb3a19225056cb5e89c8cb258a1b40dcb032dcc1711d979ee7bd5fb9fac8c82574f57d10e7ae8648b06930714aeeb0fe29f5db88e8e39e51e8a8e892cea84c5049a137406965fac7b222fdbde7bb9c12b835ff4fb587d3370b9a6eb988ca04c8d82abf1d86ab35a571c318a284cb0f3a8817fc881686b1b9e5fa574e69d55ca271ad6f3308a0ac47a6f62dedf9cf6efa3bf081a3e384f48eb95c6a30c818df4a3dd2b698345323ef2d114b960f7b32168222589634567fa31a0dc1e08066047c2cd0d64c4fb70166c922a64d24a816075f0cec7eadf7dcd6bfee67b767c14aa53b569d35f00bbbbb7f92295c4e6ed3f790d2ee7865b7b33ba65fbb1b82e673f1016bba5982bef4cdcc5e109a4a7b5f9169c4b86d140d2b3c79f5529c3eccfb70dc60899bc612db8decc0ea4783dd839faddd0baa05781466ed168c8f1f7e582b24031a6991829d990c828413b8771033e3305489f06ec5a8a25c40c563be5a128467e204a186742713274f42d9d4c0523bdc26f30a1fb6f021bb70a833370f11b93c248270071409d3efa8bc83ad10b40d4b17404f96124f3ded698f9c3c65dc88045caddc063b195d10db10a3dfac1d1b2960ae35d602c2e454ceee12a658f4497bad153c2465031fc546de7bf0ae90e7457f7ce7f69642839e80a5ec8cdc2710f6141cfe6fce21fd28efc3fe15c0d0d8c5666af571c776ee5a1a18dfead4cac7cf3b549bc8fc3913ac87b2c96817e52f307be4017f79663108627368df7e8270f94238abd778a57e98a758a5697a14daa4f1ff5915ba9d6f3e3255c8dab29ad87037d0013b1e255dc86bf524ffc0dcd6845242dbd01bdbb9fef1ca1c7f077ab771f5a0acf44751d1995d6b1f590ab6067cf87af61136109002f9d1dab7fc23bab7782db96b07ffc798aa53097b5af9fc26de3ca80e08a06557539006d1da6dd2c88a5fa78d4b8a43d3213e6bca3f06ab31ba17edb0ca866bbdd7bb9cdeacf6d0fdfd5f09559df602443639d6da1eade2752f416f637b15a842786a734dacf6d26257c9f2996ddb24f62c1d3457de0ff5e2861f1f110069140a413dbaf4d4a95d7d3655ab8062c177e5f36478d6d9bf9655bb579d999304080f1d2190dfb21eb89ab79c68156f6fc694114a8229f7b40d06e70b41b3d20a308adf39666d507ba722e5a44e30a2a80c64c9ad620d1b82731ecbaf87f839fb5480d3297cb1c02a8614acb50c56faf3e15a033a0db9adf6ab44da455c3b5751401beef4a2045aee8c34b80f10e6f7438854b1b51d7bdfff7f9eaa25a9d345d7689dea4aa6c0eff8b55724bdb32c124d14a3400070f2db79ae4325acdb233a22a5e65991a3b479691300fd0f4d53133defbb41252ca22cb4b3efd37cbaa74d611f4fb24f464f80f81607715292e9afa6662d7409a987388d66ac99260c54d5dafc0dc5e96bf190e4e22240c3ef6f48895c3c918fb74d069835ba2a3397401eb105c957dc9ab5adbfa107d806bc04059441f759b2fce61a9e19f885b216066b2b14e82407810e5c2a81b61f377c232200799df4baa81af0317a360afa08f055c39cfe6b4aece0867d02cd2deac8e475ff15805b846ceaaf5ab2d67c50ff086be37d15dfb1347ce1ef4fdf53a6fa733a0108cfb342ff27e37c529d69a32fd3c39561234c0b6ecea95c2b5b47c8d34eaa7c4affaaf3219971d651380d1fb5b9939444bab86290c198cecd7ff32c420549147715386730e042446c4e0af1353d88831e67d52186507538210e3209772e48cec5158a4dc709386cf84a815ed65d9a9541c632ae9363b560b12cf1c984a3c68b544f5cf113dc9f5f617f0e43c8c200ee4d2122702ffe220133f7f534475ec84fcea421e3a93a363fb98c7ec65aad920da8dd7b551958c3b94d3df26bfdfa45a644399892fa50580c335ac0aa9a437ef4292ba3f74603439d55e0e3c73e4f8d07527272fe262fc3992fa25afad8c7f3aab2ab0392b27042405466bb93dfd4c9760851067f2ea7476ea4d3a3f494c5941bed0ac33cb62d7f331a2010e7b9d9ac7c71929d3bcc21a4a639ecc1d3cc0ba90e9f2ab68f2a365a179eeea0ec32085d96daa7c2b7b6ef519f275fb855d2d8c8089489abbb4c8998a4b59949ea4cddbcf507f5e59b851062ee589b4d2f56fe2ac1d8c048a6056f1d78a1f68038bc62e5b841b0f641fd440d4b1c9525cc3189104c011998b242cb6c4733672aaf2470da98847df09382a10a35827c345eb13182f6c1318ee28e40f61098d9d820e8f3775aa76fe9e3d847c739b712021d29051ff9bd6a0fac0e4bf00ae49d7b12c25776373d32303d3176e8f8c5beba28cb534302d73bc47f0cc89011b99d34f1b3ee37d450ca867e8b9f1acaae006b794fab18417dff1bf9f3151d50bacc52f375d3c2c0c9138aeec798b8e15e5beeab6bbc0441db94fc99eb8a390c6eb1a4bbabde29efd4c6222795308e737253e04650a7ac98145c8abf8226174474e87bbe8684f53a3e06bbb0dec52d6f3b6e11892f3e35394bb41ab6512ab5c53a620d8ed80e8c8c49abf9dccec239e36d811a5ce392010e60267bf2f0a360688cc3ce027a4fd9e7c3a6d09182a14b449e753ce64bccc4f56654a6baa324cab4bb35be719f4395f00616d1da9e77f77bfd1cec257a5c1d4fd3a727feb686dd911fee4aad98df2afd3f5fa688b51fb47a6e1afab089a9faa2556f57c132af5a0532ac5252ef1f4bf4eceaa2b6a47118e78a2190f5cc5015dd3612177e3a48c67cc5937dddf148c68dffafed2d2a4e7e189d085ac949859a50801759123bc9cd7cff17d269ccbde96aed8a3aa372f05d8e5beb8e3c607f650106d59b567a6f22b6e0fb8c83c0991217a1ead21bdb758695d4478f72f2b5d7c31a788266c65606f3ca552ef7cb45f7cf166005100efcb6dbe514ef23af96f01372df9240ebf920185a762886188a267a20f0f3bffea1dd5a5a4be2bcfae5f9f977facb27dd71e784a19e20d1142fafa22eaeee89e0580b86c946e16c9fee077073276bd7f79f0ef0b083b604083ef1d7766989760e67d99bc4df4c7ad2c378b9175938f397e331284791d17c1e3f22f34eacfd75d07e7821165b17be9d73fb97fc0285e02162d0a13cf0d7d5cb9872b4ef360a385f3766375f77702b6aa16ad90f9d738424cf967eea8c448ea15ae1519a83c3801edc45121179a81fcfde098005b7c270373542b02fe6118cadfe646481cd6ee343f4a8110645f5804185033e5b38048c5bb295b0d5e9cd365dcd1522ccdbb867ad5a4cf4abaf40b0c0de13e9de6c15ba8ed05f7fe1fe0b4895237e3732ad5e71998d240dd4629c6b8666372ea00c6401b10cf2c9518b49ad7b9c4c956df69350732f13f3038cc730d59f57897431827a1a6c65ad1e5657ca48171f8729a83059337068ea2baf0b1f6749cf4f2ccc0cb39f0eadac38153aa2ce921c78926380483902bee66386cd79478e6cc16ae8d65f548a543ad058b0f71978b9a9f021f9ca6cffe9e271b72f3ebc25b4b4bafcc58140748e31e7423023453d25ce7471b82a3cb9a09fe6870da78e34033f4ea9e250d45269d745f3d1d42279c5efe4ac8a0bcfbaf33a8a8e6d69c8919bab0714a45102099b279bceb1e2a1c24cae631563163725b9e54b608c981d42b4c5f4fe253d944cc7a03fa7792eb58ff17ed7a1905ea99b8d3e4a99686bb8ad2e988d2a5647e1f16307fe8651c3b0a485d70614eff2524136baa27c8fa02e0761c3b48da9f668b0ac1c8feb267b1382676996e7ff9eb6cc75dacd6fcb15d63889f3421481d0b52cf60bce76fd24eeae2a15c9e3390ea5deb67c86021164eefe8ae02d9802985933e3f6bbe25a9a6f57cb1f8c2445cb3ecca91ad446a26cbae57e760033ae7329399fbc681a811718d6a35de56af1f8b982b56294a18ec5a7e1b8cf6d75dc9f31d73bf8673ffb5d965374b4ca9198674ac89ed5aceeb3af0b79f52a1093761152f1909e2b6d20b18de6ab98e6aa4b54ac309d09bacd48601c22fdee1b0161079c193dd8d3c80098522b15c3292d45e636b91859e045e1d0fc9202788acd3a384953660d26b74f1763871a1c34100c7b7b106c09b6ab73cd22725f8087fd19ebc50834e9be6404f3c352b9c1cc77ea98183afd984953abc916705ed04ac52c6bac594b7daa269b3cea34099772fbf30d27b490b23795ce4dad46b86524044da88111426b6f0fd002875fbc42dea2f14bb477c52b6b4e53d9d2508058c9f26f15cad7f1efe1b399fbcdab1a19f3c6d39dc3b5f3c54b2e49e5d5bacc9e58cb86c51e2b74f65e0579d1a22c19403d754c5cf4eb2f6b9f870ba0018a89773c5a798dec5accb37d1d95e26674b51bdab32effa33c14bb94c7df4227f0b10f96a104b3a271af881281f32b64d0108028db98433b74dc86c23e0bc6ebf9b594668eb239e0823be3d966df937d700313d38d68cfc09db243d24d01b5115952cff2c904013285d1eaa93498f65cd25823bac3690ea1613e1b79918f6550cb9f779475815b203a1c6c0aec7389848883df5080442094090812526d5cc5cc9526b57c4d6c05c35f49ea8ed31b1eab13632b53e7fd1ae6486cccfd0f12a29c0cd12d26f371074c6212346c0d3496e17f43cef28c471f27efda27885cd5fa987948a77589844990175491d745b49b857c8284c62b9de5a89da372a101cf59b1de135c0fc0595b49eec50a1d83e44ccb8c3d99acf07fd41476916ef18f32b84551947a9d19269f864d4dd5192fc3525b88529be9a6f097f8e1625ba7e7a63a2f7eb1f567ca5bc62484717f87e0670b9cdd50a6dc6daf0acfbad251e751d6d9594f488541d4e3df05d0de1ad8bc32a21c704bd2de53f20f3f51df46d67641e139fefa1ecb10bf39fe64331152816b8ad6261f12afb872d6ceb5768b52fa235a71fccd73c3500c50c171407406702743ff8d231d6406d70836813c42c4fcee5703bcfd25fff475a8f648cf87a31031e04e656d1c2b9349d780e5ef17d1d354d9399f2f669fc25cd0d49c02376d6ff39314e254af26816f8c3b458499b577df2d941be0e11ad80d0ee2122588ecd71663c4ac26fcf0cb0944e9790b785d015686481e79a17dbfa9b6819fd0e13aca6f98be25c2544294b69d3d895e5b3ad436c51d896091d43b62b5df9de2d78c4c9e7ce780e74a5c222863ed67ebe99f76936950e3105b48620bebef1ba4c63b3b42df090873cc2e209a4e58ecc28df72ecf6c515598fab7a41a01678f6e1b9813f6a992bd7955aa954de54c0e080d66b454727d685ff44e6414cd50cd30b0b79a8104588c3f84100c765cd9783daa987d6ed2ee2f612ccf70bc76a151eb5fbd1cca51de262a790f2df71a8e160bbdaa7bf6d865c2d70d9e9eac47961a6bf9a2a12bd1f9e64fe9499de5069880b38c9ef9b49a67100123616eed81c1d66f4f0770a2d83220f1e815199e66bdf58555d52afd67a4d9d385412c4e685cd6629d2a9db947072b7712cd86fb84b944a27270d46efd74f099f4e689742dd09c04f2457791ac13bd6326263d20700f66cb7198347360cca1917dcf60b13ec63fe2aefd3999581dcfdca8dbd050967de6caa2a43bd300f99357ed9b01d80d22bdb7a26fe775c300c9fc7239fa8eb3f38fcb3ee67eeb16ac55a5d49ae7034ec55d32ea7165cab9688c91c28864e6d30c67dad0f5d95ed12c74a453176025a0e0b812ad3456102b5bce998066d47f599443ed0c57ac5b5ba9d7758ee3d7703fd833d7987f376ba7f23454dd4a0b7fb6c197a1b3786631f4b928c9b8327a60faefed546c05aab6fb42385e52b3edd579b555d2ae500198ba726c241b8e0b66898c188f9054bbcdec5e613c30228c72784b6ff62b3d976c308ebf3c063ea3dafb8a3623e341a8f2fefe395fd64c26f7a5905555db41ff050552ef0760c8c77238a8aa952a0bb8a623d1972fd0fb3b87fc5ccd10f6f70ae69ffe2e4421502882fc037ec0d54c000ae715418672392a5e32d0d95e5cc991682227525ce8cdfcdc9681d8c3f5e9200d5abda60579a7313fd6394ed1437700a95b9d88c36e4f873f3392f231bb8580bf139cb2f27dfba58b60079fa84f7d58b88a411f7b7b8c8dbc62092a4732c2f833ded758178f4fc7fad13a8056d6a9121086156d17ce51da1bd713ea94670063c413558a5c0467e1a072c473a29669fc76d7bd5f6324331542c58b059c9cc1074ba6c618394bb55a74e2f2cdc80dca372e4f911998b01234ac2d2626aff8fbf66c3a28f5aabcfa914e29b3da1c98f5115a735fa4b093d68df20bfae5cd20b4ab2ede0f828d92067f1adf5a4e36f085d24f25096f6a884a46fecad879517260b26eabb5803a2977b8f0ef6439984192700b69bc549ebfca15ff35142e54ed253ff7e5189a89bf33de28ddb95a40cbf8e89fbfaae18c11b5e10fa4a9b252df66d1a3fe4a41b14a61473dfb70ed6ab7367c383a33f81e35b40e2b3c4cc9ec45bb18bbf2f27073261de7c2c1a408eec6fb836646f9e7cebbed3acb38c9c5cee03dda20e1598a53a9f5d250d67845064e4fdd73e2d4675f9101651c171ee4708d3a9f7b023ae0a6a59606ba59ac95680988ce41179bbeab</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">年级大会，毕业相关事项</summary>
    
    
    
    <category term="⓽ 其他内容" scheme="https://blog.slks.xyz/categories/%E2%93%BD-%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS系列——DFS多种形式变体整理</title>
    <link href="https://blog.slks.xyz/2022/02/26/3e00524469fb/"/>
    <id>https://blog.slks.xyz/2022/02/26/3e00524469fb/</id>
    <published>2022-02-26T03:06:19.000Z</published>
    <updated>2022-02-26T02:48:09.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-080.-含有-k-个元素的组合"><a href="https://leetcode-cn.com/problems/uUsW3B/">剑指 Offer II 080. 含有 k 个元素的组合</a></h4><p>​ 给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="解题思路">解题思路：</h5><p>​ 该题是最经典的无限制的DFS，注意剪枝来降低整体的时间复杂度。</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">permute</span>(tmp,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> curr,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//curr代表当前 轮到的数字</span></span><br><span class="line">        <span class="comment">//count代表当前已经 放入集合中的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(curr == n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                <span class="comment">//这轮完结了，将tmp添加进入curr中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历两种情况 ： 要不要这个数字</span></span><br><span class="line">        <span class="comment">//Case1: 要这个数字</span></span><br><span class="line">        tmp.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case2: 不要这个数字</span></span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-081.-允许重复选择元素的组合"><a href="https://leetcode-cn.com/problems/Ygoe9J/">剑指 Offer II 081. 允许重复选择元素的组合</a></h4><p>​ 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>​ candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。</p><p>​ 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-1">解题思路：</h5><p>​ 相比于上一题而言，该题允许重复选择元素，大致框架类似，但是在DFS的过程中，分支的选项需要改变，同样也是选择当前元素和不选择当前元素两条分支，之前无论选不选当前元素，下一轮递归的时候都会去判断下一个元素，而在本题中，如果选择当前元素，那么下一轮递归还应该是本元素。</p><h5 id="解题代码-1">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">        <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-082.-含有重复元素集合的组合"><a href="https://leetcode-cn.com/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合</a></h4><p>​ 给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>​ candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">    [1,1,6],</span><br><span class="line">    [1,2,5],</span><br><span class="line">    [1,7],</span><br><span class="line">    [2,6]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解题思路-2">解题思路：</h5><p>​ 本题跟上题不一样的点在于：本题每个元素都只能使用一次，但是可选的元素数组中会出现重复的元素，这也就意味着如果按照正常的DFS下来，是会出现重复的组合的。此处，我们按照如下思想来处理：</p><p>​ 我们先将它提供的整数数组进行排序，使其成为有序的数组。</p><p>​ 每一轮DFS的时候，记录上一轮有没有选择元素</p><ul><li><p>如果上一轮没有选择元素，并且当前元素和上一轮元素一样：那么该轮也只能选择 “不选择当前元素”，原因是如果两轮元素一致，"上一轮没选这一轮选了"，那么势必会和 "上一轮选了，这一轮不选"，这种情况产生重复。</p></li><li><p>如果上一轮选择了元素，那么该轮就可以正常操作：可以选择当前元素，也可以不选择当前元素。</p></li></ul><h5 id="解题代码-2">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr,<span class="keyword">bool</span> choose)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= <span class="number">1</span> &amp;&amp; candidates[curr] == candidates[curr<span class="number">-1</span>] &amp;&amp; !choose)&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-083.-没有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/VvJkup/">剑指 Offer II 083. 没有重复元素集合的全排列</a></h4><p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同</code></pre><h5 id="解题思路-3">解题思路：</h5><p>​ 本题跟直接求1-n这n个数的全排列是一样的思想，基本就是每一轮确定第curr个数是什么，如果<code>curr==nums.size()</code>就输出该种可能。并且我们需要一个<code>hasInclude[]</code>数组记录，某个数有没有被访问过。</p><h5 id="解题代码-3">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-084.-含有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/7p8L0Z/">剑指 Offer II 084. 含有重复元素集合的全排列</a></h4><p>给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-4">解题思路：</h5><p>​ 084这题相对于083而言，就像是082相对于081而言，多了一个重复元素。我们就需要排除重复的信息。一种朴素的想法是，用hash表记录每一个全排列的情况，然后每产生一个全排列就去Hash表里找有没有一样的，这是一种方法，但时间复杂度肯定较高。</p><p>​ 比较优化的方法思想其实和082相似，也是需要先对数组进行排序，得到有序的nums.</p><p>​ 我们在DFS的时候，如果当前元素和前面元素一样，并且前面的元素还没有被选择，那么该元素也不在本轮被选择。原因也和082一致，如果前面的元素没被选，而当前元素被选了，势必会和正常流程中，"前面元素选了，当前元素未选"的排列造成重复。所以只有当前面的元素已经被使用了，确定好位置了，后面的相同的元素才有机会被使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !hasInclude[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">//前面元素和当前一样，并且前面的元素还没用掉，直接不选跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-085.-生成匹配的括号"><a href="https://leetcode-cn.com/problems/IDBivT/">剑指 Offer II 085. 生成匹配的括号</a></h4><p>正整数 <code>n</code> 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><h5 id="解题思路-5">解题思路：</h5><p>​ 这是一道比较有趣的DFS的题目，DFS分支的条件比较难想，整体代码较为简单。</p><p>​ 要想清楚，为什么此处我仅用两个Case就可以完成DFS分支的遍历，在最终输出的时候又做了哪些操作。</p><h5 id="解题代码-4">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,n,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left_curr,<span class="keyword">int</span> right_curr,<span class="keyword">int</span> n,string tmp,vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left_curr当前加到第几个（了，right_curr 代表已经加了几个 ）</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right_curr;i&lt;n;i++)&#123;</span><br><span class="line">                tmp += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 仅加左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr &lt; n) <span class="built_in">dfs</span>(left_curr+<span class="number">1</span>,right_curr,n,tmp+<span class="string">&quot;(&quot;</span>,res);</span><br><span class="line">        <span class="comment">//Case2: 加一对右括号</span></span><br><span class="line">        <span class="keyword">if</span>(right_curr &lt; left_curr &amp;&amp; right_curr &lt; n) <span class="built_in">dfs</span>(left_curr,right_curr+<span class="number">1</span>,n,tmp+<span class="string">&quot;)&quot;</span>,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含几道经典DFS类型的题目，难度都不是很高，可以用于练手</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="DFS" scheme="https://blog.slks.xyz/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图系列——重建序列</title>
    <link href="https://blog.slks.xyz/2022/02/26/16bfad4011e0/"/>
    <id>https://blog.slks.xyz/2022/02/26/16bfad4011e0/</id>
    <published>2022-02-26T02:50:19.000Z</published>
    <updated>2022-02-26T02:57:50.418Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode-cn.com/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h4><p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p><p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 10^4。重建 是指在序列集 seqs 中构建最短的公共超序列，即 seqs 中的任意序列都是该最短序列的子序列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3]]</span><br><span class="line">输出: false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= n &lt;= 10^4org 是数字 1 到 n 的一个排列1 &lt;= segs[i].length &lt;= 10^5seqs[i][j] 是 32 位有符号整数</code></pre><h5 id="解题思路">解题思路：</h5><p>​ 本题与<a href="https://blog.slks.xyz/2022/02/25/4e6244e39183/">[外星文字典](https://blog.slks.xyz/2022/02/25/4e6244e39183/)</a> 相似，都是通过序列seqs获取拓扑排序信息，然后依据拓扑排序，观察是否与org一致，从而达到题目要求目的。具体可以参照官方思路，本题因为已经过了一刷测试点，仅在此记录</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; org, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 边集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 记录seqs中的结点，可能有不在org里的这时候就要停了返回false</span></span><br><span class="line">        <span class="comment">// org 是一定是数字 1 到 n 的一个排列， 但seqs很自由</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>; </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 不再org范围了</span></span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">0</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 记录出现结点数</span></span><br><span class="line">                <span class="keyword">if</span> (++nodes[seq[i]] == <span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                edges[seq[i - <span class="number">1</span>]].<span class="built_in">push_back</span>(seq[i]);</span><br><span class="line">                inDegree[seq[i]]++;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结点数不同</span></span><br><span class="line">        <span class="keyword">if</span> (cnt != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 用队列和栈都可</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 队列中有2个以上结点，就有2种以上可能不唯一了</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (org[index] != node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            index++;   </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edges[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[edges[node][i - <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(edges[node][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，图的综合应用。一刷已过所有点，只是题目比较经典且综合，里面也有一些较坑的测试点，值得二刷，故在此记录</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="topological sort" scheme="https://blog.slks.xyz/tags/topological-sort/"/>
    
  </entry>
  
</feed>
