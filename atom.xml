<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-01-30T11:33:09.251Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java系列笔记6——java注解（更新中）</title>
    <link href="https://blog.slks.xyz/2022/01/31/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B06%E2%80%94java%E6%B3%A8%E8%A7%A3/"/>
    <id>https://blog.slks.xyz/2022/01/31/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B06%E2%80%94java%E6%B3%A8%E8%A7%A3/</id>
    <published>2022-01-31T10:30:19.000Z</published>
    <updated>2022-01-30T11:33:09.251Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1264799402020448</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于java注解相关的使用、定义、处理注解。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
    <category term="annotation" scheme="https://blog.slks.xyz/tags/annotation/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记5——java反射机制（更新中）</title>
    <link href="https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05%E2%80%94java%E5%8F%8D%E5%B0%84/"/>
    <id>https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05%E2%80%94java%E5%8F%8D%E5%B0%84/</id>
    <published>2022-01-30T10:30:19.000Z</published>
    <updated>2022-01-30T11:36:23.523Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945147512512</p><h4 id="一反射简介">一、反射简介</h4><p>Java的反射是指程序在运行期可以拿到一个对象的所有信息。</p><p>​ 反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。正常情况下，如果我们要调用一个对象的方法，或者访问一个对象的字段，通常会传入对象实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Main.java</span></span><br><span class="line"><span class="keyword">import</span> com.itranswarp.learnjava.Person;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">getFullName</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，如果不能获得<code>Person</code>类，只有一个<code>Object</code>实例，比如这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ???</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>怎么办？有童鞋会说：强制转型啊！</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">String <span class="title">getFullName</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">    Person p = (Person) obj;</span><br><span class="line">    <span class="keyword">return</span> p.getFirstName() + <span class="string">&quot; &quot;</span> + p.getLastName();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 强制转型的时候，你会发现一个问题：编译上面的代码，仍然需要引用<code>Person</code>类。不然，去掉<code>import</code>语句，你看能不能编译通过？</p><p>​ <strong>所以，反射是为了解决在运行期，对某个实例一无所知的情况下，如何调用其方法。</strong></p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于java反射机制相关的Class类、访问字段、调用方法、调用构造方法、获取继承关系、动态代理等内容</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
    <category term="reflection" scheme="https://blog.slks.xyz/tags/reflection/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记4——java异常处理</title>
    <link href="https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04%E2%80%94java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <id>https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04%E2%80%94java%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</id>
    <published>2022-01-30T09:30:19.000Z</published>
    <updated>2022-01-30T11:36:27.162Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1264734349295520</p><h3 id="一java异常简介">一、Java异常简介：</h3><h4 id="异常介绍与分类">1、异常介绍与分类</h4><p>所以，一个健壮的程序必须处理各种各样的错误。</p><p>调用方如何获知调用失败的信息？有两种方法：</p><ul><li>方法1：约定返回错误码，常见于C</li><li>方法2：在语言层面上提供异常处理机制：（较为常用）</li></ul><p><strong>异常是一种<code>class</code>，因此它本身带有类型信息。异常可以在任何地方抛出，但只需要在上层捕获，这样就和方法调用分离了</strong></p><p>Java的异常是<code>class</code>，它的继承关系如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">                     ┌───────────┐</span><br><span class="line">                     │  Object   │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                           │</span><br><span class="line">                     ┌───────────┐</span><br><span class="line">                     │ Throwable │</span><br><span class="line">                     └───────────┘</span><br><span class="line">                           ▲</span><br><span class="line">                 ┌─────────┴─────────┐</span><br><span class="line">                 │                   │</span><br><span class="line">           ┌───────────┐       ┌───────────┐</span><br><span class="line">           │   Error   │       │ Exception │</span><br><span class="line">           └───────────┘       └───────────┘</span><br><span class="line">                 ▲                   ▲</span><br><span class="line">         ┌───────┘              ┌────┴──────────┐</span><br><span class="line">         │                      │               │</span><br><span class="line">┌─────────────────┐    ┌─────────────────┐┌───────────┐</span><br><span class="line">│OutOfMemoryError │... │RuntimeException ││IOException│...</span><br><span class="line">└─────────────────┘    └─────────────────┘└───────────┘</span><br><span class="line">                                ▲</span><br><span class="line">                    ┌───────────┴─────────────┐</span><br><span class="line">                    │                         │</span><br><span class="line">         ┌─────────────────────┐ ┌─────────────────────────┐</span><br><span class="line">         │NullPointerException │ │IllegalArgumentException │...</span><br><span class="line">         └─────────────────────┘ └─────────────────────────┘</span><br></pre></td></tr></table></figure><p>从上图继承关系可知：<code>Throwable</code>是异常体系的根，它继承自<code>Object</code>。<code>Throwable</code>有两个体系：<code>Error</code>和<code>Exception</code>，<code>Error</code>表示严重的错误，程序对此一般无能为力，例如：</p><ul><li><code>OutOfMemoryError</code>：内存耗尽</li><li><code>NoClassDefFoundError</code>：无法加载某个Class</li><li><code>StackOverflowError</code>：栈溢出</li></ul><p>而<code>Exception</code>则是运行时的错误，它可以被捕获并处理。</p><ul><li><p>某些异常是应用程序逻辑处理的一部分，应该捕获并处理。例如：</p><ul><li><p><code>NumberFormatException</code>：数值类型的格式错误</p></li><li><p><code>FileNotFoundException</code>：未找到文件</p></li><li><p><code>SocketException</code>：读取网络失败</p></li></ul></li><li><p>还有一些异常是程序逻辑编写不对造成的，应该修复程序本身。例如：</p><ul><li><p><code>NullPointerException</code>：对某个<code>null</code>的对象调用方法或字段</p></li><li><p><code>IndexOutOfBoundsException</code>：数组索引越界</p></li></ul></li></ul><p><code>Exception</code>又分为两大类：</p><ol type="1"><li><code>RuntimeException</code>以及它的子类；</li><li>非<code>RuntimeException</code>（包括<code>IOException</code>、<code>ReflectiveOperationException</code>等等）</li></ol><p><strong>Java规定</strong>：</p><ul><li>必须捕获的异常，包括<code>Exception</code>及其子类，但不包括<code>RuntimeException</code>及其子类，这种类型的异常称为<strong>Checked Exception</strong>。</li><li>不需要捕获的异常，包括<code>Error</code>及其子类，<code>RuntimeException</code>及其子类。</li></ul><h3 id="二捕获异常">二、捕获异常：</h3><h4 id="普通的捕获异常">1、普通的捕获异常：</h4><p>​ 捕获异常使用<code>try...catch</code>语句，把可能发生异常的代码放到<code>try &#123;...&#125;</code>中，然后使用<code>catch</code>捕获对应的<code>Exception</code>及其子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.UnsupportedEncodingException;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] bs = toGBK(<span class="string">&quot;中文&quot;</span>);</span><br><span class="line">        System.out.println(Arrays.toString(bs));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">byte</span>[] toGBK(String s) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 用指定编码转换String为byte[]:</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(<span class="string">&quot;GBK&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            <span class="comment">// 如果系统不支持GBK编码，会捕获到UnsupportedEncodingException:</span></span><br><span class="line">            System.out.println(e); <span class="comment">// 打印异常信息</span></span><br><span class="line">            <span class="keyword">return</span> s.getBytes(); <span class="comment">// 尝试使用用默认编码</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 如果我们不捕获<code>UnsupportedEncodingException</code>，会出现编译失败的问题：编译器会报错，错误信息类似：unreported exception UnsupportedEncodingException; must be caught or declared to be thrown，并且准确地指出需要捕获的语句是<code>return s.getBytes("GBK");</code>。意思是说，像<code>UnsupportedEncodingException</code>这样的Checked Exception，必须被捕获。</p><p>​ <strong>这是因为<code>String.getBytes(String)</code>方法定义是：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">byte</span>[] getBytes(String charsetName) <span class="keyword">throws</span> UnsupportedEncodingException &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>在方法定义的时候，使用<code>throws Xxx</code>表示该方法可能抛出的异常类型</strong>。调用方在调用的时候，必须强制捕获这些异常，否则编译器会报错。</p><p>​ <strong>注意</strong>：只要是方法声明的Checked Exception，不在调用层捕获，也必须在更高的调用层捕获。所有未捕获的异常，最终也必须在<code>main()</code>方法中捕获，不会出现漏写<code>try</code>的情况。这是由编译器保证的。<code>main()</code>方法也是最后捕获<code>Exception</code>的机会。</p><p>​ <strong>注意</strong>：所有异常都可以调用<code>printStackTrace()</code>方法打印异常栈，这是一个简单有用的快速打印异常的方法。</p><h4 id="多个catch语句">2、多个catch语句：</h4><p>​ 可以使用多个<code>catch</code>语句，每个<code>catch</code>分别捕获对应的<code>Exception</code>及其子类。JVM在捕获到异常后，会从上到下匹配<code>catch</code>语句，匹配到某个<code>catch</code>后，执行<code>catch</code>代码块，然后不再继续匹配。</p><p>​ <strong>存在多个<code>catch</code>的时候，<code>catch</code>的顺序非常重要：</strong>子类必须写在前面。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123; <span class="comment">// 永远捕获不到</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>对于上面的代码，<code>UnsupportedEncodingException</code>异常是永远捕获不到的</strong>，因为它是<code>IOException</code>的子类。当抛出<code>UnsupportedEncodingException</code>异常时，会被<code>catch (IOException e) &#123; ... &#125;</code>捕获并执行。</p><h4 id="finally语句">3、finally语句：</h4><p>无论是否有异常发生，如果我们都希望执行一些语句</p><p>Java的<code>try ... catch</code>机制还提供了<code>finally</code>语句，<code>finally</code>语句块保证有无错误都会执行。上述代码可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Bad encoding&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;IO error&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;END&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意<code>finally</code>有几个特点：</p><ol type="1"><li><code>finally</code>语句不是必须的，可写可不写；</li><li><code>finally</code>总是最后执行。</li></ol><p>​ 如果没有发生异常，就正常执行<code>try &#123; ... &#125;</code>语句块，然后执行<code>finally</code>。如果发生了异常，就中断执行<code>try &#123; ... &#125;</code>语句块，然后跳转执行匹配的<code>catch</code>语句块，最后执行<code>finally</code>。</p><h4 id="捕获多种异常">4、捕获多种异常：</h4><p>可以把两个处理逻辑一样的异常用<code>|</code>合并到一起</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process1();</span><br><span class="line">        process2();</span><br><span class="line">        process3();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | NumberFormatException e) &#123; <span class="comment">// IOException或NumberFormatException</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Bad input&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Unknown error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三抛出异常">三、抛出异常：</h3><h4 id="抛出异常链条">1、抛出异常链条：</h4><p>​ 当某个方法抛出了异常时，如果当前方法没有捕获异常，异常就会被抛到上层调用方法，直到遇到某个<code>try ... catch</code>被捕获为止</p><p>​ 通过<code>printStackTrace()</code>可以打印出方法的调用栈，类似：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.NumberFormatException: <span class="keyword">null</span></span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">614</span>)</span><br><span class="line">    at java.base/java.lang.Integer.parseInt(Integer.java:<span class="number">770</span>)</span><br><span class="line">    at Main.process2(Main.java:<span class="number">16</span>)</span><br><span class="line">    at Main.process1(Main.java:<span class="number">12</span>)</span><br><span class="line">    at Main.main(Main.java:<span class="number">5</span>)</span><br></pre></td></tr></table></figure><p><code>printStackTrace()</code>对于调试错误非常有用，上述信息表示：<code>NumberFormatException</code>是在<code>java.lang.Integer.parseInt</code>方法中被抛出的，从下往上看，调用层次依次是：</p><ol type="1"><li><code>main()</code>调用<code>process1()</code>；</li><li><code>process1()</code>调用<code>process2()</code>；</li><li><code>process2()</code>调用<code>Integer.parseInt(String)</code>；</li><li><code>Integer.parseInt(String)</code>调用<code>Integer.parseInt(String, int)</code>。</li></ol><h4 id="如何抛出异常">2、如何抛出异常：</h4><p>抛出异常分两步：</p><ol type="1"><li>创建某个<code>Exception</code>的实例；</li><li>用<code>throw</code>语句抛出。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        NullPointerException e = <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或写成一行：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="异常捕获后再次抛出">3、异常捕获后再次抛出：</h4><p>​ 如果一个方法捕获了某个异常后，又在<code>catch</code>子句中抛出新的异常，就相当于把抛出的异常类型“转换”了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process1</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        process2();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">process2</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (s==<span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>打印出的异常栈类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>​ 这说明<strong>新的异常丢失了原始异常信息</strong>，我们已经看不到原始异常<code>NullPointerException</code>的信息了。</p><p>​ <strong>为了能追踪到完整的异常栈，在构造异常的时候，把原始的<code>Exception</code>实例传进去，新的<code>Exception</code>就可以持有原始<code>Exception</code>信息。</strong>对上述代码改进如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process1();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            process2();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NullPointerException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，打印出的异常栈类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">java.lang.IllegalArgumentException: java.lang.NullPointerException</span><br><span class="line">    at Main.process1(Main.java:15)</span><br><span class="line">    at Main.main(Main.java:5)</span><br><span class="line">Caused by: java.lang.NullPointerException</span><br><span class="line">    at Main.process2(Main.java:20)</span><br><span class="line">    at Main.process1(Main.java:13)</span><br></pre></td></tr></table></figure><p>​ 注意到<code>Caused by: Xxx</code>，说明捕获的<code>IllegalArgumentException</code>并不是造成问题的根源，根源在于<code>NullPointerException</code>，是在<code>Main.process2()</code>方法抛出的。</p><p>​ 在代码中<strong>获取原始异常可以使用<code>Throwable.getCause()</code>方法。如果返回<code>null</code>，说明已经是“根异常”了。</strong></p><h4 id="在try或catch种抛出异常finally语句会先执行然后再抛出异常">4、在try或catch种抛出异常，finally语句会先执行，然后再抛出异常</h4><h4 id="异常屏蔽">5、异常屏蔽：</h4><p>​ 如果在执行<code>finally</code>语句时抛出异常，那么，<code>catch</code>语句的异常还能否继续抛出？例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Integer.parseInt(<span class="string">&quot;abc&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;catched&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;finally&quot;</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行上述代码，发现异常信息如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">catched</span><br><span class="line">finally</span><br><span class="line">Exception in thread &quot;main&quot; java.lang.IllegalArgumentException</span><br><span class="line">    at Main.main(Main.java:11)</span><br></pre></td></tr></table></figure><p>​ 这说明<strong><code>finally</code>抛出异常后，原来在<code>catch</code>中准备抛出的异常就“消失”了，因为只能抛出一个异常。没有被抛出的异常称为“被屏蔽”的异常</strong>（Suppressed Exception）。</p><p>​ <strong>绝大多数情况下，在<code>finally</code>中不要抛出异常</strong>。因此，我们通常不需要关心<code>Suppressed Exception</code>。</p><h3 id="四自定义异常">四、自定义异常</h3><p>Java标准库定义的常用异常包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">Exception</span><br><span class="line">│</span><br><span class="line">├─ RuntimeException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ NullPointerException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ IndexOutOfBoundsException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ SecurityException</span><br><span class="line">│  │</span><br><span class="line">│  └─ IllegalArgumentException 参数检查不合法</span><br><span class="line">│     │</span><br><span class="line">│     └─ NumberFormatException</span><br><span class="line">│</span><br><span class="line">├─ IOException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ UnsupportedCharsetException</span><br><span class="line">│  │</span><br><span class="line">│  ├─ FileNotFoundException</span><br><span class="line">│  │</span><br><span class="line">│  └─ SocketException</span><br><span class="line">│</span><br><span class="line">├─ ParseException</span><br><span class="line">│</span><br><span class="line">├─ GeneralSecurityException</span><br><span class="line">│</span><br><span class="line">├─ SQLException</span><br><span class="line">│</span><br><span class="line">└─ TimeoutException</span><br></pre></td></tr></table></figure><p><strong>当我们在代码中需要抛出异常时，尽量使用JDK已定义的异常类型</strong></p><p>在一个大型项目中，可以自定义新的异常类型，但是，保持一个合理的异常继承体系是非常重要的。</p><p><strong>一个常见的做法是自定义一个<code>BaseException</code>作为“根异常”，然后，派生出各种业务类型的异常。</strong></p><p><code>BaseException</code>需要从一个适合的<code>Exception</code>派生，通常建议从<code>RuntimeException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其他业务类型的异常就可以从<code>BaseException</code>派生：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserNotFoundException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFailedException</span> <span class="keyword">extends</span> <span class="title">BaseException</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>自定义的<code>BaseException</code>应该提供多个构造方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseException</span> <span class="keyword">extends</span> <span class="title">RuntimeException</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message, Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message, cause);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(String message)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(message);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BaseException</span><span class="params">(Throwable cause)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 上述构造方法实际上都是原样照抄<code>RuntimeException</code>。这样，抛出异常的时候，就可以选择合适的构造方法。通过IDE可以根据父类快速生成子类的构造方法。</p><h3 id="五nullpointerexception">五、NullPointerException</h3><p>​ <code>NullPointerException</code>即空指针异常，俗称NPE。如果一个对象为<code>null</code>，调用其方法或访问其字段就会产生`NullPointerException</p><h4 id="如何处理nullpointerexception">1、如何处理NullPointerException</h4><p>​ 遇到<code>NullPointerException</code>，遵循原则是早暴露，早修复，严禁使用<code>catch</code>来隐藏这种编码错误，一些好的编码习惯：如下</p><ul><li>成员变量在定义时初始化：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name = <span class="string">&quot;&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>使用空字符串<code>""</code>而不是默认的<code>null</code>可避免很多<code>NullPointerException</code>，编写业务逻辑时，用空字符串<code>""</code>表示未填写比<code>null</code>安全得多。</p></li><li><p>返回空字符串<code>""</code>、空数组而不是<code>null</code>,这样可以使得调用方无需检查结果是否为<code>null</code>。</p></li><li><p>如果调用方一定要根据<code>null</code>判断，比如返回<code>null</code>表示文件不存在，那么考虑返回<code>Optional&lt;T&gt;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Optional&lt;String&gt; <span class="title">readFromFile</span><span class="params">(String file)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!fileExist(file)) &#123;</span><br><span class="line">        <span class="keyword">return</span> Optional.empty();</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样调用方必须通过<code>Optional.isPresent()</code>判断是否有结果。</p></li></ul><h4 id="如何定位nullpointerexception">2、如何定位NullPointerException</h4><p>​ 如果产生了<code>NullPointerException</code>，例如，调用<code>a.b.c.x()</code>时产生了<code>NullPointerException</code>，原因可能是：</p><ul><li><code>a</code>是<code>null</code>；</li><li><code>a.b</code>是<code>null</code>；</li><li><code>a.b.c</code>是<code>null</code>；</li></ul><p>​ 从Java 14开始，如果产生了<code>NullPointerException</code>，JVM可以给出详细的信息告诉我们<code>null</code>对象到底是谁。我们来看例子：</p><p>​ 可以在<code>NullPointerException</code>的详细信息中看到类似<code>... because "&lt;local1&gt;.address.city" is null</code>，意思是<code>city</code>字段为<code>null</code>，这样我们就能快速定位问题所在。</p><p>​ 这种增强的<code>NullPointerException</code>详细信息是Java 14新增的功能，但默认是关闭的，我们可以给JVM添加一个<code>-XX:+ShowCodeDetailsInExceptionMessages</code>参数启用它：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -XX:+ShowCodeDetailsInExceptionMessages Main.java</span><br></pre></td></tr></table></figure><h3 id="六使用断言">六、使用断言</h3><p>​ 断言（Assertion）是一种<strong>调试程序的方式</strong>。在Java中，使用<code>assert</code>关键字来实现断言。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x = Math.abs(-<span class="number">123.45</span>);</span><br><span class="line">    <span class="keyword">assert</span> x &gt;= <span class="number">0</span> : <span class="string">&quot;x must &gt;= 0&quot;</span>;</span><br><span class="line">    System.out.println(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 语句<code>assert x &gt;= 0;</code>即为断言，断言条件<code>x &gt;= 0</code>预期为<code>true</code>。如果计算结果为<code>false</code>，则断言失败，抛出<code>AssertionError</code>。": "x must &gt;= 0" " 为可选的断言消息：</p><p>​ 这样，断言失败的时候，<code>AssertionError</code>会带上消息<code>x must &gt;= 0</code>，更加便于调试。</p><p>​ <strong>Java断言的特点是：断言失败时会抛出<code>AssertionError</code>，导致程序结束退出。因此，断言不能用于可恢复的程序错误，只应该用于开发和测试阶段。</strong></p><p><strong>注意</strong>：这JVM默认关闭断言指令，即遇到<code>assert</code>语句就自动忽略了，不执行。要执行<code>assert</code>语句，必须给Java虚拟机传递<code>-enableassertions</code>（可简写为<code>-ea</code>）参数启用断言。所以，上述程序必须在命令行下运行才有效果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ java -ea Main.java</span><br><span class="line">Exception <span class="keyword">in</span> thread <span class="string">&quot;main&quot;</span> java.lang.AssertionError</span><br><span class="line">at Main.main(Main.java:5)</span><br></pre></td></tr></table></figure><p>​ 断言很少被使用，更好的方法是编写单元测试。</p><h3 id="七使用jdk-logging">七、使用JDK Logging</h3><h4 id="使用日志的目的">1、使用日志的目的？</h4><p>日志就是Logging，它的目的是为了取代<code>System.out.println()</code>。</p><p>输出日志，而不是用<code>System.out.println()</code>，有以下几个好处：</p><ol type="1"><li>可以设置输出样式，避免自己每次都写<code>"ERROR: " + var</code>；</li><li>可以设置输出级别，禁止某些级别输出。例如，只输出错误日志；</li><li>可以被重定向到文件，这样可以在程序运行结束后查看日志；</li><li>可以按包名控制日志级别，只输出某些包打的日志；</li></ol><h4 id="如何使用日志">2、如何使用日志？</h4><p>Java标准库内置了日志包<code>java.util.logging</code>，我们可以直接用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.logging.Level;</span><br><span class="line"><span class="keyword">import</span> java.util.logging.Logger;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Logger logger = Logger.getGlobal();</span><br><span class="line">        logger.info(<span class="string">&quot;start process...&quot;</span>);</span><br><span class="line">        logger.warning(<span class="string">&quot;memory is running out...&quot;</span>);</span><br><span class="line">        logger.fine(<span class="string">&quot;ignored.&quot;</span>);</span><br><span class="line">        logger.severe(<span class="string">&quot;process will be terminated...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>运行上述代码，得到类似如下的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">INFO: start process...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">WARNING: memory is running out...</span><br><span class="line">Mar 02, 2019 6:32:13 PM Hello main</span><br><span class="line">SEVERE: process will be terminated...</span><br></pre></td></tr></table></figure><p>对比可见，使用日志最大的好处是，它自动打印了时间、调用类、调用方法等很多有用的信息。</p><h4 id="日志的输出级别">3、日志的输出级别：</h4><p>再仔细观察发现上述输出，4条日志，只打印了3条，<code>logger.fine()</code>没有打印。这是因为，日志的输出可以设定级别。JDK的Logging定义了7个日志级别，从严重到普通：</p><ul><li>SEVERE</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST</li></ul><p>​ 因为<strong>默认级别是INFO，因此，INFO级别以下的日志，不会被打印出来。</strong>使用日志级别的好处在于，<strong>调整级别，就可以屏蔽掉很多调试相关的日志输出。</strong></p><p>使用Java标准库内置的Logging有以下局限：</p><ul><li><p>Logging系统在JVM启动时读取配置文件并完成初始化，一旦开始运行<code>main()</code>方法，就无法修改配置；</p></li><li><p>配置不太方便，需要在JVM启动时传递参数<code>-Djava.util.logging.config.file=&lt;config-file-name&gt;</code>。</p></li></ul><p>​ <strong>因此，Java标准库内置的Logging使用并不是非常广泛，更广泛的是下一个模块中所说的Commons Logging 或 Log4j 或</strong></p><h3 id="八使用commons-logging">八、使用Commons Logging</h3><h4 id="简单介绍">1、简单介绍</h4><p>​ <strong>Commons Logging是一个第三方日志库，它是由Apache创建的日志模块</strong></p><p>​ Commons Logging的特色是，<strong>它可以挂接不同的日志系统，并通过配置文件指定挂接的日志系统。</strong>默认情况下，<strong>Commons Logging自动搜索并使用Log4j</strong>（Log4j是另一个流行的日志系统），如果没有找到Log4j，再使用JDK Logging。</p><h4 id="如何使用">2、如何使用：</h4><p>第一步，通过<code>LogFactory</code>获取<code>Log</code>类的实例；</p><p>第二步，使用<code>Log</code>实例的方法打日志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Log log = LogFactory.getLog(Main.class);</span><br><span class="line">        log.info(<span class="string">&quot;start...&quot;</span>);</span><br><span class="line">        log.warn(<span class="string">&quot;end.&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="日志级别">3、日志级别：</h4><p>Commons Logging定义了6个日志级别：</p><ul><li>FATAL</li><li>ERROR</li><li>WARNING</li><li>INFO</li><li>DEBUG</li><li>TRACE</li></ul><p>默认级别是<code>INFO</code>。</p><h4 id="通常使用指南">4、通常使用指南</h4><ul><li>使用Commons Logging时，如果在静态方法中引用<code>Log</code>，通常直接定义一个静态类型变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在静态方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Log log = LogFactory.getLog(Main.class);</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在实例方法中引用<code>Log</code>，通常定义一个实例变量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在实例方法中引用Log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> Log log = LogFactory.getLog(getClass());</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;foo&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>注意到实例变量log的获取方式是<code>LogFactory.getLog(getClass())</code>，虽然也可以用<code>LogFactory.getLog(Person.class)</code>，但是前一种方式有个非常大的好处，就是子类可以直接使用该<code>log</code>实例。例如：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在子类中使用父类实例化的log:</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">bar</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        log.info(<span class="string">&quot;bar&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 由于Java类的动态特性，子类获取的<code>log</code>字段实际上相当于<code>LogFactory.getLog(Student.class)</code>，但却是从父类继承而来，并且无需改动代码。</p><h4 id="记录异常">5、记录异常：</h4><p>​ 此外，Commons Logging的日志方法，例如<code>info()</code>，除了标准的<code>info(String)</code>外，还提供了一个非常有用的重载方法：<code>info(String, Throwable)</code>，这使得记录异常更加简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    log.error(<span class="string">&quot;got exception!&quot;</span>, e);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="九使用log4j">九、使用Log4j</h3><h4 id="框架简介">1、框架简介：</h4><p>​ 上述介绍了Commons Logging，可以作为“日志接口”来使用。而真正的“日志实现”可以使用Log4j。</p><p>​ Log4j是一种非常流行的日志框架，最新版本是2.x。</p><p>​ Log4j是一个组件化设计的日志系统，它的架构大致如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">log.info(&quot;User signed in.&quot;);</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│ Console  │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> ├──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│   File   │</span><br><span class="line"> │   └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br><span class="line"> │</span><br><span class="line"> │   ┌──────────┐    ┌──────────┐    ┌──────────┐    ┌──────────┐</span><br><span class="line"> └──&gt;│ Appender │───&gt;│  Filter  │───&gt;│  Layout  │───&gt;│  Socket  │</span><br><span class="line">     └──────────┘    └──────────┘    └──────────┘    └──────────┘</span><br></pre></td></tr></table></figure><p>​ 当我们使用Log4j输出一条日志时，Log4j自动通过不同的Appender把同一条日志输出到不同的目的地。例如：</p><ul><li>console：输出到屏幕；</li><li>file：输出到文件；</li><li>socket：通过网络输出到远程计算机；</li><li>jdbc：输出到数据库</li></ul><p>​ <strong>在输出日志的过程中，通过Filter来过滤哪些log需要被输出，哪些log不需要被输出。例如，仅输出<code>ERROR</code>级别的日志。</strong></p><p>最后，通过Layout来格式化日志信息，例如，自动添加日期、时间、方法名称等信息。</p><p><strong>上述结构虽然复杂，但我们在实际使用的时候，并不需要关心Log4j的API，而是通过配置文件来配置它。</strong></p><h4 id="如何使用-1">2、如何使用：</h4><p>以XML配置为例，使用Log4j的时候，我们把一个<code>log4j2.xml</code>的文件放到<code>classpath</code>下就可以让Log4j读取配置文件并按照我们的配置来输出日志。下面是一个配置文件的例子：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Properties</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义日志格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;log.pattern&quot;</span>&gt;</span>%d&#123;MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125;%n%msg%n%n<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义文件名变量 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.filename&quot;</span>&gt;</span>log/err.log<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Property</span> <span class="attr">name</span>=<span class="string">&quot;file.err.pattern&quot;</span>&gt;</span>log/err.%i.log.gz<span class="tag">&lt;/<span class="name">Property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Properties</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 定义Appender，即目的地 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Appenders</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到屏幕 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Console</span> <span class="attr">name</span>=<span class="string">&quot;console&quot;</span> <span class="attr">target</span>=<span class="string">&quot;SYSTEM_OUT&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 日志格式引用上面定义的log.pattern --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Console</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 定义输出到文件,文件名引用上面定义的file.err.filename --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">RollingFile</span> <span class="attr">name</span>=<span class="string">&quot;err&quot;</span> <span class="attr">bufferedIO</span>=<span class="string">&quot;true&quot;</span> <span class="attr">fileName</span>=<span class="string">&quot;$&#123;file.err.filename&#125;&quot;</span> <span class="attr">filePattern</span>=<span class="string">&quot;$&#123;file.err.pattern&#125;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">PatternLayout</span> <span class="attr">pattern</span>=<span class="string">&quot;$&#123;log.pattern&#125;&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Policies</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!-- 根据文件大小自动切割日志 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">SizeBasedTriggeringPolicy</span> <span class="attr">size</span>=<span class="string">&quot;1 MB&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Policies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 保留最近10份 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">DefaultRolloverStrategy</span> <span class="attr">max</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">RollingFile</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Appenders</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">Root</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对info级别的日志，输出到console --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;console&quot;</span> <span class="attr">level</span>=<span class="string">&quot;info&quot;</span> /&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 对error级别的日志，输出到err，即上面定义的RollingFile --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">AppenderRef</span> <span class="attr">ref</span>=<span class="string">&quot;err&quot;</span> <span class="attr">level</span>=<span class="string">&quot;error&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Root</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Loggers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">Configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​ 虽然配置Log4j比较繁琐，但一旦配置完成，使用起来就非常方便。对上面的配置文件，凡是<code>INFO</code>级别的日志，会自动输出到屏幕，而<code>ERROR</code>级别的日志，不但会输出到屏幕，还会同时输出到文件。并且，一旦日志文件达到指定大小（1MB），Log4j就会自动切割新的日志文件，并最多保留10份。</p><p>​ 有了配置文件还不够，因为Log4j也是一个第三方库，我们需要从<a href="https://logging.apache.org/log4j/2.x/download.html">这里</a>下载Log4j，解压后，把以下3个jar包放到<code>classpath</code>中：</p><ul><li>log4j-api-2.x.jar</li><li>log4j-core-2.x.jar</li><li>log4j-jcl-2.x.jar</li></ul><p>​ 因为Commons Logging会自动发现并使用Log4j，所以，把上一节下载的<code>commons-logging-1.2.jar</code>也放到<code>classpath</code>中。</p><p>​ 要打印日志，只需要按Commons Logging的写法写，不需要改动任何代码，就可以得到Log4j的日志输出，类似：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">03-03 12:09:45.880 [main] INFO  com.itranswarp.learnjava.Main</span><br><span class="line">Start process...</span><br></pre></td></tr></table></figure><h4 id="最佳实践">3、最佳实践：</h4><p>​ 在开发阶段，始终使用Commons Logging接口来写入日志，并且开发阶段无需引入Log4j。如果需要把日志写入文件， 只需要把正确的配置文件和Log4j相关的jar包放入<code>classpath</code>，就可以自动把日志切换成使用Log4j写入，无需修改任何代码。</p><h3 id="十使用slf4j和logback">十、使用SLF4J和Logback</h3><p>​ SLF4J类似于Commons Logging，也是一个日志接口，而Logback类似于Log4j，是一个日志的实现。</p><p>​ SLF4J对Commons Logging的接口有何改进？在Commons Logging中，我们要打印日志，有时候得这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">log.info(<span class="string">&quot;Set score &quot;</span> + score + <span class="string">&quot; for Person &quot;</span> + p.getName() + <span class="string">&quot; ok.&quot;</span>);</span><br></pre></td></tr></table></figure><p>拼字符串是一个非常麻烦的事情，所以SLF4J的日志接口改进成这样了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> score = <span class="number">99</span>;</span><br><span class="line">p.setScore(score);</span><br><span class="line">logger.info(<span class="string">&quot;Set score &#123;&#125; for Person &#123;&#125; ok.&quot;</span>, score, p.getName());</span><br></pre></td></tr></table></figure><p>我们靠猜也能猜出来，SLF4J的日志接口传入的是一个带占位符的字符串，用后面的变量自动替换占位符，所以看起来更加自然。</p><p>具体可以参照更详细的官方网站的教程</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于java异常处理的笔记，包括捕获异常、抛出异常、自定义异常、断言、JDK Logging、Commons Logging、Log4j等内容</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
    <category term="exception" scheme="https://blog.slks.xyz/tags/exception/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记3——java核心类</title>
    <link href="https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B03%E2%80%94java%E6%A0%B8%E5%BF%83%E7%B1%BB/"/>
    <id>https://blog.slks.xyz/2022/01/30/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B03%E2%80%94java%E6%A0%B8%E5%BF%83%E7%B1%BB/</id>
    <published>2022-01-30T02:13:19.000Z</published>
    <updated>2022-01-30T09:29:20.946Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260469698963456</p><h3 id="一字符串和编码">一、字符串和编码</h3><p>​ Java字符串的一个重要特点就是字符串<strong>不可变</strong>。这种不可变性是通过内部的<code>private final char[]</code>字段，以及没有任何修改<code>char[]</code>的方法实现的。</p><h4 id="字符串比较">1、字符串比较</h4><p>​ 必须使用<code>equals()</code>方法而不能用<code>==</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s1 == s2);     <span class="comment">//true</span></span><br><span class="line">        System.out.println(s1.equals(s2));  <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 从表面上看，两个字符串用<code>==</code>和<code>equals()</code>比较都为<code>true</code>，但<strong>实际上那只是Java编译器在编译期，会自动把所有相同的字符串当作一个对象放入常量池，自然<code>s1</code>和<code>s2</code>的引用就是相同的。</strong></p><p>​ 所以，这种<code>==</code>比较返回<code>true</code>纯属巧合。换一种写法，<code>==</code>比较就会失败：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1 == s2);</span><br><span class="line">        System.out.println(s1.equals(s2));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 要忽略大小写比较，使用<code>equalsIgnoreCase()</code>方法。</p><h4 id="搜索与提取子串">2、搜索与提取子串</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;Hello&quot;</span>.contains(<span class="string">&quot;ll&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.indexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 2</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.lastIndexOf(<span class="string">&quot;l&quot;</span>); <span class="comment">// 3</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.startsWith(<span class="string">&quot;He&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.endsWith(<span class="string">&quot;lo&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>); <span class="comment">// &quot;llo&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span>.substring(<span class="number">2</span>, <span class="number">4</span>); <span class="string">&quot;ll&quot;</span></span><br></pre></td></tr></table></figure><h4 id="去除首尾空白字符">3、去除首尾空白字符：</h4><ul><li><p>使用<code>trim()</code>方法可以移除字符串首尾空白字符。<strong>空白字符包括空格，<code>\t</code>，<code>\r</code>，<code>\n</code></strong></p></li><li><p>另一个<code>strip()</code>方法也可以移除字符串首尾空白字符。它和<code>trim()</code>不同的是，类似中文的空格字符<code>\u3000</code>也会被移除</p></li></ul><h4 id="判断是否为空">4、判断是否为空：</h4><p><code>String</code>还提供了<code>isEmpty()</code>和<code>isBlank()</code>来判断字符串是否为空 和 空白字符串</p><p>空白字符串 代表 只含 <strong>空白字符</strong>的字符串。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;&quot;</span>.isEmpty(); <span class="comment">// true，因为字符串长度为0</span></span><br><span class="line"><span class="string">&quot;  &quot;</span>.isEmpty(); <span class="comment">// false，因为字符串长度不为0</span></span><br><span class="line"><span class="string">&quot;  \n&quot;</span>.isBlank(); <span class="comment">// true，因为只包含空白字符</span></span><br><span class="line"><span class="string">&quot; Hello &quot;</span>.isBlank(); <span class="comment">// false，因为包含非空白字符</span></span><br></pre></td></tr></table></figure><h4 id="替换子串">5、替换子串</h4><ul><li>根据字符或字符串替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">s.replace(<span class="string">&#x27;l&#x27;</span>, <span class="string">&#x27;w&#x27;</span>); <span class="comment">// &quot;hewwo&quot;，所有字符&#x27;l&#x27;被替换为&#x27;w&#x27;</span></span><br><span class="line">s.replace(<span class="string">&quot;ll&quot;</span>, <span class="string">&quot;~~&quot;</span>); <span class="comment">// &quot;he~~o&quot;，所有子串&quot;ll&quot;被替换为&quot;~~&quot;</span></span><br></pre></td></tr></table></figure><ul><li>正则表达式替换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,,B;C ,D&quot;</span>;</span><br><span class="line">s.replaceAll(<span class="string">&quot;[\\,\\;\\s]+&quot;</span>, <span class="string">&quot;,&quot;</span>); <span class="comment">// &quot;A,B,C,D&quot;</span></span><br></pre></td></tr></table></figure><h4 id="分割拼接格式化字符串">6、分割、拼接、格式化字符串：</h4><ul><li>要分割字符串，使用<code>split()</code>方法，并且传入的也是正则表达式：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;A,B,C,D&quot;</span>;</span><br><span class="line">String[] ss = s.split(<span class="string">&quot;\\,&quot;</span>); <span class="comment">// &#123;&quot;A&quot;, &quot;B&quot;, &quot;C&quot;, &quot;D&quot;&#125;</span></span><br></pre></td></tr></table></figure><ul><li>拼接字符串使用静态方法<code>join()</code>，它用指定的字符串连接字符串数组：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] arr = &#123;<span class="string">&quot;A&quot;</span>, <span class="string">&quot;B&quot;</span>, <span class="string">&quot;C&quot;</span>&#125;;</span><br><span class="line">String s = String.join(<span class="string">&quot;***&quot;</span>, arr); <span class="comment">// &quot;A***B***C&quot;</span></span><br></pre></td></tr></table></figure><ul><li>字符串提供了<code>formatted()</code>方法和<code>format()</code>静态方法，可以传入其他参数，替换占位符，然后生成新的字符串：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;Hi %s, your score is %d!&quot;</span>;</span><br><span class="line">        System.out.println(s.formatted(<span class="string">&quot;Alice&quot;</span>, <span class="number">80</span>));</span><br><span class="line">        System.out.println(String.format(<span class="string">&quot;Hi %s, your score is %.2f!&quot;</span>, <span class="string">&quot;Bob&quot;</span>, <span class="number">59.5</span>));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="类型转换">7、类型转换：</h4><p>要把任意基本类型或引用类型转换为字符串，可以使用静态方法<code>valueOf()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.valueOf(<span class="number">123</span>); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">String.valueOf(<span class="number">45.67</span>); <span class="comment">// &quot;45.67&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">true</span>); <span class="comment">// &quot;true&quot;</span></span><br><span class="line">String.valueOf(<span class="keyword">new</span> Object()); <span class="comment">// 类似java.lang.Object@636be97c</span></span><br></pre></td></tr></table></figure><p>把字符串转换为其他类型，就需要根据情况。例如，把字符串转换为<code>int</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n1 = Integer.parseInt(<span class="string">&quot;123&quot;</span>); <span class="comment">// 123</span></span><br><span class="line"><span class="keyword">int</span> n2 = Integer.parseInt(<span class="string">&quot;ff&quot;</span>, <span class="number">16</span>); <span class="comment">// 按十六进制转换，255</span></span><br></pre></td></tr></table></figure><p>把字符串转换为<code>boolean</code>类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> b1 = Boolean.parseBoolean(<span class="string">&quot;true&quot;</span>); <span class="comment">// true</span></span><br><span class="line"><span class="keyword">boolean</span> b2 = Boolean.parseBoolean(<span class="string">&quot;FALSE&quot;</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p>要特别注意，<code>Integer</code>有个<code>getInteger(String)</code>方法，它不是将字符串转换为<code>int</code>，而是把该字符串对应的系统变量转换为<code>Integer</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Integer.getInteger(<span class="string">&quot;java.version&quot;</span>); <span class="comment">// 版本号，11</span></span><br></pre></td></tr></table></figure><p><code>String</code>和<code>char[]</code>类型可以互相转换，方法是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray(); <span class="comment">// String -&gt; char[]</span></span><br><span class="line">String s = <span class="keyword">new</span> String(cs); <span class="comment">// char[] -&gt; String</span></span><br></pre></td></tr></table></figure><p>如果修改了<code>char[]</code>数组，<code>String</code>并不会改变：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">char</span>[] cs = <span class="string">&quot;Hello&quot;</span>.toCharArray();</span><br><span class="line">        String s = <span class="keyword">new</span> String(cs);</span><br><span class="line">        System.out.println(s);</span><br><span class="line">        cs[<span class="number">0</span>] = <span class="string">&#x27;X&#x27;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这是因为通过<code>new String(char[])</code>创建新的<code>String</code>实例时，它并不会直接引用传入的<code>char[]</code>数组，而是会复制一份，所以，修改外部的<code>char[]</code>数组不会影响<code>String</code>实例内部的<code>char[]</code>数组，因为这是两个不同的数组。</p><p><strong>设计注意</strong>：从<code>String</code>的不变性设计可以看出，如果传入的对象有可能改变，我们需要复制而不是直接引用。</p><h4 id="字符编码问题">8、字符编码问题：</h4><p>​ 为了统一全球所有语言的编码，全球统一码联盟发布了<code>Unicode</code>编码</p><p>​ <code>Unicode</code>编码需要两个或者更多字节表示</p><p>英文字符<code>'A'</code>的<code>ASCII</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┐</span><br><span class="line">ASCII:   │ 41 │</span><br><span class="line">         └────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 00 │ 41 │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure><p>英文字符的<code>Unicode</code>编码就是简单地在前面添加一个<code>00</code>字节。</p><p>中文字符<code>'中'</code>的<code>GB2312</code>编码和<code>Unicode</code>编码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">         ┌────┬────┐</span><br><span class="line">GB2312:  │ d6 │ d0 │</span><br><span class="line">         └────┴────┘</span><br><span class="line">         ┌────┬────┐</span><br><span class="line">Unicode: │ 4e │ 2d │</span><br><span class="line">         └────┴────┘</span><br></pre></td></tr></table></figure><p>​ 那我们经常使用的<code>UTF-8</code>又是什么编码呢？因为英文字符的<code>Unicode</code>编码高字节总是<code>00</code>，包含大量英文的文本会浪费空间，所以，出现了<code>UTF-8</code>编码，<strong>它是一种变长编码</strong>，<strong>用来把固定长度的<code>Unicode</code>编码变成1～4字节的变长编码</strong>。通过<code>UTF-8</code>编码，英文字符<code>'A'</code>的<code>UTF-8</code>编码变为<code>0x41</code>，正好和<code>ASCII</code>码一致，而中文<code>'中'</code>的<code>UTF-8</code>编码为3字节<code>0xe4b8ad</code>。</p><p>​ <strong><code>UTF-8</code>编码的另一个好处是容错能力强。</strong>如果传输过程中某些字符出错，不会影响后续字符，因为<code>UTF-8</code>编码依靠高字节位来确定一个字符究竟是几个字节，它经常用来作为传输编码。</p><p>​ 在Java中，<strong><code>char</code>类型实际上就是两个字节的<code>Unicode</code>编码</strong>。如果我们要手动把字符串转换成其他编码，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b1 = <span class="string">&quot;Hello&quot;</span>.getBytes(); <span class="comment">// 按系统默认编码转换，不推荐</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;UTF-8&quot;</span>); <span class="comment">// 按UTF-8编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b2 = <span class="string">&quot;Hello&quot;</span>.getBytes(<span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK编码转换</span></span><br><span class="line"><span class="keyword">byte</span>[] b3 = <span class="string">&quot;Hello&quot;</span>.getBytes(StandardCharsets.UTF_8); <span class="comment">// 按UTF-8编码转换</span></span><br></pre></td></tr></table></figure><p><strong>注意：转换编码后，就不再是<code>char</code>类型，而是<code>byte</code>类型表示的数组。</strong></p><p>如果要把已知编码的<code>byte[]</code>转换为<code>String</code>，可以这样做：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] b = ...</span><br><span class="line">String s1 = <span class="keyword">new</span> String(b, <span class="string">&quot;GBK&quot;</span>); <span class="comment">// 按GBK转换</span></span><br><span class="line">String s2 = <span class="keyword">new</span> String(b, StandardCharsets.UTF_8); <span class="comment">// 按UTF-8转换</span></span><br></pre></td></tr></table></figure><p><strong>始终牢记：Java的<code>String</code>和<code>char</code>在内存中总是以Unicode编码表示。</strong></p><h3 id="二stringbuilder">二、StringBuilder</h3><p>​ 在java的String类种，虽然我们可以直接拼接字符串，但是，在循环中，<strong>每次循环都会创建新的字符串对象，然后扔掉旧的字符串</strong>。这样，<strong>绝大部分字符串都是临时对象，不但浪费内存，还会影响GC效率</strong>。</p><p>​ 为了能高效拼接字符串，Java标准库提供了<code>StringBuilder</code>，它是一个可变对象，可以预分配缓冲区，这样，往<code>StringBuilder</code>中新增字符时，不会创建新的临时对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">StringBuilder sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">    sb.append(<span class="string">&#x27;,&#x27;</span>);</span><br><span class="line">    sb.append(i);</span><br><span class="line">&#125;</span><br><span class="line">String s = sb.toString();</span><br></pre></td></tr></table></figure><p><strong>链式操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> sb = <span class="keyword">new</span> StringBuilder(<span class="number">1024</span>);</span><br><span class="line">        sb.append(<span class="string">&quot;Mr &quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;Bob&quot;</span>)</span><br><span class="line">          .append(<span class="string">&quot;!&quot;</span>)</span><br><span class="line">          .insert(<span class="number">0</span>, <span class="string">&quot;Hello, &quot;</span>);</span><br><span class="line">        System.out.println(sb.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>进行链式操作的关键是：定义的<code>append()</code>方法会返回<code>this</code>，这样，就可以不断调用自身的其他方法</strong></p><p><strong>注意</strong>：对于普通的字符串<code>+</code>操作，并不需要我们将其改写为<code>StringBuilder</code>，因为Java编译器在编译时就自动把多个连续的<code>+</code>操作编码为<code>StringConcatFactory</code>的操作。在运行期，<code>StringConcatFactory</code>会自动把字符串连接操作优化为数组复制或者<code>StringBuilder</code>操作。</p><h3 id="三stringjoiner">三、StringJoiner</h3><ul><li>Java标准库还提供了一个<code>StringJoiner</code>可以用于使用分隔符拼接数组。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line">        <span class="comment">// var sj = new StringJoiner(&quot;, &quot;);  //case1 指定分隔符 </span></span><br><span class="line">        <span class="keyword">var</span> sj = <span class="keyword">new</span> StringJoiner(<span class="string">&quot;, &quot;</span>, <span class="string">&quot;Hello &quot;</span>, <span class="string">&quot;!&quot;</span>); <span class="comment">//case2 指定开头和结尾字符</span></span><br><span class="line">        <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">            sj.add(name);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(sj.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// case1 Bob, Alice, Grace </span></span><br><span class="line"><span class="comment">// case2 Hello Bob, Alice, Grace! </span></span><br></pre></td></tr></table></figure><ul><li><code>String</code>还提供了一个静态方法<code>join()</code>，这个方法在内部使用了<code>StringJoiner</code>来拼接字符串，在不需要指定“开头”和“结尾”的时候，用<code>String.join()</code>更方便：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String[] names = &#123;<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;Alice&quot;</span>, <span class="string">&quot;Grace&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">var</span> s = String.join(<span class="string">&quot;, &quot;</span>, names);</span><br></pre></td></tr></table></figure><h3 id="四包装类型">四、包装类型</h3><h4 id="什么是包装类型">1、什么是包装类型？</h4><p>java的数据类型分两种：</p><ul><li>基本类型：<code>byte</code>，<code>short</code>，<code>int</code>，<code>long</code>，<code>boolean</code>，<code>float</code>，<code>double</code>，<code>char</code></li><li>引用类型：所有<code>class</code>和<code>interface</code>类型</li></ul><p><strong>引用类型可以赋值为<code>null</code>，表示空，但基本类型不能赋值为<code>null</code></strong></p><p>如何把一个基本类型视为对象（引用类型）？</p><p>​ 比如，想要把<code>int</code>基本类型变成一个引用类型，我们可以定义一个<code>Integer</code>类，它只包含一个实例字段<code>int</code>，这样，<strong><code>Integer</code>类就可以视为<code>int</code>的包装类（Wrapper Class）</strong></p><p>实际上，因为包装类型非常有用，Java核心库为每种基本类型都提供了对应的包装类型：</p><table><thead><tr class="header"><th style="text-align: left;">基本类型</th><th style="text-align: left;">对应的引用类型</th></tr></thead><tbody><tr class="odd"><td style="text-align: left;">boolean</td><td style="text-align: left;">java.lang.Boolean</td></tr><tr class="even"><td style="text-align: left;">byte</td><td style="text-align: left;">java.lang.Byte</td></tr><tr class="odd"><td style="text-align: left;">short</td><td style="text-align: left;">java.lang.Short</td></tr><tr class="even"><td style="text-align: left;">int</td><td style="text-align: left;">java.lang.Integer</td></tr><tr class="odd"><td style="text-align: left;">long</td><td style="text-align: left;">java.lang.Long</td></tr><tr class="even"><td style="text-align: left;">float</td><td style="text-align: left;">java.lang.Float</td></tr><tr class="odd"><td style="text-align: left;">double</td><td style="text-align: left;">java.lang.Double</td></tr><tr class="even"><td style="text-align: left;">char</td><td style="text-align: left;">java.lang.Character</td></tr></tbody></table><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">        <span class="comment">// 通过new操作符创建Integer实例(不推荐使用,会有编译警告):</span></span><br><span class="line">        Integer n1 = <span class="keyword">new</span> Integer(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(int)创建Integer实例:</span></span><br><span class="line">        Integer n2 = Integer.valueOf(i);</span><br><span class="line">        <span class="comment">// 通过静态方法valueOf(String)创建Integer实例:</span></span><br><span class="line">        Integer n3 = Integer.valueOf(<span class="string">&quot;100&quot;</span>);</span><br><span class="line">        System.out.println(n3.intValue());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="auto-boxing">2、Auto Boxing</h4><p>因为<code>int</code>和<code>Integer</code>可以互相转换：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> i = <span class="number">100</span>;</span><br><span class="line">Integer n = Integer.valueOf(i);</span><br><span class="line"><span class="keyword">int</span> x = n.intValue();</span><br></pre></td></tr></table></figure><p>所以，Java编译器可以帮助我们自动在<code>int</code>和<code>Integer</code>之间转型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Integer n = <span class="number">100</span>; <span class="comment">// 编译器自动使用Integer.valueOf(int)</span></span><br><span class="line"><span class="keyword">int</span> x = n; <span class="comment">// 编译器自动使用Integer.intValue()</span></span><br></pre></td></tr></table></figure><p>​ <strong>这种直接把<code>int</code>变为<code>Integer</code>的赋值写法，称为自动装箱（Auto Boxing），反过来，把<code>Integer</code>变为<code>int</code>的赋值写法，称为自动拆箱（Auto Unboxing）。</strong></p><p>​ 注意：<strong>自动装箱和自动拆箱只发生在编译阶段，目的是为了少写代码</strong>。</p><p>装箱和拆箱会影响代码的执行效率，因为编译后的<code>class</code>代码是严格区分基本类型和引用类型的。并且，自动拆箱执行时可能会报<code>NullPointerException</code>：</p><h4 id="不变类">3、不变类</h4><p>​ 所有的包装类型都是不变类，因此，一旦创建了<code>Integer</code>对象，该对象就是不变的。</p><p>​ 对两个<code>Integer</code>实例进行比较要特别注意：绝对不能用<code>==</code>比较，因为<code>Integer</code>是引用类型，必须使用<code>equals()</code>比较：</p><h4 id="进制转换">4、进制转换：</h4><p><code>Integer</code>类本身还提供了大量方法，例如，最常用的静态方法<code>parseInt()</code>可以把字符串解析成一个整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> x1 = Integer.parseInt(<span class="string">&quot;100&quot;</span>); <span class="comment">// 100</span></span><br><span class="line"><span class="keyword">int</span> x2 = Integer.parseInt(<span class="string">&quot;100&quot;</span>, <span class="number">16</span>); <span class="comment">// 256,因为按16进制解析</span></span><br></pre></td></tr></table></figure><p><code>Integer</code>还可以把整数格式化为指定进制的字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>)); <span class="comment">// &quot;100&quot;,表示为10进制</span></span><br><span class="line">        System.out.println(Integer.toString(<span class="number">100</span>, <span class="number">36</span>)); <span class="comment">// &quot;2s&quot;,表示为36进制</span></span><br><span class="line">        System.out.println(Integer.toHexString(<span class="number">100</span>)); <span class="comment">// &quot;64&quot;,表示为16进制</span></span><br><span class="line">        System.out.println(Integer.toOctalString(<span class="number">100</span>)); <span class="comment">// &quot;144&quot;,表示为8进制</span></span><br><span class="line">        System.out.println(Integer.toBinaryString(<span class="number">100</span>)); <span class="comment">// &quot;1100100&quot;,表示为2进制</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五javabean">五、JavaBean</h3><p>在Java中，有很多<code>class</code>的定义都符合这样的规范：</p><ul><li>若干<code>private</code>实例字段；</li><li>通过<code>public</code>方法来读写实例字段。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.name; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123; <span class="keyword">this</span>.name = name; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="keyword">this</span>.age; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123; <span class="keyword">this</span>.age = age; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果读写方法符合以下这种命名规范, 那么这种<code>class</code>被称为<code>JavaBean</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读方法:</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Type <span class="title">getXyz</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">// 写方法:</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setXyz</span><span class="params">(Type value)</span></span></span><br></pre></td></tr></table></figure><p>​ 上面的字段是<code>xyz</code>，那么读写方法名分别以<code>get</code>和<code>set</code>开头，并且后接大写字母开头的字段名<code>Xyz</code>，因此两个读写方法名分别是<code>getXyz()</code>和<code>setXyz()</code>。</p><p><code>boolean</code>字段比较特殊，它的读方法一般命名为<code>isXyz()</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 读方法:</span><br><span class="line">public boolean isChild()</span><br><span class="line">// 写方法:</span><br><span class="line">public void setChild(boolean value)</span><br></pre></td></tr></table></figure><p>​ <strong>我们通常把一组对应的读方法（<code>getter</code>）和写方法（<code>setter</code>）称为属性（<code>property</code>）。例如，<code>name</code>属性</strong>：</p><ul><li>对应的读方法是<code>String getName()</code></li><li>对应的写方法是<code>setName(String)</code></li></ul><p><strong>只有<code>getter</code>的属性称为只读属性（read-only）</strong>，例如，定义一个age只读属性：</p><ul><li>对应的读方法是<code>int getAge()</code></li><li>无对应的写方法<code>setAge(int)</code></li></ul><p>类似的，只有<code>setter</code>的属性称为只写属性（write-only）。</p><h4 id="javabean-的作用">javabean 的作用：</h4><p>​ JavaBean主要用来传递数据，即把一组数据组合成一个JavaBean便于传输。此外，JavaBean可以方便地被IDE工具分析，生成读写属性的代码，主要用在图形界面的可视化设计中。</p><p>​ 通过IDE，可以快速生成<code>getter</code>和<code>setter</code></p><h4 id="如何枚举javabean的所有属性">如何枚举JavaBean的所有属性？</h4><p>要枚举一个JavaBean的所有属性，可以直接使用Java核心库提供的<code>Introspector</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        BeanInfo info = Introspector.getBeanInfo(Person.class);</span><br><span class="line">        <span class="keyword">for</span> (PropertyDescriptor pd : info.getPropertyDescriptors()) &#123;</span><br><span class="line">            System.out.println(pd.getName());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getReadMethod());</span><br><span class="line">            System.out.println(<span class="string">&quot;  &quot;</span> + pd.getWriteMethod());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">age</span></span><br><span class="line"><span class="comment">  public int Person.getAge()</span></span><br><span class="line"><span class="comment">  public void Person.setAge(int)</span></span><br><span class="line"><span class="comment">class</span></span><br><span class="line"><span class="comment">  public final native java.lang.Class java.lang.Object.getClass()</span></span><br><span class="line"><span class="comment">  null</span></span><br><span class="line"><span class="comment">name</span></span><br><span class="line"><span class="comment">  public java.lang.String Person.getName()</span></span><br><span class="line"><span class="comment">  public void Person.setName(java.lang.String) </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h3 id="六枚举类">六、枚举类</h3><h4 id="为什么需要枚举类">1、为什么需要枚举类：</h4><p>​ 在Java中，我们可以通过<code>static final</code>来定义常量,但有一个严重的问题就是，编译器无法检查每个值的合理性。比如说：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SUN = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MON = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TUE = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> WED = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THU = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FRI = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SAT = <span class="number">6</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>注意到<code>Weekday</code>定义的常量范围是<code>0</code>~<code>6</code>，并不包含<code>7</code>，编译器无法检查不在枚举中的<code>int</code>值；</p></li><li><p>定义的常量仍可与其他变量比较，但其用途并非是枚举星期</p></li></ul><p>​ 为了让编译器能自动检查某个值在枚举的集合内，并且，不同用途的枚举需要不同的类型来标记，不能混用，我们可以使用<code>enum</code>来定义枚举类：</p><h4 id="如何定义枚举类">2、如何定义枚举类？</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day == Weekday.SAT || day == Weekday.SUN) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>定义枚举类是通过关键字<code>enum</code>实现的，我们只需依次列出枚举的常量名。</p><p>使用<code>enum</code>定义枚举有如下好处：</p><ul><li><p>首先，<code>enum</code>常量本身带有类型信息，即<code>Weekday.SUN</code>类型是<code>Weekday</code>，编译器会自动检查出类型错误。</p></li><li><p>其次，不可能引用到非枚举的值，因为无法通过编译。</p></li><li><p>最后，不同类型的枚举不能互相比较或者赋值，因为类型不符。</p></li></ul><h4 id="enum的比较">3、enum的比较：</h4><p>​ <code>enum</code>类型的每个常量在JVM中只有一个唯一实例，所以可以直接用<code>==</code>比较</p><h4 id="enum类型">4、enum类型：</h4><p>通过<code>enum</code>定义的枚举类，和其他的<code>class</code>没有任何区别。</p><p><code>enum</code>定义的类型就是<code>class</code>，只不过它有以下几个特点：</p><ul><li><p>定义的<code>enum</code>类型总是继承自<code>java.lang.Enum</code>，且无法被继承；</p></li><li><p>只能定义出<code>enum</code>的实例，而无法通过<code>new</code>操作符创建<code>enum</code>的实例；</p></li><li><p>定义的每个实例都是引用类型的唯一实例；</p></li><li><p>可以将<code>enum</code>类型用于<code>switch</code>语句。</p><p>例如，我们定义的<code>Color</code>枚举类：</p></li></ul><h4 id="enum示例">5、Enum示例：</h4><p>如下所示定义的enum:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Color</span> </span>&#123;</span><br><span class="line">    RED, GREEN, BLUE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么编译器编译出的<code>class</code>大概就像这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Color</span> <span class="keyword">extends</span> <span class="title">Enum</span> </span>&#123; <span class="comment">// 继承自Enum，标记为final class</span></span><br><span class="line">    <span class="comment">// 每个实例均为全局唯一:</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color RED = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color GREEN = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Color BLUE = <span class="keyword">new</span> Color();</span><br><span class="line">    <span class="comment">// private构造方法，确保外部无法调用new操作符:</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Color</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以，编译后的<code>enum</code>类和普通<code>class</code>并没有任何区别。但是我们自己无法按定义普通<code>class</code>那样来定义<code>enum</code>，必须使用<code>enum</code>关键字，这是Java语法规定的。</p><p>因为<strong><code>enum</code>是一个<code>class</code>，每个枚举的值都是<code>class</code>实例</strong>，因此，这些实例有一些方法：</p><ul><li>name()</li></ul><p>返回常量名，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = Weekday.SUN.name(); <span class="comment">// &quot;SUN&quot;</span></span><br></pre></td></tr></table></figure><ul><li>ordinal()</li></ul><p>返回定义的常量的顺序，从0开始计数，例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = Weekday.MON.ordinal(); <span class="comment">// 1</span></span><br></pre></td></tr></table></figure><p>改变枚举常量定义的顺序就会导致<code>ordinal()</code>返回值发生变化。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    SUN, MON, TUE, WED, THU, FRI, SAT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 的<code>ordinal</code>就是不同的。如果在代码中编写了类似<code>if(x.ordinal()==1)</code>这样的语句，就要保证<code>enum</code>的枚举顺序不能变。新增的常量必须放在最后。</p><h4 id="书写健壮的enum代码">6、书写健壮的Enum代码</h4><p><code>Weekday</code>的枚举常量如果要和<code>int</code>转换，使用<code>ordinal()</code>不是非常方便, 比如这样写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String task = Weekday.MON.ordinal() + <span class="string">&quot;/ppt&quot;</span>;</span><br><span class="line">saveToFile(task);</span><br></pre></td></tr></table></figure><p>​ 但是，如果不小心修改了枚举的顺序，编译器是无法检查出这种逻辑错误的。<strong>要编写健壮的代码，就不要依靠<code>ordinal()</code>的返回值。</strong> <strong>因为<code>enum</code>本身是<code>class</code>，所以我们可以定义<code>private</code>的构造方法，并且，给每个枚举常量添加字段：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">if</span> (day.dayValue == <span class="number">6</span> || day.dayValue == <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at home!&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Work at office!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>), TUE(<span class="number">2</span>), WED(<span class="number">3</span>), THU(<span class="number">4</span>), FRI(<span class="number">5</span>), SAT(<span class="number">6</span>), SUN(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这样就无需担心顺序的变化，新增枚举常量时，也需要指定一个<code>int</code>值。</p><p>默认情况下，对枚举常量调用<code>toString()</code>会返回和<code>name()</code>一样的字符串。但是，<code>toString()</code>可以被覆写，而<code>name()</code>则不行。我们可以给<code>Weekday</code>添加<code>toString()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON(<span class="number">1</span>, <span class="string">&quot;星期一&quot;</span>), TUE(<span class="number">2</span>, <span class="string">&quot;星期二&quot;</span>), WED(<span class="number">3</span>, <span class="string">&quot;星期三&quot;</span>), THU(<span class="number">4</span>, <span class="string">&quot;星期四&quot;</span>), FRI(<span class="number">5</span>, <span class="string">&quot;星期五&quot;</span>), SAT(<span class="number">6</span>, <span class="string">&quot;星期六&quot;</span>), SUN(<span class="number">0</span>, <span class="string">&quot;星期日&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> dayValue;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String chinese;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Weekday</span><span class="params">(<span class="keyword">int</span> dayValue, String chinese)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dayValue = dayValue;</span><br><span class="line">        <span class="keyword">this</span>.chinese = chinese;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.chinese;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="enum适合用在switch语句中">7、<code>enum</code>适合用在<code>switch</code>语句中</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Weekday day = Weekday.SUN;</span><br><span class="line">        <span class="keyword">switch</span>(day) &#123;</span><br><span class="line">        <span class="keyword">case</span> MON:</span><br><span class="line">        <span class="keyword">case</span> TUE:</span><br><span class="line">        <span class="keyword">case</span> WED:</span><br><span class="line">        <span class="keyword">case</span> THU:</span><br><span class="line">        <span class="keyword">case</span> FRI:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at office!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> SAT:</span><br><span class="line">        <span class="keyword">case</span> SUN:</span><br><span class="line">            System.out.println(<span class="string">&quot;Today is &quot;</span> + day + <span class="string">&quot;. Work at home!&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">&quot;cannot process &quot;</span> + day);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Weekday</span> </span>&#123;</span><br><span class="line">    MON, TUE, WED, THU, FRI, SAT, SUN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="七记录类">七、记录类</h3><h4 id="以往类的繁琐之处">1、以往类的繁琐之处：</h4><p>使用<code>String</code>、<code>Integer</code>等类型的时候，这些类型都是不变类，一个不变类具有以下特点：</p><ol type="1"><li>定义class时使用<code>final</code>，无法派生子类；</li><li>每个字段使用<code>final</code>，保证创建实例后无法修改任何字段。</li></ol><p>假设我们希望定义一个<code>Point</code>类，有<code>x</code>、<code>y</code>两个变量，同时它是一个不变类，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> y;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">x</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">y</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里演示<code>Point</code>不变类的写法目的是，这些代码写起来都非常简单，但是很繁琐。</p><h4 id="record-记录类">2、record 记录类:</h4><p>​ 从Java 14开始，引入了新的<code>Record</code>类。我们定义<code>Record</code>类时，使用关键字<code>record</code>。把上述<code>Point</code>类改写为<code>Record</code>类，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Point p = <span class="keyword">new</span> Point(<span class="number">123</span>, <span class="number">456</span>);</span><br><span class="line">        System.out.println(p.x());</span><br><span class="line">        System.out.println(p.y());</span><br><span class="line">        System.out.println(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>如果要把上述定义，以class的形式改写代码的话，应当如下所示：（其实也就是编译器会帮我们编译成如下的代码）</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public final class Point extends Record &#123;</span><br><span class="line">    private final int x;</span><br><span class="line">    private final int y;</span><br><span class="line"></span><br><span class="line">    public Point(int x, int y) &#123;</span><br><span class="line">        this.x = x;</span><br><span class="line">        this.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int x() &#123;</span><br><span class="line">        return this.x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int y() &#123;</span><br><span class="line">        return this.y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public String toString() &#123;</span><br><span class="line">        return String.format(&quot;Point[x=%s, y=%s]&quot;, x, y);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public boolean equals(Object o) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    public int hashCode() &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 除了用<code>final</code>修饰class以及每个字段外，编译器还自动为我们创建了构造方法，和字段名同名的方法，以及覆写<code>toString()</code>、<code>equals()</code>和<code>hashCode()</code>方法。</p><p>​ <strong>换句话说，使用<code>record</code>关键字，可以一行写出一个不变类。</strong></p><p>​ <strong>和<code>enum</code>类似，我们自己不能直接从<code>Record</code>派生，只能通过<code>record</code>关键字由编译器实现继承。</strong></p><h4 id="构造方法">3、构造方法：</h4><p>​ 编译器默认按照<code>record</code>声明的变量顺序自动创建一个构造方法，并在方法内给字段赋值。那么问题来了，如果我们要检查参数，应该怎么办？</p><p>​ <strong>假设<code>Point</code>类的<code>x</code>、<code>y</code>不允许负数，我们就得给<code>Point</code>的构造方法加上检查逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Point &#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 注意到方法<code>public Point &#123;...&#125;</code>被称为Compact Constructor，它的目的是让我们编写检查逻辑，<strong>编译器最终生成的构造方法如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> <span class="keyword">extends</span> <span class="title">Record</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 这是我们编写的Compact Constructor:</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || y &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 这是编译器继续生成的赋值代码:</span></span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>作为<code>record</code>的<code>Point</code>仍然可以添加静态方法。一种常用的静态方法是<code>of()</code>方法，用来创建<code>Point</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> record <span class="title">Point</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Point <span class="title">of</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Point(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样我们可以写出更简洁的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> z = Point.of();</span><br><span class="line"><span class="keyword">var</span> p = Point.of(<span class="number">123</span>, <span class="number">456</span>);</span><br></pre></td></tr></table></figure><h4 id="总结">4、总结：</h4><p>从Java 14开始，提供新的<code>record</code>关键字，可以非常方便地定义Data Class：</p><ul><li>使用<code>record</code>定义的是不变类；</li><li>可以编写Compact Constructor对参数进行验证；</li><li>可以定义静态方法。</li></ul><h3 id="八biginteger">八、BigInteger</h3><p>​ 在Java中，由CPU原生提供的整型最大范围是64位<code>long</code>型整数。<strong>使用<code>long</code>型整数可以直接通过CPU指令进行计算，速度非常快</strong></p><p>​ 如果我们使用的整数范围超过了<code>long</code>型，就只能用软件来模拟一个大整数。<code>java.math.BigInteger</code>就是用来表示任意大小的整数。<code>BigInteger</code>内部用一个<code>int[]</code>数组来模拟一个非常大的整数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigInteger bi = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">System.out.println(bi.pow(<span class="number">5</span>)); <span class="comment">// 2867971860299718107233761438093672048294900000</span></span><br></pre></td></tr></table></figure><p>对<code>BigInteger</code>做运算的时候，只能使用实例方法，例如，加法运算：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i1 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;1234567890&quot;</span>);</span><br><span class="line">BigInteger i2 = <span class="keyword">new</span> BigInteger(<span class="string">&quot;12345678901234567890&quot;</span>);</span><br><span class="line">BigInteger sum = i1.add(i2); <span class="comment">// 12345678902469135780</span></span><br></pre></td></tr></table></figure><p><code>BigInteger</code>和<code>Integer</code>、<code>Long</code>一样，也是不可变类，并且也继承自<code>Number</code>类。因为<code>Number</code>定义了转换为基本类型的几个方法：</p><ul><li>转换为<code>byte</code>：<code>byteValue()</code></li><li>转换为<code>short</code>：<code>shortValue()</code></li><li>转换为<code>int</code>：<code>intValue()</code></li><li>转换为<code>long</code>：<code>longValue()</code></li><li>转换为<code>float</code>：<code>floatValue()</code></li><li>转换为<code>double</code>：<code>doubleValue()</code></li></ul><p>​ 因此，通过上述方法，可以把<code>BigInteger</code>转换成基本类型。如果<code>BigInteger</code>表示的范围超过了基本类型的范围，转换时将丢失高位信息，即结果不一定是准确的。如果需要准确地转换成基本类型，可以使用<code>intValueExact()</code>、<code>longValueExact()</code>等方法，在转换时如果超出范围，将直接抛出<code>ArithmeticException</code>异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">BigInteger i = <span class="keyword">new</span> BigInteger(<span class="string">&quot;123456789000&quot;</span>);</span><br><span class="line">System.out.println(i.longValue()); <span class="comment">// 123456789000</span></span><br><span class="line">System.out.println(i.multiply(i).longValueExact()); <span class="comment">// java.lang.ArithmeticException: BigInteger out of long range</span></span><br></pre></td></tr></table></figure><p>​ 使用<code>longValueExact()</code>方法时，如果超出了<code>long</code>型的范围，会抛出<code>ArithmeticException</code>。</p><h3 id="九bigdecimal">九、BigDecimal</h3><h4 id="bigdecimal简介">1、BigDecimal简介</h4><p>和<code>BigInteger</code>类似，<code>BigDecimal</code>可以表示<strong>一个任意大小且精度完全准确</strong>的浮点数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal bd = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4567&quot;</span>);</span><br><span class="line">System.out.println(bd.multiply(bd)); <span class="comment">// 15241.55677489</span></span><br></pre></td></tr></table></figure><ul><li><code>BigDecimal</code>用<code>scale()</code>输出小数位数，例如：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 2,两位小数</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><ul><li>通过<code>BigDecimal</code>的<code>stripTrailingZeros()</code>方法，可以将一个<code>BigDecimal</code>格式化为一个相等的，但去掉了末尾0的<code>BigDecimal</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.4500&quot;</span>);</span><br><span class="line">BigDecimal d2 = d1.stripTrailingZeros();</span><br><span class="line">System.out.println(d1.scale()); <span class="comment">// 4</span></span><br><span class="line">System.out.println(d2.scale()); <span class="comment">// 2,因为去掉了00</span></span><br><span class="line"></span><br><span class="line">BigDecimal d3 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;1234500&quot;</span>);</span><br><span class="line">BigDecimal d4 = d3.stripTrailingZeros();</span><br><span class="line">System.out.println(d3.scale()); <span class="comment">// 0</span></span><br><span class="line">System.out.println(d4.scale()); <span class="comment">// -2</span></span><br></pre></td></tr></table></figure><ul><li><p>如果一个<code>BigDecimal</code>的<code>scale()</code>返回负数，例如，<code>-2</code>，表示这个数是个整数，并且末尾有2个0。</p></li><li><p>可以对一个<code>BigDecimal</code>设置它的<code>scale</code>，如果精度比原始值低，那么按照指定的方法进行四舍五入或者直接截断：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456789&quot;</span>);</span><br><span class="line">        BigDecimal d2 = d1.setScale(<span class="number">4</span>, RoundingMode.HALF_UP); <span class="comment">// 四舍五入，123.4568</span></span><br><span class="line">        BigDecimal d3 = d1.setScale(<span class="number">4</span>, RoundingMode.DOWN); <span class="comment">// 直接截断，123.4567</span></span><br><span class="line">        System.out.println(d2);</span><br><span class="line">        System.out.println(d3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对<code>BigDecimal</code>做加、减、乘时，精度不会丢失，但是做除法时，存在无法除尽的情况，这时，就必须指定精度以及如何进行截断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;23.456789&quot;</span>);</span><br><span class="line">BigDecimal d3 = d1.divide(d2, <span class="number">10</span>, RoundingMode.HALF_UP); <span class="comment">// 保留10位小数并四舍五入</span></span><br><span class="line">BigDecimal d4 = d1.divide(d2); <span class="comment">// 报错：ArithmeticException，因为除不尽</span></span><br></pre></td></tr></table></figure><p>还可以对<code>BigDecimal</code>做除法的同时求余数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.345&quot;</span>);</span><br><span class="line">        BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.12&quot;</span>);</span><br><span class="line">        BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line">        System.out.println(dr[<span class="number">0</span>]); <span class="comment">// 102</span></span><br><span class="line">        System.out.println(dr[<span class="number">1</span>]); <span class="comment">// 0.105</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>divideAndRemainder()</code>方法时，返回的数组包含两个<code>BigDecimal</code>，分别是商和余数，其中商总是整数，余数不会大于除数。我们可以利用这个方法判断两个<code>BigDecimal</code>是否是整数倍数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal n = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;12.75&quot;</span>);</span><br><span class="line">BigDecimal m = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;0.15&quot;</span>);</span><br><span class="line">BigDecimal[] dr = n.divideAndRemainder(m);</span><br><span class="line"><span class="keyword">if</span> (dr[<span class="number">1</span>].signum() == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">// n是m的整数倍</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="比较bigdecimal">2、比较BigDecimal</h4><p>在比较两个<code>BigDecimal</code>的值是否相等时，要特别注意，使用<code>equals()</code>方法不但要求两个<code>BigDecimal</code>的值相等，还要求它们的<code>scale()</code>相等：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">BigDecimal d1 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.456&quot;</span>);</span><br><span class="line">BigDecimal d2 = <span class="keyword">new</span> BigDecimal(<span class="string">&quot;123.45600&quot;</span>);</span><br><span class="line">System.out.println(d1.equals(d2)); <span class="comment">// false,因为scale不同</span></span><br><span class="line">System.out.println(d1.equals(d2.stripTrailingZeros())); <span class="comment">// true,因为d2去除尾部0后scale变为2</span></span><br><span class="line">System.out.println(d1.compareTo(d2)); <span class="comment">// 0</span></span><br></pre></td></tr></table></figure><p>必须使用<code>compareTo()</code>方法来比较，它根据两个值的大小分别返回负数、正数和<code>0</code>，分别表示小于、大于和等于。</p><p>总是使用compareTo()比较两个BigDecimal的值，不要使用equals()！</p><p>如果查看<code>BigDecimal</code>的源码，可以发现，实际上一个<code>BigDecimal</code>是通过一个<code>BigInteger</code>和一个<code>scale</code>来表示的，即<code>BigInteger</code>表示一个完整的整数，而<code>scale</code>表示小数位数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BigDecimal</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">BigDecimal</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BigInteger intVal;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> scale;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>BigDecimal</code>也是从<code>Number</code>继承的，也是不可变对象。</p><h3 id="十常用工具类">十、常用工具类</h3><h4 id="math">1、Math</h4><ul><li>求绝对值：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.abs(-<span class="number">100</span>); <span class="comment">// 100</span></span><br><span class="line">Math.abs(-<span class="number">7.8</span>); <span class="comment">// 7.8</span></span><br></pre></td></tr></table></figure><ul><li>取最大或最小值:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.max(<span class="number">100</span>, <span class="number">99</span>); <span class="comment">// 100</span></span><br><span class="line">Math.min(<span class="number">1.2</span>, <span class="number">2.3</span>); <span class="comment">// 1.2</span></span><br></pre></td></tr></table></figure><ul><li>计算<span class="math inline">\(x^y\)</span>次方：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">10</span>); <span class="comment">// 2的10次方=1024</span></span><br></pre></td></tr></table></figure><ul><li>计算√x：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.sqrt(<span class="number">2</span>); <span class="comment">// 1.414...</span></span><br></pre></td></tr></table></figure><ul><li>计算ex次方：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.exp(<span class="number">2</span>); <span class="comment">// 7.389...</span></span><br></pre></td></tr></table></figure><ul><li>计算以e为底的对数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log(<span class="number">4</span>); <span class="comment">// 1.386...</span></span><br></pre></td></tr></table></figure><ul><li>计算以10为底的对数：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.log10(<span class="number">100</span>); <span class="comment">// 2</span></span><br></pre></td></tr></table></figure><ul><li>Math还提供了几个数学常量：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> pi = Math.PI; <span class="comment">// 3.14159...</span></span><br><span class="line"><span class="keyword">double</span> e = Math.E; <span class="comment">// 2.7182818...</span></span><br><span class="line">Math.sin(Math.PI / <span class="number">6</span>); <span class="comment">// sin(π/6) = 0.5</span></span><br></pre></td></tr></table></figure><ul><li>生成一个随机数x，x的范围是<code>0 &lt;= x &lt; 1</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.random(); <span class="comment">// 0.53907... 每次都不一样</span></span><br></pre></td></tr></table></figure><h4 id="random">2、Random</h4><p><code>Random</code>用来创建伪随机数。所谓伪随机数，是指只要给定一个初始的种子，产生的随机数序列是完全一样的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Random r = <span class="keyword">new</span> Random();</span><br><span class="line">r.nextInt(); <span class="comment">// 2071575453,每次都不一样</span></span><br><span class="line">r.nextInt(<span class="number">10</span>); <span class="comment">// 5,生成一个[0,10)之间的int</span></span><br><span class="line">r.nextLong(); <span class="comment">// 8811649292570369305,每次都不一样</span></span><br><span class="line">r.nextFloat(); <span class="comment">// 0.54335...生成一个[0,1)之间的float</span></span><br><span class="line">r.nextDouble(); <span class="comment">// 0.3716...生成一个[0,1)之间的double</span></span><br></pre></td></tr></table></figure><p>这是因为我们创建<code>Random</code>实例时，如果不给定种子，就使用系统当前时间戳作为种子，因此每次运行时，种子不同，得到的伪随机数序列就不同。</p><p>如果我们在创建<code>Random</code>实例时指定一个种子，就会得到完全确定的随机数序列：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Random r = <span class="keyword">new</span> Random(<span class="number">12345</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            System.out.println(r.nextInt(<span class="number">100</span>));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 51, 80, 41, 28, 55...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="securerandom">3、SecureRandom</h4><p>​ 有伪随机数，就有真随机数。实际上真正的真随机数只能通过量子力学原理来获取，而我们想要的是一个不可预测的安全的随机数，<code>SecureRandom</code>就是用来创建安全的随机数的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">SecureRandom sr = <span class="keyword">new</span> SecureRandom();</span><br><span class="line">System.out.println(sr.nextInt(<span class="number">100</span>));</span><br></pre></td></tr></table></figure><p><code>SecureRandom</code>的安全性是通过操作系统提供的安全的随机种子来生成随机数。这个种子是通过CPU的热噪声、读写磁盘的字节、网络流量等各种随机事件产生的“熵”。</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于java核心类的笔记，包括字符串、编码、StringBuilder、StringJoiner、包装、JavaBean、枚举、记录、BigInteger、BigDecimal、常用工具类等内容。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
    <category term="core class" scheme="https://blog.slks.xyz/tags/core-class/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记2——java面向对象编程基础</title>
    <link href="https://blog.slks.xyz/2022/01/29/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02%E2%80%94java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/"/>
    <id>https://blog.slks.xyz/2022/01/29/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B02%E2%80%94java%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B/</id>
    <published>2022-01-29T03:34:19.000Z</published>
    <updated>2022-01-30T11:36:15.675Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</p><h3 id="一类的方法">一、类的方法</h3><h4 id="一个类通过定义public方法就可以给外部代码暴露一些操作的接口">1、一个类通过定义public方法，就可以给外部代码暴露一些操作的接口。</h4><p>一般而言内部的变量设置为private，对内部变量的操作由暴露的接口进行，这样内部能够自己保证逻辑一致性。</p><p>在public的方法内部，我们就有机会检查参数对不对。比如：<code>setName()</code>方法可以做检查，例如，不允许传入<code>null</code>和空字符串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (name == <span class="keyword">null</span> || name.isBlank()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">&quot;invalid name&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.name = name.strip(); <span class="comment">// 去掉首尾空格</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="在方法内部可以使用一个隐含的变量this它始终指向当前实例">2、在方法内部，可以使用一个隐含的变量<code>this</code>，它始终指向当前实例</h4><p>如果没有命名冲突，可以省略<code>this</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name; <span class="comment">// 相当于this.name</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可变参数">3、可变参数：</h4><p>可变参数用<code>类型...</code>定义，可变参数相当于数组类型,可变参数可以保证无法传入<code>null</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Group</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String[] names;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNames</span><span class="params">(String... names)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.names = names;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Group g = <span class="keyword">new</span> Group();</span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>, <span class="string">&quot;Xiao Jun&quot;</span>); <span class="comment">// 传入3个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="string">&quot;Xiao Hong&quot;</span>); <span class="comment">// 传入2个String</span></span><br><span class="line">g.setNames(<span class="string">&quot;Xiao Ming&quot;</span>); <span class="comment">// 传入1个String</span></span><br><span class="line">g.setNames(); <span class="comment">// 传入0个String</span></span><br></pre></td></tr></table></figure><h4 id="参数传递">4、参数传递：</h4><p>引用类型参数的传递，调用方的变量，和接收方的参数变量，指向的是同一个对象。双方任意一方对这个对象的修改，都会影响对方（因为指向同一个对象嘛）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 一个陷阱题目</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        String bob = <span class="string">&quot;Bob&quot;</span>;</span><br><span class="line">        p.setName(bob); <span class="comment">// 传入bob变量</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;</span></span><br><span class="line">        bob = <span class="string">&quot;Alice&quot;</span>; <span class="comment">// bob改名为Alice</span></span><br><span class="line">        System.out.println(p.getName()); <span class="comment">// &quot;Bob&quot;还是&quot;Alice&quot;?</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//回答： 应该是Alice：</span></span><br><span class="line"><span class="comment">// String bob = &quot;Bob&quot;; 的时候，为其分配内存，然后bob 是一个指针，指向该内存，比如0x0011.</span></span><br><span class="line"><span class="comment">// bob = &quot;Alice&quot; 时发生了重新赋值</span></span><br><span class="line"><span class="comment">// 但在java中String类型是不可变的，当发生改变时，会重新分配内存，即生成一个新的内存地址，例如：0x0022,这个时候，现在的bob的内存指向&quot;Alice&quot;，也就是指向0x0022，而p.bob的内存指向仍为0x0011，也就是Bob，所以输出的依旧是Bob。</span></span><br></pre></td></tr></table></figure><h3 id="二构造方法">二、构造方法：</h3><h4 id="没有在构造方法中初始化字段时引用类型的字段默认是null数值类型的字段用默认值int类型默认值是0布尔类型默认值是false">1、没有在构造方法中初始化字段时，引用类型的字段默认是<code>null</code>，数值类型的字段用默认值，<code>int</code>类型默认值是<code>0</code>，布尔类型默认值是<code>false</code>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name; <span class="comment">// 默认初始化为null</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age; <span class="comment">// 默认初始化为0</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="可以定义多个构造方法">2、可以定义多个构造方法：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="既对字段进行初始化又在构造方法中对字段进行初始化">3、既对字段进行初始化，又在构造方法中对字段进行初始化：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Person &#123;</span><br><span class="line">    private String name = &quot;Unamed&quot;;</span><br><span class="line">    private int age = 10;</span><br><span class="line"></span><br><span class="line">    public Person(String name, int age) &#123;</span><br><span class="line">        this.name = name;</span><br><span class="line">        this.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当我们创建对象的时候，<code>new Person("Xiao Ming", 12)</code>得到的对象实例，字段的初始值是啥？</p><p>在Java中，创建对象实例的时候，按照如下顺序进行初始化：</p><ol type="1"><li>先初始化字段，例如，<code>int age = 10;</code>表示字段初始化为<code>10</code>，<code>double salary;</code>表示字段默认初始化为<code>0</code>，<code>String name;</code>表示引用类型字段默认初始化为<code>null</code>；</li><li>执行构造方法的代码进行初始化。</li></ol><p>​ 因此，<strong>构造方法的代码由于后运行</strong>，所以，<code>new Person("Xiao Ming", 12)</code>的字段值最终由构造方法的代码确定。</p><h4 id="一个构造方法可以调用其他构造方法这样做的目的是便于代码复用调用其他构造方法的语法是this">4、一个构造方法可以调用其他构造方法，这样做的目的是便于代码复用。调用其他构造方法的语法是<code>this(…)</code>：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(name, <span class="number">18</span>); <span class="comment">// 调用另一个构造方法Person(String, int)</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="string">&quot;Unnamed&quot;</span>); <span class="comment">// 调用另一个构造方法Person(String)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="三方法重载overload">三、方法重载Overload：</h3><ul><li><p>方法重载是指多个方法的方法名相同，但各自的参数不同；</p></li><li><p>重载方法应该完成类似的功能，参考<code>String</code>的<code>indexOf()</code>；</p></li><li><p><strong>重载方法返回值类型应该相同,各自的参数应当不同</strong></p></li></ul><h3 id="四继承">四、继承：</h3><h4 id="基础继承与protected关键字">1、基础继承与Protected关键字：</h4><ul><li><p>Java使用<code>extends</code>关键字来实现继承：</p></li><li><p>注意：子类自动获得了父类的所有字段，严禁定义与父类重名的字段！</p></li><li><p>Java只允许一个class继承自一个类，因此，一个类有且仅有一个父类。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getAge</span><span class="params">()</span> </span>&#123;...&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(<span class="keyword">int</span> age)</span> </span>&#123;...&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 不要重复name和age字段/方法,</span></span><br><span class="line">    <span class="comment">// 只需要定义新增score字段/方法:</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getScore</span><span class="params">()</span> </span>&#123; … &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setScore</span><span class="params">(<span class="keyword">int</span> score)</span> </span>&#123; … &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>子类无法访问父类的<code>private</code>字段或者<code>private</code>方法</li><li>父类中用<code>protected</code>修饰的字段可以被子类访问</li><li><code>protected</code>关键字可以把字段和方法的访问权限控制在继承树内部，一个<code>protected</code>字段和方法可以被其子类，以及子类的子类所访问</li></ul><h4 id="super关键字">2、Super关键字：</h4><ul><li><p><code>super</code>关键字表示父类（超类）。子类引用父类的字段时，可以用<code>super.fieldName</code>。</p></li><li><p>观察以下代码，为何会编译错误？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Student s = <span class="keyword">new</span> Student(<span class="string">&quot;Xiao Ming&quot;</span>, <span class="number">12</span>, <span class="number">89</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Person</span><span class="params">(String name, <span class="keyword">int</span> age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li><li><p>在Java中，任何<code>class</code>的构造方法，第一行语句必须是调用父类的构造方法。如果没有明确地调用父类的构造方法，编译器会帮我们自动加一句<code>super();</code>，所以，<code>Student</code>类的构造方法实际上是这样：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(); <span class="comment">// 自动调用父类的构造方法</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是，<code>Person</code>类并没有无参数的构造方法，因此，编译失败。</p><p>解决方法是调用<code>Person</code>类存在的某个构造方法。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">int</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Student</span><span class="params">(String name, <span class="keyword">int</span> age, <span class="keyword">int</span> score)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(name, age); <span class="comment">// 调用父类的构造方法Person(String, int)</span></span><br><span class="line">        <span class="keyword">this</span>.score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>结论：如果父类没有默认的构造方法，子类就必须显式调用<code>super()</code>并给出参数以便让编译器定位到父类的一个合适的构造方法。且子类不会继承任何父类的构造方法。子类默认的构造方法是编译器自动生成的，不是继承的。</li></ul><h4 id="阻止继承">3、阻止继承：</h4><ul><li>正常情况下，只要某个class没有<code>final</code>修饰符，那么任何类都可以从该class继承。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// compile error: 不允许继承自Person</span></span><br><span class="line">Student extends Person &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从Java 15开始，允许使用<code>sealed</code>修饰class，并通过<code>permits</code>明确写出能够从该class继承的子类名称。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> sealed <span class="class"><span class="keyword">class</span> <span class="title">Shape</span> <span class="title">permits</span> <span class="title">Rect</span>, <span class="title">Circle</span>, <span class="title">Triangle</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意：这种<code>sealed</code>类主要用于一些框架，防止继承被滥用。</li></ul><p><code>sealed</code>类在Java 15中目前是预览状态，要启用它，必须使用参数<code>--enable-preview</code>和<code>--source 15</code>。</p><h4 id="向上转型">4、向上转型：</h4><p>​ 把一个子类类型赋值给父类类型的变量，被称为向上转型（upcasting）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">Person p = s; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o1 = p; <span class="comment">// upcasting, ok</span></span><br><span class="line">Object o2 = s; <span class="comment">// upcasting, ok</span></span><br></pre></td></tr></table></figure><p>​ 注意到继承树是<code>Student &gt; Person &gt; Object</code>，所以，可以把<code>Student</code>类型转型为<code>Person</code>，或者更高层次的<code>Object</code>。</p><h4 id="向下转型">5、向下转型：</h4><p>​ 如果把一个父类类型强制转型为子类类型，就是向下转型（downcasting）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Person p1 = <span class="keyword">new</span> Student(); <span class="comment">// upcasting, ok</span></span><br><span class="line">Person p2 = <span class="keyword">new</span> Person();</span><br><span class="line">Student s1 = (Student) p1; <span class="comment">// ok</span></span><br><span class="line">Student s2 = (Student) p2; <span class="comment">// runtime error! ClassCastException!</span></span><br></pre></td></tr></table></figure><ul><li><p><code>Person</code>类型<code>p1</code>实际指向<code>Student</code>实例，</p></li><li><p><code>Person</code>类型变量<code>p2</code>实际指向<code>Person</code>实例。</p></li></ul><p>在向下转型的时候：</p><ul><li><p>把<code>p1</code>转型为<code>Student</code>会成功，因为<code>p1</code>确实指向<code>Student</code>实例，</p></li><li><p>把<code>p2</code>转型为<code>Student</code>会失败，因为<code>p2</code>的实际类型是<code>Person</code>，不能把父类变为子类，因为子类功能比父类多，多的功能无法凭空变出来。</p></li></ul><p>因此，向下转型很可能会失败。失败的时候，Java虚拟机会报<code>ClassCastException</code>。</p><p>为了避免向下转型出错，Java提供了<code>instanceof</code>操作符，可以先判断一个实例究竟是不是某种类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Person();</span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(p <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Person); <span class="comment">// true</span></span><br><span class="line">System.out.println(s <span class="keyword">instanceof</span> Student); <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line">Student n = <span class="keyword">null</span>;</span><br><span class="line">System.out.println(n <span class="keyword">instanceof</span> Student); <span class="comment">// false</span></span><br></pre></td></tr></table></figure><p><code>instanceof</code>实际上判断一个变量所指向的实例是否是指定类型，或者这个类型的子类。如果一个引用变量为<code>null</code>，那么对任何<code>instanceof</code>的判断都为<code>false</code>。</p><p>利用<code>instanceof</code>，在向下转型前可以先判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line"><span class="keyword">if</span> (p <span class="keyword">instanceof</span> Student) &#123;</span><br><span class="line">    <span class="comment">// 只有判断成功才会向下转型:</span></span><br><span class="line">    Student s = (Student) p; <span class="comment">// 一定会成功</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五多态">五、多态：</h3><h4 id="覆写-override">1、覆写 Override</h4><p>在继承关系中，子类如果定义了一个与父类方法签名完全相同的方法，被称为覆写（Override）。</p><ul><li><p>OverRide传入参数与返回值都应该相同。</p></li><li><p>加上<code>@Override</code>可以让编译器帮助检查是否进行了正确的覆写。希望进行覆写，但是不小心写错了方法签名，编译器会报错。</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span> <span class="comment">// Compile error!</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">(String s)</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="多态">2、多态</h4><p>Java的实例方法调用是基于运行时的实际类型的动态调用，而非变量的声明类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person p = <span class="keyword">new</span> Student();</span><br><span class="line">p.run(); <span class="comment">// 运行的时Student的run()方法</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runTwice</span><span class="params">(Person p)</span> </span>&#123;</span><br><span class="line">    p.run();</span><br><span class="line">    p.run(); <span class="comment">//它传入的参数类型是Person，我们是无法知道传入的参数实际类型究竟是Person，还是Student，还是Person的其他子类，因此，也无法确定调用的是不是Person类定义的run()方法。</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>多态的特性就是，运行期才能动态决定调用的子类方法。对某个类型调用某个方法，执行的实际方法可能是某个子类的覆写方法。这种不确定性的方法调用，究竟有什么作用？</strong></p><p>​ 示例如下：</p><ul><li>假设我们定义一种收入，需要给它报税，那么先定义一个<code>Income</code>类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">double</span> income;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> income * <span class="number">0.1</span>; <span class="comment">// 税率10%</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于工资收入，可以减去一个基数，那么我们可以从<code>Income</code>派生出<code>Salary</code>，并覆写<code>getTax()</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Salary</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (income &lt;= <span class="number">5000</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (income - <span class="number">5000</span>) * <span class="number">0.2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果你享受国务院特殊津贴，那么按照规定，可以全部免税：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StateCouncilSpecialAllowance</span> <span class="keyword">extends</span> <span class="title">Income</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">getTax</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在，我们要编写一个报税的财务软件，对于一个人的所有收入进行报税，可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 给一个有普通收入、工资收入和享受国务院特殊津贴的小伙伴算税:</span></span><br><span class="line">        Income[] incomes = <span class="keyword">new</span> Income[] &#123;</span><br><span class="line">            <span class="keyword">new</span> Income(<span class="number">3000</span>),</span><br><span class="line">            <span class="keyword">new</span> Salary(<span class="number">7500</span>),</span><br><span class="line">            <span class="keyword">new</span> StateCouncilSpecialAllowance(<span class="number">15000</span>)</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(totalTax(incomes));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">double</span> <span class="title">totalTax</span><span class="params">(Income... incomes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">double</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Income income: incomes) &#123;</span><br><span class="line">            total = total + income.getTax();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>观察<code>totalTax()</code>方法：利用多态，<code>totalTax()</code>方法只需要和<code>Income</code>打交道，它完全不需要知道<code>Salary</code>和<code>StateCouncilSpecialAllowance</code>的存在，就可以正确计算出总的税。如果我们要新增一种稿费收入，只需要从<code>Income</code>派生，然后正确覆写<code>getTax()</code>方法就可以。把新的类型传入<code>totalTax()</code>，不需要修改任何代码。</strong></p><h4 id="覆写object类的方法">3、覆写Object类的方法：</h4><p>​ 因为所有的<code>class</code>最终都继承自<code>Object</code>，而<code>Object</code>定义了几个重要的方法：</p><ul><li><code>toString()</code>：把instance输出为<code>String</code>；</li><li><code>equals()</code>：判断两个instance是否逻辑相等；</li><li><code>hashCode()</code>：计算一个instance的哈希值。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 显示更有意义的字符串:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Person:name=&quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 比较是否相等:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 当且仅当o为Person类型:</span></span><br><span class="line">        <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Person) &#123;</span><br><span class="line">            Person p = (Person) o;</span><br><span class="line">            <span class="comment">// 并且name字段相同时，返回true:</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name.equals(p.name);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算hash:</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.name.hashCode();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="super调用">4、Super调用</h4><p>在子类的覆写方法中，如果要调用父类的被覆写的方法，可以通过<code>super</code>来调用。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Student extends Person &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 调用父类的hello()方法:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.hello() + <span class="string">&quot;!&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final-字段">5、Final 字段</h4><ul><li>如果一个父类不允许子类对它的某个方法进行覆写，可以把该方法标记为<code>final</code>。用<code>final</code>修饰的方法不能被<code>Override</code>：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> String name;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Hello, &quot;</span> + name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>对于一个类的实例字段，同样可以用<code>final</code>修饰。用<code>final</code>修饰的字段在初始化后不能被修改。例如:</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> String name = <span class="string">&quot;Unamed&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="六抽象类">六、抽象类</h3><ul><li>如果父类的方法本身不需要实现任何功能，仅仅是为了定义方法签名，目的是让子类去覆写它，那么，可以把父类的方法声明为抽象方法：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//编译错误</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//编译成功</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>abstract</code>定义的方法是抽象方法，它只有定义，没有实现。抽象方法定义了子类必须实现的接口规范；</p></li><li><p>定义了抽象方法的class必须被定义为抽象类，从抽象类继承的子类必须实现抽象方法；</p></li><li><p>如果不实现抽象方法，则该子类仍是一个抽象类；</p></li></ul><h3 id="七面向抽象编程">七、面向抽象编程：</h3><p>我们定义了抽象类<code>Person</code>，以及具体的<code>Student</code>、<code>Teacher</code>子类的时候，我们可以通过抽象类<code>Person</code>类型去引用具体的子类的实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person s = <span class="keyword">new</span> Student();</span><br><span class="line">Person t = <span class="keyword">new</span> Teacher();</span><br></pre></td></tr></table></figure><p>这种引用抽象类的好处在于，我们对其进行方法调用，并不关心<code>Person</code>类型变量的具体子类型：</p><p>这种尽量引用高层类型，避免引用实际子类型的方式，称之为面向抽象编程。</p><p>面向抽象编程的本质就是：</p><ul><li>上层代码只定义规范（例如：<code>abstract class Person</code>）；</li><li>不需要子类就可以实现业务逻辑（正常编译）；</li><li>具体的业务逻辑由不同的子类实现，调用者并不关心。</li></ul><h3 id="八接口interface">八、接口Interface</h3><h4 id="基础知识">1、基础知识</h4><p>如果一个抽象类没有字段，所有方法全部都是抽象方法：就可以把该抽象类改写为接口：<code>interface</code>。</p><p>在Java中，使用<code>interface</code>可以声明一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所谓<code>interface</code>，就是比抽象类还要抽象的纯抽象接口，因为它连字段都不能有。因为接口定义的所有方法默认都是<code>public abstract</code>的，所以这两个修饰符不需要写出来（写不写效果都一样)</p><ul><li><p>当一个具体的<code>class</code>去实现一个<code>interface</code>时，需要使用<code>implements</code>关键字。</p></li><li><p>```java class Student implements Person { private String name;</p><pre><code>public Student(String name) &#123;    this.name = name;&#125;@Overridepublic void run() &#123;    System.out.println(this.name + &quot; run&quot;);&#125;@Overridepublic String getName() &#123;    return this.name;&#125;</code></pre><p>} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 一个类可以实现多个`interface`</span><br><span class="line"></span><br><span class="line">- ```</span><br><span class="line">  class Student implements Person, Hello &#123; // 实现了两个interface</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p></li></ul><h4 id="接口继承使用extends">2、接口继承：使用extends</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">Person</span> <span class="keyword">extends</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="default方法">3、default方法：</h3><p>在接口中，可以定义<code>default</code>方法。</p><p><strong>实现类可以不必覆写<code>default</code>方法。</strong></p><p><code>default</code>方法的目的是，当我们需要给接口新增一个方法时，将会涉及到修改全部子类。</p><p>但如果新增的是<code>default</code>方法，那么子类就不必全部修改，只需要在需要覆写的地方去覆写新增方法。</p><h3 id="九静态字段和静态方法">九、静态字段和静态方法：</h3><h4 id="静态字段">1、静态字段：</h4><p>​ 所有实例共享一个静态字段。推荐用类名来访问静态字段。可以把静态字段理解为描述<code>class</code>本身的字段（非实例字段）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Person.number = <span class="number">99</span>;</span><br><span class="line">System.out.println(Person.number);</span><br></pre></td></tr></table></figure><h4 id="静态方法">2、静态方法：</h4><ul><li><p>调用实例方法必须通过一个实例变量，而调用静态方法则不需要实例变量，通过类名就可以调用</p></li><li><p>静态方法内部，无法访问<code>this</code>变量，也无法访问实例字段，它只能访问静态字段</p></li></ul><h4 id="接口的静态字段">3、接口的静态字段：</h4><ul><li>因为<code>interface</code>是一个纯抽象类，所以它不能定义实例字段。但是，<code>interface</code>是可以有静态字段的，并且静态字段必须为<code>final</code>类型：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 实际上，因为<code>interface</code>的字段只能是<code>public static final</code>类型，所以我们可以把这些修饰符都去掉，上述代码可以简写为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 编译器会自动加上public statc final:</span></span><br><span class="line">    <span class="keyword">int</span> MALE = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> FEMALE = <span class="number">2</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十包">十、包：</h3><h4 id="简介">1、简介：</h4><p>如果小军写了一个<code>Arrays</code>类，恰好JDK也自带了一个<code>Arrays</code>类，如何解决类名冲突？</p><p>在Java中，我们使用<code>package</code>来解决名字冲突。</p><p><strong>Java定义了一种名字空间，称之为包：<code>package</code>。一个类总是属于某个包，类名（比如<code>Person</code>）只是一个简写，真正的完整类名是<code>包名.类名</code>。</strong></p><p>例如：</p><ul><li><p>小明的<code>Person</code>类存放在包<code>ming</code>下面，因此，完整类名是<code>ming.Person</code>；</p></li><li><p>小红的<code>Person</code>类存放在包<code>hong</code>下面，因此，完整类名是<code>hong.Person</code>；</p></li><li><p>小军的<code>Arrays</code>类存放在包<code>mr.jun</code>下面，因此，完整类名是<code>mr.jun.Arrays</code>；</p></li></ul><h4 id="如何申明包">2、如何申明包：</h4><p>在定义<code>class</code>的时候，我们需要在第一行声明这个<code>class</code>属于哪个包。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> ming; <span class="comment">// 申明包名ming</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：包没有父子关系。java.util和java.util.zip是不同的包，两者没有任何继承关系。</p><h4 id="组织java文件">3、组织java文件：</h4><p>我们还需要按照包结构把上面的Java文件组织起来。假设以<code>package_sample</code>作为根目录，<code>src</code>作为源码目录，那么所有文件结构就是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ src</span><br><span class="line">    ├─ hong</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    │  ming</span><br><span class="line">    │  └─ Person.java</span><br><span class="line">    └─ mr</span><br><span class="line">       └─ jun</span><br><span class="line">          └─ Arrays.java</span><br></pre></td></tr></table></figure><h4 id="包作用域">4、包作用域：</h4><p>​ 位于同一个包的类，可以访问包作用域的字段和方法。不用<code>public</code>、<code>protected</code>、<code>private</code>修饰的字段和方法就是包作用域。例如，<code>Person</code>类定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 包作用域:</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Main</code>类也定义在<code>hello</code>包下面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> hello;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Person p = <span class="keyword">new</span> Person();</span><br><span class="line">        p.hello(); <span class="comment">// 可以调用，因为Main和Person在同一个包</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="包的引入">5、包的引入：</h4><h4 id="在一个class中我们总会引用其他的class由3种方法">1、在一个<code>class</code>中，我们总会引用其他的<code>class</code>，由3种方法：</h4><ul><li>写完整类名：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mr.jun.Arrays arrays = <span class="keyword">new</span> mr.jun.Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>用<code>import</code>语句，导入小军的<code>Arrays</code>，然后写简单类名：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入完整类名:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays arrays = <span class="keyword">new</span> Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>在写<code>import</code>的时候，可以使用<code>*</code>，表示把这个包下面的所有<code>class</code>都导入进来（但不包括子包的<code>class</code>）：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.java</span></span><br><span class="line"><span class="keyword">package</span> ming;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 导入mr.jun包的所有class:</span></span><br><span class="line"><span class="keyword">import</span> mr.jun.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Arrays arrays = <span class="keyword">new</span> Arrays();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="java编译器如何查找">2、Java编译器如何查找？</h4><p>Java编译器最终编译出的<code>.class</code>文件只使用完整类名，因此，在代码中，当编译器遇到一个<code>class</code>名称时：</p><ul><li>如果是完整类名，就直接根据完整类名查找这个<code>class</code>；</li><li>如果是简单类名，按下面的顺序依次查找：<ul><li>查找当前<code>package</code>是否存在这个<code>class</code>；</li><li>查找<code>import</code>的包是否包含这个<code>class</code>；</li><li>查找<code>java.lang</code>包是否包含这个<code>class</code>。</li></ul></li></ul><h4 id="最佳实践">3、最佳实践：</h4><p>为了避免名字冲突，我们需要确定唯一的包名。推荐的做法是使用倒置的作用域名来确保唯一性。例如：</p><ul><li>org.apache</li><li>org.apache.commons.log</li><li>com.liaoxuefeng.sample</li></ul><p>子包就可以根据功能自行命名。</p><h3 id="十一作用域">十一、作用域：</h3><h4 id="public">1、public</h4><ul><li><p>定义为<code>public</code>的<code>class</code>、<code>interface</code>可以被其他任何类访问</p></li><li><p>定义为<code>public</code>的<code>field</code>、<code>method</code>可以被其他类访问，前提是首先有访问<code>class</code>的权限：</p></li></ul><h4 id="private">2、private</h4><ul><li><p>定义为<code>private</code>的<code>field</code>、<code>method</code>无法被其他类访问</p></li><li><p><code>private</code>访问权限被限定在<code>class</code>的内部，而且与方法声明顺序<em>无关</em>。推荐把<code>private</code>方法放到后面，因为<code>public</code>方法定义了类对外提供的功能，阅读代码的时候，应该先关注<code>public</code>方法</p></li><li><p>Java支持嵌套类，如果一个类内部还定义了嵌套类，那么，嵌套类拥有访问<code>private</code>的权限：</p></li><li><p><strong>嵌套类</strong>：</p></li><li><p>定义在一个<code>class</code>内部的<code>class</code>称为嵌套类（<code>nested class</code>），Java支持好几种嵌套类。</p></li><li><p>``` public class Main { public static void main(String[] args) { Inner i = new Inner(); i.hi(); }</p><pre><code>// private方法:private static void hello() &#123;    System.out.println(&quot;private hello!&quot;);&#125;// 静态内部类:static class Inner &#123;    public void hi() &#123;        Main.hello();    &#125;&#125;</code></pre><p>}</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 3、protected</span><br><span class="line"></span><br><span class="line">- `protected`作用于继承关系。定义为`protected`的字段和方法可以被子类访问，以及子类的子类</span><br><span class="line"></span><br><span class="line">#### 4、package：</span><br><span class="line"></span><br><span class="line">- 包作用域是指一个类允许访问同一个`package`的没有`public`、`private`修饰的`class`，以及没有`public`、`protected`、`private`修饰的字段和方法。</span><br><span class="line"></span><br><span class="line">```java</span><br><span class="line">package abc;</span><br><span class="line">// package权限的类:</span><br><span class="line">class Hello &#123;</span><br><span class="line">    // package权限的方法:</span><br><span class="line">    void hi() &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>只要在同一个包，就可以访问<code>package</code>权限的<code>class</code>、<code>field</code>和<code>method</code>：</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> abc;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 可以访问package权限的类:</span></span><br><span class="line">        Hello h = <span class="keyword">new</span> Hello();</span><br><span class="line">        <span class="comment">// 可以调用package权限的方法:</span></span><br><span class="line">        h.hi();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="final">5、final</h4><p><code>final</code>与访问权限不冲突，它有很多作用：</p><ul><li>用<code>final</code>修饰<code>class</code>可以阻止被继承：</li><li>用<code>final</code>修饰<code>method</code>可以阻止被子类覆写</li><li>用<code>final</code>修饰<code>field</code>可以阻止被重新赋值</li><li>用<code>final</code>修饰局部变量可以阻止被重新赋值</li></ul><h4 id="最佳实践-1">6、最佳实践：</h4><ul><li><p>如果不确定是否需要<code>public</code>，就不声明为<code>public</code>，即尽可能少地暴露对外的字段和方法。</p></li><li><p>把方法定义为<code>package</code>权限有助于测试，因为测试类和被测试类只要位于同一个<code>package</code>，测试代码就可以访问被测试类的<code>package</code>权限方法。</p></li><li><p><strong>一个<code>.java</code>文件只能包含一个<code>public</code>类，但可以包含多个非<code>public</code>类。如果有<code>public</code>类，文件名必须和<code>public</code>类的名字相同。</strong></p></li></ul><h3 id="十二内部类">十二、内部类：</h3><p>Java的内部类分为好几种，通常情况用得不多，但也需要了解它们是如何使用的</p><h4 id="inner-class">1、Inner Class</h4><p>如果一个类定义在另一个类的内部，这个类就是Inner Class：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 定义了一个Inner Class</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Inner Class的实例不能单独存在，必须依附于一个Outer Class的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>); <span class="comment">// 实例化一个Outer</span></span><br><span class="line">        Outer.Inner inner = outer.<span class="function">new <span class="title">Inner</span><span class="params">()</span></span>; <span class="comment">// 实例化一个Inner</span></span><br><span class="line">        inner.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Inner</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Outer.Inner inner = outer.new Inner();</span><br></pre></td></tr></table></figure><ul><li><p>Inner Class和普通Class相比，除了能引用Outer实例外，还有一个额外的“特权”，<strong>就是可以修改Outer Class的<code>private</code>字段</strong>，因为Inner Class的作用域在Outer Class内部，所以能访问Outer Class的<code>private</code>字段和方法。</p></li><li><p>观察Java编译器编译后的<code>.class</code>文件可以发现，<code>Outer</code>类被编译为<code>Outer.class</code>，而<code>Inner</code>类被编译为<code>Outer$Inner.class</code>。</p></li></ul><h4 id="anonymous-class">2、Anonymous Class</h4><p>​ 有一种定义Inner Class的方法，它不需要在Outer Class中明确地定义这个Class，而是在方法内部，通过匿名类（Anonymous Class）来定义。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer outer = <span class="keyword">new</span> Outer(<span class="string">&quot;Nested&quot;</span>);</span><br><span class="line">        outer.asyncHello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">asyncHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.<span class="keyword">this</span>.name);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="keyword">new</span> Thread(r).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 观察<code>asyncHello()</code>方法，我们在方法内部实例化了一个<code>Runnable</code>。<code>Runnable</code>本身是接口，接口是不能实例化的，所以这里实际上是定义了一个实现了<code>Runnable</code>接口的匿名类，并且通过<code>new</code>实例化该匿名类，然后转型为<code>Runnable</code>。在定义匿名类的时候就必须实例化它，定义匿名类的写法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Runnable r = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="comment">// 实现必要的抽象方法...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>匿名类和Inner Class一样，可以访问Outer Class的<code>private</code>字段和方法。之所以我们要定义匿名类，是因为在这里我们通常不关心类名，比直接定义Inner Class可以少写很多代码。</p><h4 id="static-nested-class-静态内部类">3、Static Nested Class 静态内部类：</h4><p>最后一种内部类和Inner Class类似，但是使用<code>static</code>修饰，称为静态内部类（Static Nested Class）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Outer.StaticNested sn = <span class="keyword">new</span> Outer.StaticNested();</span><br><span class="line">        sn.hello();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Outer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> String NAME = <span class="string">&quot;OUTER&quot;</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    Outer(String name) &#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticNested</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Hello, &quot;</span> + Outer.NAME);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 用<code>static</code>修饰的内部类和Inner Class有很大的不同，它不再依附于<code>Outer</code>的实例，而是一个完全独立的类，因此无法引用<code>Outer.this</code>，但它可以访问<code>Outer</code>的<code>private</code>静态字段和静态方法。如果把<code>StaticNested</code>移到<code>Outer</code>之外，就失去了访问<code>private</code>的权限。</p><h4 id="总结">4、总结：</h4><p>Java的内部类可分为Inner Class、Anonymous Class和Static Nested Class三种：</p><ul><li>Inner Class和Anonymous Class本质上是相同的，都必须依附于Outer Class的实例，即隐含地持有<code>Outer.this</code>实例，并拥有Outer Class的<code>private</code>访问权限；</li><li>Static Nested Class是独立类，但拥有Outer Class的<code>private</code>访问权限。</li></ul><h3 id="十三classpath-和-jar">十三、classpath 和 jar</h3><h4 id="classpath是什么">1、classpath是什么？</h4><p>​ <code>classpath</code>是JVM用到的一个环境变量，它用来指示JVM如何搜索<code>class</code></p><p>​ 因为Java是编译型语言，源码文件是<code>.java</code>，而编译后的<code>.class</code>文件才是真正可以被JVM执行的字节码。因此，JVM需要知道，如果要加载一个<code>abc.xyz.Hello</code>的类，应该去哪搜索对应的<code>Hello.class</code>文件。</p><p>​ 所以，<code>classpath</code>就是一组目录的集合，它设置的搜索路径与操作系统相关。例如，在Windows系统上，用<code>;</code>分隔，带空格的目录用<code>""</code>括起来，可能长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\work\project1\bin;C:\shared;&quot;D:\My Documents\project1\bin&quot;</span><br></pre></td></tr></table></figure><p>​ 在Linux系统上，用<code>:</code>分隔，可能长这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/shared:/usr/local/bin:/home/liaoxuefeng/bin</span><br></pre></td></tr></table></figure><p>​ 现在我们假设<code>classpath</code>是<code>.;C:\work\project1\bin;C:\shared</code>，当JVM在加载<code>abc.xyz.Hello</code>这个类时，会依次查找：</p><ul><li><当前目录>.class</li><li>C:.class</li><li>C:.class</li></ul><p>​ 注意到<code>.</code>代表当前目录。如果JVM在某个路径下找到了对应的<code>class</code>文件，就不再往后继续搜索。如果所有路径下都没有找到，就报错。</p><h4 id="如何设定classpath">2、如何设定classpath?</h4><p>​ 在启动JVM时设置<code>classpath</code>变量,实际上就是给<code>java</code>命令传入<code>-classpath</code>或<code>-cp</code>参数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -classpath .;C:\work\project1\bin;C:\shared abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>​ 没有设置系统环境变量，也没有传入<code>-cp</code>参数，那么JVM默认的<code>classpath</code>为<code>.</code>，即当前目录：</p><p>​ 在IDE中运行Java程序，IDE自动传入的<code>-cp</code>参数是当前工程的<code>bin</code>目录和引入的jar包</p><p><strong>注意：不要把任何Java核心库添加到classpath中！JVM根本不依赖classpath加载核心库！</strong></p><h4 id="jar包是什么">3、jar包是什么？：</h4><p>​ 如果有很多<code>.class</code>文件，散落在各层目录中，肯定不便于管理。如果能把目录打一个包，变成一个文件，就方便多了。</p><p>​ jar包就是用来干这个事的，它可以把<code>package</code>组织的目录层级，以及各个目录下的所有文件（包括<code>.class</code>文件和其他文件）都打成一个jar文件，这样一来，无论是备份，还是发给客户，就简单多了。</p><p>​ jar包实际上就是一个zip格式的压缩文件，而jar包相当于目录。如果我们要执行一个jar包的<code>class</code>，就可以把jar包放到<code>classpath</code>中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ava -cp ./hello.jar abc.xyz.Hello</span><br></pre></td></tr></table></figure><p>​ 这样JVM会自动在<code>hello.jar</code>文件里去搜索某个类。</p><h4 id="如何创建jar包">4、如何创建jar包？</h4><p>​ 因为jar包就是zip包，所以，直接在资源管理器中，找到正确的目录，点击右键，在弹出的快捷菜单中选择“发送到”，“压缩(zipped)文件夹”，就制作了一个zip文件。然后，把后缀从<code>.zip</code>改为<code>.jar</code>，一个jar包就创建成功。</p><p>假设编译输出的目录结构是这样：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">package_sample</span><br><span class="line">└─ bin</span><br><span class="line">   ├─ hong</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   │  ming</span><br><span class="line">   │  └─ Person.class</span><br><span class="line">   └─ mr</span><br><span class="line">      └─ jun</span><br><span class="line">         └─ Arrays.class</span><br></pre></td></tr></table></figure><p>这里需要特别注意的是，jar包里的第一层目录，不能是<code>bin</code>，而应该是<code>hong</code>、<code>ming</code>、<code>mr</code>。应当如下所示：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/pic.png" alt="pic" /><figcaption aria-hidden="true">pic</figcaption></figure><h4 id="特殊文件-manifest.mf">4、特殊文件 MANIFEST.MF：</h4><p>​ jar包还可以包含一个特殊的<code>/META-INF/MANIFEST.MF</code>文件，<code>MANIFEST.MF</code>是纯文本，可以指定<code>Main-Class</code>和其它信息。JVM会自动读取这个<code>MANIFEST.MF</code>文件，如果存在<code>Main-Class</code>，我们就不必在命令行指定启动的类名，而是用更方便的命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -jar hello.jar</span><br></pre></td></tr></table></figure><p>​ jar包还可以包含其它jar包，这个时候，就需要在<code>MANIFEST.MF</code>文件里配置<code>classpath</code>了。</p><p>​ 在大型项目中，不可能手动编写<code>MANIFEST.MF</code>文件，再手动创建zip包。Java社区提供了大量的开源构建工具，例如<a href="https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200">Maven</a>，可以非常方便地创建jar包。</p><h3 id="十四模块">十四、模块：</h3><h4 id="java9之前的程序打包运行">1、java9之前的程序打包运行：</h4><p>从Java 9开始，JDK又引入了模块（Module）</p><p><code>.class</code>文件是JVM看到的最小可执行文件，而一个大型程序需要编写很多Class，并生成一堆<code>.class</code>文件，很不便于管理，所以，<code>jar</code>文件就是<code>class</code>文件的容器。</p><p>在Java 9之前，一个大型Java程序会生成自己的jar文件，同时引用依赖的第三方jar文件，而JVM自带的Java标准库，实际上也是以jar文件形式存放的，这个文件叫<code>rt.jar</code>，一共有60多M。</p><p>如果是自己开发的程序，除了一个自己的<code>app.jar</code>以外，还需要一堆第三方的jar包，运行一个Java程序，一般来说，命令行写这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">java -cp app.jar:a.jar:b.jar:c.jar com.liaoxuefeng.sample.Main</span><br></pre></td></tr></table></figure><p>如果漏写了某个运行时需要用到的jar，那么在运行期极有可能抛出<code>ClassNotFoundException</code>。</p><p>所以，jar只是用于存放class的容器，<strong>它并不关心class之间的依赖</strong>。</p><h4 id="java9之后引入的模块">2、java9之后引入的模块：</h4><p>​ 主要为了解决依赖的问题。</p><p>​ 如果<code>a.jar</code>必须依赖另一个<code>b.jar</code>才能运行，那我们应该给<code>a.jar</code>加点说明啥的，让程序在编译和运行的时候能自动定位到<code>b.jar</code>，这种自带“依赖关系”的class容器就是模块。</p><p>为了表明Java模块化的决心，从Java 9开始，原有的Java标准库已经由一个单一巨大的<code>rt.jar</code>分拆成了几十个模块，这些模块以<code>.jmod</code>扩展名标识，可以在<code>$JAVA_HOME/jmods</code>目录下找到它们：</p><ul><li>java.base.jmod</li><li>java.compiler.jmod</li><li>java.datatransfer.jmod</li><li>java.desktop.jmod</li><li>...</li></ul><p>​ 这些<code>.jmod</code>文件每一个都是一个模块，模块名就是文件名。例如：模块<code>java.base</code>对应的文件就是<code>java.base.jmod</code>。模块之间的依赖关系已经被写入到模块内的<code>module-info.class</code>文件了。所有的模块都直接或间接地依赖<code>java.base</code>模块，只有<code>java.base</code>模块不依赖任何模块，它可以被看作是“根模块”，好比所有的类都是从<code>Object</code>直接或间接继承而来。</p><p>​ 把一堆class封装为jar仅仅是一个打包的过程，而把一堆class封装为模块则不但需要打包，还需要写入依赖关系，并且还可以包含二进制代码（通常是JNI扩展）。此外，模块支持多版本，即在同一个模块中可以为不同的JVM提供不同的版本。</p><h4 id="如何编写模块">3、如何编写模块：</h4><p>​ 首先，创建模块和原有的创建Java项目是完全一样的，以<code>oop-module</code>工程为例，它的目录结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">├── build.sh</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><p>其中，<code>bin</code>目录存放编译后的class文件，<code>src</code>目录存放源码，按包名的目录结构存放，仅仅在<code>src</code>目录下多了一个<code>module-info.java</code>这个文件，这就是模块的描述文件。在这个模块中，它长这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line"><span class="keyword">requires</span> java.base; <span class="comment">// 可不写，任何模块都会自动引入java.base</span></span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中，<code>module</code>是关键字，后面的<code>hello.world</code>是模块的名称，它的命名规范与包一致。花括号的<code>requires xxx;</code>表示这个模块需要引用的其他模块名。除了<code>java.base</code>可以被自动引入外，这里我们引入了一个<code>java.xml</code>的模块。</p><p>当我们使用模块声明了依赖关系后，才能使用引入的模块。例如，<code>Main.java</code>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 必须引入java.xml模块后才能使用其中的类:</span></span><br><span class="line"><span class="keyword">import</span> javax.xml.XMLConstants;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">Greeting g = <span class="keyword">new</span> Greeting();</span><br><span class="line">System.out.println(g.hello(XMLConstants.XML_NS_PREFIX));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果把<code>requires java.xml;</code>从<code>module-info.java</code>中去掉，编译将报错。可见，模块的重要作用就是声明依赖关系。</p><h4 id="命令行编译并创建模块">4、 命令行编译并创建模块：</h4><p>首先，我们把工作目录切换到<code>oop-module</code>，在当前目录下编译所有的<code>.java</code>文件，并存放到<code>bin</code>目录下，命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ javac -d bin src/module-info.java src/com/itranswarp/sample/*.java</span><br></pre></td></tr></table></figure><p>如果编译成功，现在项目结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">oop-module</span><br><span class="line">├── bin</span><br><span class="line">│   ├── com</span><br><span class="line">│   │   └── itranswarp</span><br><span class="line">│   │       └── sample</span><br><span class="line">│   │           ├── Greeting.class</span><br><span class="line">│   │           └── Main.class</span><br><span class="line">│   └── module-info.class</span><br><span class="line">└── src</span><br><span class="line">    ├── com</span><br><span class="line">    │   └── itranswarp</span><br><span class="line">    │       └── sample</span><br><span class="line">    │           ├── Greeting.java</span><br><span class="line">    │           └── Main.java</span><br><span class="line">    └── module-info.java</span><br></pre></td></tr></table></figure><p>注意到<code>src</code>目录下的<code>module-info.java</code>被编译到<code>bin</code>目录下的<code>module-info.class</code>。</p><p>下一步，我们需要把bin目录下的所有class文件先打包成jar，在打包的时候，注意传入<code>--main-class</code>参数，让这个jar包能自己定位<code>main</code>方法所在的类：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jar --create --file hello.jar --main-class com.itranswarp.sample.Main -C bin .</span><br></pre></td></tr></table></figure><p>现在我们就在当前目录下得到了<code>hello.jar</code>这个jar包，它和普通jar包并无区别，可以直接使用命令<code>java -jar hello.jar</code>来运行它。但是我们的目标是创建模块，所以，继续使用JDK自带的<code>jmod</code>命令把一个jar包转换成模块：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jmod create --class-path hello.jar hello.jmod</span><br></pre></td></tr></table></figure><p>于是，在当前目录下我们又得到了<code>hello.jmod</code>这个模块文件，这就是最后打包出来的传说中的模块！</p><h4 id="运行模块">5、运行模块：</h4><p>要运行一个jar，我们使用<code>java -jar xxx.jar</code>命令。要运行一个模块，我们只需要指定模块名。试试：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jmod --module hello.world</span><br></pre></td></tr></table></figure><p>结果是一个错误：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Error occurred during initialization of boot layer</span><br><span class="line">java.lang.module.FindException: JMOD format not supported at execution time: hello.jmod</span><br></pre></td></tr></table></figure><p>原因是<code>.jmod</code>不能被放入<code>--module-path</code>中。换成<code>.jar</code>就没问题了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ java --module-path hello.jar --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><h4 id="打包jre">6、打包JRE</h4><p>我们可以利用创建的<code>hello.jmod</code>来打包JRE。</p><p>​ 为了支持模块化，Java 9首先带头把自己的一个巨大无比的<code>rt.jar</code>拆成了几十个<code>.jmod</code>模块，原因就是，运行Java程序的时候，实际上我们用到的JDK模块，并没有那么多。不需要的模块，完全可以删除。</p><p>​ 过去发布一个Java应用程序，要运行它，必须下载一个完整的JRE，再运行jar包。而完整的JRE块头很大，有100多M。怎么给JRE瘦身呢？</p><p>​ 现在，JRE自身的标准库已经分拆成了模块，只需要带上程序用到的模块，其他的模块就可以被裁剪掉。怎么裁剪JRE呢？并不是说把系统安装的JRE给删掉部分模块，而是“复制”一份JRE，但只带上用到的模块。为此，JDK提供了<code>jlink</code>命令来干这件事。命令如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ jlink --module-path hello.jmod --add-modules java.base,java.xml,hello.world --output jre/</span><br></pre></td></tr></table></figure><p>我们在<code>--module-path</code>参数指定了我们自己的模块<code>hello.jmod</code>，然后，在<code>--add-modules</code>参数中指定了我们用到的3个模块<code>java.base</code>、<code>java.xml</code>和<code>hello.world</code>，用<code>,</code>分隔。最后，在<code>--output</code>参数指定输出目录。</p><p>现在，在当前目录下，我们可以找到<code>jre</code>目录，这是一个完整的并且带有我们自己<code>hello.jmod</code>模块的JRE。试试直接运行这个JRE：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ jre/bin/java --module hello.world</span><br><span class="line">Hello, xml!</span><br></pre></td></tr></table></figure><p>要分发我们自己的Java应用程序，只需要把这个<code>jre</code>目录打个包给对方发过去，对方直接运行上述命令即可，既不用下载安装JDK，也不用知道如何配置我们自己的模块，极大地方便了分发和部署。</p><h4 id="访问权限">7、访问权限：</h4><p>Java的class访问权限分为public、protected、private和默认的包访问权限。</p><p>引入模块后，这些访问权限的规则就要稍微做些调整。</p><p>确切地说，<strong>class的这些访问权限只在一个模块内有效</strong>，模块和模块之间，例如，a模块要访问b模块的某个class，必要条件是b模块明确地导出了可以访问的包。</p><p>举个例子：我们编写的模块<code>hello.world</code>用到了模块<code>java.xml</code>的一个类<code>javax.xml.XMLConstants</code>，我们之所以能直接使用这个类，是因为模块<code>java.xml</code>的<code>module-info.java</code>中声明了若干导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> java.xml &#123;</span><br><span class="line">    <span class="keyword">exports</span> java.xml;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.catalog;</span><br><span class="line">    <span class="keyword">exports</span> javax.xml.datatype;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只有它声明的导出的包，外部代码才被允许访问。换句话说，如果外部代码想要访问我们的<code>hello.world</code>模块中的<code>com.itranswarp.sample.Greeting</code>类，我们必须将其导出：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">module</span> hello.world &#123;</span><br><span class="line">    <span class="keyword">exports</span> com.itranswarp.sample;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">requires</span> java.base;</span><br><span class="line"><span class="keyword">requires</span> java.xml;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因此，模块进一步隔离了代码的访问权限。</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记面向对象编程内容，包含java程序类、构造、重载、继承、多态、抽象、接口、静态、包、作用域、内部类等多个需要注意的基础知识点</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
    <category term="oop" scheme="https://blog.slks.xyz/tags/oop/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记1——java基础</title>
    <link href="https://blog.slks.xyz/2022/01/28/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01%E2%80%94java%E5%9F%BA%E7%A1%80/"/>
    <id>https://blog.slks.xyz/2022/01/28/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B01%E2%80%94java%E5%9F%BA%E7%A1%80/</id>
    <published>2022-01-28T15:34:19.000Z</published>
    <updated>2022-01-30T02:14:52.546Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1260467032946976</p><h3 id="一第一个java程序">一、第一个Java程序</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ java规定，某个类定义的<code>public static void main(String[] args)</code>是java程序的固定入口方法，因此，java程序总是从<code>main</code>方法开始执行。</p><h3 id="二如何运行java程序">二、如何运行Java程序：</h3><p>1、用javac把Hello.java编译成字节码文件Hello.class，</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> javac Hello.java</span></span><br></pre></td></tr></table></figure><p>2、然后用java命令执行这个字节码文件。javac是编译器</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> java Hello</span></span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>给虚拟机传递的参数<code>Hello</code>是我们定义的类名，虚拟机自动查找对应的class文件并执行</p><p><strong>注意</strong>：</p><p>一个Java源码只能定义一个<code>public</code>类型的class，并且class名称和文件名要完全一致；</p><p>使用<code>javac</code>可以将<code>.java</code>源码编译成<code>.class</code>字节码；</p><p>使用<code>java</code>可以运行一个已编译的Java程序，参数是类名。</p><h3 id="三程序基本结构">三、程序基本结构：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 可以用来自动创建文档的注释</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Hello</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 向屏幕输出文本:</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello, world!&quot;</span>);</span><br><span class="line">        <span class="comment">/* 多行注释开始</span></span><br><span class="line"><span class="comment">        注释内容</span></span><br><span class="line"><span class="comment">        注释结束 */</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="comment">// class定义结束</span></span><br></pre></td></tr></table></figure><p><code>public</code>是访问修饰符，表示该<code>class</code>是公开的。不写<code>public</code>，也能正确编译，但是这个类将无法从命令行执行。</p><h3 id="四数据类型">四、数据类型</h3><p><strong>基本数据类型：</strong></p><ul><li>整数类型：byte，short，int，long</li><li>浮点数类型：float，double</li><li>字符类型：char</li><li>布尔类型：boolean</li></ul><p><strong>引用类型</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">&quot;hello&quot;</span>;</span><br></pre></td></tr></table></figure><p>引用类型的变量类似于C语言的指针，它内部存储一个“地址”，指向某个对象在内存的位置</p><p><strong>常量</strong>：</p><p>如果加上<code>final</code>修饰符，这个变量就变成了常量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">double</span> PI = <span class="number">3.14</span>; <span class="comment">// PI是一个常量</span></span><br></pre></td></tr></table></figure><p><strong>var关键字:</strong></p><p>如果想省略变量类型，可以使用<code>var</code>关键字</p><h3 id="五浮点数运算">五、浮点数运算：</h3><p>​ 由于浮点数存在运算误差，所以比较两个浮点数是否相等常常会出现错误的结果。正确的比较方法是判断两个浮点数之差的绝对值是否小于一个很小的数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> r = Math.abs(x - y);</span><br><span class="line"><span class="comment">// 再判断绝对值是否足够小:</span></span><br><span class="line"><span class="keyword">if</span> (r &lt; <span class="number">0.00001</span>) &#123;</span><br><span class="line">    <span class="comment">// 可以认为相等</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 不相等</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>整数运算在除数为<code>0</code>时会报错，而浮点数运算在除数为<code>0</code>时，不会报错，但会返回几个特殊值：</p><ul><li><code>NaN</code>表示Not a Number</li><li><code>Infinity</code>表示无穷大</li><li><code>-Infinity</code>表示负无穷大</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">double</span> d1 = <span class="number">0.0</span> / <span class="number">0</span>; <span class="comment">// NaN</span></span><br><span class="line"><span class="keyword">double</span> d2 = <span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// Infinity</span></span><br><span class="line"><span class="keyword">double</span> d3 = -<span class="number">1.0</span> / <span class="number">0</span>; <span class="comment">// -Infinity</span></span><br></pre></td></tr></table></figure><h3 id="六字符类型">六、字符类型：</h3><p>一个<code>char</code>保存一个Unicode字符：</p><p>因为Java在内存中总是使用Unicode表示字符，所以，一个英文字符和一个中文字符都用一个<code>char</code>类型表示，它们都占用两个字节。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int n1 = &#x27;A&#x27;; // 字母“A”的Unicodde编码是65</span><br><span class="line">int n2 = &#x27;中&#x27;; // 汉字“中”的Unicode编码是20013</span><br><span class="line">还可以直接用转义字符\u+Unicode编码来表示一个字符：</span><br><span class="line">// 注意是十六进制:</span><br><span class="line">char c3 = &#x27;\u0041&#x27;; // &#x27;A&#x27;，因为十六进制0041 = 十进制65</span><br><span class="line">char c4 = &#x27;\u4e2d&#x27;; // &#x27;中&#x27;，因为十六进制4e2d = 十进制20013</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>如果用<code>+</code>连接字符串和其他数据类型，会将其他数据类型先自动转型为字符串，再连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> age = <span class="number">25</span>;</span><br><span class="line">        String s = <span class="string">&quot;age is &quot;</span> + age;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从Java 13开始，字符串可以用<code>"""..."""</code>表示多行字符串（Text Blocks）了。</p><p>多行字符串前面共同的空格会被去掉，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;&quot;</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">                   SELECT * FROM</span></span><br><span class="line"><span class="string">                     users</span></span><br><span class="line"><span class="string">                   WHERE id &gt; 100</span></span><br><span class="line"><span class="string">                   ORDER BY name DESC</span></span><br><span class="line"><span class="string">                   &quot;</span><span class="string">&quot;&quot;</span>;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>不可见特性：</strong></p><p>Java的字符串除了是一个引用类型外，还有个重要特点，就是字符串不可变。考察以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 hello</span></span><br><span class="line">        s = <span class="string">&quot;world&quot;</span>;</span><br><span class="line">        System.out.println(s); <span class="comment">// 显示 world</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>观察执行结果，难道字符串<code>s</code>变了吗？其实变的不是字符串，而是变量<code>s</code>的“指向”。</p><p><strong>空值null:</strong></p><p>引用类型的变量可以指向一个空值<code>null</code>，它表示不存在，即该变量不指向任何对象。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String s1 = <span class="keyword">null</span>; <span class="comment">// s1是null</span></span><br><span class="line">String s2; <span class="comment">// 没有赋初值值，s2也是null</span></span><br></pre></td></tr></table></figure><h3 id="七数组">七、数组：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] ns = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span>[] ns = &#123; <span class="number">68</span>, <span class="number">79</span>, <span class="number">91</span>, <span class="number">85</span>, <span class="number">62</span> &#125;;</span><br><span class="line">System.out.println(ns.length); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure><h3 id="八流程控制手段">八、流程控制手段</h3><h4 id="输出">1、输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">System.out.print(<span class="string">&quot;A,&quot;</span>); <span class="comment">//输出后不换行</span></span><br><span class="line">System.out.println() <span class="comment">//输出后自动换行</span></span><br><span class="line">System.out.printf(<span class="string">&quot;%.2f\n&quot;</span>, d); <span class="comment">// 格式化输出，显示两位小数3.14</span></span><br></pre></td></tr></table></figure><h4 id="输入">2、输入：</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Scanner scanner = <span class="keyword">new</span> Scanner(System.in); <span class="comment">// 创建Scanner对象</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your name: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        String name = scanner.nextLine(); <span class="comment">// 读取一行输入并获取字符串</span></span><br><span class="line">        System.out.print(<span class="string">&quot;Input your age: &quot;</span>); <span class="comment">// 打印提示</span></span><br><span class="line">        <span class="keyword">int</span> age = scanner.nextInt(); <span class="comment">// 读取一行输入并获取整数</span></span><br><span class="line">        System.out.printf(<span class="string">&quot;Hi, %s, you are %d\n&quot;</span>, name, age); <span class="comment">// 格式化输出</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过<code>import</code>语句导入<code>java.util.Scanner</code></li><li>创建<code>Scanner</code>对象并传入<code>System.in</code></li><li>有了<code>Scanner</code>对象后，要读取用户输入的字符串，使用<code>scanner.nextLine()</code>，要读取用户输入的整数，使用<code>scanner.nextInt()</code>。<code>Scanner</code>会自动转换数据类型，因此不必手动转换。</li></ul><h3 id="九判断引用类型变量内容是否相等">九、判断引用类型变量内容是否相等：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s1 = <span class="string">&quot;hello&quot;</span>;</span><br><span class="line">        String s2 = <span class="string">&quot;HELLO&quot;</span>.toLowerCase();</span><br><span class="line">        System.out.println(s1);</span><br><span class="line">        System.out.println(s2);</span><br><span class="line">        <span class="keyword">if</span> (s1 == s2) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 == s2&quot;</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;s1 != s2&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 输出结果是 s1 != s2</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>要判断引用类型的变量内容是否相等，必须使用<code>equals()</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">s1.equals(s2)</span><br></pre></td></tr></table></figure><h3 id="十新switch表达式">十、新Switch表达式：</h3><p>​ 从Java 12开始，<code>switch</code>语句升级为更简洁的表达式语法，使用类似模式匹配（Pattern Matching）的方法，保证只有一种路径会被执行，并且不需要<code>break</code>语句</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String fruit = <span class="string">&quot;apple&quot;</span>;</span><br><span class="line"><span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected apple&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span> -&gt; System.out.println(<span class="string">&quot;Selected pear&quot;</span>);</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&quot;mango&quot;</span> -&gt; &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Selected mango&quot;</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;Good choice!&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">default</span> -&gt; System.out.println(<span class="string">&quot;No fruit selected&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十一switch中的yield返回值">十一、Switch中的Yield返回值：</h3><p>大多数时候，在<code>switch</code>表达式内部，我们会返回简单的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String fruit = <span class="string">&quot;orange&quot;</span>;</span><br><span class="line">        <span class="keyword">int</span> opt = <span class="keyword">switch</span> (fruit) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;apple&quot;</span> -&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&quot;pear&quot;</span>, <span class="string">&quot;mango&quot;</span> -&gt; <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">default</span> -&gt; &#123;</span><br><span class="line">                <span class="keyword">int</span> code = fruit.hashCode();</span><br><span class="line">                yield code; <span class="comment">// switch语句返回值</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(<span class="string">&quot;opt = &quot;</span> + opt);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十二for-each-循环">十二、for each 循环</h3><p>和<code>for</code>循环相比，<code>for each</code>循环的变量n不再是计数器，而是直接对应到数组的每个元素。<code>for each</code>循环的写法也更简洁。但是，<code>for each</code>循环无法指定遍历顺序，也无法获取数组的索引。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>, <span class="number">25</span> &#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n : ns) &#123;</span><br><span class="line">            System.out.println(n);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="十三排序库arrays.sort">十三、排序库：Arrays.sort()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] ns = &#123; <span class="number">28</span>, <span class="number">12</span>, <span class="number">89</span>, <span class="number">73</span>, <span class="number">65</span>, <span class="number">18</span>, <span class="number">96</span>, <span class="number">50</span>, <span class="number">8</span>, <span class="number">36</span> &#125;;</span><br><span class="line">        Arrays.sort(ns);</span><br><span class="line">        System.out.println(Arrays.toString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十四多维数组">十四、多维数组：</h3><h4 id="二维数组">1) 二维数组</h4><p>二维数组的每个数组元素的长度并不要求相同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span> &#125;,</span><br><span class="line">            &#123; <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line">        System.out.println(ns.length); <span class="comment">// 3</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>打印多维数组可以使用<code>Arrays.deepToString()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[][] ns = &#123;</span><br><span class="line">            &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span> &#125;,</span><br><span class="line">            &#123; <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span> &#125;,</span><br><span class="line">            &#123; <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span> &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        System.out.println(Arrays.deepToString(ns));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="十五命令行参数">十五、命令行参数：</h3><p>命令行参数类型是<code>String[]</code>数组； 命令行参数由JVM接收用户输入并传给<code>main</code>方法；如何解析命令行参数需要由程序自己实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (String arg : args) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="string">&quot;-version&quot;</span>.equals(arg)) &#123;</span><br><span class="line">                System.out.println(<span class="string">&quot;v 1.0&quot;</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记基础内容，包含java程序基本结构、数据类型、浮点数、字符、数组、输入输出、引用类型变量、Switch表达式、Yield返回值、For each循环等多个需要注意的基础知识点</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>《UniFormer:Unifying Convolution and Self-attention for Visual Recognition》</title>
    <link href="https://blog.slks.xyz/2022/01/27/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B06%E2%80%94%E2%80%94%E3%80%8AUniFormer%20Unifying%20Convolution%20and%20Self%20Attention%20for%20Visual%20Recognition%E3%80%8B/"/>
    <id>https://blog.slks.xyz/2022/01/27/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B06%E2%80%94%E2%80%94%E3%80%8AUniFormer%20Unifying%20Convolution%20and%20Self%20Attention%20for%20Visual%20Recognition%E3%80%8B/</id>
    <published>2022-01-27T10:12:19.000Z</published>
    <updated>2022-01-29T07:28:44.875Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称uniformer-unifying-convolution-and-self-attention-for-visual-recognition">论文名称：《UniFormer: Unifying Convolution and Self-attention for Visual Recognition》</h4><h4 id="论文地址-httpsarxiv.orgpdf2201.09450.pdf">论文地址： https://arxiv.org/pdf/2201.09450.pdf</h4><h2 id="关键词">1、关键词：</h2><p>​ Visual Recognition、CNN、SelfAttention、Transformer</p><h2 id="领域背景visual-recognition">2、领域背景—Visual Recognition：</h2><p>​ 表征学习一直是视觉识别领域的比较基本的研究。主要在面临向图像以及视频数据的时候，会存在两个问题：</p><ul><li>1、局部区域（空间、时间、时空）中的视觉内容往往是相似的，也就意味着局部冗余会比较大，这会导致不必要的计算量</li><li>2、全局的依赖关系比较复杂，在不同区域的目标物体之间都会存在一些动态的关系。</li></ul><h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2><p>​ 基于领域背景中的两个主要问题，主流的解决方案就是CNN和ViT，但是它们都只针对上述问题中的某一个做出了解决，而忽略了另一个。如下所示：</p><ul><li><p>CNN能够通过小范围的卷积，降低局部冗余，减小计算量，但在捕获全局依赖中很有限制。</p></li><li><p>ViT能够通过Self-Attention很有效的捕获长距离的依赖，但是盲目的去计算所有tokens之间的相似关系，会带来很大的计算冗余。其在浅层网络上很难有效的去编码局部的特征。</p><ul><li>本文的作者进行了一个实验：如下图所示，显示的是ViT网络的第三层的Attention图，我们发现虽然Attention机制计算了全局的token之间的关系，但最终在锚点（绿色方框）学习到的有效信息均来源于其很小的一个邻域范围（红色填充方框）。所以,ViT花费了非常大的计算复杂度，去编码了一个局部的视觉表示特征。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129104342853.png" /></li></ul></li></ul><h2 id="主要设计思想">4、主要设计思想：</h2><p>​ 基于上述的工作描述，作者提出了UniFormer，将3D卷积和时空自注意力机制结合在一个简洁的<a href="https://so.csdn.net/so/search?q=transformer&amp;spm=1001.2101.3001.7020">transformer</a>结构中，能够同时处理局部冗余和全局依赖，其主要包括三个模块：</p><ul><li>Dynamic Position Embedding( DPE )</li><li>Multi-Head Relation Aggregator ( MHRA ) <strong>【和CNN与ViT的主要不同所在】</strong></li><li>Feed-Forward Network ( FFN )</li></ul><p>UniFormer与其他transformer的区别主要在于MHRA模块：</p><ul><li><p>在浅层，aggregator利用一个小的learnable matrix学习局部的token之间的相似性关系，通过聚合小的3D邻域的token信息极大地减少计算量。在深层，aggregator学习全局token之间的相似性关系，可以灵活的建立远距离图像区域或视频帧的token之间的长程依赖关系。</p></li><li><p>最后，通过以分层方式逐步堆叠局部和全局 UniFormer 块，我们可以灵活地整合它们的协作能力来促进Representation Learning。 最后，我们为视觉识别提供了一个通用且强大的主干，并通过简单而精细的适应成功地解决了各种下游视觉任务。</p></li></ul><h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2><h3 id="uniformer-block">1) UniFormer Block</h3><p>​ 下面图片就是UniFormer Block的整体架构，其中在标注维度的地方，所有标红的字符都是仅对于视频输入有效，代表了输入视频的帧数，如果输入是个图像，那么这些标红的值应该都 = 1.</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127163758510.png" /></p><ul><li><strong>概述</strong>：Uniformer Block 的整体架构如上所示，分割成了几个阶段，每个阶段中由三个核心的模块重复堆叠L次组成，下面就是单词堆叠中，所有的模块的大致介绍：<ul><li>Dynamic Position Embedding( DPE )</li><li>Multi-Head Relation Aggregator ( MHRA )</li><li>Feed-Forward Network ( FFN )</li><li>我们首先引入 DPE 将位置信息动态集成到所有Tokens（等式1）。它支持任意输入分辨率，并充分利用Tokens的顺序以获得更好的视觉识别效果。 然后，我们使用 MHRA ，其利用每个Token的上下文token，通过关系学习的方式，来增强每个Token（等式 2）。 通过在浅层和深层灵活设计Token的相似性，我们的 MHRA 可以巧妙地统一卷积和自注意力机制，以减少局部冗余并学习全局依赖性。 最后，我们像传统的 ViTs 一样添加 FFN，它由两个线性层和一个非线性函数GELU组成（等式 3）。 通道数先扩大4倍再恢复，因此每个token会被单独增强.</li></ul></li><li><strong>输入</strong>：<span class="math inline">\(X_{in} \in R^{C \times T \times H \times W}\)</span>, T 为视频帧数，当输入为图像时，T = 1</li><li><strong>输出</strong>：<span class="math inline">\(Z\)</span>特征空间向量</li><li><strong>公式表达</strong>：<ul><li><span class="math inline">\(X = DPE(X_{in}) + X_{in}\)</span></li><li><span class="math inline">\(Y = MHRA(Norm(X)) + X\)</span></li><li><span class="math inline">\(Z = FFN(Norm(Y)) + Y\)</span></li></ul></li></ul><h3 id="multi-head-relation-aggregator">2) Multi-Head Relation Aggregator</h3><ul><li><p><strong>概述</strong>：该模块可以巧妙地统一卷积和自注意力机制，以减少局部冗余并学习全局依赖性。MHRA使用multi-head机制来计算token间的关系，公式表达如下：</p></li><li><p><strong>公式表达</strong>：</p><ul><li><strong>MHRA模块的第n个head</strong>： <span class="math inline">\(R_n(X) = A_nV_n(X)\)</span>，输入向量<span class="math inline">\(X \in R^{C \times T \times H \times W}\)</span>，我们会将其首先Reshape成一个token的序列<span class="math inline">\(X \in R^{L \times C}\)</span>, 其中 <span class="math inline">\(L = T \times H \times W\)</span></li><li><strong>总体</strong>： <span class="math inline">\(MHRA(X) = Concat(R_1(X);R_2(X);...;R_N(X))U\)</span>，<span class="math inline">\(U \in R^{C \times C}\)</span>是一个可学习矩阵，用于聚合N个Head的内容</li></ul></li><li><p><strong>单个Head内部变换细节介绍</strong>：</p><ul><li>每个RA包含<strong>token context encoding </strong>和 <strong>token affinity learning</strong>两步</li><li>1、我们应用<strong>线性变换</strong>将<strong>原始标记</strong>编码为<strong>上下文标记</strong>：<span class="math inline">\(V_n(X) \in R^{L \times \frac{C}{N}}\)</span></li><li>2、An是 <strong>token相似度</strong>，RA可以在其指导下来概括上下文信息，进行总结</li></ul></li><li><p><strong>浅层网络中的Local MHRA</strong>:</p><ul><li><p><strong>概述：</strong>在先前的比较中，我们发现：在浅层网络计算全局Self-Attention最终学到的也只是局部的信息，所以我们在浅层网络中，现在只在局部区域内来进行计算。因此，在浅层网络中，我们将Local Affinity作为一个<strong>可学习参数的矩阵</strong>。</p></li><li><p><strong>具体而言：</strong>给定anchor token <span class="math inline">\(X_i\)</span> , 局部RA学习该token和一个小邻域<span class="math inline">\(\Omega_i^{t \times h \times w}\)</span>内的其他token的相似性。<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129110111062.png" alt="image-20220129110111062" /></p><p><span class="math inline">\(a_n \in R^{t \times h \times w}\)</span> , <span class="math inline">\(X_j\)</span> 代表邻域内的任一一个token，<span class="math inline">\(i-j\)</span> 表示token i和j的相对位置关系</p></li><li><p><strong>注意</strong>：因为tokens的感受野很小，相邻token之间的视觉内容在浅层中会发生微妙的变化。在这种情况下，没有必要去让token相似度动态的进行变化，因此我们使用一个可学习的参数矩阵来描述局部的token相似度，token的相似度仅取决于两个token之间的相对位置关系。</p></li><li><p><strong>与CNN的比较</strong>：其可以视为是 PWConv-DWConv-PWConv的组合，但是该论文中的Uniformer块是基于一个通用的Transformer的格式进行设计的，也就是说除了MHRA之外，还带有DPE和FFN，这一简单的继承能够非常有效的加强token的表示能力。</p></li></ul></li><li><p><strong>深层网络中的Global MHRA</strong>:</p><ul><li><p><strong>概述</strong>：在深层网络中，在更广阔的空间中获取长距离依赖很重要。因此，我们通过在全局条件下比较内容来进行token相似度的计算。</p></li><li><p><strong>具体而言</strong>：给定anchor token <span class="math inline">\(X_i\)</span> , 局部RA学习该token和所有其他token 的相似性</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129111415083.png" /></p><p><span class="math inline">\(X_j\)</span> 代表全局范围<span class="math inline">\(size = T \times H \times W\)</span>内的任意一个token，<span class="math inline">\(Q_n 和 K_n\)</span>是两个不同的线性变换。</p></li><li><p><strong>与Transformer的比较</strong>：</p><p>可以被实例化为一个时空self-attention，<span class="math inline">\(Q_n 、K_n、V_n\)</span>代表Query、Key、Value.但是，UniformerBlock又和传统的ViT块不同：</p><ul><li>1、以往的video tranformer在视频域中分割开了时间和空间的attention，为了减少在计算token相似度比较时候的计算量。但是这会不可避免地恶化token之间的时空关系。相比之下，我们的模块联合编码时空token关系以生成更具辨别力的视频表示以进行识别。因为我们在浅层的时候大大的节省了token比较的计算量，所以整体模型上还是能到达一个计算量-准确度比较好的一个平衡。</li><li>2、其次，我们在 UniFormer 中采用动态位置嵌入 (DPE) 代替绝对位置嵌入。它是卷积风格的（见下节），可以克服排列不变性，对不同输入长度的视觉tokens友好</li></ul></li></ul></li></ul><h3 id="dynamic-position-embedding">3) Dynamic Position Embedding</h3><ul><li><p><strong>概述：</strong>先前绝大多数的位置编码都采用<strong>绝对或相对位置嵌入</strong>，然而绝对位置嵌入必须通过微调对各种输入大小进行插值，而相对位置嵌入由于自注意力机制的修改容易无法很好地工作。最近，有人提出了卷积位置编码，具体而言，卷积位置编码CPE，可以隐式地将位置信息通过卷积操作进行编码，这样可以让Transformer去处理任意的输入大小，并且提高识别性能。鉴于其即插即用地性质，我们将其拿过来作为我们的DPE模块：</p></li><li><p><span class="math inline">\(DPE(X_{in})= DWConv(X_in)\)</span> , DWConv 代表 depth-wise 卷积，zero padding</p></li><li><p><strong>原因</strong>：</p><ul><li><p>1、depthwise 卷积对任意的输入大小很友好（使用其时空版本对视频中的 3D 位置信息进行编码很简单）</p></li><li><p>2、很轻量化，能够较好的平衡计算量与准确性的平衡。</p></li><li><p>3、增加Zero padding，它可以通过逐步查询它们的邻居来帮助token了解它们的绝对位置</p><p>（Finally, we add extra zero paddings, since it can help tokens be aware of their absolute positions by querying their neighbors progressively 论文3.3最后一句话 ）</p></li></ul><!-- Zero Padding ？ 如何逐步查询令居进而帮助token了解绝对位置？ --></li></ul><h2 id="衍生框架-framework">6、衍生框架 FrameWork</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220129115021079.png" /></p><h3 id="图像分类框架">1) 图像分类框架：</h3><ul><li>Stage1 和 Stage2 用的是 Local Uniformer Blocks<ul><li>使用 PWConv-DWConv-PWConv 进行实例化</li></ul></li><li>Stage3 和 Stage4 用的是 Global Uniformer Blocks<ul><li>使用 multi-head self-attention 进行实例化，heads = 64</li></ul></li><li>DPE 都实例化成 DWConv， spatial size = 3 x 3</li><li>FFN 的 Expand Ratio = 4</li><li>卷积 用 BN， self-attention 用 LN</li><li>特征降维：<ul><li>Stage1前： $ 4  ， stride = 4 $</li><li>其他Stage前： $ 2  ， stride = 2 $</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127163758510.png" /></p><h3 id="视频分类-密集预测-等其他框架详见论文主体">2） 视频分类 &amp;&amp; 密集预测 等其他框架详见论文主体</h3>]]></content>
    
    
    <summary type="html">提出了UniFormer，将3D卷积和时空自注意力机制结合在一个简洁的transformer结构中。能够同时处理局部冗余和全局依赖，其主要包括三个模块：Dynamic Position Embedding( DPE )\Multi-Head Relation Aggregator ( MHRA )\Feed-Forward Network( FFN )</summary>
    
    
    
    <category term="论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="CNN" scheme="https://blog.slks.xyz/tags/CNN/"/>
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
    <category term="Visual Recognition" scheme="https://blog.slks.xyz/tags/Visual-Recognition/"/>
    
  </entry>
  
  <entry>
    <title>《HandWritting Transformers》(更新中)</title>
    <link href="https://blog.slks.xyz/2022/01/26/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E3%80%8AHandWrittng%20Transformers%E3%80%8B/"/>
    <id>https://blog.slks.xyz/2022/01/26/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B05%E2%80%94%E2%80%94%E3%80%8AHandWrittng%20Transformers%E3%80%8B/</id>
    <published>2022-01-26T10:12:19.000Z</published>
    <updated>2022-01-29T07:28:32.645Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称handwriting-transformers">论文名称：《<strong>Handwriting Transformers</strong>》</h4><h4 id="论文地址-httpsarxiv.orgabs2104.03964">论文地址： https://arxiv.org/abs/2104.03964</h4><h2 id="关键词">1、关键词：</h2><p>​ 手写字体生成（英文）、GAN、Transformer</p><h2 id="领域背景手写字体生成">2、领域背景—手写字体生成：</h2><p>​ 自动的手写文字生成对于一些书写障碍的人十分重要。通常使用的方法是利用GAN来进行离线的手写文字图像生成。</p><h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2><p>​ 两类生成方法： 基于笔画的在线生成方法（需要记录时序数据） 和 基于图像的离线生成方法。</p><ul><li><p>GANwriting ：该方法利用在少量信息中提取样式特征和预定义固定长度的文本内容来进行文本生成。</p></li><li><p>我们的方法：与GANwritting相似，我们的方法也是在少量的风格样例中去提取风格特征，但又与 GANwriting 不同，我们的方法具有生成任意长度的风格化文本的灵活性。 我们能够同时捕获全局和局部的书写风格。</p></li></ul><h2 id="主要设计思想">4、主要设计思想：</h2><p>两个主要改进的Motivation:</p><p>1、除了字/行级别的样式-内容纠缠之外，字符级别的样式和内容之间的纠缠有助于模仿特定字符的写作风格以及泛化到词汇外的内容。</p><p>2、为了生成准确的风格文本图像，需要模仿全局的（例如墨水宽度、倾斜度等）和局部的（例如字符风格、连字等）风格特征。</p><h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2><p><strong>问题公式化描述：</strong></p><ul><li><span class="math inline">\(i \in W\)</span>, <span class="math inline">\(W\)</span>包含M个作者，<span class="math inline">\(i\)</span>代表某一个作者</li><li>一个手写文字图像集合 P</li><li>输入的文本内容<span class="math inline">\(A = \{a_j\}_{j=1}^Q\)</span>，视为一个Word String的集合</li><li>每个WordString 包含长度不定的字符，字符来自于字符集C</li><li>字符集C包含 字母表、标点、数字</li><li><span class="math inline">\(\hat X_i^t\)</span>代表依据新的文本内容t，生成的作者<span class="math inline">\(i\)</span>的新图像</li></ul><h3 id="整体架构overall-pipeline">1) 整体架构（Overall Pipeline）</h3><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127103226508.png" /></p><ul><li><strong>概述</strong>：先利用CNN，将风格图像变换至高维特征空间，然后进入Transformer Encoder中，生成特征潜在向量Z，输入到Transformer Decoder中，与Query Words进行结合，解码输出F，再通过CNN Decoder，最终生成图像，然后进入到不同的判别器中，基于不同的角度，定义了4个损失函数，进行函数的优化。</li><li>Query Words进入到Transformer Decoder中前，需要进行词嵌入编码，对每个字符，定义了一个可学习的词嵌入向量，<span class="math inline">\(q_c \in R^{512}\)</span>，这样一种基于字符的表示，以及基于transformer的序列处理方式，帮助模型能够生成任意长度的手写单词，并且能够更好的泛化到词汇表外的数据。<ul><li><span class="math inline">\(G_\theta\)</span>生成器，用于合成手写文本图像</li><li><span class="math inline">\(D_\Psi\)</span>判别器，用于确保生成图像的 手写风格的真实性（即确保看上去是手写图像）</li><li><span class="math inline">\(R_\phi\)</span>识别器，用于保持文本内容正确</li><li><span class="math inline">\(S_\eta\)</span>风格分类器，用于确保迁移的手写风格正确性（即确保生成的风格与Style Example一致）</li></ul></li><li><strong>输入</strong>： <span class="math inline">\(a_j \in A\)</span> &amp;&amp; <span class="math inline">\(X_i^s\)</span>文本 + 风格图像示例</li><li><strong>输出</strong>： <span class="math inline">\(\hat X_i^t\)</span>新生成的风格化手写字符图像（文本内容为 t ）</li></ul><h3 id="encoder-network-tepsilon">2) Encoder Network <span class="math inline">\(T\epsilon\)</span></h3><ul><li><strong>概述</strong>：将风格手写示例图编码至风格特征空间向量</li><li><strong>输入</strong>：<span class="math inline">\(X_i^s\)</span>风格手写示例图</li><li><strong>输出</strong>：<span class="math inline">\(Z \in R^{N \times d}\)</span>风格特征空间向量</li><li><strong>网络结构</strong>：<ul><li><strong>Part1 : CNN Encoder</strong><ul><li>采用<strong>ResNet18</strong>: 为每个style image生成低分辨率的激活图<span class="math inline">\(h_{ij} \in R^{h \times w \times d}\)</span></li><li>将<span class="math inline">\(h_{ij}\)</span>在空间维度上展平，得到一个Sequence, <span class="math inline">\(n \times d\)</span>，其中<span class="math inline">\(n = h \times w\)</span>, 这个序列可以被视为风格图像某区域的描述子</li><li>同时，因为总共我们会提供P张风格示例图像，将所有风格示例图像中提取出的Sequence进行拼接，得到一个Tensor，<span class="math inline">\(H_i \in R^{N \times d}\)</span>其中，<span class="math inline">\(N = n \times P\)</span></li></ul></li><li><strong>Part2: Transformer-Based Encoder</strong><ul><li>L层，每一层都由multihead-self-attention 和 MLP模块组成。重复L遍，很标准的Transformer Encoder（论文中没有细讲有无Residual）</li><li>为保留提供的输入序列的未知信息，采用固定位置编码</li></ul></li></ul></li><li><strong>意义</strong>：对局部的和全局的手写风格图像特征建模，例如倾斜、歪斜、字符形状、连字、墨水宽度等</li></ul><h3 id="decoder-network-t_d">3) Decoder Network <span class="math inline">\(T_d\)</span></h3><ul><li><strong>概述</strong>：结合输入的字符序列，生成风格化的手写字符图像</li><li><strong>输入</strong>：<span class="math inline">\(Z \in R^{N \times d}\)</span>风格特征空间向量 + <span class="math inline">\(A\)</span>输入的字符序列</li><li><strong>输出</strong>：<span class="math inline">\(\hat X_i^t\)</span>新生成的风格化手写字符图像（文本内容为 t ）</li><li><strong>网络结构</strong>：<ul><li><strong>Part1: Query Words 处理</strong><ul><li>将Query Words 编码成 Query Embedding，其为可学习的位置编码参数，加入到之后Transformer-Based Decoder中。简单来讲，这一步的作用就是要让每一个Query Embedding都在提供的样式图像中，能够去查找感兴趣的区域，从而进一步推断所有查询字符的风格属性。</li><li>如下图所示，t对应的位置编码，需要去学习的就是在我们提供的样例风格图像中，寻找字符t相关的位置（感兴趣的区域）。</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127112528447.png" /></li></ul></li><li><strong>Part2: Transformer Based Decoder:</strong><ul><li>注意1：和self-attention不同，其key &amp; value 来源于Encoder的输出， query向量来源于Decoder自己的层。</li><li>注意2：在所有的Transformer Based Decoder中，我们是并行的去处理每一个Query Embeddings的，每个Query Embedding就代表一个字符。</li><li>将上一步的Query Embeddings 经过连续的 Transformer Based Decoder以后，会累积一些风格信息，产生一个输出 <span class="math inline">\(F_{a_j} \in R^{m_j \times d}\)</span>. <span class="math inline">\(m_j\)</span>是某个单词的字符数</li><li>然后，我们会将<span class="math inline">\(N(0,1)\)</span>的噪音，加入到 <span class="math inline">\(F_{a_j}\)</span>中，来模拟自然情况下的外部干扰变化。</li><li><strong>举例而言</strong>：<ul><li>一个m个字符的单词</li><li>我们会将m个Embeddings Vectors连接起来，然后再通过一个FC层，得到一个<span class="math inline">\(m_j \times 8192\)</span>的矩阵，我们将其Reshape成 <span class="math inline">\(512 \times 4 \times 4m_j\)</span>,然后输入到CNN Decoder中。</li></ul></li></ul></li><li><strong>Part3: CNN Decoder</strong>:<ul><li>4 个残差模块 + tanh激活函数</li><li>获得最终的输出图像</li></ul></li></ul></li></ul><h3 id="training-loss-objectives">4) Training &amp; Loss Objectives</h3><ul><li><p><strong>概述</strong>：总共由4个Loss函数组成，每个Loss负责不同的部分，在网络结构概述中已经有所提及。</p><ul><li>1、<span class="math inline">\(D_\Psi\)</span>判别器，用于确保生成图像的 手写风格的真实性（即确保看上去是手写图像）</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115520938.png" /></p><ul><li><p>2、<span class="math inline">\(R_\phi\)</span>手写文本识别器，用于保持文本内容正确，使用CRNN搭建，使用CTC Loss函数，比较query words和识别输出的差别。识别器 Rφ 仅针对真实的、标记的、手写样本进行优化训练，但它用于鼓励 Gθ 生成具有准确内容的可读文本。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115740239.png" /></p></li><li><p>3、<span class="math inline">\(S_\eta\)</span>风格分类器，用于确保迁移的手写风格正确性（即确保生成的风格与Style Example一致） ，其能够预测一个给定的手写图像的作者。使用Cross-Entropy来定义Loss函数：其只在真实的样例上利用如下损失函数进行训练：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127115916996.png" /></p></li><li><p>4、利用Cycle Loss 来确保编码的style features由循环一致性。这个损失函数能够让decoder最大程度上在解码阶段保留风格信息，使得我们能够从生成的图像中重建出最开始的风格特征序列。给定生成的图像 <span class="math inline">\(\hat X_i^t\)</span>，我们使用 编码器<span class="math inline">\(T\epsilon\)</span>来重建风格特征向量<span class="math inline">\(\hat Z\)</span>。如下所示的循环损失<span class="math inline">\(L_c\)</span>用于最小化<span class="math inline">\(Z\)</span>和 <span class="math inline">\(\hat Z\)</span>之间的L1差距</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120112639.png" /></p><p>循环损失对解码器施加了正则化，以一致地模仿生成的样式文本图像中的写作风格。</p></li></ul></li><li><p>总的来说，我们以端到端的方式训练我们的 HWT 模型，损失目标如下</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120324671.png" /></p><ul><li>同时，我们观察到平衡网络 Sη 和 Rφ 的梯度有助于使用我们的损失公式进行训练。根据 [3]，我们将 ∇Sη 和 ∇Rφ 归一化，使其具有与对抗性损失梯度相同的标准偏差 (σ)</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220127120433481.png" /></li><li><span class="math inline">\(\alpha\)</span>是一个超参数，在训练我们的模型的时候被固定为1</li></ul>]]></content>
    
    
    <summary type="html">自动的手写文字生成对于一些书写障碍的人十分重要。通常使用的方法是利用GAN来进行离线的手写文字图像生成。</summary>
    
    
    
    <category term="论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="GAN" scheme="https://blog.slks.xyz/tags/GAN/"/>
    
    <category term="HandWritting Generation" scheme="https://blog.slks.xyz/tags/HandWritting-Generation/"/>
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>Tmux常用命令</title>
    <link href="https://blog.slks.xyz/2022/01/26/%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AC%94%E8%AE%B0/tmux_command/"/>
    <id>https://blog.slks.xyz/2022/01/26/%E5%B7%A5%E5%85%B7%E7%B1%BB%E7%AC%94%E8%AE%B0/tmux_command/</id>
    <published>2022-01-26T07:47:19.000Z</published>
    <updated>2022-01-26T07:05:09.568Z</updated>
    
    <content type="html"><![CDATA[<h3 id="tmux常用命令">Tmux常用命令</h3><ul><li><p>创建并指定session名字 tmux new -s $session_name</p></li><li><p>删除session Ctrl+b :kill-session</p></li><li><p>临时退出session Ctrl+b d</p></li><li><p>列出session tmux ls</p></li><li><p>进入已存在的session tmux a -t $session_name</p></li><li><p>删除所有session Ctrl+b :kill-server</p></li><li><p>删除指定session tmux kill-session -t $session_name</p></li><li><p>开启光标</p></li></ul><p>​ ctrl + b 按下后松开 再立马按 [</p><ul><li>关闭光标</li></ul><p>​ ctrl + q 按下后松开 再立马按 [</p>]]></content>
    
    
    <summary type="html">描述了Tmux中的常用命令</summary>
    
    
    
    <category term="工具类使用笔记" scheme="https://blog.slks.xyz/categories/%E5%B7%A5%E5%85%B7%E7%B1%BB%E4%BD%BF%E7%94%A8%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Tmux" scheme="https://blog.slks.xyz/tags/Tmux/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记14——ResNet详解及为什么能解决深度网络退化问题</title>
    <link href="https://blog.slks.xyz/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B014%E2%80%94ResNet%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E9%80%80%E5%8C%96%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.slks.xyz/2022/01/23/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B014%E2%80%94ResNet%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E8%A7%A3%E5%86%B3%E6%B7%B1%E5%BA%A6%E7%BD%91%E7%BB%9C%E9%80%80%E5%8C%96%E9%97%AE%E9%A2%98/</id>
    <published>2022-01-23T12:26:19.000Z</published>
    <updated>2022-01-29T07:34:19.165Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一深度网络退化背景">一、深度网络退化背景</h2><p>​ 对于卷积神经网络，深度是一个很重要的因素。深度卷积网络自然的整合了低中高不同层次的特征，特征的层次可以靠加深网络的层次来丰富。因此在构建卷积网络时，网络的深度越高，可抽取的特征层次就越丰富越抽象。所以一般我们会倾向于使用更深层次的网络结构，以便取得更高层次的特征。但是更深层的网络结构有的时候并不会带来更好的结果，层数一旦过多以后，就会导致表现明显下降，这就是深度网络的退化问题。</p><p>​ 深度网络的退化问题到底是由于什么导致的呢？过拟合？还是梯度消失？梯度爆炸？</p><p>​ 其实都不是。如下图论文中显示的所示，显然其在训练集上的误差也很大，就不可能是过拟合问题。而梯度消失或梯度爆炸，通过加入BN层，就能够通过规整数据分布来解决这个问题，所以应当也不是梯度消失或爆炸的问题。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS82Y2M3OThjNC0wMTNmLTRkNjQtYmY5Yi0yZDg0YWExOTQzNzYucG5n.png" /></p><p>​ 那么根本原因是什么呢？</p><p>​ 在<strong>MobileNet V2</strong>的论文中提到，由于非线性激活函数Relu的存在，每次输入到输出的过程都几乎是不可逆的，这也造成了许多<strong>不可逆的信息损失</strong>。我们试想一下，一个特征的一些有用的信息损失了，那他的表现还能做到持平吗？显然不可能做到持平。随着网络层数的加深，造成了许多不可逆的信息损失，最终导致了深度网络的退化问题。</p><h2 id="二resnet提出初衷与详解">二、ResNet提出初衷与详解</h2><p>​ 我们选择加深网络的层数，是希望深层的网络的表现能比浅层好，或者是<strong>希望它的表现至少和浅层网络持平（相当于直接复制浅层网络的特征）</strong>，可实际的结果却让我们大吃一惊（深度网络退化），这是为什么呢？</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81OGU1NDU3Yy1lZWEwLTRmMjctOGVlMS04ZDJhMTk4YmJkOTcucG5n.png" /></p><p>​ 如图所示，这是一个直观的例子，我们把右边的网络理解为左边浅层网络加深了三层（框起来的部分），假如我们希望右边的深层网络与左边的浅层网络持平，即是希望框起来的三层跟没加一样，也就是加的三层的输入等于输出。我们假设这三层的输入为x，输出为H(x)，那么深层网络与浅层网络表现持平的直观理解即是H(x)=x，这种让输出等于输入的方式，就是ResNet论文中提到的<strong>恒等映射（identity mapping)</strong>。</p><p>​ 所以<strong>ResNet的初衷，就是让网络拥有这种恒等映射的能力，能够在加深网络的时候，至少能保证深层网络的表现至少和浅层网络持平</strong>。</p><p>​ 所以，现在我们知道，<strong>如果想要让深度神经网络不退化，根本的原因就是如何去做到恒等映射</strong>。然而现有的神经网络很难拟合潜在的恒等映射函数，H(x) = x，因为神经网络内部总会做一些参数的调整。但我们如果把恒等映射作为网络的一部分，将网络设计为H(x) = F(x) + x的形式，即如残差结构中所示那样，网络的输出是由x 和 F(x) 相加得到的，那么就可以把问题转化为 让中间多出来的那三层，去学习一个残差函数F(x) = H(x) - x。只要学习到的残差函数，能够使得F(x) = 0，那么就构成了一个恒等映射。最终网络的结果就不会比失去这几层要差。<strong>并且，让网络去拟合一个残差比拟合一个恒等映射容易得多（原因见后）</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS9mNGI5ZjRjYi04NWE4LTRmNjQtYjc0Ny1lMzU0ZDdjNmM2YmUucG5n.png" /></p><p>​ ResNet中，<strong>shortcut connection</strong>，<strong>通过跳接在激活函数前，将上一层（或几层）的输出与本层输出相加，将求和的结果输入到激活函数作为本层的输出</strong></p><p>​</p><h2 id="三为什么resnet能解决深度网络退化问题">三、为什么ResNet能解决深度网络退化问题？</h2><p>1、加了残差结构后就是给了输入x多一个选择，在神经网络学习到这层的参数是冗余的时候它可以选择直接走这条“跳接”曲线，跳过这个冗余层，而不需要再去拟合参数使得输出H(x)等于x。</p><p>2、因为学习残差的计算量比学习恒等映射小。假设普通网络为A，残差网络为B，输入为2，输出为2（输入和输出一样是为了模拟冗余层需要恒等映射的情况），那么普通网络就是A (2) = 2，而残差网络就是B ( 2 ) = F ( 2 ) + 2 = 2，显然残差网络中的F ( 2 ) = 0 。我们知道网络中权重一般会初始化成0附近的数，那么我们就很容易理解，为什么让F(2)（拟合0会比A (2) = 2 容易了</p><p>3、我们知道ReLU能够将负数激活为0，而正数输入等于输出。这相当于过滤了负数的线性变化，让F(x)=0变得更加容易。</p><p>4、我们知道残差网络可以表示成H ( x ) = F ( x ) + x ，这就说明了在求输出H ( x ) 对输入x 的倒数（梯度），也就是在反向传播的时候，H ′ ( x ) = F ′ ( x ) + 1，残差结构的这个常数1也能保证在求梯度的时候梯度不会消失。</p><h2 id="四一些细节问题">四、一些细节问题：</h2><p>​ 在ResNet中，残差连接的相加，指的是逐元素相加，在ReSNet的网络示意图中，有的Skip-Connection是实线，有的是虚线，<strong>虚线的代表这些模块前后的维度不一致，因为去掉残差结构的Plain网络还是和VGG一样，也就是每隔n层进行下采样但深度翻倍（VGG通过池化层下采样，ResNet通过卷积）</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS81YjZhMTNiZi00ZTU1LTRlMzYtOWY1NC05YzAzYzhkMmVkY2EucG5n.png" /></p><ul><li><p>空间上不一致时，需要给输入的X做一个线性的映射：调整一下H*W维度</p></li><li><p>深度上不一致时，有两种解决方法，一种是在跳接过程中加一个1×1的卷积层进行升维，另一种则是直接补零（先做下采样）。</p></li><li><p>针对比较深的神经网络，作者也考虑到计算量，会先用1×1的卷积将输入的256维降到64维，然后通过1×1恢复。这样做的目的是减少参数量和计算量。</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cHM6Ly9pbWdrci5jbi1iai51ZmlsZW9zLmNvbS85M2RiMDgzYi05NTk3LTRjZmUtODJmZC04NzRlNTI2NjViNmIucG5n.png" /></p><p>引用：https://blog.csdn.net/cristiano20/article/details/104309948</p>]]></content>
    
    
    <summary type="html">对于卷积神经网络，深度是一个很重要的因素。深度卷积网络自然的整合了低中高不同层次的特征，特征的层次可以靠加深网络的层次来丰富。因此在构建卷积网络时，网络的深度越高，可抽取的特征层次就越丰富越抽象。所以一般我们会倾向于使用更深层次的网络结构，以便取得更高层次的特征。但是更深层的网络结构有的时候并不会带来更好的结果，层数一旦过多以后，就会导致表现明显下降，这就是深度网络的退化问题。</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="ResNet" scheme="https://blog.slks.xyz/tags/ResNet/"/>
    
    <category term="Degradation" scheme="https://blog.slks.xyz/tags/Degradation/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记13——DropOut详解及为什么能够防止过拟合</title>
    <link href="https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94DropOut%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94DropOut%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E5%A4%9F%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2022-01-21T15:25:19.000Z</published>
    <updated>2022-01-29T07:34:08.351Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一dropout是什么">一、DropOut是什么？</h2><p>​ 过拟合是Deep Neural Networks(DNN)网络存在的问题之一。过拟合的特点是模型对训练数据的拟合非常好，但对测试数据的拟合却非常差，具体表现为loss和在训练集上的错误率非常低，而在验证集或测试集上却都要高很多。针对解决过拟合问题设计出来的方法很多，dropout就是其中一种最简单，也是最有效的方法。</p><p>​ 在训练DNN网络的过程中，对于每一个神经元，以p的概率被随机的drop out，也就是将其值置零。这样，在该轮前传和反传的过程中，该神经元将失去作用，相当于不存在，如下图所示。DropOut整体来说，是在训练过程中以一定的概率的使神经元失活，即输出为0，以提高模型的泛化能力，减少过拟合。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/dropout.jpeg" /></p><h2 id="二dropout阶段在训练阶段和测试阶段的区别">二、DropOut阶段在训练阶段和测试阶段的区别：</h2><h3 id="训练阶段">1、训练阶段：</h3><p>​ 在前向传播时，假设有这一层n个神经元，则我们可以假设每个神经元的概率都是0~1(可以通过python得到随机的值)，然后小于p的就失活，即不参与训练。</p><p>​ 在反向传播时，也只对参与训练的神经元进行参数更新。</p><p>​ 每次训练的时候，又是n个神经元，重新进行dropout</p><p>​ <strong>Dropout 在训练时采用，是为了减少神经元对部分上层神经元的依赖，类似将多个不同网络结构的模型集成起来，减少过拟合的风险。</strong></p><h3 id="测试阶段">2、测试阶段：</h3><p>​ 在测试时，应该用整个训练好的模型，不需要进行dropout。</p><p>​ 参与学习的节点和那些被隐藏的节点需要以一定的概率p加权求和，综合计算得到网络的输出。</p><p>​ 即预测的时候，每一个单元的参数要预乘以p。为什么要预乘以p呢？</p><p>​ 因为我们训练的时候会随机的丢弃一些神经元，但是预测的时候就没办法随机丢弃了。<strong>如果丢弃一些神经元，这会带来结果不稳定的问题，也就是给定一个测试数据，有时候输出a有时候输出b，结果不稳定，这是实际系统不能接受的</strong>，用户可能认为模型预测不准。那么<strong>一种”补偿“的方案就是每个神经元的权重都乘以一个p，这样在“总体上”使得测试数据和训练数据是大致一样的</strong>。</p><p>​ <strong>比如一个神经元的输出是x，那么在训练的时候它有p的概率参与训练，(1-p)的概率丢弃，那么它输出的期望是<span class="math inline">\(p \times x+(1-p) \times 0 = p \times x\)</span>。因此测试的时候把这个神经元的权重乘以p可以得到同样的期望。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121204115930.png" /></p><h2 id="三dropout如何防止过拟合">三、DropOut如何防止过拟合？</h2><p><strong>（1）数据层面</strong></p><p>​ 对于每一个dropout后的网络，进行训练时，相当于做了Data Augmentation。比如，对于某一层，dropout一些单元后，形成的结果是(1.5，0，2.5，0，1，2，0)，其中0是被drop的单元，那么总能找到一个样本，使得结果也是如此。这样每一次dropout其实都相当于增加了样本。</p><p><strong>（2）模型层面</strong></p><ul><li><p><strong>在较大程度上减小了网络的大小：</strong>在这个“残缺”的网络中，让神经网络学习数据中的局部特征（即部分分布式特征），但这些特征也足以进行输出正确的结果。</p></li><li><p><strong>取平均的作用：</strong> 如果正常的模型（没有dropout），我们用相同的训练数据去训练5个不同的神经网络，一般会得到5个不同的结果，此时我们可以采用 “5个结果取均值”或者“多数取胜的投票策略”去决定最终结果。（例如 3个网络判断结果为数字9,那么很有可能真正的结果就是数字9，其它两个网络给出了错误结果）。<strong>这种“综合起来取平均”的策略通常可以有效防止过拟合问题。因为不同的网络可能产生不同的过拟合，取平均则有可能让一些“相反的”拟合互相抵消。每次训练随机dropout掉不同的隐藏神经元，网络结构已经不同，这就类似在训练不同的网络，整个dropout过程就相当于对很多个不同的神经网络取平均。而不同的网络产生不同的过拟合，一些互为“反向”的拟合相互抵消就可以达到整体上减少过拟合。</strong></p></li><li><p><strong>减少神经元之间共适应关系：</strong> 因为dropout导致两个神经元不一定每次都在一个网络中出现，这样权值的更新不再依赖于有固定关系的隐含节点的共同作用，阻止了某些特征仅仅在其它特定特征下才有效果的情况， 迫使网络去学习更加鲁棒的特征。换句话说，假如神经网络是在做出某种预测，<strong>它不应该对一些特定的线索片段太过敏感</strong>，即使丢失特定的线索，它也应该可以从众多其它线索中学习一些共同的模式（鲁棒性）。</p></li></ul><p>引用：</p><p>https://zhuanlan.zhihu.com/p/175142160</p><p>https://www.zhihu.com/question/402485242/answer/1553947864</p>]]></content>
    
    
    <summary type="html">过拟合是Deep Neural Networks(DNN)网络存在的问题之一。过拟合的特点是模型对训练数据的拟合非常好，但对测试数据的拟合却非常差，具体表现为loss和在训练集上的错误率非常低，而在验证集或测试集上却都要高很多。针对解决过拟合问题设计出来的方法很多，dropout就是其中一种最简单，也是最有效的方法。在训练DNN网络的过程中，对于每一个神经元，以p的概率被随机的drop out，也就是将其值置零。这样，在该轮前传和反传的过程中，该神经元将失去作用，相当于不存在，如下图所示。DropOut整体来说，是在训练过程中以一定的概率的使神经元失活，即输出为0，以提高模型的泛化能力，减少过拟合。</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="OverFitting" scheme="https://blog.slks.xyz/tags/OverFitting/"/>
    
    <category term="DropOut" scheme="https://blog.slks.xyz/tags/DropOut/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记12——BatchNorm详解及为什么能防止过拟合</title>
    <link href="https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B012%E2%80%94BatchNorm%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B012%E2%80%94BatchNorm%E8%AF%A6%E8%A7%A3%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E8%83%BD%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2022-01-21T14:01:19.000Z</published>
    <updated>2022-01-29T07:34:02.518Z</updated>
    
    <content type="html"><![CDATA[<h2 id="一详解batchnorm原理">一、详解BatchNorm原理：</h2><p>​ BatchNorm是一种能够加速深度神经网络收敛，避免过拟合的方法，那么为什么呢？首先我们需要探讨一下这个问题，为什么深度神经网络<strong>随着网络深度加深，训练起来越困难，收敛越来越慢？</strong></p><p>在回答这个问题前需要首先了解两个概念：</p><p>​ <strong>1、独立同分布（IID）</strong>：即假设训练数据和测试数据是满足相同分布的。它是通过训练数据获得的模型能够在测试集获得好的效果的一个基本保障</p><p>​ <strong>2、Covariate shift</strong>：<strong>如果ML系统实例集合&lt;X,Y&gt;中的输入值X的分布老是变，这不符合IID假设</strong>，网络模型很难<strong>稳定的学规律</strong>。</p><p>​ 所以，之所以深度神经网络随着网络深度加深，训练越来越困难是因为，对于深度学习这种包含很多隐层的网络结构，在训练过程中，因为各层参数不停在变化，所以每个隐层都会面临covariate shift的问题，也就是<strong>在训练过程中，隐层的输入分布老是变来变去，这就是所谓的“Internal Covariate Shift（ICS）”，Internal指的是深层网络的隐层，是发生在网络内部的事情，而不是covariate shift问题只发生在输入层</strong></p><p>​ BatchNorm的基本思想就是能不能<strong>让每个隐层节点的激活输入分布固定下来呢</strong>？这样就避免了“Internal Covariate Shift”问题了。</p><p>所以BN实质上就是在深度神经网络训练过程中使得每一层神经网络的输入保持相同分布的一种方法。</p><p>​ BN的基本思想其实相当直观：因为深层神经网络在做非线性变换前的<strong>激活输入值随着网络深度加深或者在训练过程中，其分布逐渐发生偏移或者变动，之所以训练收敛慢，一般是整体分布逐渐往非线性函数的取值区间的上下限两端靠近</strong>（对于Sigmoid函数来说，意味着激活输入值WU+B是大的负值或正值），所以这<strong>导致反向传播时低层神经网络的梯度消失</strong>，这是训练深层神经网络收敛越来越慢的<strong>本质原因</strong>，<strong>而BN就是通过一定的规范化手段，把每层神经网络任意神经元这个输入值的分布强行拉回到均值为0方差为1的标准正态分布</strong>，其实就是把越来越偏的分布强制拉回比较标准的分布，这样使得激活输入值落在非线性函数对输入比较敏感的区域，这样输入的小变化就会导致损失函数较大的变化，意思是<strong>这样让梯度变大，避免梯度消失问题产生，而且梯度变大意味着学习收敛速度快，能大大加快训练速度。</strong></p><p>​ <strong>对于每个隐层神经元，把逐渐向非线性函数映射后向取值区间极限饱和区靠拢的输入分布强制拉回到均值为0方差为1的比较标准的正态分布，使得非线性变换函数的输入值落入对输入比较敏感的区域，以此避免梯度消失问题。</strong>因为梯度一直都能保持比较大的状态，所以很明显对神经网络的参数调整效率比较高，就是变动大，就是说向损失函数最优值迈动的步子大，也就是说收敛地快。BN说到底就是这么个机制，方法很简单，道理很深刻。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/aHR0cDovL3FsLm1hZ2ljLXNldmVuLnRvcC91cGxvYWQvMjAyMC8zL2ltYWdlLTVkMjU4MDQxNGI0YTRkNjhiODEzMDMxMDZlMzY5YzNiLnBuZw.png" /></p><h2 id="二batchnorm在训练阶段和测试阶段的做法与意义">二、BatchNorm在训练阶段和测试阶段的做法与意义：</h2><h3 id="训练阶段">1、训练阶段：</h3><p>​ 首先计算均值和方差（每次训练给一个批量，计算批量的均值方差），然后归一化，然后缩放和平移，完事！</p><h3 id="测试阶段">2、测试阶段：</h3><p>​ 每次只输入一张图片，这怎么计算批量的均值和方差，于是，就有了代码中下面两行，在训练的时候实现计算好mean、 var，测试的时候直接拿来用就可以了，不用计算均值和方差。</p><p>​ 用训练集来估计总体均值 μ 和总体标准差 σ 。</p><p>​ 较为简单的做法就是把每个mini-batch的均值和方差都保存下来，然后训练完了求均值的均值，方差的均值即可。</p><p>​ 在测试阶段应用BatchNorm的含义，应该就是要让测试集的测试精度与整个训练网络保持一致。</p><h2 id="三batchnorm的两个参数gamma和beta有什么作用">三、BatchNorm的两个参数<span class="math inline">\({\gamma}\)</span>和<span class="math inline">\(\beta\)</span>有什么作用？</h2><p><img src="https://www.zhihu.com/equation?tex=y%3D\frac%7Bx-\mathrm%7BE%7D%5Bx%5D%7D%7B\sqrt%7B\operatorname%7BVar%7D%5Bx%5D%2B\epsilon%7D%7D+*+\gamma%2B\beta+" /></p><h3 id="如果只做归一化为什么是学不到任何东西的">1、如果只做归一化，为什么是学不到任何东西的？</h3><p>​ 如果在每一层之后都归一化成0-1的高斯分布（减均值除方差）那么数据的分布一直都是高斯分布，数据分布都是固定的了，这样即使加更多层就没有意义了，<strong>深度网络就是想学习数据的分布发现规律性，BN就是不让学习的数据分布偏离太远</strong></p><h3 id="两个参数的作用">2、两个参数的作用</h3><p>​ 为了减小Internal Covariate Shift，对神经网络的每一层做归一化不就可以了，假设将每一层输出后的数据都归一化到0均值，1方差，满足正胎分布，但是，此时有一个问题，<strong>如果每一层的数据分布都是标准正太分布，导致其完全学习不到输入数据的特征，因为，费劲心思学习到的特征分布被归一化了，因此，直接对每一层做归一化显然是不合理的。</strong>但是如果稍作修改，加入可训练的参数做归一化，那就是BatchNorm 实现的了。</p><p>​ 接下来详细介绍一下这额外的两个参数，之前也说过如果直接做归一化不做其他处理，神经网络是学不到任何东西的，但是加入这两个参数后，事情就不一样了。先考虑特殊情况下，如果γ 和β 分别等于此batch的标准差和均值，那么<span class="math inline">\(y_i\)</span>就还原到归一化前的x了吗，也即是缩放平移到了归一化前的分布，相当于batch norm没有起作用，<span class="math inline">\(β\)</span>和γ 分别称之为 平移参数和缩放参数 。这样就<strong>保证了每一次数据经过归一化后还保留的有学习来的特征，同时又能完成归一化这个操作，加速训练</strong>。</p><p>引用：https://www.cnblogs.com/hoojjack/p/12350707.html</p>]]></content>
    
    
    <summary type="html">BatchNorm是一种能够加速深度神经网络收敛，避免过拟合的方法，那么为什么呢？首先我们需要探讨一下这个问题，为什么深度神经网络随着网络深度加深，训练起来越困难，收敛越来越慢？</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="OverFitting" scheme="https://blog.slks.xyz/tags/OverFitting/"/>
    
    <category term="Batch Normalization" scheme="https://blog.slks.xyz/tags/Batch-Normalization/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记11——Training Data、Validation Data、Testing Data含义及作用</title>
    <link href="https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B011%E2%80%94Training%20Data%E3%80%81Validation%20Data%E3%80%81Testing%20Data%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8/"/>
    <id>https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B011%E2%80%94Training%20Data%E3%80%81Validation%20Data%E3%80%81Testing%20Data%E5%90%AB%E4%B9%89%E5%8F%8A%E4%BD%9C%E7%94%A8/</id>
    <published>2022-01-21T08:01:19.000Z</published>
    <updated>2022-01-29T07:33:51.758Z</updated>
    
    <content type="html"><![CDATA[<p>我们在进行一个机器学习的任务的时候，往往会将所有数据划分成三块——Training Data、Validation Data、Testing Data,它们各自在训练的过程中扮演何种角色呢？</p><h4 id="一trainvaltest的含义与作用">一、Train、Val、Test的含义与作用：</h4><p>顾名思义，三个数据集合它们的简单含义如下：</p><ul><li>训练集(train)：训练模型，用来拟合模型的数据集；</li><li>验证集(val)：评估模型，训练过程中提供相对于train的无偏估计的数据集，同时用来调整超参数和特征选择，实际参与训练</li><li>测试集(test)：最终模型训练好之后，用来提供相对于train+valid的无偏估计的数据集。</li></ul><p>​ 一般我们会将最开始划分的Training Set分割为Training Data和Validation Data两个集合，一般而言比例为9：1。我们使用划分后的Training Data进行训练，在每个Epoch结束后使用训练期间机器没有见到过的Validation进行验证，依据验证集得到的Loss值来进行模型好坏的衡量。</p><p>​ 话句话说，Validation Data　其实就是用来避免过拟合的，在训练过程中，我们通常用它来确定一些超参数（比如根据validation data上的accuracy来确定early stopping的epoch大小、根据validation data确定learning rate等等）。</p><p>​ 那为啥不直接在Testing data上做这些呢？因为如果在Testing data做这些，那么随着训练的进行，我们的网络实际上就是在一点一点地overfitting我们的Testing data，导致最后得到的Testing accuracy没有任何参考意义。因此，Training data的作用是计算梯度更新权重，Validation data在每个Epoch结束后进行验证，Testing data则给出一个accuracy以判断网络的好坏。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/20210202115236662.png" /></p><p><strong>如上所示的训练划分容易带来一些显而易见的问题：</strong></p><ul><li>如果样本数量太少，验证集和测试集更少，无法在统计学上代表数据</li><li>划分数据前时，进行不同的随机打乱则得到的模型性能差别可能很大，可能训练集中的数据都偏向于某一类，而验证集的数据偏向于另一类</li></ul><h4 id="二n-fold-cross-validation">二、N-Fold Cross Validation</h4><p>此时，就可以使用常见的叫做N-Fold Cross Validation，（K折交叉验证）：</p><p>​ 如下图所示,我们将Training Set分为N个集合(示例中为3个),其中N-1个集合用于训练,1个集合用于验证,然后每轮Epoch中,都执行N遍,每一遍都拿不同的集合用于训练与验证,然后计算一遍Loss值,最终选取平均Loss最小的那一组参数进行模型的更新.</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/imac/image-20220114111918585.png" /></p>]]></content>
    
    
    <summary type="html">我们在进行一个机器学习的任务的时候，往往会将所有数据划分成三块——Training Data、Validation Data、Testing Data,它们各自在训练的过程中都扮演着某种角色</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Training Set" scheme="https://blog.slks.xyz/tags/Training-Set/"/>
    
    <category term="Validation Set" scheme="https://blog.slks.xyz/tags/Validation-Set/"/>
    
    <category term="Testing Set" scheme="https://blog.slks.xyz/tags/Testing-Set/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记10——L1、L2正则化以及为什么正则化能够防止过拟合</title>
    <link href="https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B010%E2%80%94L1%20L2%E6%AD%A3%E5%88%99%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AD%A3%E5%88%99%E5%8C%96%E8%83%BD%E5%A4%9F%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/"/>
    <id>https://blog.slks.xyz/2022/01/21/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B010%E2%80%94L1%20L2%E6%AD%A3%E5%88%99%E5%8C%96%E4%BB%A5%E5%8F%8A%E4%B8%BA%E4%BB%80%E4%B9%88%E6%AD%A3%E5%88%99%E5%8C%96%E8%83%BD%E5%A4%9F%E9%98%B2%E6%AD%A2%E8%BF%87%E6%8B%9F%E5%90%88/</id>
    <published>2022-01-21T07:01:19.000Z</published>
    <updated>2022-01-29T07:33:02.646Z</updated>
    
    <content type="html"><![CDATA[<p>在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合）。其直观的表现如下图所示，随着训练过程的进行，模型复杂度增加，在Training data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集，对训练集外的数据却不work。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/OhX9eFQ.jpg" /></p><p>​ 在ML2021课程系列笔记2中，提及了一些防止过拟合的内容，本篇用于详细解释其中正则化的部分：</p><h3 id="一什么是l1l2正则化">一、什么是L1、L2正则化？</h3><h4 id="l1-正则化">L1 正则化：</h4><p>​ 简单而言，L1正则化就是在Loss函数后面增加一个正则化项，L1正则化的公式如下,</p><p>​ <span class="math inline">\(C_0\)</span>为原来的损失函数，即所有权重w的绝对值的和. n是训练集的样本大小，λ 是正则项系数，C为加了正则化后的损失函数</p><p>​ <span class="math inline">\(C = C_0 + \frac{\lambda}{n} \sum_{w}|w|\)</span></p><h4 id="l2-正则化">L2 正则化：</h4><p>​ 简单而言，L2正则化也是在Loss函数后面增加一个正则化项，L2正则化的公式如下,与上含义类似。</p><p>​ <span class="math inline">\(C = C_0 + \frac{\lambda}{2n} \sum_w w^2\)</span></p><h3 id="二l1l2正则化如何避免overfitting">二、L1、L2正则化如何避免OverFitting？</h3><h4 id="l1l2正则化能降低权重值w">1、L1、L2正则化能降低权重值w</h4><p>​ 我们以L2正则化项为例，进行解释，首先我们让C对偏置项b和对权重系数w进行求导，得到如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/mebEC90.jpg" /></p><p>​ 我们发现，C对b求导与正则化项无关，C对w求导得到得结果与正则化项有关。</p><p>​ 最终所反映到梯度下降优化参数上，就是如下图所示得情况：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/qM83geg.jpg" /></p><p>​ <strong>如果没有正则化项，那么更新得w前得系数应当为1，而现在由于因为η、λ、n都是正的，所以 1−ηλ/n小于1，它的效果是减小w，这也就是权重衰减（weight decay）的由来</strong>。</p><p>​ <strong>到此为止，我们发现L2正则化项，其能够使得减小w。（其实这一点比较直观的也能看出来，因为Loss函数中加入了一项<span class="math inline">\(w^2\)</span>的求和，也就是说如果权重值w过大，Loss函数值会上升，这就意味着这一个正则化项惩罚了权值矩阵使其不能取太大值。）</strong></p><p>​ 那么，关键问题是，<strong>为什么权重矩阵w小，能够防止过拟合呢？</strong></p><h4 id="较高的权重w往往意味着过拟合的函数">2、较高的权重w往往意味着过拟合的函数：</h4><p>​ 我们会发现：<strong>过拟合的时候，拟合函数的系数往往非常大，为什么？如下图所示，过拟合，就是拟合函数需要顾忌每一个点，最终形成的拟合函数波动很大。在某些很小的区间里，函数值的变化很剧烈。这就意味着函数在某些小区间里的导数值（绝对值）非常大，由于自变量值可大可小，所以只有系数足够大，才能保证导数值很大。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/RsR5cOK.png" /></p><p>​</p><p>​ 更进一步的解释：当权重系数很小的时候，容易出现像左图一样，高偏差拟合能力很差的情况，随着权重系数逐渐增大，就会像右侧的图进行发展。如果权重系数很大，往往意味着在某些很小的区间中，函数值的变化会非常的剧烈，导致一些高方差的结果，也就是函数对于训练数据过度拟合了。</p><p>​ <img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220121122935964.png" /></p><p>​</p>]]></content>
    
    
    <summary type="html">在训练数据不够多时，或者overtraining时，常常会导致overfitting（过拟合）。其直观的表现为，随着训练过程的进行，模型复杂度增加，在Training data上的error渐渐减小，但是在验证集上的error却反而渐渐增大——因为训练出来的网络过拟合了训练集，对训练集外的数据却不work。在ML2021课程系列笔记2中，提及了一些防止过拟合的内容，本篇用于详细解释其中正则化的部分：</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="OverFitting" scheme="https://blog.slks.xyz/tags/OverFitting/"/>
    
    <category term="Regularization" scheme="https://blog.slks.xyz/tags/Regularization/"/>
    
  </entry>
  
  <entry>
    <title>《DG-Font Deformable Generative Networks for Unsupervised Font Generation》</title>
    <link href="https://blog.slks.xyz/2022/01/20/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E3%80%8ADG-Font%20Deformable%20Generative%20Networks%20for%20Unsupervised%20Font%20Generation%E3%80%8B/"/>
    <id>https://blog.slks.xyz/2022/01/20/Paper%E7%AC%94%E8%AE%B0/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B04%E2%80%94%E2%80%94%E3%80%8ADG-Font%20Deformable%20Generative%20Networks%20for%20Unsupervised%20Font%20Generation%E3%80%8B/</id>
    <published>2022-01-20T10:12:19.000Z</published>
    <updated>2022-01-29T07:28:02.397Z</updated>
    
    <content type="html"><![CDATA[<h4 id="论文名称dg-font-deformable-generative-networks-for-unsupervised-font-generationcvpr2021">论文名称：《DG-Font: Deformable Generative Networks for Unsupervised Font Generation》CVPR2021</h4><h4 id="论文地址-httpsopenaccess.thecvf.comcontentcvpr2021htmlxie_dg-font_deformable_generative_networks_for_unsupervised_font_generation_cvpr_2021_paper.html">论文地址： https://openaccess.thecvf.com/content/CVPR2021/html/Xie_DG-Font_Deformable_Generative_Networks_for_Unsupervised_Font_Generation_CVPR_2021_paper.html</h4><h2 id="关键词">1、关键词：</h2><p>​ Font-Generation、Deformable Convolution Skip Connection、Unsupervised Learning</p><h2 id="领域背景">2、领域背景：</h2><p>​ 字体生成是一个具有挑战的任务，现存的大部分方法都是通过<strong>有监督学习</strong>的方法进行字体的生成，他们需要大量的<strong>paired data</strong>（例如对应风格的字符图像），然而大量的这些数据需要花费非常昂贵的代价去进行收集。</p><p>​ 字体生成目标是自动的能够生成某种特定字体的字符，并且创造一个字体字符集。</p><p>​ 在传统的字符集的创造方式中，严重依赖于专家设计者，独立的去绘制每一个字体的图像，这对于一些基于语标的语言（比如中文、日文、韩文）很不友好。专家们需要有大量的工作量去进行设计，字体生成领域就是为了解决这样一个问题，使用神经网络去学习从一种风格到另一种风格的映射关系，从而生成特定语言的某种风格的一个字符集。</p><p>​ 与字体生成最相关的<strong>图像生成领域 （Image-To-Image Translation）</strong>，在通常的image-to-image的转换模型中通常将<strong>style</strong>定义为<strong>纹理和颜色</strong>，而字体的<strong>style</strong>往往是指<strong>字体的格式几何形状、笔画粗细、笔尖和连笔书写的模式等内容。（geometric transformation, stroke thickness, tips, and joined-up writing pattern）</strong>，故而没法直接应用到字体的生成上。同时在图像中往往采用的<strong>AdaIN-based</strong>方法（这种方法是在统计学上对齐特征来迁移图像的纹理和颜色特征）对于字体这种变换局部的特征模式的任务是不合适的。</p><p>​ 同时，对于image-to-image的生成任务而言，一系列的<strong>无监督</strong>的方法，都是使用对抗<strong>训练结合Consistent Contrains</strong>来进行的。如果使用image-to-image的方法直接应用到字体生成任务中的话，即使Consistent Constraints会帮助我们<strong>保留一个字符图片内容的结构</strong>，但是他们仍然会导致<strong>诸如模糊、丢失笔画</strong>等问题。</p><h2 id="先前工作描述与比较">3、先前工作描述与比较：</h2><h4 id="image-to-image-translation">1) Image-To-Image Translation</h4><p>​ <strong>image-to-image迁移的任务，就是学习一个从source domain到target domain的映射关系。其可以用于艺术风格迁移、语义分割、图像动画等等。</strong></p><ul><li>Pix2Pix是基于Conditional GAN的第一个做Image-to-Image的迁移任务。</li><li>Cycle-GAN通过Cycle Consistency 做到了无监督学习。</li></ul><p>​ <strong>这类工作无法直接应用至Font-Generation中，原因在Part2的领域背景最后已经做了简略的描述</strong></p><h4 id="font-generation">2) Font-Generation</h4><p>​ <strong>字体生成目标是自动的能够生成某种特定字体的字符，并且创造一个字体字符集。</strong></p><p>​ <strong>一般而言，从前的方法有两大条路径：</strong></p><ul><li><strong>基于paired data进行训练</strong><ul><li>EMD和SAVAE设计的神经网络，分割开了字体的内容和风格（content &amp; style）的表示，可以生成新的风格的字符内容。</li><li>zi2zi和rewrite这两篇论文，通过上千对匹配的字符，基于GAN进行了有监督学习。其之后，很多文章基于zi2zi进行了生成质量的改进。</li></ul></li><li><strong>基于辅助标识（例如笔画、部首等内容）</strong><ul><li><strong>这类方法往往都依赖于先验知识，并且只能应用到特定的书写系统中去。 并且这些方法仍旧需要数千匹配的数据以及辅助注释</strong></li><li>《Scfont: Structure-guided chinese font generation via deep stacked networks.》给每个笔画打上标签，来通过书写轨迹的合成，生成字的图像</li><li>DM-FONT 提出解纠缠策略来解纠缠复杂的字形结构，这有助于在富文本设计中捕获局部细节</li><li>CalliGAN 进一步将字符分解为组件，并提供包括笔画顺序在内的低级结构信息来指导生成过程。</li><li>《RD-GAN: few/zero-shot chinese character styletransfer via radical decomposition and rendering》 使用对字符偏旁部首的分解，来达到字体的生成</li><li>其他一些的方法也通过提取字符的骨架和笔画的算法来进行生成</li></ul></li></ul><p>​ <strong>相比之下，该篇论文提出的DG-FONT不需要其他的辅助标识，并且是无监督的形式进行的</strong></p><h4 id="deformable-convolution">3) Deformable Convolution</h4><p>​ <strong>介绍链接：https://blog.slks.xyz/2022/01/07/basic5/</strong></p><p>​ <strong>可变形卷积Deformable Convolution</strong>，<strong>其加强了CNN的变换建模能力</strong>，它通过额外的偏移量增加了模块中的空间采样位置。 可变形卷积已被应用于解决几个高级视觉任务，例如对象检测、视频对象检测采样、语义分割和人体姿态估计。</p><p>​ 最近，一些方法尝试在图像生成任务中应用可变形卷积。 TDAN[48] 通过使用可变形卷积对齐两个连续帧并输出高分辨率帧来解决视频超分辨率任务。</p><p>​ <strong>在我们提出的 DG-Font 中，可变形卷积的偏移量是通过 learned latent style code来进行估计的。</strong>（具体内容见后细节）</p><h2 id="主要设计思想">4、主要设计思想：</h2><p>​ 作者提出了可变形生成网络（Deformable Generative Networks）来做<strong>非监督的字体生成</strong>。其利用提供的目标字体图像（<strong>style image input</strong>）来将一种字体的字符变形和转换为另一种字体。</p><p>​ DG-FONT 分离了字体的style和content，然后再将两个domain的表示进行融合，生成新的字体的字符。</p><p>​ 其核心模块为一个叫做<strong>FDSC（feature deformation skip connection）的东西</strong>，可以用来预测一个位移映射map然后使用位移映射map去对low-level的特征图做变形卷积。然后FDSC的输出被送入一个混合器，然后生成最终的结果。</p><p>​ FDSC模块将会<strong>对内容图像的低层级特征进行变换，其能够保留文字本身的模式</strong>，比如笔画和偏旁部首信息。因为对于内容相同的两种不同风格的字体，<strong>它们的每一笔画通常都是对应的</strong>（如下图所示）。利用字体的空间关系，利用FDSC进行空间变形，<strong>有效地保证了生成的字符具有完整的结构</strong>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116172624229.png" /></p><p>​</p><p>​ 同时，为了区分不同的风格，模型还使用了一个多任务标识符判别器Multi-Task Discriminator，以保证每个风格都可以被独立判定。</p><h2 id="具体方法与网络架构">5、具体方法与网络架构：</h2><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116160758876.png" /></p><h3 id="整体架构overall-pipeline">1) 整体架构（Overall Pipeline）</h3><ul><li><p><strong>概述</strong>：如上图所示，整个网络包含一个 Style Encoder、一个Content Encoder、一个Mixer、和两个FDSC模块。</p><ul><li><p><strong>Style Encoder</strong> 从输入图像中学习Style Representation。具体而言，其将一个Style Image作为输入，将其映射至一个Style Latent Vector <span class="math inline">\(Z_S\)</span>。</p></li><li><p><strong>Content Encoder</strong> 提取Content Images的结构特征，将其 映射到一个空间特征图 <span class="math inline">\(Z_C\)</span></p></li><li><p><strong>Deformable Convolution</strong>能够使得<em>Content Encoder</em>去识别到相同内容的字中Style-Invariant的特征</p></li><li><p><strong>Mixer</strong> 通过混合<span class="math inline">\(Z_C\)</span>和<span class="math inline">\(Z_S\)</span>来生成输出字符。其使用<strong>AdaIN</strong>方法将style特征注入Mixer中。</p></li><li><p><strong>FDSC</strong> 模块能够将变形的<em>Low-Level</em>特征从<em>Content Encoder</em>中传输到Mixer中</p></li><li><p><strong>Multi-Task Discriminator</strong> ：当字符图像从生成网络生成后，该判别器用来对每个单独的 Style 同时执行判断任务。对于每一个style来说， Discriminator的输出是一个二元分类器， 判断其是真实图片还是生成图片。同时，因为在训练集中，有多种不同的字体风格，所以判别器的输出是一个数组，它的长度是所有风格的数量，数组里的每个元素是一个二元向量【例如，假设总共有5个风格，最终判别器输出的应当是如下的一个向量：</p><p>​ [ [ 1 0 ] , [ 0 0 ] , [ 0 0 ] , [ 0 0 ] , [ 0 0 ] ]</p><p>】</p></li></ul></li><li><p><strong>输入</strong>：<strong>Style Image</strong>【风格A，汉字1】、<strong>Content Image</strong>【风格B，汉字2】</p></li><li><p><strong>输出</strong>：<strong>Output Image</strong>【风格A，汉字2】</p></li></ul><h3 id="style-encoder">2) Style Encoder</h3><ul><li><strong>概述</strong>：从输入图像中学习 Style Representation。具体而言，其将一个Style Image作为输入，将其映射至一个Style Latent Vector <span class="math inline">\(Z_S\)</span>。</li><li><strong>输入</strong>：Style Image <span class="math inline">\(I_s \in R^{H*W}\)</span></li><li><strong>输出</strong>：Style Latent Vector <span class="math inline">\(Z_s \in R\)</span></li><li><strong>网络结构</strong>：如下所示<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220119151744473.png" /></li></ul></li><li><strong>公式表达</strong>：</li><li><strong>实现细节（官方代码）</strong><ul><li>其在源代码中，其为GuidingNet文件部分，可供选择的项有Vgg11，Vgg13，Vgg16，Vgg19等。这个StyleEncoder网络将输入的StyleImage进行特征的提取以后，得到特征向量，在Decoder中使用AdaIn融合之前，源代码中还经过了一个MLP模块。然后，利用MLP模块输出的内容，对AdaIN2d里面的weight和bias进行初始化，最终达到</li></ul></li></ul><h3 id="content-encoder">3) Content Encoder</h3><ul><li><p><strong>概述</strong>：提取Content Images的结构特征，将其 映射到一个空间特征图 <span class="math inline">\(Z_C\)</span></p></li><li><p><strong>输入</strong>：Content Image <span class="math inline">\(I_c \in R^{H*W}\)</span></p></li><li><p><strong>输出</strong>：Content Latent Vector <span class="math inline">\(Z_c \in R\)</span></p></li><li><p><strong>网络结构细节</strong>：</p><ul><li><p>in_channel = 3,out_channel=64,kernel_size=7 x 7,stride = 1,padding = 3 的变形卷积层 + IN(64) 归一化 + Activation(ReLu)</p></li><li><p>得到FDSC-1模块的输入 skip1 [32, 64, 80, 80]</p></li><li><p>in_channel = 64,out_channel=128,kernel_size =4 x 4,stride=2,padding=1 的变形卷积层 + IN(128) 归一化 + Activation(ReLu)</p></li><li><p>得到FDSC-2模块的输入 skip2 [30,128,40,40]</p></li><li><p>in_channel =128,out_channel=256,kernel_size =4 x 4,stride=2,padding=1 的变形卷积层 + IN(256) 归一化 + Activation(ReLu)</p></li><li><p>N个ResBlock</p><ul><li><p>每个ResBlock如下：</p></li><li><p>Input---&gt;Conv2D---&gt;Conv2D---&gt; + ---&gt; output</p><p><span class="math inline">\(\downarrow\)</span>-------------------------------------------<span class="math inline">\(\uparrow\)</span></p></li><li><p>Conv2D,in_dim=256,out_dim=256,kernel_size=3x3,stride=1,padding=1 普通卷积层</p></li></ul></li></ul></li><li><p><strong>举例</strong>：</p><ul><li>假设输入图像为 80 * 80 ，Batch_Size = 32 , 那么：skip1,skip2和最终的output <span class="math inline">\(Z_c\)</span>的大小分别如下：</li><li>skip1.shape: torch.Size([32, 64, 80, 80])</li><li>skip2.shape: torch.Size([32, 128, 40, 40])</li><li>ouput.shape: torch.Size([32, 256, 20, 20])</li></ul></li><li><p><strong>意义</strong>：提取Content Images的结构特征，应用变形卷积层能够保持字体笔画结构</p></li></ul><h3 id="feature-deformation-skip-connection-fdsc-module">4) Feature Deformation Skip Connection ( FDSC Module)</h3><ul><li><p><strong>概述</strong>：其由一个变形卷积层组成，具体的作用作者在书写时写在了Mixer的卷积层后的内容里</p></li><li><p><strong>实现细节</strong></p><ul><li><p>首先，其输入来自于Content Encoder，也就是文中提及的skip1和skip2，我们以skip1为例继续讲解：</p></li><li><p>其次，它会将Skip1和Mixer中经过了Conv以后的内容A，Concat一起，然后将这个Concat完的东西放入变形卷积模块中，得到一个新计算的Concat_Pre,最后将这个Concat_Pre和A再Concat到一起，得到最终的输出。</p></li><li><p>这就是为什么在论文的示意图中：这个FDSC模块有来回的箭头表示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_19_15_31_59_728.png" /></p></li></ul></li></ul><h3 id="mixer">5) Mixer</h3><ul><li><p><strong>概述</strong>：通过混合<span class="math inline">\(Z_C\)</span>和<span class="math inline">\(Z_S\)</span>来生成输出字符。其使用<strong>AdaIN</strong>方法将style特征注入Mixer中。</p></li><li><p><strong>输入</strong>： <span class="math inline">\(Z_c \in R\)</span>即ContentEncoder的输出，256通道的特征图 [32,256,20,20]</p></li><li><p><strong>输出</strong>：</p></li><li><p><strong>网络结构及细节</strong>：</p><ul><li>2个ResBlock，输出仍然为256通道的特征图 [32,256,20,20]</li><li>Upsample上采样 ，特征图大小变为 40 x 40</li><li>Conv2dBlock，in_channel = 256,out_channel=128,kernel_size =5 x 5,stride=1,padding=2 的卷积层 + AdIN(128) 归一化 + Activation(ReLu), 经过该层后，计算得到的大小应当为 [32,128,40,40]<ul><li>然后，需要将此层输出的output和skip2在Channel通道Concat起来，得到deformable_concat [32,256,40,40]</li><li>然后将deformable_concat与skip2 输入 FDSC的变形卷积模块中，得到 concat_pre [32,128,40,40] 和 offset2 [32,18,40,40]</li><li>最后将cancat_pre和最开始的output Concat起来，得到该步的最终输出，大小为 [32，256，40，40]</li></ul></li><li>Upsample上采样，特征图大小变为80 x 80</li><li>Conv2dBlock，in_channel = 256,out_channel=64,kernel_size =5 x 5,stride=1,padding=2 的卷积层 + AdIN(64) 归一化 + Activation(ReLu), 经过该层后，计算得到的大小应当为 [32,64,80,80]<ul><li>然后，需要将此层输出的output和skip1在Channel通道Concat起来，得到deformable_concat [32,128,80,80]</li><li>然后将deformable_concat与skip1 输入 变形卷积模块中，得到 Concat_pre [32,128,40,40] 和 offset2 [32,18,40,40]</li><li>最后将cancat_pre和最开始的outputConcat起来，得到该步的最终输出，大小为 [32，256，40，40]</li></ul></li><li>Conv2dBlock，in_channel = 128,out_channel=3,kernel_size =7 x 7,stride=1,padding=3 的卷积层 + Activation(Tanh), 经过该层后，计算得到的大小应当为 [32,3,80,80]</li></ul></li></ul><h3 id="multi-task-discriminator">6) Multi-Task Discriminator</h3><ul><li><p><strong>概述</strong>：当字符图像从生成网络生成后，该判别器用来对每个单独的 Style 同时执行判断任务。对于每一个style来说， Discriminator的输出是一个二元分类器， 判断其是真实图片还是生成图片。</p></li><li><p><strong>输入</strong>：</p><ul><li>- x: images of shape (batch, 3, image_size, image_size).，例如为 4个 3 * 64 * 64的图像</li><li>- y: domain indices of shape (batch). 例如 y_in 为 4个需要其判断的 domain的标号</li></ul></li><li><p><strong>输出</strong>：各个需要判断的得分情况</p></li><li><p><strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">D = Discriminator(<span class="number">64</span>, <span class="number">4</span>)  <span class="comment"># 初始化判别器参数 64 为图像大小，4为该判别器需要判别区分的domain的数量</span></span><br><span class="line">x_in = torch.randn(<span class="number">2</span>, <span class="number">3</span>, <span class="number">64</span>, <span class="number">64</span>)  <span class="comment"># x_in 为 2个 3*64*64的图像  y_in 为 2个需要其判断的 domain的标号</span></span><br><span class="line">y_in = torch.randint(<span class="number">0</span>, <span class="number">10</span>, size=(<span class="number">2</span>, )) <span class="comment"># 假设为[1,3] 就是要让D去判断，第一个图是否属于domain1，第二个图是否属于domain3……</span></span><br><span class="line">out, feat = D(x_in, y_in)</span><br><span class="line"><span class="built_in">print</span>(out, feat)    </span><br><span class="line"><span class="built_in">print</span>(out.shape, feat.shape)  <span class="comment"># out为Discriminator打的分数（内部简化过）,feat为没处理过的原始输出，差别见下示例</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">out。shape = 1 * 2 ,out的第一个值相当于取了feat中[1,1,1,1]因为是第一个图片，并且是判断是否属于domain1的值，即为1.7796</span></span><br><span class="line"><span class="string">out的第二个值相当于取了feat中[2,3,1,1]因为是第二个图片，并且是判断是否属于domain3的值，即为0.9986</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">out: [1.7796, 0.9986]    </span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">feat。shape = 2 * 4 * 1 * 1 ，其有2张需要判断的图像，第一张图像有4个值，分别是根据domain0-domain3打的分数</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">feat:tensor([[[[-0.8181]],  </span></span><br><span class="line"><span class="string">         [[ 1.7796]],</span></span><br><span class="line"><span class="string">         [[ 3.0122]],</span></span><br><span class="line"><span class="string">         [[ 0.9614]]],</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">        [[[-0.5011]],</span></span><br><span class="line"><span class="string">         [[ 0.5076]],</span></span><br><span class="line"><span class="string">         [[ 3.4774]],</span></span><br><span class="line"><span class="string">         [[ 0.9986]]]]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>网络细节（官方代码）</strong></p><ul><li>与论文附录一致：</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220119155654674.png" /></li></ul></li></ul><h2 id="dg-font网络的训练验证以及主函数见下一篇dg-font代码详解">6、DG-Font网络的训练、验证以及主函数（见下一篇DG-Font代码详解）：</h2><p><strong>注：此部分结合了官方源码的内容，讲述训练的整体过程</strong></p>]]></content>
    
    
    <summary type="html">作者提出了可变形生成网络（Deformable Generative Networks）来做非监督的字体生成。其利用提供的目标字体图像（style image input）来将一种字体的字符变形和转换为另一种字体。DG-FONT 分离了字体的style和content，然后再将两个domain的表示进行融合，生成新的字体的字符。其核心模块为一个叫做FDSC（feature deformation skip connection）的东西，可以用来预测一个位移映射map然后使用位移映射map去对low-level的特征图做变形卷积。然后FDSC的输出被送入一个混合器，然后生成最终的结果。FDSC模块将会对内容图像的低层级特征进行变换，其能够保留文字本身的模式，比如笔画和偏旁部首信息。因为对于内容相同的两种不同风格的字体，它们的每一笔画通常都是对应的（如下图所示）。利用字体的空间关系，利用FDSC进行空间变形，有效地保证了生成的字符具有完整的结构。</summary>
    
    
    
    <category term="论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
    <category term="Deformable Convolution Skip Connection" scheme="https://blog.slks.xyz/tags/Deformable-Convolution-Skip-Connection/"/>
    
    <category term="Unsupervised Learning" scheme="https://blog.slks.xyz/tags/Unsupervised-Learning/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记10——PyTorch 中，nn与nn.functional有什么区别？（搬运）</title>
    <link href="https://blog.slks.xyz/2022/01/18/Pytorch%E7%AC%94%E8%AE%B0/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94nn.Functional%E5%92%8Cnn%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://blog.slks.xyz/2022/01/18/Pytorch%E7%AC%94%E8%AE%B0/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010%E2%80%94%E2%80%94nn.Functional%E5%92%8Cnn%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2022-01-18T07:51:19.000Z</published>
    <updated>2022-01-28T12:18:29.891Z</updated>
    
    <content type="html"><![CDATA[<h1 id="pytorch-中nn-与-nn.functional-有什么区别">PyTorch 中，nn 与 nn.functional 有什么区别？</h1><p>​ 注：在阅读代码以及Pytorch文档的时候发现，nn和nn.functional有很多相同的函数，文档中也有许多引用，故而搜索了一下有何区别，该文为搬运文，以下为引用说明，避免产生误会。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">作者：肥波喇齐</span><br><span class="line">链接：https://www.zhihu.com/question/66782101/answer/579393790</span><br><span class="line">来源：知乎</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><h4 id="两者的相同之处">1、两者的相同之处：</h4><ul><li><code>nn.Xxx</code>和<code>nn.functional.xxx</code>的实际功能是相同的，即<code>nn.Conv2d</code>和<code>nn.functional.conv2d</code> 都是进行卷积，<code>nn.Dropout</code> 和<code>nn.functional.dropout</code>都是进行dropout,………………；</li><li>运行效率也是近乎相同。</li></ul><p>​ <code>nn.functional.xxx</code>是函数接口，而<code>nn.Xxx</code>是<code>nn.functional.xxx</code>的类封装，并且<strong><code>nn.Xxx</code>都继承于一个共同祖先<code>nn.Module</code>。</strong>这一点导致<code>nn.Xxx</code>除了具有<code>nn.functional.xxx</code>功能之外，内部附带了<code>nn.Module</code>相关的属性和方法，例如<code>train(), eval(),load_state_dict, state_dict</code>等。</p><h4 id="两者的差别之处">2、两者的差别之处：</h4><ul><li><strong>两者的调用方式不同。</strong></li></ul><p><code>nn.Xxx</code> 需要先实例化并传入参数，然后以函数调用的方式调用实例化的对象并传入输入数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">inputs = torch.rand(<span class="number">64</span>, <span class="number">3</span>, <span class="number">244</span>, <span class="number">244</span>)</span><br><span class="line">conv = nn.Conv2d(in_channels=<span class="number">3</span>, out_channels=<span class="number">64</span>, kernel_size=<span class="number">3</span>, padding=<span class="number">1</span>)</span><br><span class="line">out = conv(inputs)</span><br></pre></td></tr></table></figure><p><code>nn.functional.xxx</code>同时传入输入数据和weight, bias等其他参数 。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">weight = torch.rand(<span class="number">64</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">bias = torch.rand(<span class="number">64</span>) </span><br><span class="line">out = nn.functional.conv2d(inputs, weight, bias, padding=<span class="number">1</span>)</span><br></pre></td></tr></table></figure><ul><li><p><strong><code>nn.Xxx</code>继承于<code>nn.Module</code>， 能够很好的与<code>nn.Sequential</code>结合使用， 而<code>nn.functional.xxx</code>无法与<code>nn.Sequential</code>结合使用。</strong></p></li><li><p><strong><code>nn.Xxx</code>不需要你自己定义和管理weight；而<code>nn.functional.xxx</code>需要你自己定义weight，每次调用的时候都需要手动传入weight, 不利于代码复用。</strong></p><p>例如：使用<code>nn.Xxx</code>定义一个CNN</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.cnn1 = nn.Conv2d(in_channels=<span class="number">1</span>,  out_channels=<span class="number">16</span>, kernel_size=<span class="number">5</span>,padding=<span class="number">0</span>)</span><br><span class="line">        self.relu1 = nn.ReLU()</span><br><span class="line">        self.maxpool1 = nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.cnn2 = nn.Conv2d(in_channels=<span class="number">16</span>, out_channels=<span class="number">32</span>, kernel_size=<span class="number">5</span>,  padding=<span class="number">0</span>)</span><br><span class="line">        self.relu2 = nn.ReLU()</span><br><span class="line">        self.maxpool2 = nn.MaxPool2d(kernel_size=<span class="number">2</span>)</span><br><span class="line">        </span><br><span class="line">        self.linear1 = nn.Linear(<span class="number">4</span> * <span class="number">4</span> * <span class="number">32</span>, <span class="number">10</span>)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = self.maxpool1(self.relu1(self.cnn1(x)))</span><br><span class="line">        out = self.maxpool2(self.relu2(self.cnn2(out)))</span><br><span class="line">        out = self.linear1(out.view(x.size(<span class="number">0</span>), -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>使用<code>nn.function.xxx</code>定义一个与上面相同的CNN。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CNN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="built_in">super</span>(CNN, self).__init__()</span><br><span class="line">        </span><br><span class="line">        self.cnn1_weight = nn.Parameter(torch.rand(<span class="number">16</span>, <span class="number">1</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.bias1_weight = nn.Parameter(torch.rand(<span class="number">16</span>))</span><br><span class="line">        </span><br><span class="line">        self.cnn2_weight = nn.Parameter(torch.rand(<span class="number">32</span>, <span class="number">16</span>, <span class="number">5</span>, <span class="number">5</span>))</span><br><span class="line">        self.bias2_weight = nn.Parameter(torch.rand(<span class="number">32</span>))</span><br><span class="line">        </span><br><span class="line">        self.linear1_weight = nn.Parameter(torch.rand(<span class="number">4</span> * <span class="number">4</span> * <span class="number">32</span>, <span class="number">10</span>))</span><br><span class="line">        self.bias3_weight = nn.Parameter(torch.rand(<span class="number">10</span>))</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        x = x.view(x.size(<span class="number">0</span>), -<span class="number">1</span>)</span><br><span class="line">        out = F.conv2d(x, self.cnn1_weight, self.bias1_weight)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = F.max_pool2d(out)</span><br><span class="line">        </span><br><span class="line">        out = F.conv2d(x, self.cnn2_weight, self.bias2_weight)</span><br><span class="line">        out = F.relu(out)</span><br><span class="line">        out = F.max_pool2d(out)</span><br><span class="line">        </span><br><span class="line">        out = F.linear(x, self.linear1_weight, self.bias3_weight)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure></li></ul><p>​ 上面两种定义方式得到CNN功能都是相同的，但PyTorch官方推荐：具有学习参数的（例如，conv2d, linear, batch_norm)采用<code>nn.Xxx</code>方式，没有学习参数的（例如，maxpool, loss func, activation func）等根据个人选择使用<code>nn.functional.xxx</code>或者<code>nn.Xxx</code>方式。</p><p>​ 但关于<strong>dropout</strong>，个人强烈推荐使用<code>nn.Xxx</code>方式，因为一般情况下只有训练阶段才进行dropout，在eval阶段都不会进行dropout。使用<code>nn.Xxx</code>方式定义dropout，在调用<code>model.eval()</code>之后，model中所有的dropout layer都关闭，但以<code>nn.function.dropout</code>方式定义dropout，在调用<code>model.eval</code>之后并不能关闭dropout。</p>]]></content>
    
    
    <summary type="html">PyTorch 中，nn与nn.functional的区别与联系</summary>
    
    
    
    <category term="Pytorch学习笔记" scheme="https://blog.slks.xyz/categories/Pytorch%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记9——归一化方法FRN(Filter Response Normalization)</title>
    <link href="https://blog.slks.xyz/2022/01/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B09%E2%80%94FRN/"/>
    <id>https://blog.slks.xyz/2022/01/18/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B09%E2%80%94FRN/</id>
    <published>2022-01-18T05:46:19.000Z</published>
    <updated>2022-01-29T07:32:12.138Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一简介">一、简介</h4><p>​ <strong>在先前的文章中，链接：https://blog.slks.xyz/2022/01/16/basic7/，讲解了BN、LN、IN、CIN、GN等多种不同的Normalization，由于在DG-Font的阅读过程中，又发现了一个新的归一化方法叫做FRN，故而在此篇略做记录。</strong></p><p>​ <strong>FRN</strong>是谷歌提出的一种新的归一化方法，和GN一样不依赖batch，故而FRN层不仅消除了模型训练过程中对batch的依赖，而且当batch size较大时性能优于BN。</p><p>​ <strong>原论文名称：</strong>《Filter Response Normalization Layer: Eliminating Batch Dependence in the Training of Deep Neural Networks》</p><p>​ <strong>原论文地址：</strong>https://arxiv.org/abs/1911.09737</p><h4 id="二结构">二、结构：</h4><p>​ 如下所示，FRN层整体结构包括归一化层FRN（Filter Response Normalization）和激活层TLU（Thresholded Linear Unit）。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220118102128474.png" /></p><p>​ 整个结构并不复杂，就是通过一个公式计算，最后经过一个阈值限制输出</p><p>​ 其中FRN的操作是对每个样例的每个channel单独进行归一化的，这里<span class="math inline">\(x\)</span>就是一个N（=HxW）维度的向量，所以FRN没有BN层对batch依赖的问题。BN层采用归一化方法是减去均值然后除以标准差，而FRN却不同，这里没有减去均值操作，公式中的<span class="math inline">\(v^2\)</span>是<span class="math inline">\({x}\)</span>的二次范数的平均值。这种归一化方式类似BN可以用来消除中间操作（卷积和非线性激活）带来的尺度问题，有助于模型训练。 公式里的<span class="math inline">\({\epsilon}\)</span>是一个很小的正常量，一般为<span class="math inline">\(1^{-6}\)</span>以防止除0。</p><p>​ 一般情况下网络的特征图大小N(=HxW)较大，但是有时候可能会出现1x1的特征图的情况，比如InceptionV3和VGG网络，此时就<span class="math inline">\({\epsilon}\)</span>比较关键，</p><p>​ 归一化之后同样需要进行缩放和平移变换，这里的<span class="math inline">\(\gamma\)</span>和<span class="math inline">\(\beta\)</span>也是可学习的参数（参数为长度是C的向量, 即为特征数目，也就是通道数):</p><p>​ <span class="math display">\[{y = \gamma \hat{x} + \beta}\]</span></p><p>​ FRN缺少去均值的操作，这可能使得归一化的结果任意地偏移0，如果FRN之后是ReLU激活层，可能产生很多0值，这对于模型训练和性能是不利的。为了解决这个问题，FRN之后采用的阈值化的ReLU，即TLU：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_01_18_10_32_35_986.png" /></p><p>​ 这里的<span class="math inline">\(\tau\)</span>是一个可学习的参数。原论文中发现FRN之后采用TLU对于提升性能是至关重要的。</p><h4 id="三代码实现coding">三、代码实现Coding</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FRN</span>(<span class="params">nn.Module</span>):</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, num_features, eps=<span class="number">1e-6</span></span>):</span></span><br><span class="line">        <span class="built_in">super</span>(FRN, self).__init__()</span><br><span class="line">        self.tau = nn.Parameter(torch.zeros(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.gamma = nn.Parameter(torch.ones(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.beta = nn.Parameter(torch.zeros(<span class="number">1</span>, num_features, <span class="number">1</span>, <span class="number">1</span>))</span><br><span class="line">        self.eps = eps</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self, x</span>):</span></span><br><span class="line">        <span class="comment">## input x  shape [B,C,H,W] (batch_size , channel , height , width)</span></span><br><span class="line">        x1 = torch.mean(x**<span class="number">2</span>, dim=[<span class="number">2</span>, <span class="number">3</span>], keepdim=<span class="literal">True</span>)</span><br><span class="line">        <span class="comment">## x1       shape [B,C,1,1] (batch_size , channel , 1 , 1)</span></span><br><span class="line">        x2 = x1 + self.eps</span><br><span class="line">        <span class="comment">## x2     shape [B,C,1,1] (batch_size , channel , 1 , 1),  【+ 为逐元素相加，不改变维度】</span></span><br><span class="line">        x3 = torch.rsqrt(x2)</span><br><span class="line">        <span class="comment">## x3       shape [B,C,1,1] (batch_size , channel , 1 , 1),  【sqrt 为逐元素操作，不改变为维度】</span></span><br><span class="line">        x4 = x * x3</span><br><span class="line">        <span class="comment">## x4       shape [B,C,H,W] (batch_size , channel , height , width)  </span></span><br><span class="line">        <span class="comment">##          广播机制,逐元素相乘  [B,C,H,W] * [B,C,1,1] = [B,C,H,W]</span></span><br><span class="line">        output = torch.<span class="built_in">max</span>(self.gamma * x4 + self.beta, self.tau)</span><br><span class="line">        <span class="comment">## output   shape [B,C,H,W] (batch_size , channel , height , width)  torch.max 逐元素操作</span></span><br><span class="line">        <span class="keyword">return</span> output</span><br><span class="line"></span><br><span class="line"><span class="comment">## 相关注解：</span></span><br><span class="line"><span class="comment">## 输入的 x.shape = [B,C,H,W] ( Batch_Size \ Channel \ Height \ Width )</span></span><br><span class="line"><span class="comment">## torch.rsqrt()  对每个元素取平方根后再取倒数，并不会影响如维度等因素。</span></span><br><span class="line"><span class="comment">## torch.mean() 其中dim=[2,3] 代表按第2、3维求平均值, 即在单个实例、单个Channel上求平均</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">FRN是谷歌提出的一种新的归一化方法，和GN一样不依赖batch，故而FRN层不仅消除了模型训练过程中对batch的依赖，而且当batch size较大时性能优于BN。</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Normalization" scheme="https://blog.slks.xyz/tags/Normalization/"/>
    
  </entry>
  
  <entry>
    <title>Torch/Numpy的广播机制介绍</title>
    <link href="https://blog.slks.xyz/2022/01/18/Python%E7%AC%94%E8%AE%B0/python_import_module/"/>
    <id>https://blog.slks.xyz/2022/01/18/Python%E7%AC%94%E8%AE%B0/python_import_module/</id>
    <published>2022-01-18T05:39:19.000Z</published>
    <updated>2022-01-28T12:21:36.245Z</updated>
    
    <content type="html"><![CDATA[<p>Numpy以及Tensor的广播机制介绍（以Torch为例，两者一致）</p><h3 id="广播机制在何处会出现">1、广播机制在何处会出现？</h3><p>​ 广播针对的运算是element wise类型的运算，即元素对元素类型的运算</p><p>​ <strong>Element-wise的计算符号包括如下：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">算数运算：+, -, *, /, //, %, divmod(), ** or pow(), &lt;&lt;, &gt;&gt;, &amp;, ^, |</span><br><span class="line"></span><br><span class="line">比较运算：==, &lt;, &gt;, &lt;=, &gt;=, !=</span><br></pre></td></tr></table></figure><h3 id="广播机制的规则与出现的原因">2、广播机制的规则与出现的原因</h3><p>​ 正常来说，两个做Element wise类型运算的变量，其相应维度的长度要相等，如下所示：这种形式做Element-Wise的运算是非常简单且易理解的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">a = torch.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">b = torch.rand(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">c = a * b</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">a:tensor([[0.9912, 0.3736],</span></span><br><span class="line"><span class="string">        [0.0708, 0.6939]])</span></span><br><span class="line"><span class="string">b:tensor([[0.5788, 0.6296],</span></span><br><span class="line"><span class="string">        [0.9746, 0.8540]])</span></span><br><span class="line"><span class="string">c:tensor([[0.5737, 0.2352],</span></span><br><span class="line"><span class="string">        [0.0690, 0.5925]])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 那么当两个Tensor的对应维度不对齐的时候，<strong>为了避免用户使用代码for循环来操作填补数组，导致一些低效率的行为出现</strong>，所以其提供了一种广播机制，其实质就是一种处理规则，在不对齐的维度上，长度较短的自动做值复制来扩充长度，从而使得两个Tensor在该维度上一致。</p><h3 id="广播机制起效的情况">3、广播机制起效的情况</h3><p>​ 但是，实际上，并不是所有的不同维度的Tensor相乘时，都会触发广播机制。例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = torch.rand(<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">1</span>)</span><br><span class="line">c = a * b</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">RuntimeError: The size of tensor a (2) must match the size of tensor b (3) at non-singleton dimension 0</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>​ 那么，广播机制在何时才会起效呢？其只对如下情况起作用：</p><p>​ <strong>两个Tensor，它们如果在某一个维度上长度不同的话，必定有一个Tensor在这个维度上的长度为1，广播机制才会起效。即 1 vs M 的情况</strong></p><p>​ <strong>具体计算规则：</strong>长度为1的Tensor在维度上会复制该元素并扩充至长度为M，当这个维度完成对齐，接着重复检查上一层维度，如此反复，直至所有维度都检查完。</p><p>​ <strong>示例</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = torch.rand(<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>)</span><br><span class="line">b = torch.rand(<span class="number">3</span>,<span class="number">5</span>,<span class="number">1</span>)</span><br><span class="line">c = a * b</span><br><span class="line"><span class="built_in">print</span>(c.shape)</span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">torch.Size([3, 5, 3])</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><p>​ <strong>示意图</strong>：</p><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/20200308204131296.png" alt="20200308204131296" /><figcaption aria-hidden="true">20200308204131296</figcaption></figure>]]></content>
    
    
    <summary type="html">本文讲解了Torch和Numpy中进行Element-Wise的计算的时候，采用的广播机制是什么，如何执行。</summary>
    
    
    
    <category term="python基础扩充笔记" scheme="https://blog.slks.xyz/categories/python%E5%9F%BA%E7%A1%80%E6%89%A9%E5%85%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
    <category term="Auto BroadCasting" scheme="https://blog.slks.xyz/tags/Auto-BroadCasting/"/>
    
  </entry>
  
  <entry>
    <title>Python导入自定义模块（同目录、子目录、跨目录）</title>
    <link href="https://blog.slks.xyz/2022/01/18/Python%E7%AC%94%E8%AE%B0/python_broadcast_module/"/>
    <id>https://blog.slks.xyz/2022/01/18/Python%E7%AC%94%E8%AE%B0/python_broadcast_module/</id>
    <published>2022-01-18T03:33:19.000Z</published>
    <updated>2022-01-28T12:21:32.108Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本格式">1、基本格式：</h3><p>​ <strong>from 文件名 import 类名</strong></p><h3 id="分情形讨论引入方式">2、分情形讨论引入方式：</h3><p>​ 假设现有如下目录结构：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">└── model2/</span><br><span class="line">    └── model2_main.py</span><br></pre></td></tr></table></figure><h4 id="同级目录引入">1）同级目录引入</h4><p><strong>main.py</strong> 中需要导入 <strong>model0.py</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model0</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">from</span> model0 <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>两者都是可以的，同级目录下引入十分简便，直接import即可</p><h4 id="子目录引入">2）子目录引入</h4><p><strong>main.py</strong> 中需要导入 <strong>model1_main.py</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">我们首先需要在model1/下建立__init__.py空文件，让编译器认为这是一个模块。</span><br></pre></td></tr></table></figure><p>建立后，<strong>目录结构应当如下所示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── model2/</span><br><span class="line">    └── model2_main.py</span><br></pre></td></tr></table></figure><p>然后进行引入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> model1.model1_main</span><br><span class="line"><span class="comment"># 或</span></span><br><span class="line"><span class="keyword">from</span> model1.model1_main <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><h4 id="跨目录引入">3）跨目录引入</h4><p><strong>model1_main.py</strong>导入<strong>model2/model2_main.py</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同理我们首先需要在model2/下建立__init__.py空文件，让编译器认为这是一个模块。</span><br></pre></td></tr></table></figure><p>建立后，<strong>目录结构应当如下所示：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">├── model0.py</span><br><span class="line">├── main.py</span><br><span class="line">├── model1/</span><br><span class="line">│   └── model1_main.py</span><br><span class="line">│   └── __init__.py</span><br><span class="line">└── model2/</span><br><span class="line">│   └── model2_main.py</span><br><span class="line">│   └── __init__.py</span><br></pre></td></tr></table></figure><p>然后在model1_main文件中进行引入</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&quot;..&quot;</span>)</span><br><span class="line"><span class="keyword">import</span> model2.model2_main</span><br></pre></td></tr></table></figure><h4 id="更为一般的介绍">4）更为一般的介绍：</h4><p>sys模块是python内置的，我们导入跨自定义模块的步骤一般如下：</p><p>​ 首先要确保被导入的模块文件夹内有 __init__.py文件，确保其被识别为一个模块，然后再执行下面步骤：</p><ol type="1"><li><strong>先导入sys模块</strong></li><li>然后通过<code>sys.path.append(path)</code> 函数来导入自定义模块所在的目录</li><li><strong>导入自定义模块</strong>。</li></ol><p>​ 只不过在同级目录以及子目录下进行引入，不需要这么复杂，可以有更简单的方法，而在跨目录引入时，就需要采用这种方案。</p>]]></content>
    
    
    <summary type="html">本文讲解了Python导入自定义模块的方式，分为同目录、子目录、跨目录三种情况，同时也讲解了引入的一般形式。</summary>
    
    
    
    <category term="python基础扩充笔记" scheme="https://blog.slks.xyz/categories/python%E5%9F%BA%E7%A1%80%E6%89%A9%E5%85%85%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Python" scheme="https://blog.slks.xyz/tags/Python/"/>
    
    <category term="Module Import" scheme="https://blog.slks.xyz/tags/Module-Import/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记8——图像风格迁移方法AdaIN</title>
    <link href="https://blog.slks.xyz/2022/01/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B08%E2%80%94%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB%E7%AE%97%E6%B3%95%20AdaIN%20/"/>
    <id>https://blog.slks.xyz/2022/01/17/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B08%E2%80%94%E5%9B%BE%E5%83%8F%E9%A3%8E%E6%A0%BC%E8%BF%81%E7%A7%BB%E7%AE%97%E6%B3%95%20AdaIN%20/</id>
    <published>2022-01-17T04:33:19.000Z</published>
    <updated>2022-01-29T07:32:04.875Z</updated>
    
    <content type="html"><![CDATA[<p><strong>AdaIN</strong>是一种经典的图片风格迁移算法，在 2017 年ICCV中提出。主要用于将一张图片(风格图) 中的风格、纹理迁移到另一张图片 (内容图)，同时要保留内容图的主体结构。如下所示：</p><p>​ <strong>论文名称：《Arbitrary Style Transfer in Real-time with Adaptive Instance Normalization》</strong></p><p>​ <strong>论文链接：https://arxiv.org/abs/1703.06868</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/b219ebc4b74543a95e9180d3cb15748ab9011436.jpeg" /></p><h2 id="一adain简介">一、AdaIN简介</h2><p>​ 这篇论文的主要目标是实现<strong>实时的、任意风格的风格迁移（style transfer）</strong>，核心方法就是其提出的自适应实例标准化（<strong>Adaptive Instance Normalization，AdaIN</strong>），通过<strong>将内容图像（content image）特征的均值和方差对齐到风格图像（style image）的均值和方差</strong>来实现风格迁移。</p><p>​ 此外，这个方法还给用户非常多的控制权，包括如下：</p><ul><li>内容和风格的折中（trade off）<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183935766.png" /></li></ul></li><li>风格插值（混合风格迁移）<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183943127.png" /></li></ul></li><li>是否保留颜色<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183918123.png" /></li></ul></li><li>对图像的特定区域进行风格迁移<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220116183906461.png" /></li></ul></li></ul><h2 id="二前备知识">二、前备知识：</h2><p>​ 你需要熟悉Batch Normaliztion（BN）、Layer Norm（LN）、Instance Norm（IN）、Group Norm（GN）、Conditional Instance Norm（CIN）等概念。</p><p>​ 下图为特征图张量，可以直观看出BN，LN，IN，GN等规范化方法的区别。N为样本维度，C为通道维度，H为height，W即width，代表特征图的尺寸。</p><p><img src="https://img-blog.csdnimg.cn/2019061216413530.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl8zNTU3Njg4MQ==,size_16,color_FFFFFF,t_70" /></p><p>​ 具体每种Normalization的方法介绍可以参见我的这一篇Blog：</p><p>​ https://blog.slks.xyz/2022/01/16/basic7/</p><p>​</p><h2 id="三adain具体介绍">三、AdaIN具体介绍</h2><h5 id="输入content-input-x-style-input-y">输入：Content Input x &amp;&amp; Style Input y</h5><p>​ AdaIN 简单地将 x 的通道均值和方差对齐以匹配 y 的均值和方差。 不像BN、IN或CIN，AdaIN没有需要从网络中进行学习的仿射变换参数，它能够自适应的从style input中计算得到仿射变换的参数。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220117103448955.png" /></p><p>​ 我们简单地用 σ(y) 缩放归一化的Content Input，并用 µ(y) 移动它。 与 IN 类似，这些统计数据是跨空间位置计算的。也就是说，其实对于单个实例的单个特征通道计算的均值和方差数据。</p><p>​ 直观地说，让我们考虑一个检测特定风格笔触的特征通道。</p><p>​ 具有这种风格的图像会对它的特征部分产生较高的平均激活。AdaIN 产生的输出将对该特征具有相同的高平均激活，同时其也保留内容图像的空间结构。 然后我们可以使用前馈解码器将风格特征转换回图像空间。同时，这个特征通道的方差可以编码更细微的风格信息，这些信息也传递到 AdaIN 输出和最终输出图像。</p><p>​ 简而言之，AdaIN 通过传输特征统计数据（特别是通道均值和方差）在特征空间中执行风格迁移。我们的 AdaIN 层就像一个 IN 层一样简单，几乎不增加计算成本。</p><h2 id="四网络结构">四、网络结构</h2><p>​ 在论文中，其使用VGG-19来编码内容和风格，在浅层空间将特征图通过AdaIN层，进行上述仿射变换，解码器根据变换后的特征图试图重建图像，通过反向传播训练解码器，使得解码器输出越来越真实的图像。整体架构如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/2019061217185282.png" /></p><p>​ 更为具体的代码可见以下链接地址：</p><p>​ https://github.com/xunhuang1995/AdaIN-style</p>]]></content>
    
    
    <summary type="html">AdaIN是一种经典的图片风格迁移算法，在2017年ICCV中提出。主要用于将一张图片(风格图)中的风格、纹理迁移到另一张图片(内容图)，同时要保留内容图的主体结构。</summary>
    
    
    
    <category term="机器学习基础系列笔记" scheme="https://blog.slks.xyz/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%9F%BA%E7%A1%80%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Style Transfer" scheme="https://blog.slks.xyz/tags/Style-Transfer/"/>
    
    <category term="AdaIN" scheme="https://blog.slks.xyz/tags/AdaIN/"/>
    
  </entry>
  
</feed>
