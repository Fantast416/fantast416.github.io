<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-02-08T11:34:31.298Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>奇妙应用——字符串比较中广义邻居的应用</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E2%80%94%E5%B9%BF%E4%B9%89%E9%82%BB%E5%B1%85/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%AF%94%E8%BE%83%E2%80%94%E5%B9%BF%E4%B9%89%E9%82%BB%E5%B1%85/</id>
    <published>2022-02-08T11:02:19.000Z</published>
    <updated>2022-02-08T11:34:31.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-064.-神奇的字典"><a href="https://leetcode-cn.com/problems/US1pGT/">剑指 Offer II 064. 神奇的字典</a></h4><p>​ 设计一个使用单词列表进行初始化的数据结构，单词列表中的单词 互不相同 。 如果给出一个单词，请判定能否只将这个单词中一个字母换成另一个字母，使得所形成的新单词存在于已构建的神奇字典中。</p><p>实现 MagicDictionary 类：</p><ul><li>MagicDictionary() 初始化对象</li><li>void buildDict(String[] dictionary) 使用字符串数组 dictionary 设定该数据结构，dictionary 中的字符串互不相同</li><li>bool search(String searchWord) 给定一个字符串 searchWord ，判定能否只将字符串中 一个 字母换成另一个字母，使得所形成的新字符串能够与字典中的任一字符串匹配。如果可以，返回 true ；否则，返回 false 。</li></ul><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">输入</span><br><span class="line">inputs = [&quot;MagicDictionary&quot;, &quot;buildDict&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;, &quot;search&quot;]</span><br><span class="line">inputs = [[], [[&quot;hello&quot;, &quot;leetcode&quot;]], [&quot;hello&quot;], [&quot;hhllo&quot;], [&quot;hell&quot;], [&quot;leetcoded&quot;]]</span><br><span class="line">输出</span><br><span class="line">[null, null, false, true, false, false]</span><br><span class="line"></span><br><span class="line">解释</span><br><span class="line">MagicDictionary magicDictionary = new MagicDictionary();</span><br><span class="line">magicDictionary.buildDict([&quot;hello&quot;, &quot;leetcode&quot;]);</span><br><span class="line">magicDictionary.search(&quot;hello&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;hhllo&quot;); // 将第二个 &#x27;h&#x27; 替换为 &#x27;e&#x27; 可以匹配 &quot;hello&quot; ，所以返回 True</span><br><span class="line">magicDictionary.search(&quot;hell&quot;); // 返回 False</span><br><span class="line">magicDictionary.search(&quot;leetcoded&quot;); // 返回 False</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= dictionary.length &lt;= 1001 &lt;= dictionary[i].length &lt;= 100dictionary[i] 仅由小写英文字母组成dictionary 中的所有字符串 互不相同1 &lt;= searchWord.length &lt;= 100searchWord 仅由小写英文字母组成buildDict 仅在 search 之前调用一次最多调用 100 次 search</code></pre><p><strong>解题思路</strong>：</p><p>​ 一开始看到这道题，想到前缀树，但是经过尝试，发现前缀树没法使用，判定两个字符串只差1个字符，非常非常绕，并且当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,hallo。我们查找hello，我的前缀树算法因为找到了完全匹配的hello，就会返回false，而忽略了字典中存在的hallo。</strong></p><p>​ 然后，我们发现，如果想要采用先前的方法，用一个vector(26)来统计字符串字符出现的个数，然后利用相差1个字符来进行判定也不可行，当如下情况出现时，会发生错误：</p><p>​ <strong>例如：字典中存在hello,我们查找llohh，在vector统计中，两者确实只在h的个数上有不同，但是问题是两个单词顺序完全不一样，vector统计会将单词的顺序信息丢失。</strong></p><p><strong>故而：这题需要一个全新的概念叫做 广义邻居：</strong></p><p><strong>思路引用</strong>：https://leetcode-cn.com/problems/US1pGT/solution/offerii064shen-qi-de-zi-dian-by-logilong-4hmn/</p><p><strong>广义邻居：</strong>也就是一字只差的单词，比如说【*pple, a*ple, ap*le, app*e, appl*】，这几个单词互为广义邻居。</p><p>然后，我们这道题就可以按照如下的步骤进行求解：</p><ul><li><p>初始化字典： 生成字典中所有单词的广义邻居，例如 apple 就生成上述五个广义邻居。将所有字典词的广义邻居都以 <code>&lt;广义邻居，个数&gt;</code> 保存到 <code>HashMap</code>。</p></li><li><p>查找：当我们需要在字典中查找是否有一个单词和 word 只有一字只差，那不就是查找第二步中 HashMap 中是否存在 word 的广义邻居吗？这时候我们就只要生成 word 所有的广义邻居，然后在 HashMap 中查找是否存在其中的一个就可以了。</p></li></ul><p><strong>关键疑问</strong>：为什么需要记录所有字典词的广义邻居数量？</p><p>​ <strong>这是为了防止字典中出现和查找词一摸一样的词，如果出现上述情况，则会找到符合条件的广义邻居，但是其实并不是邻居，而是它自己！</strong></p><p>所以，刚才的查找不是很完整，<strong>完整正确的查找应当如下</strong>：</p><p>​ 生成待查找词 word 的所有广义邻居。每个广义邻居都到 HashMap 中查找出现的次数，根据出现次数分为3种情况。</p><ul><li>广义邻居数 &gt; 1 ，则说明字典中肯定存在两个不同的字符，这两个字符互为广义邻居，且和查找字符也是广义邻居，由于字典中的单词是不重复的，所以此时满足条件。</li><li>广义邻居数 == 1 , 说明字典中可能存在一个广义邻居，也可能存在查找字符串本身，如果是广义邻居就满足条件，如果是查找字符串本身的话就不符合条件。</li><li>广义邻居数 == 0 , 说明不存在广义邻居，则继续遍历下一个广义邻居。</li></ul>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为字符串的差值比较，但是无法用简单的Hash表统计解决，提出了一种新的概念，叫做广义邻居，通过广义邻居来对不同的字符串进行相似性比较。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="string" scheme="https://blog.slks.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>C++ 优先队列 PriorityQueue 容器使用</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/C++%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8/</id>
    <published>2022-02-08T07:53:19.000Z</published>
    <updated>2022-02-08T09:55:42.094Z</updated>
    
    <content type="html"><![CDATA[<p><strong>定义</strong>：<code>priority_queue&lt;Type, Container, Functional&gt;</code></p><p>​ Type 就是数据类型，Container 就是容器类型（Container必须是用数组实现的容器，比如vector,deque等等，但不能用 list。STL里面默认用的是vector），Functional 就是比较的方式，当需要用自定义的数据类型时才需要传入这三个参数，使用基本数据类型时，只需要传入数据类型，<strong>默认是大顶堆</strong></p><ul><li>1、一般情况：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//升序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,greater&lt;<span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line"><span class="comment">//降序队列</span></span><br><span class="line">priority_queue &lt;<span class="keyword">int</span>,vector&lt;<span class="keyword">int</span>&gt;,less&lt;<span class="keyword">int</span>&gt; &gt;q;</span><br></pre></td></tr></table></figure><ul><li>2、如果内部的元素是Pair的话，其也自带了比较函数,比较规则是先比较第一个元素，第一个相等比较第二个。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; a;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(<span class="number">1</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(<span class="number">1</span>, <span class="number">3</span>)</span></span>;</span><br><span class="line"><span class="function">pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">d</span><span class="params">(<span class="number">2</span>, <span class="number">5</span>)</span></span>;</span><br></pre></td></tr></table></figure><ul><li>3、内部为自定义元素：一个是通过重载自定义struct的 &lt; 规则</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tmp1</span> //运算符重载&lt;</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="built_in">tmp1</span>(<span class="keyword">int</span> a) &#123;x = a;&#125;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> tmp1&amp; a) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> x &lt; a.x; <span class="comment">//大顶堆</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function">tmp1 <span class="title">a</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">b</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line"><span class="function">tmp1 <span class="title">c</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">priority_queue&lt;tmp1&gt; d;</span><br></pre></td></tr></table></figure><ul><li>另一个方法是通过定义一个比较类：</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> value;</span><br><span class="line">    <span class="keyword">int</span> priority;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 优先队列存放 Node* 时优先级的比较方法 */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Compare_Node_Pointer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/* Node::priority 大的优先 */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span> <span class="params">()</span> <span class="params">(Node* &amp;a, Node* &amp;b)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;priority &lt; b-&gt;priority;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 用法 */</span></span><br><span class="line">std::priority_queue&lt;Node*, std::vector&lt;Node*&gt;, Compare_Node_Pointer&gt; my_queue;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-061.-和最小的-k-个数对"><a href="https://leetcode-cn.com/problems/qn8gGX/">剑指 Offer II 061. 和最小的 k 个数对</a></h4><p><strong>题目描述</strong>：</p><p>​ 给定两个以升序排列的整数数组 nums1 和 nums2 , 以及一个整数 k 。定义一对值 (u,v)，其中第一个元素来自 nums1，第二个元素来自 nums2 。请找到和最小的 k 个数对 (u1,v1), (u2,v2) ... (uk,vk) 。</p><p><strong>解题思路</strong>：</p><p>​ 遍历nums1 和 nums2 ，然后将所有的组合push进入自定义的优先队列中，然后按照顺序，出队前k个元素或将队列出空即可。但是这样子的话，时间复杂度会达到O(mn)，也就是nums1和nums2的长度的乘积。其实，因为提供的数组是有序序列，所以我们只需要进队列 nums1的前k个和nums2的前k个的组合，也就是O(K^2)即可。</p><p><strong>解题代码</strong>：（熟悉priority queue的操作）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">int</span> v1;</span><br><span class="line">    <span class="keyword">int</span> v2;</span><br><span class="line">    <span class="built_in">Node</span>(<span class="keyword">int</span> v1,<span class="keyword">int</span> v2)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v1 = v1;</span><br><span class="line">        <span class="keyword">this</span>-&gt;v2 = v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NodeCompare</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span> <span class="params">(Node* &amp;a,Node* &amp;b)</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a-&gt;v1 + a-&gt;v2 &gt; b-&gt;v1 + b-&gt;v2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">kSmallestPairs</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums1, vector&lt;<span class="keyword">int</span>&gt;&amp; nums2, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        priority_queue&lt;Node*,vector&lt;Node*&gt;,NodeCompare&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;k &amp;&amp; i&lt;nums1.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;k &amp;&amp; j&lt;nums2.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                Node* tmp = <span class="keyword">new</span> <span class="built_in">Node</span>(nums1[i],nums2[j]);</span><br><span class="line">                q.<span class="built_in">push</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(k-- &amp;&amp; q.<span class="built_in">size</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">            Node* tmp = q.<span class="built_in">top</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(&#123;tmp-&gt;v1,tmp-&gt;v2&#125;);</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">记录PriorityQueue C++中的使用，主要是其的一些构造函数以及额外排序规则如何确定。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——&quot;动态数据流+第k大的数值&quot;相关问题优化</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%B5%81+%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E6%95%B0%E6%8D%AE%E6%B5%81+%E7%AC%ACK%E5%A4%A7%E7%9A%84%E6%95%B0%E5%80%BC%20%E4%BC%98%E5%8C%96%E6%80%9D%E8%B7%AF/</id>
    <published>2022-02-08T03:20:19.000Z</published>
    <updated>2022-02-08T03:30:08.006Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-059.-数据流的第-k-大数值"><a href="https://leetcode-cn.com/problems/jBjn9C/">剑指 Offer II 059. 数据流的第 K 大数值</a></h4><p><strong>题目描述</strong>：</p><p>​ 设计一个找到数据流中第 k 大元素的类（class）。注意是排序后的第 k 大元素，不是第 k 个不同的元素。</p><p>​ 请实现 KthLargest 类：</p><pre><code>KthLargest(int k, int[] nums) 使用整数 k 和整数流 nums 初始化对象。int add(int val) 将 val 插入数据流 nums 后，返回当前数据流中第 k 大的元素。</code></pre><p><strong>解题思路</strong>：</p><p>​ 我对于这类没有设计类实现的题目，数据结构的敏感度不够高，基本上想起来都只能用最暴力的方法去解决。此题目，我一开始是想要在内部维护一个Vector，但是我发现，维护有序向量的成本太高了，虽然通过了测试点，但是时间复杂度等方面可以优化的内容实在太多了。</p><p><strong>优化思路</strong>：</p><p>​ 比较重要重要的信息点是 <strong>动态插入</strong>、<strong>第K大</strong>，这两个关键信息，应当能够导向一个动态的数据结构，也就是优先队列——堆。可以维护一个优先队列（最小堆），然后在其内维护最大的K个元素。这样的话，每次插入完需要返回第K大的元素的时候，直接返回堆顶的元素（堆顶的元素是堆中最小的那个元素，但是是所有数组中第K大的那个元素）即可。</p><p>​ 故而，在单次插入的操作中，我们首先将元素 val 加入到优先队列中。如果此时优先队列的大小大于 k，我们需要将优先队列的队头元素弹出，以保证优先队列的大小为 k。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">KthLargest</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    priority_queue&lt;<span class="keyword">int</span>, vector&lt;<span class="keyword">int</span>&gt;, greater&lt;<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="built_in">KthLargest</span>(<span class="keyword">int</span> k, vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">             <span class="built_in">add</span>(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        q.<span class="built_in">push</span>(val);</span><br><span class="line">        <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; k) &#123;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> q.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为动态数据流+第k大的数值，利用内置数据结构优化解题思路。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="priority queue" scheme="https://blog.slks.xyz/tags/priority-queue/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——日程表类的设计优化思想</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%97%A5%E7%A8%8B%E8%A1%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%97%A5%E7%A8%8B%E8%A1%A8%E7%B1%BB%E8%AE%BE%E8%AE%A1%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-08T02:50:19.000Z</published>
    <updated>2022-02-08T03:02:25.843Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-058.-日程表"><a href="https://leetcode-cn.com/problems/fi9suh/">剑指 Offer II 058. 日程表</a></h4><p><strong>题目描述</strong>：</p><p>​ 请实现一个 MyCalendar 类来存放你的日程安排。如果要添加的时间内没有其他安排，则可以存储这个新的日程安排。</p><p>​ MyCalendar 有一个 book(int start, int end)方法。它意味着在 start 到 end 时间内增加一个日程安排，注意，这里的时间是半开区间，即 [start, end), 实数 x 的范围为， start &lt;= x &lt; end。</p><p>​ 当两个日程安排有一些时间上的交叉时（例如两个日程安排都在同一时间内），就会产生重复预订。</p><p>​ 每次调用 MyCalendar.book方法时，如果可以将日程安排成功添加到日历中而不会导致重复预订，返回 true。否则，返回 false 并且不要将该日程安排添加到日历中。</p><p>​ 请按照以下步骤调用 MyCalendar 类: MyCalendar cal = new MyCalendar(); MyCalendar.book(start, end)</p><p>提示：</p><pre><code>每个测试用例，调用 MyCalendar.book 函数最多不超过 1000次。0 &lt;= start &lt; end &lt;= 109</code></pre><p><strong>我的解题思路</strong>：一开始看到每个测试用例，调用.book函数不超过1000次，我就使用了较为暴力的算法，使用成员变量记录先前所有的日程，然后新来一个日程以后，去判断和先前的有没有区间重复，代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; calendar;</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkIsCollision</span><span class="params">(<span class="keyword">int</span> start,<span class="keyword">int</span> end)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;calendar.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> tmp_start = calendar[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tmp_end = calendar[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(!(start &gt;= tmp_end || end &lt;= tmp_start))&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">checkIsCollision</span>(start,end))&#123;</span><br><span class="line">            calendar.<span class="built_in">push_back</span>(&#123;start,end&#125;);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyCalendar object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyCalendar* obj = new MyCalendar();</span></span><br><span class="line"><span class="comment"> * bool param_1 = obj-&gt;book(start,end);</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><p><strong>优化思路</strong>：按照上述方法做的话，其实是比较浪费时间的，因为每新来一个日程，我们就需要去和先前所有的日程比较，从理论上来说，大部分的比较都是无效比较，我们其实只需要和最近的两个区间进行比较就可以了，因为已知先前的日程都是不重叠的，所以我们每次只需要查询最近的时间段的前后，看看起止时间有无冲突即可。</p><p>​ 此时，我们会想，那我们不是需要维护日程vector，让它变得有序就可以了。思路没错！但是我们可以不用vector了，直接使用map。map是有序的key-value键值对，底层使用红黑树建立，更加方便而且高效。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendar</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; calendar;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">MyCalendar</span>() &#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> iter = calendar.<span class="built_in">lower_bound</span>(start);</span><br><span class="line">        <span class="comment">//第一个大于等于插入元素的时间段。这个时间段的起始时间不能小于插入时间的终止时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">end</span>() &amp;&amp; iter-&gt;first &lt; end)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//迭代器往前走一步就是小于等于当前时间段的最大时间段。这个时间段的终止时间不能大于插入的起始时间</span></span><br><span class="line">        <span class="keyword">if</span>(iter != calendar.<span class="built_in">begin</span>() &amp;&amp; (--iter)-&gt;second &gt; start)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        calendar[start] = end;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>参考：https://leetcode-cn.com/problems/fi9suh/solution/c-hong-hei-shu-map058-ri-cheng-biao-by-d-f7q9/</p><p>附录：</p><ul><li>map中的lower_bound和upper_bound函数：<ul><li>map::lower_bound(key): 返回map中第一个大于或等于key的迭代器指针</li><li>map::upper_bound(key): 返回map中第一个大于key的迭代器指针</li></ul></li></ul>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录日程表类的设计优化思想，合理利用C++内置的数据结构，能够大幅加快运行时间。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="red black tree" scheme="https://blog.slks.xyz/tags/red-black-tree/"/>
    
  </entry>
  
  <entry>
    <title>奇妙应用——求解直方图最大矩形面积 &amp;&amp; 矩阵中最大的矩形求解</title>
    <link href="https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%B1%82%E8%A7%A3%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/"/>
    <id>https://blog.slks.xyz/2022/02/08/LeetCode%E7%AC%94%E8%AE%B0/%E6%B1%82%E8%A7%A3%E7%9B%B4%E6%96%B9%E5%9B%BE%E6%9C%80%E5%A4%A7%E7%9F%A9%E5%BD%A2%E9%9D%A2%E7%A7%AF/</id>
    <published>2022-02-08T01:30:19.000Z</published>
    <updated>2022-02-08T02:50:40.265Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-039.-直方图最大矩形面积"><a href="https://leetcode-cn.com/problems/0ynMMM/">剑指 Offer II 039. 直方图最大矩形面积</a></h4><p><strong>题目描述</strong>：给定非负整数数组 <code>heights</code> ，数组中的数字用来表示柱状图中各个柱子的高度。每个柱子彼此相邻，且宽度为 <code>1</code> 。求在该柱状图中，能够勾勒出来的矩形的最大面积。</p><p><strong>示例1</strong>：<img src="https://assets.leetcode.com/uploads/2021/01/04/histogram.jpg" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：heights = [<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br><span class="line">输出：<span class="number">10</span></span><br><span class="line">解释：最大的矩形为图中红色区域，面积为 <span class="number">10</span></span><br></pre></td></tr></table></figure><p>题解参考：https://leetcode-cn.com/problems/0ynMMM/solution/jian-zhi-offer-2-mian-shi-ti-39-shu-zhon-qzaw/</p><p><strong>解题思路</strong>： 本题如果采用暴搜的方法，O(n^2)复杂度，是比较简单易懂的，但是时间耗费太长，会超时。所以此篇博客要记录的是一个叫做 <strong>“单调栈”</strong>的解决方案：</p><ul><li><p><strong>基本思想</strong>：<strong>保证存在栈中的柱子的高度是递增的。</strong>基础操作为，从左往右扫描数组内的柱子高度，若当前柱高大于栈顶柱高，那么该柱子下标入栈；反之，将栈顶柱子出栈，并计算栈顶的柱子高度为顶高的最高矩阵面积，直至可入栈。</p></li><li><p><strong>核心问题</strong>：如何确定以栈顶柱子高为顶的最大矩阵面积呢？</p><ul><li>该矩阵的宽度一定是，<strong>从栈顶柱子的两边出发直到遇到比该柱高矮的柱子所夹成的宽度</strong>。因为单调栈中保存的柱高是递增的，所以<strong>栈中位于栈顶柱子前面的柱子一定比栈顶柱子矮，同样当前扫描到的柱子也矮于位于栈顶的柱子</strong>，所以顶柱子为顶的最高矩阵的宽度就确定了，那么面积也就确定了。</li></ul></li><li><p><strong>操作示例</strong>：下面以 [2, 1, 5, 6, 2, 3] 为例说明，过程如图所示</p><ul><li><figure><img src="https://pic.leetcode-cn.com/1629450891-DTWpaG-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure></li><li><p>可以发现，最后栈中除了为了处理方便而加入的初始化的 -1 以外，还有 1, 4, 5 三个元素，说明以 1, 2, 3 柱高为顶的最大矩阵还未计算。这时候只要多想一步，它们未被计算是因为还未出现比它们矮的柱子。若假设最后再加入一个高度为 0 的柱高，那么栈中除了 -1 以外，所有的元素都会出栈，那么所有的柱子均被计算，计算完毕，继续的过程如下</p></li><li><figure><img src="https://pic.leetcode-cn.com/1629451413-pOKglw-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure></li></ul></li><li><p><strong>解题代码</strong>：</p><ul><li>以下代码是理解了上述所说以后书写的，和上述所说的细节部分有所不同，它是先往栈里面push了一个-1，保证栈不会空。而我没有这么干，我是在pop完了以后，在计算宽度的时候，会判断栈空了没有，如果空了则 new_top_idx = -1 ，如果没空就是 s.top();</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>); <span class="comment">//先把第一个元素push进去</span></span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul><h4 id="剑指-offer-ii-040.-矩阵中最大的矩形"><a href="https://leetcode-cn.com/problems/PLYXKQ/">剑指 Offer II 040. 矩阵中最大的矩形</a></h4><p><strong>题目描述</strong>：给定一个由 0 和 1 组成的矩阵 matrix ，找出只包含 1 的最大矩形，并返回其面积。</p><p>注意：此题 matrix 输入格式为一维 01 字符串数组。</p><p><strong>示例</strong>：<img src="https://assets.leetcode.com/uploads/2020/09/14/maximal.jpg" alt="img" /></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [<span class="string">&quot;10100&quot;</span>,<span class="string">&quot;10111&quot;</span>,<span class="string">&quot;11111&quot;</span>,<span class="string">&quot;10010&quot;</span>]</span><br><span class="line">输出：<span class="number">6</span></span><br><span class="line">解释：最大矩形如上图所示。</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 本题可以用结合上一题的思路进行求解：</p><p>​ <strong>我们循环每一行，将每一行都看作是上一题中的一系列直方图。然后，某行某位置的高度，如果该位置是1，那么它的高度是上一行的该对应位置的直方图的高度+1.如果该位置是0，则该位置的直方图高度就直接清0.</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//即利用一个数组rectangular来记录直方图高度</span></span><br><span class="line"><span class="comment">//遍历每一行每一个位置，更新rectangular中的数值</span></span><br><span class="line"><span class="comment">//然后调用上一题中的方法，进行求解</span></span><br><span class="line"><span class="keyword">if</span>(nums[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line"> rectangular[j]++;</span><br><span class="line"> &#125;<span class="keyword">else</span>&#123;</span><br><span class="line"> rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p><strong>解题代码</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">largestRectangleArea</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; heights)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        heights.<span class="built_in">push_back</span>(<span class="number">0</span>);  <span class="comment">//先在最后加一个高度为0的柱子，方便后续操作</span></span><br><span class="line">        s.<span class="built_in">push</span>(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;heights.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            <span class="keyword">while</span>(heights[i] &lt; heights[top_idx])&#123;</span><br><span class="line">                s.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> new_top_idx = s.<span class="built_in">empty</span>() ? <span class="number">-1</span> : s.<span class="built_in">top</span>();</span><br><span class="line">                <span class="comment">//计算pop出去的这个元素，maxValue</span></span><br><span class="line">                maxValue = <span class="built_in">max</span>(maxValue,heights[top_idx] * (i - new_top_idx - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(s.<span class="built_in">empty</span>()) <span class="keyword">break</span>;</span><br><span class="line">                top_idx = s.<span class="built_in">top</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            s.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximalRectangle</span><span class="params">(vector&lt;string&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; rectangular;</span><br><span class="line">        <span class="keyword">int</span> maxValue = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;matrix.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            string row = matrix[i];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;row.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i==<span class="number">0</span>) rectangular.<span class="built_in">push_back</span>(row[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(row[j] == <span class="string">&#x27;1&#x27;</span>)&#123;</span><br><span class="line">                        rectangular[j]++;</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                        rectangular[j]=<span class="number">0</span>;<span class="comment">//这一行的某个字符为“0”，那就矩形高度清0</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//更新好了以后，计算改行的maxValue</span></span><br><span class="line">            maxValue = <span class="built_in">max</span>(maxValue,<span class="built_in">largestRectangleArea</span>(rectangular));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxValue;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录一下两道神奇的题目，非常巧妙的利用栈的思想进行求解。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="stack" scheme="https://blog.slks.xyz/tags/stack/"/>
    
  </entry>
  
  <entry>
    <title>树系列——二叉树的序列化与反序列化（如何更好的用线性方式记录二叉树的结构）</title>
    <link href="https://blog.slks.xyz/2022/02/07/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%9D%E6%83%B3%E6%89%A9%E5%85%85/"/>
    <id>https://blog.slks.xyz/2022/02/07/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%BA%8F%E5%88%97%E5%8C%96%E6%80%9D%E6%83%B3%E6%89%A9%E5%85%85/</id>
    <published>2022-02-07T03:58:19.000Z</published>
    <updated>2022-02-07T04:32:17.903Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-048.-序列化与反序列化二叉树"><a href="https://leetcode-cn.com/problems/h54YBf/">剑指 Offer II 048. 序列化与反序列化二叉树</a></h4><p><strong>题目描述</strong>：</p><p>​ 序列化是将一个数据结构或者对象转换为连续的比特位的操作，进而可以将转换后的数据存储在一个文件或者内存中，同时也可以通过网络传输到另一个计算机环境，采取相反方式重构得到原数据。</p><p>​ 请设计一个算法来实现二叉树的序列化与反序列化。这里不限定你的序列 / 反序列化算法执行逻辑，只需要保证一个二叉树可以被序列化为一个字符串并且将这个字符串反序列化为原始的树结构。</p><p><strong>解题思路</strong>：</p><p>​ 我们都很清楚，<strong>一个前序序列（后序/层序序列）+中序序列可以确定恢复一颗二叉树结构。</strong>在这个题目里的话，我一开始的思路是记录前序+ 中序序列，将它们变成字符串，然后反序列化的时候，再通过前序和中序序列重构即可。思路整体而言也较为清晰，但是当我写完所有代码的时候，发现了一个令人窒息的问题：</p><p>​ <strong>这个题目中树节点的值是可能重复的</strong>，这就会导致如果只记录节点的值，树的重构是会出问题的。如果，需要克服这个问题，我们还要给每个节点加上index，并且利用一个hash表记录节点index和值的对应关系。这是比较麻烦的。</p><p>​ 此Blog就是为了记录另一种解题思路：<strong>在特定条件下，我们可以仅凭借树的前序序列就能够确定恢复一颗唯一的二叉树</strong>。</p><p>​ <strong>如果想要达到上面的效果，那么我们的前序遍历序列是需要记录为Null的节点的，示例如下</strong>：</p><p><img src="https://assets.leetcode.com/uploads/2020/09/15/serdeser.jpg" alt="img" style="zoom:33%;" /></p><p>​ 对于上述二叉树，普通的前序序列应当为:</p><p>​ <strong>1 2 3 4 5 </strong></p><p>​ 而如果我们想要用来恢复树结构，前序序列应当为：</p><p>​ <strong>1 2 None None 3 4 None None 5 None None</strong></p><p>​ 具体如何操作，以及如何恢复见如下代码：先序遍历和正常的类似，只不过如果碰到了为NULL的节点，我们不是直接return，而是会将其记录入序列中。</p><p>​ 在重建操作中，我们将序列存入一个队列中操作较为方便，然后如果碰到None就返回NULL，否则就新建一个节点，利用递归的形式，确定左右子树节点，然后返回新建节点。最终就能完成一整颗树的重建。这种方法从时间复杂度和代码复杂度上都优于前一种通过两个序列进行重建的方法。但是局限就是，前序遍历得到的序列需要是你自己形成的“特殊”的前序遍历序列。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Codec</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">preOrder</span><span class="params">(TreeNode* root,string &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            res += <span class="string">&quot;None,&quot;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        res += <span class="built_in">to_string</span>(root-&gt;val) + <span class="string">&quot;,&quot;</span>;</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;left,res);</span><br><span class="line">        <span class="built_in">preOrder</span>(root-&gt;right,res);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="function">string <span class="title">serialize</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        string str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="comment">//需要一棵树的前序(P) + 中序遍历序列(I)才能够进行重构</span></span><br><span class="line">        <span class="built_in">preOrder</span>(root,str);</span><br><span class="line">        <span class="keyword">return</span> str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">TreeNode* <span class="title">preOrderReverse</span><span class="params">(queue&lt;string&gt; &amp;q)</span></span>&#123;</span><br><span class="line">        string tmp = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(tmp == <span class="string">&quot;None&quot;</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(<span class="built_in">stoi</span>(tmp));</span><br><span class="line">        root-&gt;left = <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        root-&gt;right =<span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">deserialize</span><span class="params">(string data)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 先把string转成序列的形式</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;data.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="comment">// i = 0 是第一个数字的起始位置，i = data.lenth()-1 是 I前面那个逗号的位置</span></span><br><span class="line">            string tmp_str = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            <span class="keyword">while</span>(data[i]!=<span class="string">&#x27;,&#x27;</span>)&#123;</span><br><span class="line">                tmp_str += data[i];</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            q.<span class="built_in">push</span>(tmp_str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//然后再通过序列重建树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">preOrderReverse</span>(q);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，记录一下二叉树的序列化与重构方式的扩展，如何更好的用线性方式记录二叉树的结构。我们都知道一个前序序列+中序序列可以确定恢复一颗二叉树结构，但在特定条件下的一个前序序列也能够确定恢复一颗二叉树。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="tree" scheme="https://blog.slks.xyz/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>树系列——当二叉树需要以层为单位计算时层序遍历的优化版本</title>
    <link href="https://blog.slks.xyz/2022/02/06/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BC%98%E5%8C%96/"/>
    <id>https://blog.slks.xyz/2022/02/06/LeetCode%E7%AC%94%E8%AE%B0/%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86%E4%BC%98%E5%8C%96/</id>
    <published>2022-02-06T13:02:19.000Z</published>
    <updated>2022-02-07T03:57:57.629Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-045.-二叉树最底层最左边的值"><a href="https://leetcode-cn.com/problems/LwUNpT/">剑指 Offer II 045. 二叉树最底层最左边的值</a></h4><p><strong>题目描述</strong>：</p><p>​ 给定一个二叉树的 <strong>根节点</strong> <code>root</code>，请找出该二叉树的 <strong>最底层 最左边</strong> 节点的值。假设二叉树中至少有一个节点。具体信息请点击链接查看。</p><p><strong>题目解答</strong>：</p><p>​ 思路是很简单的，一个层序遍历，然后最后一层层序遍历的第一个值返回即可，但是整个过程中还是有很多步骤可以优化的。以最简单的思想来讲，我们需要先来一遍层序遍历，确定总共有多少层，然后再来一遍层序遍历，当知道到最后一层的第一个节点的时候记录返回。但是其实可以只用一次层序遍历完成：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;TreeNode*&gt;&gt; v;</span><br><span class="line">        queue&lt;TreeNode*&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(root);  </span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            vector&lt;TreeNode*&gt; tmp;</span><br><span class="line">            <span class="keyword">while</span>(size--)&#123;          <span class="comment">// 最精妙的在于此</span></span><br><span class="line">                TreeNode* t = q.<span class="built_in">front</span>();</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(t);</span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;left) q.<span class="built_in">push</span>(t-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(t-&gt;right) q.<span class="built_in">push</span>(t-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            v.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> v[v.<span class="built_in">size</span>()<span class="number">-1</span>][<span class="number">0</span>]-&gt;val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ 上述层序遍历中，最为精髓的部分就是在while(!q.empty())中，加入了一个while(size--)的循环，而每次在这里面进行循环的，必定是同一层的节点。这一点尝试以后就会发现是正确的，如此一来就大大缩减了整个层序遍历的过程。如果这道题目需要找到每一层的最大值，也就不需要两次遍历了，我们只要在内循环中每次找到一个最大值，就是在每一层里找最大值。</p><p>​ 此篇博客就是为了记录这样一个小的Trick。</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要以层为单位计算一颗树的性质，我们可以不需要非常复杂的记录每个节点的层级信息，然后遍历完后再去遍历节点获取level信息，而是可以在层序遍历的过程中将每一层的遍历区分开。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="tree" scheme="https://blog.slks.xyz/tags/tree/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——LRU最近最少使用缓存的容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/LRU%E7%BC%93%E5%AD%98%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T11:02:19.000Z</published>
    <updated>2022-02-06T03:44:38.987Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目-剑指-offer-ii-031.-最近最少使用缓存">题目: <a href="https://leetcode-cn.com/problems/OrIXps/">剑指 Offer II 031. 最近最少使用缓存</a></h3><p><strong>题目简要描述</strong>：</p><p>​ 运用所掌握的数据结构，设计和实现一个 LRU (Least Recently Used，最近最少使用) 缓存机制 。</p><p><strong>实现 LRUCache 类：</strong></p><ul><li><p>LRUCache(int capacity) 以正整数作为容量 capacity 初始化 LRU 缓存</p></li><li><p>int get(int key) 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</p></li><li><p>void put(int key, int value) 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</p></li></ul><p><strong>类模版</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ <strong>使用 双向链表 与 Hash 表</strong>，实现 LRU：将新插入的元素放在链表头部，或将最新访问的节点放在链表的头部。如果容量到达上限，去除链表最后的元素。在此期间，<strong>为了保证访问链表的头部和尾部都是O(1)时间，我们需要维护一个Head和一个Tail节点，分别指向双向链表的头部和尾部，这两个头部和尾部的节点中是不存放数据，留空的，仅为了进行指示。</strong>并且为了保证<strong>在O(1)时间内能够获取任意一个元素</strong>，我们还需要建立一个HashMap，将key值与对应的链表节点关联，以方便以O(1)时间进行访问。</p><p><strong>代码</strong>：以下代码我并没有做任何的优化，比如说合并一些可复用的函数，因为这样看上去更简单明了一些，其实比如说像一些将Node插入到链表前方的操作，以及删除链表最后一个元素的操作，都是可以写成函数封装起来的。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Node* prev;</span><br><span class="line">Node* next;</span><br><span class="line"><span class="keyword">int</span> key;</span><br><span class="line"><span class="keyword">int</span> value;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">Node</span>() &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">Node</span>(<span class="keyword">int</span> key, <span class="keyword">int</span> value) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;prev = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;key = key;</span><br><span class="line"><span class="keyword">this</span>-&gt;value = value;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> capacity;</span><br><span class="line"><span class="keyword">int</span> curr_size;</span><br><span class="line">Node* head; <span class="comment">//链表头节点</span></span><br><span class="line">Node* tail; <span class="comment">//链表尾巴节点</span></span><br><span class="line">unordered_map&lt;<span class="keyword">int</span>, Node*&gt; key2Node; <span class="comment">//key - Node 的转换</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">LRUCache</span>(<span class="keyword">int</span> capacity) &#123;</span><br><span class="line"><span class="keyword">this</span>-&gt;curr_size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">this</span>-&gt;capacity = capacity;</span><br><span class="line"><span class="keyword">this</span>-&gt;head = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line"><span class="keyword">this</span>-&gt;tail = <span class="keyword">new</span> <span class="built_in">Node</span>();</span><br><span class="line">head-&gt;next = tail;</span><br><span class="line">tail-&gt;prev = head;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) == key2Node.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">Node* curr = key2Node[key];</span><br><span class="line"><span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">Node* prev = curr-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line"><span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">curr-&gt;prev = head;</span><br><span class="line">head-&gt;next = curr;</span><br><span class="line">curr-&gt;next = next;</span><br><span class="line">next-&gt;prev = curr;</span><br><span class="line"><span class="keyword">return</span> curr-&gt;value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (key2Node.<span class="built_in">find</span>(key) != key2Node.<span class="built_in">end</span>()) &#123;</span><br><span class="line"><span class="comment">//修改值并将该元素插到最前面</span></span><br><span class="line">Node* curr = key2Node[key];</span><br><span class="line">curr-&gt;value = value;</span><br><span class="line"><span class="comment">//将curr先从链表中删掉</span></span><br><span class="line">Node* prev = curr-&gt;prev;</span><br><span class="line"><span class="keyword">if</span> (prev) prev-&gt;next = curr-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (curr-&gt;next) curr-&gt;next-&gt;prev = prev;</span><br><span class="line"><span class="comment">//然后添加到链表的最前面</span></span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">curr-&gt;prev = head;</span><br><span class="line">head-&gt;next = curr;</span><br><span class="line">curr-&gt;next = next;</span><br><span class="line">next-&gt;prev = curr;</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">this</span>-&gt;curr_size == <span class="keyword">this</span>-&gt;capacity) &#123;</span><br><span class="line"><span class="comment">//如果容量满了,丢掉最尾巴的那个，然后插入到最前面</span></span><br><span class="line"><span class="comment">//丢掉最尾巴那个</span></span><br><span class="line">Node* prev = <span class="keyword">this</span>-&gt;tail-&gt;prev;</span><br><span class="line">key2Node.<span class="built_in">erase</span>(prev-&gt;key); <span class="comment">//抹除key2Node里</span></span><br><span class="line"><span class="keyword">if</span> (prev-&gt;prev) prev-&gt;prev-&gt;next = tail;</span><br><span class="line">tail-&gt;prev = prev-&gt;prev;</span><br><span class="line">prev-&gt;prev = prev-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="comment">//插入该元素到最前面</span></span><br><span class="line">Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">temp-&gt;prev = head;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;next = next;</span><br><span class="line">next-&gt;prev = temp;</span><br><span class="line">key2Node[key] = temp;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//如果容量没满，元素插入到最前面，并加载入map中</span></span><br><span class="line">Node* temp = <span class="keyword">new</span> <span class="built_in">Node</span>(key, value);</span><br><span class="line">Node* next = <span class="keyword">this</span>-&gt;head-&gt;next;</span><br><span class="line">temp-&gt;prev = head;</span><br><span class="line">head-&gt;next = temp;</span><br><span class="line">temp-&gt;next = next;</span><br><span class="line">next-&gt;prev = temp;</span><br><span class="line">key2Node[key] = temp;</span><br><span class="line"><span class="keyword">this</span>-&gt;curr_size++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong>:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_06_11_41_37_32.png" /></p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要针对 LRU最近最少使用缓存 设计一个容器。使得其获取与插入的方法时间复杂度都为O(1)</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——前缀树容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%BC%80%E6%A0%91%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/%E5%89%8D%E7%BC%80%E6%A0%91%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T11:02:19.000Z</published>
    <updated>2022-02-08T15:37:13.716Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-062.-实现前缀树"><a href="https://leetcode-cn.com/problems/QC3q1f/">剑指 Offer II 062. 实现前缀树</a></h4><p><strong>题目描述</strong>：</p><p>​ Trie（发音类似 "try"）或者说 前缀树 是一种树形数据结构，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如<strong>自动补完和拼写检查</strong>。****</p><p>请你实现 Trie 类：</p><pre><code>Trie() 初始化前缀树对象。void insert(String word) 向前缀树中插入字符串 word 。boolean search(String word) 如果字符串 word 在前缀树中，返回 true（即，在检索之前已经插入）；否则，返回 false 。boolean startsWith(String prefix) 如果之前已经插入的字符串 word 的前缀之一为 prefix ，返回 true ；否则，返回 false 。</code></pre><p><strong>解题思路</strong>：</p><p>​ Trie，又称前缀树或字典树，是一棵有根树，其每个节点包含以下字段：</p><ul><li>指向子节点的指针数组 childrens。在本题中，这可以是一个动态的vector，也可以是一个大小定为26的vector，因为本文中的字符限定为小写字母。两者各有好处，动态的vector节省一些空间，静态的vector在查找和插入时节省一些时间，实现起来也较为方便一些。</li><li>布尔字段 isEnd，表示该节点是否为字符串的结尾。</li></ul><p>下面是一张比较清晰的图：非常明了</p><figure><img src="https://pic.leetcode-cn.com/1632672370-gVXuKM-image.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><p><strong>代码实现（动态vector版本，我写的）</strong>：</p><p>​ Search操作和startsWith其实就是差一个判定字符串结尾的操作，所以我将两个函数合并成了一个，用一个形参来控制，使得代码尽量简介。Insert操作其实和Search操作也有大量的重复代码，循环判定都是一致的，就是判定后操作逻辑不太一样，但为了不混在一起，我还是将其分开写了。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_08_168.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="keyword">char</span> character,<span class="keyword">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if the word is in the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(word,<span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns if there is any word in the trie that starts with the given prefix. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">mySearch</span>(prefix,<span class="literal">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">mySearch</span><span class="params">(string word,<span class="keyword">bool</span> includePrefix)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> res = <span class="literal">true</span>;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续找下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span> &amp;&amp; !includePrefix)&#123; <span class="comment">//如果是最后一个自符，还需要判定下一个r-&gt;isEnd</span></span><br><span class="line">                    <span class="keyword">if</span>(!r-&gt;isEnd) res = <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p><strong>代码实现（静态vector版本，引自LeetCode题解）</strong>：</p><p>​ 可以看到，其本身代码简洁程度较高，并且它将Trie直接视为一个节点了，没有建立额外的TreeNode类。运行时间上和我的算法类似，差别不是很大。但是其内存消耗是远大于我的算法的，</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_15_17_59_414.png" /></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;Trie*&gt; children;</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line"></span><br><span class="line">    <span class="function">Trie* <span class="title">searchPrefix</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : prefix) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Trie</span>() : <span class="built_in">children</span>(<span class="number">26</span>), <span class="built_in">isEnd</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">char</span> ch : word) &#123;</span><br><span class="line">            ch -= <span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span> (node-&gt;children[ch] == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                node-&gt;children[ch] = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;children[ch];</span><br><span class="line">        &#125;</span><br><span class="line">        node-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">search</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(word);</span><br><span class="line">        <span class="keyword">return</span> node != <span class="literal">nullptr</span> &amp;&amp; node-&gt;isEnd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">startsWith</span><span class="params">(string prefix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>-&gt;<span class="built_in">searchPrefix</span>(prefix) != <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/QC3q1f/solution/shi-xian-qian-zhui-shu-by-leetcode-solut-un50/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure><p>再记录一道上述数据结构的应用题：</p><h4 id="剑指-offer-ii-063.-替换单词"><a href="https://leetcode-cn.com/problems/UhWRSj/">剑指 Offer II 063. 替换单词</a></h4><p>​ 在英语中，有一个叫做 词根(root) 的概念，它可以跟着其他一些词组成另一个较长的单词——我们称这个词为 继承词(successor)。例如，词根an，跟随着单词 other(其他)，可以形成新的单词 another(另一个)。</p><p>​ 现在，给定一个由许多词根组成的词典和一个句子，需要将句子中的所有继承词用词根替换掉。如果继承词有许多可以形成它的词根，则用最短的词根替换它。需要输出替换之后的句子。</p><p>​ 示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：dictionary = [&quot;cat&quot;,&quot;bat&quot;,&quot;rat&quot;], sentence = &quot;the cattle was rattled by the battery&quot;</span><br><span class="line">输出：&quot;the cat was rat by the bat&quot;</span><br></pre></td></tr></table></figure><p><strong>代码（Author: Fantast）</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_08_18_14_35_668.png" /></p><p>​ 主要思路就是实现一个前缀树，其中和上题不一样的是，上题是前缀找单词，这题是单词找前缀，反了反，所以我将startsWith改成了searchRoot函数，大体搜寻逻辑一致。然后再应用该数据结构解题即可。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> isEnd;</span><br><span class="line">    <span class="keyword">char</span> character;</span><br><span class="line">    vector&lt;MyTreeNode*&gt; childrens;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MyTreeNode</span>(<span class="keyword">char</span> character,<span class="keyword">bool</span> isEnd)&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;isEnd = isEnd;</span><br><span class="line">        <span class="keyword">this</span>-&gt;character = character;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> &#123;</span></span><br><span class="line">    MyTreeNode* root;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">Trie</span>() &#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a word into the trie. */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，插入一个新的节点</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>(word[i],i == word.<span class="built_in">length</span>()<span class="number">-1</span>);</span><br><span class="line">                r-&gt;childrens.<span class="built_in">push_back</span>(c);</span><br><span class="line">                r = c;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，那么继续下一个字符，</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                <span class="keyword">if</span>(i == word.<span class="built_in">length</span>()<span class="number">-1</span>)&#123;  <span class="comment">//如果是最后一个字符，那么</span></span><br><span class="line">                    r-&gt;isEnd = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** 查询字典中是否有该单词的词根，如果有返回词根，如果没有，返回原单词*/</span></span><br><span class="line">    <span class="function">string <span class="title">searchRoot</span><span class="params">(string word)</span> </span>&#123;</span><br><span class="line">        string res;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;word.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(j = <span class="number">0</span>;j&lt; r-&gt;childrens.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;childrens[j]-&gt;character == word[i])&#123;</span><br><span class="line">                    flag = <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果没找到，返回false</span></span><br><span class="line">            <span class="keyword">if</span>(!flag)&#123;</span><br><span class="line">                res = word;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了，观察其是否是一个词根</span></span><br><span class="line">                r = r-&gt;childrens[j];</span><br><span class="line">                res += r-&gt;character;</span><br><span class="line">                <span class="keyword">if</span>(r-&gt;isEnd)&#123; <span class="comment">//如果是一整个词根，直接返回</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">replaceWords</span><span class="params">(vector&lt;string&gt;&amp; dictionary, string sentence)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;dictionary.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(dictionary[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        string res;</span><br><span class="line">        string word;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;sentence.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sentence[i] == <span class="string">&#x27; &#x27;</span>)&#123;</span><br><span class="line">                res += t-&gt;<span class="built_in">searchRoot</span>(word) + <span class="string">&quot; &quot;</span>;</span><br><span class="line">                word = <span class="string">&quot;&quot;</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                word += sentence[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res += t-&gt;<span class="built_in">searchRoot</span>(word);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>再记录一道上述数据结构的拓展应用题：</p><h4 id="剑指-offer-ii-067.-最大的异或"><a href="https://leetcode-cn.com/problems/ms70jA/">剑指 Offer II 067. 最大的异或</a></h4><p>给定一个整数数组 <code>nums</code> ，返回 <code>nums[i] XOR nums[j]</code> 的最大运算结果，其中 <code>0 ≤ i ≤ j &lt; n</code> 。</p><p><strong>提示：</strong></p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 10^4</code></li><li><code>0 &lt;= nums[i] &lt;= 2^31 - 1</code></li></ul><p><strong>解题思路</strong>：</p><p>​ 将整数视为二进制字符串 0 / 1，此题目的字典树孩子仅有0和1，然后遍历所有数组中的元素，对于任意一个元素ai来说，通过字典树找到和它异或最大的那个值。遍历元素O(n)复杂度，通过字典树找到每个元素的异或最大的值为log(C)，故而总的时间复杂度为O(nlog(C))</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTreeNode</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* left;  <span class="comment">// 0 </span></span><br><span class="line">    MyTreeNode* right; <span class="comment">// 1</span></span><br><span class="line">    <span class="built_in">MyTreeNode</span>()&#123;</span><br><span class="line">        <span class="keyword">this</span>-&gt;left = <span class="keyword">this</span>-&gt;right = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    MyTreeNode* root;</span><br><span class="line">    <span class="built_in">Trie</span>()&#123;</span><br><span class="line">        root = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;left)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;right)&#123; <span class="comment">//找到这个节点了</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//没找到这个节点，进行插入</span></span><br><span class="line">                MyTreeNode* c = <span class="keyword">new</span> <span class="built_in">MyTreeNode</span>();</span><br><span class="line">                <span class="keyword">if</span>(bit == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//插入左侧</span></span><br><span class="line">                    r-&gt;left = c;</span><br><span class="line">                    r = r-&gt;left;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="comment">//插入右侧</span></span><br><span class="line">                    r-&gt;right = c;</span><br><span class="line">                    r = r-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMax</span><span class="params">(<span class="keyword">int</span> val)</span></span>&#123;</span><br><span class="line">        MyTreeNode* r = <span class="keyword">this</span>-&gt;root;</span><br><span class="line">        <span class="keyword">int</span> multi_val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">32</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> bit = (val &gt;&gt; (<span class="number">31</span>-i)) &amp; <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且有1，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且有0，那么直接往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">0</span> &amp;&amp; !r-&gt;right &amp;&amp; r-&gt;left)&#123;</span><br><span class="line">                <span class="comment">//当前位为0，且无1，则往0那边走</span></span><br><span class="line">                r = r-&gt;left;</span><br><span class="line">                multi_val = multi_val &lt;&lt; <span class="number">1</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(bit == <span class="number">1</span> &amp;&amp; !r-&gt;left &amp;&amp; r-&gt;right)&#123;</span><br><span class="line">                <span class="comment">//当前位为1，且无0，那么直接往1那边走</span></span><br><span class="line">                r = r-&gt;right;</span><br><span class="line">                multi_val = (multi_val &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> multi_val ^ val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findMaximumXOR</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        Trie* t = <span class="keyword">new</span> <span class="built_in">Trie</span>();</span><br><span class="line">        <span class="keyword">int</span> maxVal = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            t-&gt;<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            maxVal = <span class="built_in">max</span>(maxVal,t-&gt;<span class="built_in">calculateMax</span>(nums[i]));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxVal;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">前缀树 是一种树形数据结构，又称字典树，用于高效地存储和检索字符串数据集中的键。这一数据结构有相当多的应用情景，例如自动补完和拼写检查。本文用于实现该数据结构，以及一道应用题目。当题目涉及到字符串寻找前缀，或者是字符串是否含有某字符串的任务，可以采用该数据结构，能够大幅降低算法时间复杂度</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>容器设计——插入、删除和随机访问都是 O(1) 的容器设计</title>
    <link href="https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/O(1)%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/"/>
    <id>https://blog.slks.xyz/2022/02/05/LeetCode%E7%AC%94%E8%AE%B0/O(1)%E5%AE%B9%E5%99%A8%E8%AE%BE%E8%AE%A1/</id>
    <published>2022-02-05T01:02:19.000Z</published>
    <updated>2022-02-06T03:44:42.086Z</updated>
    
    <content type="html"><![CDATA[<h3 id="题目剑指-offer-ii-030.-插入删除和随机访问都是-o1-的容器">题目：<a href="https://leetcode-cn.com/problems/FortPu/">剑指 Offer II 030. 插入、删除和随机访问都是 O(1) 的容器</a></h3><p><strong>题目简要描述</strong>：</p><p>设计一个支持在平均 时间复杂度 O(1) 下，执行以下操作的数据结构：</p><pre><code>insert(val)：当元素 val 不存在时返回 true ，并向集合中插入该项，否则返回 false 。remove(val)：当元素 val 存在时返回 true ，并从集合中移除该项，否则返回 false 。getRandom：随机返回现有集合中的一项。每个元素应该有 相同的概率 被返回。</code></pre><p><strong>类模版</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>解题思路</strong>：</p><p>​ 首先，题目要求插入和删除都需要是O(1)的时间复杂度，在我们熟知的数据结构中，<strong>只有Hash表能达到这个效果</strong>。但是，Hash表显然不能满足随机取getRandom这一操作，随机取的操作，<strong>底层应当是数组，而且最好是紧凑的连续存放内容的数组</strong>，这样才方便进行随机取的行为，并且概率一致。</p><p>​ 综上所述，我们应当设计这样一个数据结构，利用数组保存元素，然后利用哈希表保存元素值（key）和 该值在数组中存放的index（value），这样子就能实现上述的要求了。</p><p>​ 同时，我们还需要注意的一个细节就是，<strong>当我们删除元素时，不能直接将该元素在它的位置上删除</strong>，如果这样的话，就会导致数组存储元素的idx不连续，从而后续随机取元素的时候，各个元素的概率不再相等。我们应该用数组最后的那个元素将我们要删的元素进行替换，然后把数组最后的那个元素删除，最后更新哈希表中的idx即可。</p><p>​ 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RandomizedSet</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">  vector&lt;<span class="keyword">int</span>&gt; v;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="built_in">RandomizedSet</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Inserts a value to the set. Returns true if the set did not already contain the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">insert</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) != m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        m[val] = v.<span class="built_in">size</span>();</span><br><span class="line">        v.<span class="built_in">push_back</span>(val);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes a value from the set. Returns true if the set contained the specified element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">remove</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(val) == m.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> idx = m[val];</span><br><span class="line">        <span class="keyword">int</span> max_idx = m.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        m[v[max_idx]] = idx;</span><br><span class="line">        m.<span class="built_in">erase</span>(val);</span><br><span class="line">        v[idx] = v[max_idx];</span><br><span class="line">        v.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get a random element from the set. */</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="built_in">rand</span>() % m.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">return</span> v[idx];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，需要设计一个插入、删除和随机访问都是 O(1) 的容器。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="container" scheme="https://blog.slks.xyz/tags/container/"/>
    
  </entry>
  
  <entry>
    <title>链表系列——链表问题的常见技巧</title>
    <link href="https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%9A%84%E5%B8%B8%E7%94%A8%E4%BC%98%E5%8C%96%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-04T05:52:19.000Z</published>
    <updated>2022-02-05T01:01:30.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一剑指-offer-ii-022.-链表中环的入口节点">一、<a href="https://leetcode-cn.com/problems/c32eOV/">剑指 Offer II 022. 链表中环的入口节点</a></h3><p><strong>题目简单描述</strong>：</p><p>​ 给定一个链表，需要返回链表开始入环的第一个节点。 从链表的头节点开始沿着 next 指针进入环的第一个节点为环的入口节点。如果链表无环，则返回 null。</p><p>​ 进阶：是否可以使用 O(1) 空间解决此题？</p><p><strong>解题思路</strong>：</p><p>​ 本题本身想要解答十分简单，将其放入博客中整理是想记录我们应该如何利用O(1)空间去解决这个题目呢？</p><p>​ <strong>快慢指针法</strong>，我们使用两个指针，fast 与 slow。它们起始都位于链表的头部。随后，slow 指针每次向后移动一个位置，而 fast 指针向后移动两个位置。如果链表中存在环，则 fast 指针最终将再次与 slow 指针在环中相遇。</p><p>​ 如下图所示，即可非常好的理解如下：那么，又该如何判断入环点的位置呢？我们先上结论：经过数学推断可以得知：</p><p>​ <strong>假设快慢指针相遇时，fast指针已经走完了环的n圈，那么</strong></p><p>​ <strong>从相遇点到入环点的距离加上 n−1 圈的环长，恰好等于从链表头部到入环点的距离。</strong></p><p>​ <strong>根据此结论，我们只需要在快慢指针相遇时，再加一个ptr指针，让其指向链表头部；随后，它和 slow 指针每次向后移动一个位置。最终，它们会在入环点相遇。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-04 下午2.06.49.png" alt="截屏2022-02-04 下午2.06.49" style="zoom:33%;" /></p><p>​ <strong>结论证明</strong>：设链表中环外部分的长度为 a。slow 指针进入环后，又走了 b 的距离与 fast 相遇。此时，fast 指针已经走完了环的 n 圈，因此它走过的总距离为 <span class="math inline">\(a + n \times (b+c) + b\)</span> ,而此时，slow指针走过的总距离为 <span class="math inline">\(a + b\)</span>。</p><p>​ <strong>【此处需要解释一下：为何fast与slow相遇时，slow必定还在走第一圈？】</strong>（我们假设fast和slow如果同时从入环点出发，由于速度是2倍的关系，slow走完1圈的时候，fast刚好走完2圈，他们会在起点相遇。但是现在，fast比slow先入环，也就是说slow入环的时候，fast不管在环的哪里，肯定能在slow走完一圈前，将其追上。）</p><p>​ 由于fast指针走的速度是slow指针的2倍，那么可以得到以下等式：$ a + n (b+c) = 2 (a + b)$ 所以可以得到如下结论： $ a = c + (n-1) (b+c)$ ,这也就意味着，最开始说的， 从相遇点到入环点的距离 + (n-1) 圈环的距离，等于链表头到入环点的距离。</p><p>​ 那么为什么说，如果相遇的时候，ptr从链表头出发，ptr和slow必定在入环口相遇呢？因为a的距离是c加上许多圈环的距离，所以当ptr到达链表入环口的时候，时间经过了a，此时slow必定出现在入环口处。所以我们可以根据此来判断，入环口的位置是哪一个节点。</p><h3 id="二剑指-offer-ii-023.-两个链表的第一个重合节点">二、<a href="https://leetcode-cn.com/problems/3u1WK4/">剑指 Offer II 023. 两个链表的第一个重合节点</a></h3><p><strong>简单题目描述</strong>：</p><p>​ 给定两个单链表的头节点 headA 和 headB ，请找出并返回两个单链表相交的起始节点。如果两个链表没有交点，返回 null 。详细见原网址</p><p><strong>解题思路</strong>：</p><p>参考：https://leetcode-cn.com/problems/3u1WK4/solution/liang-ge-lian-biao-de-di-yi-ge-zhong-he-0msfg/</p><p>此题难点在于设计一个时间复杂度 O(n) 、仅用 O(1) 内存的解决方案？</p><p>​ 我们可以考虑双指针的方法对两个链表进行求解，但是双指针的难点在于，两条链表的长度不同，无法做到一一对应。我们先给出<strong>解决方案</strong>：</p><p>​ 当链表 headA 和 headB 都不为空时，创建两个指针 pA 和 pB ，初始时分别指向两个链表的头节点 headA和 headB ，然后将两个指针依次遍历两个链表的每个节点。具体做法如下：</p><ul><li>每步操作需要同时更新指针 pA 和 pB。</li><li>如果指针 pA 不为空，则将指针 pA 移到下一个节点；如果指针 pB 不为空，则将指针 pB 移到下一个节点。</li><li>如果指针 pA 为空，则将指针 pA 移到链表 headB 的头节点；如果指针 pB 为空，则将指针 pB 移到链表 headA 的头节点。</li><li>当指针 pA 和 pB 指向同一个节点或者都为空时，返回它们指向的节点或者 null。</li></ul><p>​ <strong>乍一看，其中有一个非常奇怪的点</strong>，就是如果指针pA为空，那么将指针pA移动到链表headB的头节点。但其实仔细一想，这样子是没问题的。也正是因为这个操作，我们才能够得以解决两个链表长度不一致导致的不对应问题。较为详细的证明如下：</p><p>​ 我们先考虑<strong>两链表相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达某一个节点。</p><p>​ 如果两链表长度不一致，这样子的话，我们假设链表A、B长度为m和n，A、B的不相交部分节点数为a，b，相交部分节点数为c，那么m = a + c , n = b + c. pA和pB第一遍遍历完各自的链表后，他们不是同时到达尾部节点的，但是当pA遍历完 a + c + b个节点，当pB遍历完b + c + a个节点的时候，两者就会同时到达相交的节点。</p><p>​ 再证明<strong>两链表不相交的情况</strong>，如果两链表长度一致，那不需要想，pA和pB必定同时到达最终的NULL节点。</p><p>​ 如果两链表长度不一致，这样子的话，我们假设链表A、B的长度各位m和n，当pA 遍历完 m + n个节点，pB遍历完 n + m个节点的时候，必定同时到达尾部的NULL节点。</p>]]></content>
    
    
    <summary type="html">链表问题的解题技巧与常见优化思路，比如快慢指针法以达到O(1)空间复杂度、双指针以缩减空间复杂度等。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="linked list" scheme="https://blog.slks.xyz/tags/linked-list/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——回文字符串相关处理技巧</title>
    <link href="https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.slks.xyz/2022/02/04/LeetCode%E7%AC%94%E8%AE%B0/%E5%9B%9E%E6%96%87%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9B%B8%E5%85%B3%E5%A4%84%E7%90%86%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-04T05:30:19.000Z</published>
    <updated>2022-02-06T13:37:11.818Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一剑指-offer-ii-020.-回文子字符串的个数">一、<a href="https://leetcode-cn.com/problems/a7VOhD/">剑指 Offer II 020. 回文子字符串的个数</a></h3><p><strong>题目描述：</strong></p><p>给定一个字符串 s ，请计算这个字符串中有多少个回文子字符串。</p><p>具有不同开始位置或结束位置的子串，即使是由相同的字符组成，也会被视作不同的子串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;abc&quot;</span><br><span class="line">输出：3</span><br><span class="line">解释：三个回文子串: &quot;a&quot;, &quot;b&quot;, &quot;c&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aaa&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：6个回文子串: &quot;a&quot;, &quot;a&quot;, &quot;a&quot;, &quot;aa&quot;, &quot;aa&quot;, &quot;aaa&quot;</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= s.length &lt;= 1000s 由小写英文字母组成</code></pre><p><strong>解题思路</strong>：</p><p>​ 引用：https://leetcode-cn.com/problems/a7VOhD/solution/jssan-jie-bao-li-shuang-zhi-zhen-zhong-x-qqq0/</p><ul><li><p>思路1: 暴力搜索</p><ul><li>搜索所有的子串，并分别判断是否为回文串</li><li>时间复杂度：O(n^3)</li><li>空间复杂度：O(1)</li></ul></li><li><p>思路2: 双指针，思路1的优化版本：</p><ul><li>先使用双指针 i 和 j 枚举所有子串的起点和终点，同时分别按顺序和逆序累加所有遍历过的字符得到字符串 s1 和 s2，判断是否回文只需对 s1 和 s2 判等即可。这里将回文判断的时间复杂度从 O(n)优化到 O(1)，但整体空间复杂度从 O(1)升到 O(n)，算是空间换时间。</li><li>但此思路的时间耗费仍然会较高，因为字符串的拼接操作都较为费时</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i =<span class="number">0</span>;i&lt;s.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            string s1,s2;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;s.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                s1 += s[j];</span><br><span class="line">                s2 = s[j] + s2;</span><br><span class="line">                <span class="keyword">if</span>(s1==s2) count++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li><li><p><strong>思路3: 中心扩展：</strong></p><ul><li><p>枚举所有可能的回文中心 s[i] 或 s[i]、s[i + 1]，若回文子串长度为奇数则其中心为 s[i]，回文子串长度为偶数则其中心为 s[i]、s[i + 1]；</p></li><li><p>以中心向左右两边扩展，即</p><ul><li>左边界 l 减 1</li><li>右边界 r 加1</li><li>如果 s[l] 与 s[r] 相等则回文数加1。</li></ul></li><li><div class="sourceCode" id="cb2"><pre class="sourceCode java"><code class="sourceCode java"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>  <span class="kw">class</span> Solution <span class="op">&#123;</span></span><span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a>  <span class="kw">public</span><span class="op">:</span></span><span id="cb2-3"><a href="#cb2-3" aria-hidden="true" tabindex="-1"></a>      <span class="dt">int</span> <span class="fu">countSubstrings</span><span class="op">(</span>string s<span class="op">)</span> <span class="op">&#123;</span></span><span id="cb2-4"><a href="#cb2-4" aria-hidden="true" tabindex="-1"></a>          <span class="dt">int</span> count <span class="op">=</span> <span class="dv">0</span><span class="op">;</span></span><span id="cb2-5"><a href="#cb2-5" aria-hidden="true" tabindex="-1"></a>          <span class="cf">for</span><span class="op">(</span><span class="dt">int</span> i <span class="op">=</span><span class="dv">0</span><span class="op">;</span>i<span class="op">&lt;</span>s<span class="op">.</span><span class="fu">length</span><span class="op">();</span>i<span class="op">++)&#123;</span></span><span id="cb2-6"><a href="#cb2-6" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i<span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span><span id="cb2-7"><a href="#cb2-7" aria-hidden="true" tabindex="-1"></a>              <span class="cf">for</span> <span class="op">(</span><span class="dt">int</span> l <span class="op">=</span> i<span class="op">,</span> r <span class="op">=</span> i <span class="op">+</span> <span class="dv">1</span><span class="op">;</span> l <span class="op">&gt;=</span> <span class="dv">0</span> <span class="op">&amp;&amp;</span> s<span class="op">[</span>l<span class="op">]</span> <span class="op">==</span> s<span class="op">[</span>r<span class="op">];</span> l<span class="op">--,</span> r<span class="op">++)</span> count<span class="op">++;</span></span><span id="cb2-8"><a href="#cb2-8" aria-hidden="true" tabindex="-1"></a>          <span class="op">&#125;</span></span><span id="cb2-9"><a href="#cb2-9" aria-hidden="true" tabindex="-1"></a>          <span class="cf">return</span> count<span class="op">;</span></span><span id="cb2-10"><a href="#cb2-10" aria-hidden="true" tabindex="-1"></a>      <span class="op">&#125;</span></span><span id="cb2-11"><a href="#cb2-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">&#125;;</span></span></code></pre></div></li></ul></li></ul>]]></content>
    
    
    <summary type="html">与回文字符串相关的题目的解题技巧与常见优化思路</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记13——Maven基础介绍（更新中）</title>
    <link href="https://blog.slks.xyz/2022/02/04/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94Maven%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/"/>
    <id>https://blog.slks.xyz/2022/02/04/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B013%E2%80%94Maven%E5%9F%BA%E7%A1%80%E4%BB%8B%E7%BB%8D/</id>
    <published>2022-02-04T00:54:19.000Z</published>
    <updated>2022-02-02T04:50:43.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1255945359327200</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于Maven相关的内容。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——经典三数之和问题</title>
    <link href="https://blog.slks.xyz/2022/02/03/LeetCode%E7%AC%94%E8%AE%B0/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.slks.xyz/2022/02/03/LeetCode%E7%AC%94%E8%AE%B0/%E4%B8%89%E6%95%B0%E4%B9%8B%E5%92%8C%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-03T11:53:19.000Z</published>
    <updated>2022-02-05T01:01:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="q1剑指-offer-ii-007.-数组中和为-0-的三个数">Q1、<a href="https://leetcode-cn.com/problems/1fGaJU/">剑指 Offer II 007. 数组中和为 0 的三个数</a></h3><p>​ 给定一个包含 n 个整数的数组 nums，判断 nums 中是否存在三个元素 a ，b ，c ，使得 a + b + c = 0 ？请找出所有和为 0 且 不重复 的三元组。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [-1,0,1,2,-1,-4]</span><br><span class="line">输出：[[-1,-1,2],[-1,0,1]]</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = []</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0]</span><br><span class="line">输出：[]</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 3000-105 &lt;= nums[i] &lt;= 105</code></pre><h4 id="解题思路">解题思路：</h4><p>​ 该题最重要的是如何<strong>高效率的循环遍历</strong>以及 如何<strong>高效率的去除重复三元组</strong></p><p>​ 最简单的O(n^3)的暴力求解，对于该题而言时间复杂度会大大超出。所以我们考虑双指针的解法。<strong>双指针在三数之和中如何应用呢？</strong></p><p>​ <strong>无非是在传统双指针求法的前提上，在外层多加了一层循环</strong>，也就是先固定住一个元素，然后利用双指针，将内部O(n^2)的复杂度，缩减至O(n)，从而使得整个求解复杂度降至O(n ^2)。</p><p>​ 该题另外一个核心要点是，如何高效率的去除重复？我们当然可以去使用Hash表，然后每有一个元素就将其push进去，并进行比较，如果已经存在就不计入结果中。但是这样的方法仍然会导致大量的计算浪费。</p><p>​ 观察后，我们会发现，在循环的时候，有两种情况会导致重复：</p><p><strong>情况1</strong>：当外层循环的i , nums[i] == nums[i-1] 的时候，原因是，如果nums[i] == nums[i-1]，那么当前nums[i]能够找到的j和k，在nums[i-1]中必定已经出现过了，所以我们的处理方法是，直接跳过该次外层循环，进入下一个i</p><p><strong>情况2</strong>：出现在内部双指针运行的时候，如下述情况：i，j, k分别指向-4，-1，5，此时满足一组条件，我们会将 j++, 以让循环继续运行。此时，重复发生了，如果nums[j] == nums[j + 1]，那么nums[j+1]所产生的符合条件的三元组就会与之前的重复，所以我们采取的措施是，让j一直自增，直到其和下一个元素不相等或者到达k。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-4  -1  -1  -1  2  5</span><br><span class="line"></span><br><span class="line">​i   j              k</span><br></pre></td></tr></table></figure><p>综上，代码书写如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>]) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">int</span> j = i+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> k = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(j&lt;k)&#123;</span><br><span class="line">                <span class="keyword">int</span> value = nums[i] + nums[j] + nums[k];</span><br><span class="line">                <span class="keyword">if</span>(value &gt; <span class="number">0</span>) k--;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(value &lt; <span class="number">0</span>) j++;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[i],nums[j],nums[k]&#125;);</span><br><span class="line">                    <span class="keyword">while</span> (j &lt; k &amp;&amp; nums[j] == nums[j + <span class="number">1</span>]) j++; </span><br><span class="line">                    j++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">讲解经典三数之和问题的高效解法，关键在于双指针与高效率去重的应用。</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 题目情况整理（持续更新）</title>
    <link href="https://blog.slks.xyz/2022/02/03/LeetCode%E7%AC%94%E8%AE%B0/LeetCode%E9%A2%98%E7%9B%AE%E6%83%85%E5%86%B5%E6%95%B4%E7%90%86/"/>
    <id>https://blog.slks.xyz/2022/02/03/LeetCode%E7%AC%94%E8%AE%B0/LeetCode%E9%A2%98%E7%9B%AE%E6%83%85%E5%86%B5%E6%95%B4%E7%90%86/</id>
    <published>2022-02-03T09:59:19.000Z</published>
    <updated>2022-02-08T15:37:35.929Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="3686381fb043665ad91837ff2391412e6a54eff1055732ecaeb3330c0fe8e397">0b64cd3abe5b0a0a039a37d86c66d75e6ec8e220ebc13f2625638343d94e3b658da8c40ea430452654890c623f4dcfb24f0642b20202d7d277d1f2eaf3401d7e8931cbb53388f684d3b93e2de9e153f12e895a94d070525ce2de906373fb4cbf94e92e031f207c298839595348f1501b4bf727abc1428dfc74b33b7500340198f1d3a287ba35df763ca88f190b4ec65f9d676337edc877b8c21ce07a08a995fd892898347b548004ec7204b456116e8b1081289da98b952774bba0123bae9a554ce991d3f4c089dc1beb9b187c241b72f075dc547471768b5fd797194b1c30b3eb864d8c75c7039f4aeb9dfacfadef6a221a5e56f6895ce4b6e22baf85cf0aa4bf137d21a4f7f90899e8f2ff6643be5717872df903679740e097a36d415f3f61ece25e16235a00b75e97dcb8cc1183f0447fec3391444e8166a92e8d3f371a46a92150509927d96271fa80f3b7e3895d335ac3143ce2ec26b5efbb52747362513e09d7c0e096cf194bc8a5a72ee409f6925270e32c3a0f920d42dbb534993224b891719d16507a4cde73c8a00842640edd1aad78c6d60488148f53fc71a9407dfbcc53b83df62880339fb8dc351aa7c8e726a7b80a837f4b54b131060e16f528422250fa026347585717c79e7d30cace4622baff98402ee34c64045c2314258c776a67348743f24232d32898c00578eadde05541d64eb8304abe23fbaf676d00a67debff1d11bf8e5dcba931bc26ba9a7ebd5727fe131948da1432a9c106a5b6d2434a9ee955ce8af03e6ef5973a6f5b0997903c70a839fba6be406829290f6834279150d486392c1794291aba8800319fcf57ab39466942e05d84cbc3dbfb6dd388a4d22343820f6d5a98a1b21021d050de7f5992334a7796174c8773b38bffdcb2b6db4478590ccb1fc9e53d33557cb569b740c5f6a9a1e63e62cb7a11774b24d14d11b2ce55b01f7611d0f646ba0ea73ba0096b49a7d59482c54fab0ef2b5e2758f6a6ff10edf80a46c8d7d4ee753649d79e9b72ed7503048b952286cd0f6f83b95c6186a8d8345ae954c20cd30686b518d3751003fc132a751b362f2d5816dbab8317c7de432fd2ae3cbaab703c3e232363d961a476511bb9367d5d3dc37743c58d7753d45ec0121c941a74314bd0b0579c508f8cb2ee6ae5dfc26e12eed08e94a9d7eda6c945b67e3523c3b184a22b1ec77f894440942712d79f17e13914bdbd663920f83644c48bbd2e0d8928b1065893a8d4e2321b4e827578ab6b5831db0ae15417df1ecfae2ebe6dcb37517116f2d368c1d1ea49d39b432bfe1e171b50c3abdd2c76a26c91ae929bd0f1a22f7fd07f59e9a056394986230667d92cbe1218eb663831115a8fde730866d33cb1d787b038b2bb2912eaf6f114f54f7b828f69aee53d3b881a95a03720af2f946da7902d7eedd62251e028aa8dcc9af645d29dea3ff10bd13796fdb7e9535cde6230116db183a19bcea9cf53c7c57381cf3e89562eca9fff9985e60ccb521594dc981169dafdf2059600868bd3d30088dbce803e76a677dd6e594af0a9ba5bc5672ff1887689a2bcb22eb939684fbb9add8cb9b5cc3ceefb5f0a0b49f77d1d079a7b2cd44d6056e5028b768ddc8af447bd0102759543bd2d3dc9ba5cd8c4d97b4279383f466ec1d9721cc4012be9ed810b8db826569a42e82b49fcd6cc59856eab515020da8cd0e756fbda0441b57abc73e739c7ea713a100282a992851b4436805e0fc4310f1481859d30933a2206ecd926441e4f4b43281afa928fee6c052c19cbf8e1c1dfd2508a35d79c87c112c21b4df6a244142d3146842770775574c4308475691bce551c8109fc24f9f3d96edc038841d3d3f6ea992e4a44594e4dfa2a8175d25515987f6ff1c7bbe23cc4ddedc03535a542af09f4ba633a1b50776aff22f6e9814ae2e0eaa74cc8345700954356fd85232fe33bdbe3f3713ac2632d65fed914b324ade4b3da5ecb1f2728acc8e662e4eede4f8f74a6418ddd3e7e844ef5e61a36ef95230c69cb11a49b33e5a7076133cb053ae52bdbc44d6bffb22504f70c442f9db71f920f2db672a75b9b13e166f9ec86f5af50342c258f9dde7da88297c0b74c7bab9509122bfbd2052d7d81ce24ae08ab886aab39cade69a45740f6dc6f283f078c4eb77cd857ace623dd365a75d41d8d38460e4c51c72ef09bdc19d2600beefb7a66fbd37509398e3bf5fe3cf27755455bd545e7f9fdf814c86f8f636759dc5c67e1965063146bf4bcc5702c5c8a72db2ca79d29abd6aac14c1ab868bd9b22ff31ff213d00781b792585cc37e52fb8e29d7bc5250d93036c2a767e214932571217e1cce28091a752e45a69b40f9fdd81161bc8c30dc4e6a45f2f1768354531e6613c0b58c1f0ec5e73c2cb3eeb0787251bc17eec1eae8f98fd8174155f39c65c1080dfe6973ffc3db9512467e0826f34c7cbd219dd1eb1044de9d6176870396a044a442ccae627ba3cb9bf7171d56a40432a66fc89b11ff2f62ac8d7c295bc152476dee1716420f3157e3cc00fd35b7e7253151a15db7bfed72175ecdb6428a72697c900a4cea694149c57adba015ceef10819a8fa59e3293909503f9853fd2ffc5674525746e8d14b6e26522f3957d19a073409463c2d96eac2de71384428b6f6dddaaad1f59cd64fdd61ce734946c95d25d919aa57547a99837907fbd964159822f647470dd433f68ea6ae7714becbdc9a18fe599f58ed92ed1ede9c04164a2fd80930aed9a5c36359bcbb29e0444c8d87d5ed3171110d2efc7473f9c343521229b2058b906783c0dd6059d868603771e0de15eec3110181af27592d441ba9362c9767d770e298fa3c4bf380562534cc46d6b59eb14d7fc6fae3785877e15e6da9b1f3ae39f42a358af4c5d63b5e3e94d74d272a4f6c20f8c361937e3aba0436cc31a1fd82bceca79a56d97fb88b0123df23ed720be8760f0ac413a60e0b08dd1c4a28173f252399695c95873073cc1d5e00c4de541a1cae047a6f73111e353548831f2dbe20e1c998e11a18ecc95a6758726c28ae7869ad6fb9505eacfa81fea8e7a7b6f87a7c5770d8cec15574872f34e6b4e8056be9c1cb326d973e35aac942dbe542e627f145b84e2c239eb2be9d2f22e28e4233ec2e9c7c1ce2d866bd76d2c1f1289ccd85da44e94750f30bf9e2563e82b6f004e5d5e72625e7ed37e905128cff9171f0f1db6085fb5bf91aac67ab09f841eeec6100cda618cb132222aec59ed44cf645bc299359020a1f7936279110441b815bd3f3138ae85803a92787f41f65f8b2f6f3661598130d40a0fa42a70d92fcaca9f2206c9b47ef4b990204d2f3b958aac7ca022b6c83f34c5b3de19b423530bea336faf9602dc079b899b73ee82b57f0c245ab7838b8880e333fec43cc0572f4f77b2aeb747bea18bf8deb3c5571b76c3112e6c812689e5efdcd48e6a7ca75095fc60a7d38df7e0860ef42b9b0b01fc323c9ed94a1d5fcf9044c918afd15b6f5d793935777cf9772bb58fb1f422bae4fb23b8a51fea6fbb94d668b8e417e75919a5ef931f6eeec2d2091ccfce5390348a09e5a86fdd94f1d77861eb3cef86236a6adb87ab83ee3dbbfaeb9b27670b38c2bdc51f5c7010bb7de7c0962b08558164299b84ae8678f4a9fa414f0e141167a4afefb22cb4e95d1eb0b64c23648741c58624a43c83d831a836d0f691bb9d36a50d12934f5ce246e1d8b4382e55a63913076cc9aabec75ef97c05d9a789af9ddcf0946792495f25fdf72a7ac2d6e9b313c40a4fdf9343d78ffa79bddb154d9ac73d36dab32dea1612fd492a7375e9a737532c46a2b754b173e047777e605ca261a839d175ad16b493b0bd704fb3382233f997dc8dfb49f55e86c9bc012c728f481ac47eed9a446a9871f77dd34f3eb0165ffb01fbb750bf46c43f3132b18c80f3fb288e0b7faed3f60b2afeee0dcbaf1ae33b4c1ac3afaf28bb621c6e44271bbafb8a0cf279b481874204a0cb28631236fa050cab13bb12b9e64051e431d4a6aeb525fba8ce0e5676b7cceceb8d9a0cd976c80316f695b342a23787685981623634f1a19f68b3419bd47be50dc3dd867585a24da4f07e73230ab187465030426c5e07c721beffb4b9cd8af20d7c3c47f67a9f60de7652574c480bafd528c7a17b72c8469d0ea2420ca2e9c82797a2447f4f2c21d7ffd8fb04ccfe431d95a2094ee7b8f5fae98571de09a9b394a7dd9cd8e2db334ae2f24681b5fd924fe0c5162f9ca0831e7de9a7d12e1395a1a5c4f54fbb805092d3884d9fde0c4d9941c168db6dd4abfeb536f46fcdf65b32af2081e88f135ef2f004c14a2e8b5d2001c2c798dceab20dd5410de1fbe7af529530253f49f3e8086f6434e58472f72c070c3dc447006eeb13d4a282e23f7ab98a562edca3911c836a6775974876477af28cd952da0e6d2d21d3bd5d710b2aa3b721e3062a98c0d1423d1b83a51cd3f7665f810cee1679ca9a038d994704d2135d997e3eac1ea893df300caee5caa40cb8af6c85ccb8995e6db79256fbc9cdca55a6c868a0554089d58ac52c1c6980878c3167fdecc74ab1ce6c3eba6b828cc42abfa0fdba0bc0295e897791544548baa95a4513f37c49912ff688c5f8b5073feb07bb798f487f887019ef6ed5428775e0e3b169cde2326a7335623ec15c3993ed055472d55c335f413f84b510cfcc924782c9dbbd8f510e6b495e8509768dcaeec87943435f74c41e702fd895437eae152ba5d25089322b7b35dc290260a50f501b404da3384f2c30cd76c5cc945ab2b8d40202aa3f54f143b8c54433079b64cd375af591d284443445e5c68a1e58419ca94b64599c3a6baeb7c96bae4e5f562c34336be242653a946af0e649a0dd210561813a16215e1db87cc5f76451f0dfb611f71a8cffc98e6c7c7aa35ac6313a3d6011843fae20b26b348dd61389654668ced4809e9c5f8b80f4084abe7963fb0c851875fd324c31c88bc8b0568f988939065f07b1bc2c0c82275e381c522c3136fdfff36b87043934fcfda58bce231116daf9f1ac9cbe162d14b2a17bae2e8b793bf6dc063902e625d1c0fb19f8b4ee1118c4d51b35e48bd431ed752fc1eb5eb12af19e5e1dcd5335aace1c3311aa280da7664acf94e35f29f7994860fce6e3f204d4ee1a9e071928e3714ac64f70d9ad68617e71432df20b50a5c8c8e5f4d45e7cdf427f7c9303665f54c03ced8e598276aa41b9a3c56e976190be95554802802a87c1426363faad53ac02b8222d197da698f16c4c8a3749cbdee7188926a5df7831c57905d785cc22e6c92618a5546b420fd6efaab78f1b602be6f2b92dd64abf36e0b06e8e222861e2cd8636a877ec1135289c38cadff2bf7d2bdcce6eedba2abd4ddd58a3b7802f036bdf00aa10ba138133f0f2a36615975954d90e311bbd9fe5bc5e77d0ccb1ae41cc35f03ce3897d7283b9b4f2a2d86cbf0e322b4fca74cb33e584fd973c7fd5e80cc196a44f7d8ef402294aff0d8cd35b5c0ce3318f051eae35db88ef6abaf150b4d10de5049ad9cd0e4004dcad4e06c68ee7cc3de0debbb61d61e8dcef6af0661021eca08cd9705428c57dff1307202803c0c950aeb4077f860e0c6c1c04c9473843dcf81e9385c4d9c032f3257d2c717915465d1e0a45062e6dc8be927fb2938cf5bd82e6d877f5a52a531c4d26abc06a8957aa3cbec4958d5775bbdbf8226424e1205faca33f8bdf98d6e2315085fa86597982f032656e3e427c462e9f24f16c64672c9c5d11886d3b9d5e6c38fa05dc8880d139443ce51cc70a73b8de83b0311df9a6f4d6ee65f5505e4bf57d70e7333f21e5020036b3e05bb62b681991c6a6143df7d2840b4fb0f5d333c3d4c0ef682fe4d321532a4725d3fd1755de64ca1b5b835930ab1b93f431799333f8e6e6f0cc2f563dc40472c4670255a462d86de5f272981b04a5df874c279af6450f2be72c745eccf47608e18904cf31f4b1f2bad053d6393583e3a6f03b5ccef4ff6a0cad716701112028d25f2b3b6c1a6238a12d14e2e0ddde15e006b09a7956aae3bb929639ab68c0358504670059bec459cc40551cf832ca7d7d09637f4203c78302099b5a832546cf71fbf7de35837823335d31c45693df0df75b6840d272f2ec53b3f3b3b2b0b41da63568a6ac7166f0341d466cd94770d8b3790dcb0fb6be544104825ef89e3cfae457f7d6f188d07e843298eb1ea38d7977cdd0b8d848ea87ab07cf2172474db609cefe86e88040b9a0aa290e592d02f135f4d21346377362b04f89427ac493d8a63e237c87ebf146f488d5cc028262b802f47a29d969b8c8ef72be61fbd010c98d4a1636a5bfcec336e1affef711c29ab54d01482dbcc4a931d5e64d9280a77476a2a8255255794870eff744c2efe4839a1f7909fe98f62e49afda989dc170beb4661a594be4e117b29eabfda2db6d5ea62fc008f6b7f5c4935223b79ab57011290405e45e553456bfab20cb8289d353d215587f1ff8e1f1dc148d43291c1f2ae93f12e567d64a0c1e5dbb0273e0096928e9f13b8b829b8325bb184a6661f7f9ca39838cd88176622f925377509bbae9ca5a9bdf62aa0d9fad4ddd356321c0fd4e8938762a4ad472609efa1072df463a363b87c9f76cdce1e35965264acc4d2d653884f28a44c795b31d56f024cf26b94a109fe4504c9738897cdf2f63cdbc80c84b04046d0bcd125805043426d85810c17d287f4ae1ec85ac9a531b5f865467602b00e18896184e414e02459afd549706ae7e1b1f06f82a187ede5727e709ffbe59d8d1f55540fde06e7e1e6cf3b017e16144892aa6bfb2ca101d729ee71938fddc920cd973ae91eeeda36d353323676e60e602e7f1f71c69d7fc7f1279b73f2a66d5345a73e11f71cc11f0e94f836d237a1f9cfadd5d5fbe2bd62413170da150830158c4a57053962ee558fda9d83d3668e9ea00843b10f46cd360aac8c4a8a96f41a75ca6a8f21a296904330289648c30c1a5176777862b36e4d6cf84e04a4e9ee0ef59b6cb6a91b57e62d524be6e39f224296ba7b7dc179f339ccf3b86fb3ce48df2cac05eb83830b89af571317c28c2faffa605c1d3c58fe626d8b136f59cbe04cc83698a751aceae3bc3c6ecd2414a692f816658d82b1542c0d6efbc15797f06eba7f19d29ff30252c8b14b903700fa0415295c36ae25653b537ef58d3b7b0573ae517af9261dda0acc40d8a10629879b188939baa66f27ea3021d2eb3f76f41d268f0b85f88681a46a96ad1ae207efc76d6adf9faab7cc4a845aaf56fa920318b8fb741b8c0a6ef5e145a6cde2bc095dea3e4212e5ae8025bc959a6ab8775581ebe7491a416581969430bd11acb7edce564cec059ed2003703a523b24313a7b323f9a80627ad7f5ffcd4a8eb71d377f3759d62955aa36695af9133f9a8eaf1bedeaaed4ea38b8b7b9266af70f1d94bdc3e82d27b99e8ac246eeaac89de9e2ecc926255a80f851371fd6802b807de7d041b59a536f575fdfc3b770c9da522253dc86f745b7436a931dc023a064ee0d59baaa8cb25894220f328b15f81dbead1b0ab6ea11cf5f0afbe1b7db39675033ca0801fde6d6075aa7c5d59d558f4c60b4368bced92c0403a6b3c063eb65198a5bddfeab017ec79a78e83ad62fc9d83a454a622174a4a0dab230b4f8d680706c42007dcbd58c158b4ba5a438afe578024aa25116dcedeb93c3b131c8ccbbd1491c32425363f5a39fe13f87944d92dc998b347f171e604ea98498ac04ec2bd3f84bd8fdde1589fe1af146fb047e54680a7e9dc407857a3982e2b96ebe289760f04fc1a62b2ff09bb5505ae4c2f982e4f0393b71325aa5c01f2833c258de90db4d30efa4ac162767aaee7acbed393f5c6cae9b177abccc010bbbe3b9a373513ceb7919acd708219473a50fd08ca07bb92d0b3b451bb352ffe86c6b9e104fb9a3d5c6ddaa1a86b3ef4f2d577aab52cf9f0c28db643fe2be36b0491b6e85ac3e3ed777d8972bc720cafb196fecb3cb87ca6b822e38644aefb20be1566593921526519a38d0447ce9767cb9b8bff4a150f02f47100745b3421008c6a5c552a853a2ae5fdb5a3f485dd60bc4e2ab99b605aa09041fad59e117efd0039227a5939fd3234dc85455aa1888bd1e74375a05619f53e2912a1ef930ed078b12e98d6976073c47892fe8a92512f86d19ddc831c11553ea221d62d33b62defa8ab6629e85883ae177ad57d3c1098feb45d97f5f712d50f973cca1bd00abb9dd618b221693bcbb5adb0a6d854ff751050c0bdf25e2e2b0d358de5345bf7d939080ed35c944cfacfd50d89c9bfb421dbe532e688759509a921677485936ab6e32d07ce58f05dcab38de96d4d4b55817a4c39453f92875f27b73f389b34d3e02980f6dc79d7f93ce0a928d3db9533af688e375881044374284b634854580cb4f15a45e80a6a310efb78dc574e4192ac257de9117985256fa39a3b3d56603ce1fe376ffe94d32c3373a6ecd5a5ad2e56ad2a3be6a107ebcf0e73ba26daa3c3dc8b542ed193eb5beb8680dcebbf2a15adeb8ac2e50b9c0c6a29120e719f5d9159c3dd9ae70c1814df75b1954b834fd36739697939d33b04c24b0aa5bb724385b6b2df78b1d9092dcb7b97cda516bdd748216474768602e349fc456ddf76edda9156731e2fb3caa792ed81b37f5f8b7d01af0f7cee252393eb5ce42be3faf0ef37e6163aa335bf692cf83c024ffde7e8438d87f394bb663ec003edf23bccc42f736a397d2ff95d1bb6e14b9eafb9153735dbf453b93f74ea1db2fbe6344437c10f49fdb856f2df15a851fed10a3d5f85ec0a89c0fb06dfc39ecb0aa5531582e65d1367a113e96d8b89889dcfaf49b2f0fe09c2ba902b2f2bafdba7814d6b728b7eb511e1dc7e999c097e131d1042053befa424b1f3f6d998000408c9eb7f9f60c130098abbbb43fe2d7b3559c5533bfb24d7f7093ba44910d801c3dcd4333794de899c75d7c853ee6d9c85e387179a6ecae86b0936e38759c8641d2c0e0282e43fd76a72f2752cf658077f6b0ea97c65ff80b8ab589f2ad7b0add87fe7569da48660b3c04d2063a5516b06286688ac6300d20dff8b950c82305ca5f160d32733c66b4c6be20224d5c8a8814dbaed61e651a2de6c182ee405b121cf5f8e687a1812caa482fd2742deaf8c6265be70c5cdcd9132b53af1a9ee93addf9a4a06d3d5c1770e80b3b06866c12c3749c3b00ffca1275c7bfa2cb80e9054e52c4ceecbfb09e6064177700616f7f86a7f3c57d23507ada914df5bdc8193dc188bc161d198d2fffc127a498967c46cc708ebe3b933f32981ad19bb5e1e41b7efb1e2ad33fbea00bf1fb5092988d3dbe7dfead0b98304dbc51a3b3de18954eb4436f35aab477cf73557bc75ec7c1f9a468ee346ab5a70282ab6e2716c9af19dedb83182b295384448e3664f6a58832d490e073c77d5e9e73f277d8f291ac7f4e771703bbf0103c62e4ffc7e224c960dbf259e2af6fcf6ea802fd79113e29d81f11e3ccf3ef5ef6667f7c32ddbadc5ee1e3380a3bef86d7268e528a44a364bd1affba980d1b95675e4064029a1afd62c30f6ae59532e1a5ac9548857f374430adddc7f22ced648e110d94e8258080b6ce593271981477b6a4644b60589aee9e4779a8fbca3951d428be8a9e3fe888cc34e8d2b2ab5a6c2033218204ab7b7aacd956fd631b564168b878b3a5c64302fd87d988c205e15a409db84fa0c2172bcc433aebb5dca2af779fd3f9523cbff68d1cc6a5b8fef9aac70c18aa166ad62d4660bd71774858a08abd2b63602df523ce4e15506c8769da3f482b21e3235f3b6d1a7f4918e3e52400be69e52bed12301dcacdcabd535218c78fb50c199c68d6e29aca940144cfb1e65ed61df3d5bdd1de9f43819dafdd4c9e1411bc817d8413bddf0ec15e01901772e569c44b1cad754257cb31e3257ebc97b12be866f253837e4b18aab8df923c13d8e8e7e9310550dee0c7e2ee13fa336341180043200033562965d8fe475f20788f269e324551f8a3b449d6f1b21490a1ce555a7464231dd781f00780e9d1799077aa9b8947b5394e1b1cace775b57cb9704d4f0de047a03bd0bb1f3827f9bd3e5bd670863da33e6bf1323249089f5f65e4a42e5ec9fb780ffb547bb5a4271b46c4fb57a569026db7c8e4fe7bf36b1e8d60c0f94bfbbc3319504906607b67a9562cce972da63a1514b6529a17e97606008df2824b2e42a124f9684a2bda18d16f9fa3bb85c376819d328b68473b1bdc9154dfebd6a1abe17c0a7fba40b5f10825416645ff7ade27c0663233bb0a52e0f178bc53e1b342046b5289951617c98bbf8e8c95afb53be33fbb3956289111e36dcbc85468f9e8af6adf7cfc67adc17f65c002599df4921df4f4ded44a28f6b5adec8bc7cbdddb985d809306bb9afeb7969ae5e331cf0e35a1f582f4bd89fe69dd4d95676f62e27517ef5004b7f679bf6d86c4e5ad4dca1348526e84171a1177cf91924c1f35248b3c2a150a58637c6eb76340339e9ad60cce9efb6a25c0ead62933faf709ac1faaa5d1ac6ea22d2aeae4edbd0b82c1b262e2079874bb202c0bc376a7ba2f2e984a82ff101abc74a3ef44601d1e5c96b3d84b227e48328ce28bb38a21eeab947ee6fcb84021c34e766e833ef05c7b03b2a62f024dda03f7e7bb7f7642f2420609f7193575a158b3b7616dc6be33b783e8ed804bd023504b607782b2258ddbd10637ff9a9612b5bb25c90492802550417b49072b58a37ff6b6aeb0a0759f5f6df7a1c5654739291f894fa70ebf9d9a3500551c41cdcb8f7745e3e93e5d8b06292aca79b898566ee2313b4b29f07cc3d09d621052f1fa3e048948a283df1f4b7955f0abf22a3de89e70e3c35fa3ad0c606dd1fcdc3e4c6b9434eecf449cf933c4c2e4f881965081522ddaba9b74e901da4045dc750b58c4d5024f445010042a39ab1f94e961dcb5c9337e5a1007ca20a24962ec2092a8a76478357ab3e8365ffa9c0d8bc529a0567be6d599d408adfba28d0749cb9e10086acb69fdc0d20928dd91a0dfb354c869fbb0fa664438fa0ecb5fff99485051c11024f2c8011ba06a7b868231762d089407df03fca6d18a45f69dae9d958ed84a760b4abccd362706bc918cde0e64f2e2344cd18bfe5ce4224d680360825f4e2e88ea6d4683655d7829e8c8a9fb5d7a569d18260cbf7968bc8f45efd2e13aa91025f66d70c719b6eecc1bf81509affcfd1aa5333141867557c403ad614020cdd1828a234d1c4d944661cc1a6a1e705d4bd920b657ac4445759ff5dc4a6921d069715927375fdd5e8ccda57208ab79d39f545231b782560bc2719f1b87bda5517ad6e8241c0a72f0e5318504b976d8159de24167e898783589b1e0f568b21753c8bcd1688e6e2b3e82b1c41d2f87e6c642bb74823b473d3c0ffe03916fddca41f692954a97f6392f40d34e2e715c32eadac423b28f6f3c8af7e4e7b3a8fe9180b1d7d718b5b8e39c951c0f439e825c613bb49e62b56bd90fc6cc2a6eaf5bd7cd4207ad7efb6862e98be1d8f837113b8b98533485a6c58e039ba4594c44e0d61401cecbca149bbd3d33c1487ffaf9c732fbbf54568d339b859198e784277eb9ce5449f3fd29dd9ddcf1cbcc0893b502bb7a49cce8c5c8aefea1f62723d17070d35cd4f55a45c3143b1ebdbfe543d90a9ae9937d42f50d3e09210eaf748fcbc9af4e03cc30357edd5ffa86c3aa0a1c15b271434c3d00c7930f87f30c05aac1318db4d406ca42c968ac0db6b53f98ff316cced7f62b82326d00f9707a43ec88c94452d1df4dbd2d77c3b1ee492467e7196ca6d748896f87e6f87998d49514536b94333dbc4b3ce98334db530a9dcbb4b9818274f5292b0a0a1f3da600e844bf74b880614ba7270a212e0b177455a43ebd84d72f8ad84fc9a79144c29f59c47c5edad403b107e006c4d07b442d72222df713b80b47d4b7738b8b11ab2f284c1154530e4d016b186e858bffee01ff972b94a6055e171433955b1cb9427e42f69a3067dbd72b9e4408c2a4b6a4a5e18cbf0c93b0799e869d7ad337b91710dc001d5ab5bda11d43838338fdf4f96647a8304b82f000f64aa1d110e3bc28f11624ef6e82bfc5d0f9b312278998a8c9caeb0b527c77c2f889922bf55289d8776f653b33595d1abbaad9517a5f7e16c7fb388ecca738e4c561ed383b0d3ec11e51ae553b2696106fdb10acdda278c40673ebab2ebbd151f27c886598554b906704f545907e6cb45b2c102af59971df0a3499f2a5ee24df14751e40c7cb5b22876ecc1d6b67329e947bdee17fc0a573e04dfcc5fb22032a742720d29cb19f1eed5d1e8325618aeea06d16fd351ee88a1fce637c9ba6e1b3dcd7dd8666d75a777419a59a209fc75fce353e4e68861fb36280da489f8411133fb152be1243cd9b6b318d325383f8b7d58c8dd87ad1ffd6b426f06d7efca54c29a3fd7fbe6bf9f1b5349029882c44a95436e54169e62659a0e480e338656b0996041be9cb613a7d2e15d143608917fa6084c81a24e4e02047b19c50f4f7371002bd829b6f69b916dfdf667eae545b8dc0ca58e3f14ae41ac2463c5b92db87558e536baa4018d8a8da71666a37a36bc1f74fa835fb5ac402f9641e5a6bf6707aa569facdd283fc370ecec31c83cb3fcb5913285c3ebf75eddf02d0a3b8e199288fede1f6673373b118c0af519f3e822f4992368eed9a7f7a31eb3fdf4675deb1f474fed745474b02fb7a30dd2c0261c223d2252ffb316a13ba368ef8647030cefbff35c4be2d56e5032fe9b303523b497cf6b48caa37c4221b7c88d66d20132e098c25434561ac2ab889f7d1366a9ecde37ecf6186466acdcb7c672a01c1417bae3f0991f05594a64bdc9b687c7eed37ad3dcb4af4390f114212f78dd79a4d6da71a861281b6d3d7dddb66cf9d1a07e3ae9837cd450336b39dd8119b23588b7e01ad7d8f76d0726e84d025a38f18d29d81f3bf687a5c92ad6063b44bc74c1dd238bd7d7ab38fa9db4e09edad3dc99ec650d48e0ea9ebde80130095e88459e9b5a2f193b61ecd5bc08141806a513607b6ab5c59ee91b08ca1aedb79fcd37b5cf80e173bf4c58336e8573451ef8f365c55669456547c4eb38c6b96c7cf5f7a8c8f848ceb769c93e592763f2313fe0d2283545ac518c2425a5a9940c4917e7f11d114a1bdce6947b929c6ba4b5ae2b6b592f59f024c0ab8f058e1d11616823e991b51df0a1a6d57570789260b5a60fe6c08bbde56d8f6092605db4ef9857201ca70f069d19b8ae4701f91a11a070814d97e3105e6ec50007ea279910e0e869769d18724b0027384345864be296c90ca1ecb3ec73ea6c777b2836fd0415e027dfe54aadffff63b461e4de1f9247a5600371f8496316c1b9781fcf418a6944056f8fa014bc332bb9938d5fa89f4b19f7cfafa49fc6ff0b0ea485c59b05a3c7931a855480be9c50df44b0e78799b398926cb9901f3834ddfed0106e37eec47826eb77c4c23339cb6477a6146e78026eeb23809a81e1214909f7d4b3baccc1df1dd7ec6274e5af08f48c82b43839108114d5cd6d961acf22838d183c736c834770d4dab66b00111b07966ef9a1d30569396fd7bcebc2730636711acc22bef3c32b4739ddd68912521091eb1f7c925bad5b68b5d49f1b274c0403ef4d1986fa974f91c923c47471dad1e6d40bb438586930269f112533117e2119fd482be346c988aea353a081cd22a235ea13862560a38276b660406ba6ed91ca6613dec85abe94992bd8f04c18b28edaf025087b57c45d54a2d47e0e66216dd266910ea85b0d581d9551e182c86e2abd3bafdb9470e9eaaa7d7c053426705d2ab7bcb0a4b51ead948d95eb80618368ba68b24abefadbfa76c0c65de93cadf52cc78ff79215b2f9e03bd053641d115521eb006b7d59a291f1df581e879e2a2358b12ab263e70aabc15b6424ee5f3accf04fd2202f1f8a857d57deceeb251432e0fc121a70ae2c31f6efc1242810aa13e987bd46d13372f3620e6c385aafd278705484048fc8fdba99f1c80f119bf8044c55eeebd2531ad138469adf3e2a1cfc53fb87bf9a781bab320baa3db591bb56e8644888b7c80753b02b8aa9192bf79cbca887347f9280fa3d44647b3a23e1eb7302bc6adebcc4198fd36ca0d813d6c2e067ee689ba328113b49156c9ec9a98de1b7ab4d1dcfacb6d70b33f3c9dc58838d194413fa4656f86570b6bbf644ec34106ff63c25fd686edd965cd555607cacecaca7d3452ee498d75819032ee3d26342631cf281a753d33cd357c885d4d6db02c10f70e7a8417fb0af4f793c49ba1363485c3df3ed550476c02fdd8d1a6324a8223b07fd7b338e832fa4f636e542d1c987cb96a42b5134b6cea3d8ce348b2f43668d795e620a42b5faa797581c6087e5f98bb52a04f2b246d4b33c0d43c588228815daf20828fd548c667f7b847ec4301191a807d5cd1148904fb08aca3188e2b85e270b1898175f64ad825cc9f558025e98b86ce390924e6d19288211b6c35d34ac8e28d7ef769baf20871550be0609b969fefee0ddb66196f3fa22d39ca7ace4845c56fa91f1cd0f9a069d67219230a7aaa065e4cad2f36d39ae0a03e3126a3b7a2646e847c63a5fa7eab7252c1ce244dcfb02b8bce36820d7f9d734ed8e9568789948fbb5b0e1c21baba6a68eb37ffd4dba0fb1acc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">本篇笔记为刷LeetCode过程中，一些需要二刷的题目情况记录</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记12——java多线程（更新中）</title>
    <link href="https://blog.slks.xyz/2022/02/03/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B012%E2%80%94java%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>https://blog.slks.xyz/2022/02/03/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B012%E2%80%94java%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-02-03T02:54:19.000Z</published>
    <updated>2022-02-02T04:56:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1304521607217185</p>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于多线程相关的内容。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——连续子串问题</title>
    <link href="https://blog.slks.xyz/2022/02/02/LeetCode%E7%AC%94%E8%AE%B0/%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/"/>
    <id>https://blog.slks.xyz/2022/02/02/LeetCode%E7%AC%94%E8%AE%B0/%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/</id>
    <published>2022-02-02T11:52:19.000Z</published>
    <updated>2022-02-05T08:13:07.862Z</updated>
    
    <content type="html"><![CDATA[<h4 id="注意连续子串问题较为常见的两个技巧为滑动窗口法与前缀和滑动窗口法解相关子数组问题一般而言需要数组内元素都为正整数如果数组内元素存在负数的话滑动窗口是无法处理相关的负数样例的需要采用前缀和的技巧进行求解">注意：连续子串问题较为常见的两个技巧为：滑动窗口法与前缀和，滑动窗口法解相关子数组问题，一般而言需要数组内元素都为正整数，如果数组内元素存在负数的话，滑动窗口是无法处理相关的负数样例的，需要采用前缀和的技巧进行求解。</h4><h3 id="一剑指-offer-ii-008.-和大于等于-target-的最短子数组">一、<a href="https://leetcode-cn.com/problems/2VG8Kg/">剑指 Offer II 008. 和大于等于 target 的最短子数组</a></h3><p><strong>例题1描述：</strong></p><p>​ 给定一个含有 n 个正整数的数组和一个正整数 target 。</p><p>​ 找出该数组中满足其和 ≥ target 的长度最小的连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p><ul><li><p>示例 1：</p><ul><li>输入：target = 7, nums = [2,3,1,2,4,3]</li><li>输出：2</li><li>解释：子数组 [4,3] 是该条件下的长度最小的子数组。</li></ul></li><li><p>示例 2：</p><ul><li>输入：target = 4, nums = [1,4,4]</li><li>输出：1</li></ul></li><li><p>示例 3：</p><ul><li>输入：target = 11, nums = [1,1,1,1,1,1,1,1]</li><li>输出：0</li></ul></li><li><p>提示：</p><p>1 &lt;= target &lt;= 10^9 1 &lt;= nums.length &lt;= 10^5 1 &lt;= nums[i] &lt;= 10^5</p></li></ul><p><strong>例题1详解</strong>：</p><p>​ 本题在做的时候有三种解决方案:</p><p>​ 第一种就是最为简单的先计算前缀和，然后暴力开始从len = 1 到 len = nums.length 进行搜索，找到符合条件的len即返回.</p><p>​ 第二种,在第一种的基础上进行改进,将暴力搜索改为二分索,left=1,right=nums.length, len=(left + right)/2,时间复杂度能大大降低。</p><p>​ 第三种就是本文着重记录的<strong>滑动窗口</strong>解决方案：</p><p>​ 可以使用滑窗的题目一般题目中都会有明确的“<strong>连续子数组</strong>”、“<strong>连续子串</strong>”等关键字，另外可能会附带<strong>最大</strong>、<strong>最小</strong>的限定词进行补充。</p><p>​ 那么遇到此类题目，往往可以分为以下几步进行求解：</p><ul><li>初始化窗口左边界为0，右边界可以为0，也可以根据题意固定大小。</li><li>我们需要初始化一个ret的返回值，默认为0或者根据题意默认为最大值。</li><li>窗口的大小需要根据题目条件进行调整<ul><li>最大连续...尽量扩张右边界，直到不满足题意再收缩左边界</li><li>最小连续...尽量缩小左边界，直到不满足题意再扩大右边界</li></ul></li><li>在执行3操作的过程中，不断与ret进行比较</li><li>最终返回ret结果即可。</li></ul><p>根据上述指南，我们可以书写代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSubArrayLen</span><span class="params">(<span class="keyword">int</span> target, vector&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">1e7</span>;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            total += nums[right];</span><br><span class="line">            <span class="keyword">while</span>(total &gt;= target)&#123;</span><br><span class="line">                <span class="keyword">if</span>(right - left + <span class="number">1</span> &lt; len) len = right - left + <span class="number">1</span>;</span><br><span class="line">                total-= nums[left++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len == <span class="number">1e7</span>) len = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="二剑指-offer-ii-009-乘积小于-k-的子数组">二、<a href="https://leetcode-cn.com/problems/ZVAVXX/">剑指 Offer II 009 乘积小于 K 的子数组</a></h3><p><strong>例题2描述：</strong></p><p>​ 给定一个<strong>正整数数组 <code>nums</code></strong>和整数 <code>k</code> ，请找出该数组内乘积小于 <code>k</code> 的连续的子数组的个数。</p><ul><li><p>示例 1:</p><ul><li>输入: nums = [10,5,2,6], k = 100</li><li>输出: 8</li><li>解释: 8 个乘积小于 100 的子数组分别为: [10], [5], [2], [6], [10,5], [5,2], [2,6], [5,2,6]。需要注意的是 [10,5,2] 并不是乘积小于100的子数组。</li></ul></li><li><p>示例 2:</p><ul><li>输入: nums = [1,2,3], k = 0</li><li>输出: 0</li></ul></li><li><p>提示:</p><p>1 &lt;= nums.length &lt;= 3 * 10^4 1 &lt;= nums[i] &lt;= 1000 0 &lt;= k &lt;= 10^6</p></li></ul><p><strong>例题2解析</strong>：</p><p>​ 按照上述例题1的思想，简单来向，我们发现此题目求解的不是某个长度最小或长度最大的值，而是所有的连续子数组的个数，乍一看无法按照先前的内容进行求解，但其实我们可以发现：</p><p>​ 窗口每次移动后，ret都可以增加 <strong>right - left + 1</strong>个子数组。具体而言是什么意思呢？</p><p>​ 比如某次遍历符合题意的子数组为 ABCX，那么在该条件下符合条件的有X，CX，BCX，ABCX共四个（可以进行多个例子，发现个数符合right-left+1） ​ 我们可能会有疑问：AB，BC也算，为什么不算进去？ ​ 记住一点<strong>我们是以最右边的X为必要条件，进行计算符合条件的子数组，否则会出现重复的！</strong> ​ 比如在X为右侧边界时（ABCX），我们把BC算进去了，可是我们在C为最右侧时（ABC），BC已经出现过，我们重复加了BC这个子数组两次！</p><p>具体的代码应当如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numSubarrayProductLessThanK</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> right = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> product = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(;right&lt;nums.<span class="built_in">size</span>();right++)&#123;</span><br><span class="line">            product = product * nums[right];</span><br><span class="line">            <span class="comment">//下面加了一个条件：left&lt;=right是因为，如果不加这个条件，当k=0的时候，会一直陷入该死循环中无法出循环。</span></span><br><span class="line">            <span class="keyword">while</span>(left &lt;= right &amp;&amp; product &gt;= k)&#123;</span><br><span class="line">                product = product / nums[left];</span><br><span class="line">                left++;</span><br><span class="line">            &#125;</span><br><span class="line">            count += right - left + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="三剑指-offer-ii-010.-和为-k-的子数组">三、<a href="https://leetcode-cn.com/problems/ZVAVXX/">剑指 Offer II 010. 和为 k 的子数组</a></h3><p><strong>例题3描述：</strong></p><p>​ 给定一个<strong>整数数组</strong>和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><ul><li><p>示例 1:</p><ul><li>``` 输入:nums = [1,1,1], k = 2 输出: 2 解释: 此题 [1,1] 与 [1,1] 为两种不同的情况 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 示例 2:</span><br><span class="line"></span><br><span class="line">  - ```</span><br><span class="line">    输入:nums = [1,2,3], k = 3</span><br><span class="line">    输出: 2</span><br></pre></td></tr></table></figure></li></ul></li><li><p>提示:</p><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul></li></ul><p><strong>例题3解析</strong>：</p><p>​ 非常需要注意的是：此题中给出的条件是整数数组，而非正整数，故而滑动窗口没法使用，因为滑动窗口是需要你能保证，当右边界扩充时，和必增大，左边界收缩时和必减小，但是如果数组中存在负数，那么我们无法保证。此时需要应用前缀和。</p><p>​ <strong>以前我使用前缀和，都是通过先把所有的前缀和计算得到，然后存在Vector<int>中，然后再去根据前缀和，遍历处理问题，但这样人工遍历其复杂度为N^2</strong>，就会导致较高的时间复杂度，并且容易重复计算。那么应当如何去进行处理会比较好呢？</p><p>​ 我们<strong>一般可以采用Hash表来存储前缀和，</strong>在C++中可以使用速度较快的unordered_map，其底层就是用hash表进行实现。&lt;key,value&gt;，其存储的key代表前缀和的值，value代表该前缀和出现的次数。<strong>（只有在数组内存在负数的时候，才会有前缀和出现多次的情况）</strong></p><p>​ 然后，在上述例题中，应当在计算前缀和的每一步中，就去计算，到该元素为止，以该元素为结尾的子序列，有没有符合和为k 这一条件的，不然容易重复计算。</p><p>​ 同时，我们需要注意，要在开始时就往hash表中，插入(0,1)这一对元素，以处理边界条件。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//利用哈希表存储 计算前缀和</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; sums;</span><br><span class="line">        sums[<span class="number">0</span>] = <span class="number">1</span>;  <span class="comment">// sum = 0 , 出现了1次</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum = sum + nums[i];</span><br><span class="line">            <span class="comment">//判断以该元素为结尾的子序列，有没有符合和为k 这一条件的</span></span><br><span class="line">            <span class="keyword">if</span>(sums.<span class="built_in">find</span>(sum-k) != sums.<span class="built_in">end</span>()) count+= sums[sum-k];</span><br><span class="line"><span class="comment">//将该位置的前缀和也存入hash表中，以供后续计算参考</span></span><br><span class="line">            <span class="keyword">if</span>(sums.<span class="built_in">find</span>(sum) != sums.<span class="built_in">end</span>()) sums[sum]++;</span><br><span class="line">            <span class="keyword">else</span> sums[sum] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">利用滑动窗口与前缀和等技巧解连续子串相关问题详解（包含 剑指 Offer II 008. 和大于等于 target 的最短子数组、剑指 Offer II 009 乘积小于 K 的子数组、剑指 Offer II 010. 和为 k 的子数组）</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode 算法解题Tricks（持续更新）</title>
    <link href="https://blog.slks.xyz/2022/02/02/LeetCode%E7%AC%94%E8%AE%B0/LeetCode%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    <id>https://blog.slks.xyz/2022/02/02/LeetCode%E7%AC%94%E8%AE%B0/LeetCode%E7%AE%97%E6%B3%95%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</id>
    <published>2022-02-02T08:34:19.000Z</published>
    <updated>2022-02-08T12:44:40.190Z</updated>
    
    <content type="html"><![CDATA[<h4 id="涉及二进制计算的题目">1、涉及二进制计算的题目：</h4><p>​ 一些涉及二进制计算，例如让你计算某数字的二进制形式中1的个数，或者直接计算两个二进制数之和的，多多利用<strong>逻辑运算与移位运算能够大幅提高程序运行速度</strong>。</p><h4 id="判断两个字符串是否有同一个字符">2、判断两个字符串是否有同一个字符？</h4><p>​ 已知：字符串中仅有小写字母。</p><p>​ <strong>可以利用一个数字的二进制形式，表示一个字符串中所含有的全部字符</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_02_16_37_25_816.png" /></p><p>​ <strong>然后利用 逻辑运算 &amp; ，来判断，两个字符串之间有没有字符是重合的</strong></p><p>​</p><h4 id="一旦涉及有序数组就可以考虑二分法搜索代替暴力搜索">3、一旦涉及有序数组，就可以考虑二分法搜索代替暴力搜索</h4><h4 id="涉及连续子数组连续子串等关键词">4、涉及连续子数组、连续子串等关键词</h4><p>​ 我们可以采用滑动窗口或前缀和进行问题的求解。见<a href="https://blog.slks.xyz/2022/02/02/LeetCode%E7%AC%94%E8%AE%B0/%E8%BF%9E%E7%BB%AD%E5%AD%90%E4%B8%B2%E7%9B%B8%E5%85%B3%E9%97%AE%E9%A2%98/">连续子串问题</a></p><h4 id="涉及到需要去除重复">5、涉及到需要去除重复：</h4><p>​ 可以考虑使用哈希表进行，如果需要去重的元素是数组或其他复杂的元素，可以考虑将其转换为string后，作为key进行存储。</p><h4 id="反转链表-o1-时间复杂度-利用三个指针迭代反转">6、反转链表 O(1) 时间复杂度 ？ 利用三个指针，迭代反转。</h4><h4 id="变位词加速技巧">7、变位词加速技巧：</h4><p>​ 常用到 Hash表映射。两个字符串中每个字符出现的次数都相同，则称它们互为变位词。如何快速的判定两个词是否是变位词呢？有两种方案：</p><ul><li>当仅需要比较两个变位词时，比较快速的是定义vector<int>(26),然后统计词里面各个英文字母出现的频率，最后比较两个vector是不是一样就可以了。</li><li>如果给了一个字符串数组，要进行分组分类的话，我们可能就需要用到另一种性质：也就是变位词在排序后，会变成相同的词。例如问题如下：</li></ul><p>​ 给定一个字符串数组 <code>strs</code> ，将 <strong>变位词</strong> 组合在一起。 可以按任意顺序返回结果列表。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: strs = [&quot;eat&quot;, &quot;tea&quot;, &quot;tan&quot;, &quot;ate&quot;, &quot;nat&quot;, &quot;bat&quot;]</span><br><span class="line">输出: [[&quot;bat&quot;],[&quot;nat&quot;,&quot;tan&quot;],[&quot;ate&quot;,&quot;eat&quot;,&quot;tea&quot;]]</span><br></pre></td></tr></table></figure><p>​ 我们就可以建立一个Hash表，unordered_map&lt;string,vector<string>&gt; m，key记录排序后的字符串，value记录排序前的原始字符串的集合。这样的话遍历一遍进行归类即可，归结于Hash表的O(1)查找速度，其要比两两比较查找要快。</p><h4 id="堆的应用">8、堆的应用</h4><p>​ 涉及到<strong>最大的K个元素、最小的K个元素、第K大的元素</strong>等关键词，可以考虑使用堆的特性，进行求解。尤其是对于一些动态的数据结构来说，维护一个堆可以大幅降低时间复杂度。</p><h4 id="前缀树的应用">9、前缀树的应用：</h4><p>​ 当题目涉及到字符串寻找前缀，或者是后缀，（即<strong>子串</strong>substr任务），可以采用该数据结构，能够大幅降低算法时间复杂度。</p>]]></content>
    
    
    <summary type="html">本篇笔记为刷LeetCode过程中，对一些题目进行优化的时候进行的些许思考与记录，持续更新</summary>
    
    
    
    <category term="LeetCode算法笔记" scheme="https://blog.slks.xyz/categories/LeetCode%E7%AE%97%E6%B3%95%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记11——java正则表达式</title>
    <link href="https://blog.slks.xyz/2022/02/02/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B011%E2%80%94java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://blog.slks.xyz/2022/02/02/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B011%E2%80%94java%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2022-02-02T01:54:19.000Z</published>
    <updated>2022-02-02T04:56:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1304066130968610</p><h3 id="一什么是正则表达式">一、什么是正则表达式：</h3><p>​ 正则表达式可以用字符串来描述规则，并用来匹配字符串。例如，判断手机号，我们用正则表达式<code>\d&#123;11&#125;</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">isValidMobileNumber</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.matches(<span class="string">&quot;\\d&#123;11&#125;&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 使用正则表达式的好处有哪些？一个正则表达式就是一个描述规则的字符串，所以，只需要编写正确的规则，我们就可以让正则表达式引擎去判断目标字符串是否符合规则。</p><p>​ 正则表达式是用字符串描述的一个匹配规则，使用正则表达式可以快速判断给定的字符串是否符合匹配规则。<strong>Java标准库<code>java.util.regex</code>内建了正则表达式引擎。</strong></p><h3 id="二匹配规则">二、匹配规则：</h3><p>正则表达式的匹配规则是从左到右按规则匹配。</p><h4 id="精确匹配">1、精确匹配：</h4><p>​ 对于正则表达式<code>abc</code>来说，它只能精确地匹配字符串<code>"abc"</code>，不能匹配<code>"ab"</code>，<code>"Abc"</code>，<code>"abcd"</code>等其他任何字符串。</p><p>​ 如果正则表达式有特殊字符，那就需要用<code>\</code>转义。例如，正则表达式<code>a\&amp;c</code>，其中<code>\&amp;</code>是用来匹配特殊字符<code>&amp;</code>的，它能精确匹配字符串<code>"a&amp;c"</code>，但不能匹配<code>"ac"</code>、<code>"a-c"</code>、<code>"a&amp;&amp;c"</code>等。</p><p>​ 如果想匹配非ASCII字符，例如中文，那就用<code>\u####</code>的十六进制表示，例如：<code>a\u548cc</code>匹配字符串<code>"a和c"</code>，中文字符<code>和</code>的Unicode编码是<code>548c</code>。</p><h4 id="模糊匹配.">2、模糊匹配：(.)</h4><p>​ 正则表达式<code>a.c</code>中间的<code>.</code>可以匹配一个任意字符</p><p>​ <code>.</code>匹配一个字符且仅限一个字符</p><h4 id="匹配数字">3、匹配数字：（</h4><p>​ 如果我们只想匹配<code>0</code>~<code>9</code>这样的数字，可以用<code>\d</code>匹配。例如，正则表达式<code>00\d</code>可以匹配：</p><ul><li><code>"007"</code>，因为<code>\d</code>可以匹配字符<code>7</code>；</li><li><code>"008"</code>，因为<code>\d</code>可以匹配字符<code>8</code>。</li></ul><p>​ 它不能匹配<code>"00A"</code>，<code>"0077"</code>，因为<code>\d</code>仅限单个数字字符。</p><h4 id="匹配常用字符">4、匹配常用字符：()</h4><p>用<code>\w</code>可以匹配一个字母、数字或下划线，w的意思是word。例如，<code>java\w</code>可以匹配：</p><ul><li><code>"javac"</code>，因为<code>\w</code>可以匹配英文字符<code>c</code>；</li><li><code>"java9"</code>，因为<code>\w</code>可以匹配数字字符<code>9</code>；。</li><li><code>"java_"</code>，因为<code>\w</code>可以匹配下划线<code>_</code>。</li></ul><p>因为<code>\w</code>不能匹配<code>#</code>、空格等字符。</p><h4 id="匹配空格字符">5、 匹配空格字符()</h4><p>用<code>\s</code>可以匹配一个空格字符，注意空格字符不但包括空格`<code>，还包括tab字符（在Java中用</code>表示）。例如，<code>a\sc</code>可以匹配：</p><ul><li><code>"a c"</code>，因为<code>\s</code>可以匹配空格字符``；</li><li><code>"a c"</code>，因为<code>\s</code>可以匹配tab字符<code>\t</code>。</li></ul><p>它不能匹配<code>"ac"</code>，<code>"abc"</code>等。</p><h4 id="匹配非数字">6、匹配非数字：（）</h4><p>​ <code>\D</code>匹配一个非数字</p><p>​ 类似的，<code>\W</code>可以匹配<code>\w</code>不能匹配的字符，<code>\S</code>可以匹配<code>\s</code>不能匹配的字符，这几个正好是反着来的。</p><h4 id="重复匹配">7、重复匹配：</h4><ul><li><p>修饰符<code>*</code>可以匹配任意个字符，包括0个字符。我们用<code>A\d*</code>可以匹配：</p><ul><li><p><code>A</code>：因为<code>\d*</code>可以匹配0个数字；</p></li><li><p><code>A0</code>：因为<code>\d*</code>可以匹配1个数字<code>0</code>；</p></li><li><p><code>A380</code>：因为<code>\d*</code>可以匹配多个数字<code>380</code>。</p></li></ul></li><li><p>修饰符<code>+</code>可以匹配至少一个字符。我们用<code>A\d+</code>可以匹配：</p><ul><li><code>A0</code>：因为<code>\d+</code>可以匹配1个数字<code>0</code>；</li><li><code>A380</code>：因为<code>\d+</code>可以匹配多个数字<code>380</code>。</li></ul></li><li><p>修饰符<code>?</code>可以匹配0个或一个字符。我们用<code>A\d?</code>可以匹配：</p><ul><li><code>A</code>：因为<code>\d?</code>可以匹配0个数字；</li><li><code>A0</code>：因为<code>\d?</code>可以匹配1个数字<code>0</code>。</li></ul></li><li><p>用修饰符<code>&#123;n&#125;</code>精确指定n个字符,<code>A\d&#123;3&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3&#125;</code>可以匹配3个数字<code>380</code>。</li></ul></li><li><p>用修饰符<code>&#123;n,m&#125;</code>指定匹配n~m个字符, <code>A\d&#123;3,5&#125;</code>可以精确匹配：</p><ul><li><code>A380</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配3个数字<code>380</code>；</li><li><code>A3800</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配4个数字<code>3800</code>；</li><li><code>A38000</code>：因为<code>\d&#123;3,5&#125;</code>可以匹配5个数字<code>38000</code>。</li></ul></li><li><p>如果没有上限，那么修饰符<code>&#123;n,&#125;</code>就可以匹配至少n个字符。</p></li></ul><h4 id="匹配规则快速查找">8、匹配规则快速查找：</h4><p>单个字符的匹配规则如下：</p><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td><code>A</code></td><td>指定字符</td><td><code>A</code></td></tr><tr class="even"><td><code>\u548c</code></td><td>指定Unicode字符</td><td><code>和</code></td></tr><tr class="odd"><td><code>.</code></td><td>任意字符</td><td><code>a</code>，<code>b</code>，<code>&amp;</code>，<code>0</code></td></tr><tr class="even"><td><code>\d</code></td><td>数字0~9</td><td><code>0</code>~<code>9</code></td></tr><tr class="odd"><td><code>\w</code></td><td>大小写字母，数字和下划线</td><td><code>a</code><sub><code>z</code>，<code>A</code></sub><code>Z</code>，<code>0</code>~<code>9</code>，<code>_</code></td></tr><tr class="even"><td><code>\s</code></td><td>空格、Tab键</td><td>空格，Tab</td></tr><tr class="odd"><td><code>\D</code></td><td>非数字</td><td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr><tr class="even"><td><code>\W</code></td><td>非</td><td><code>&amp;</code>，<code>@</code>，<code>中</code>，……</td></tr><tr class="odd"><td><code>\S</code></td><td>非</td><td><code>a</code>，<code>A</code>，<code>&amp;</code>，<code>_</code>，……</td></tr></tbody></table><p>多个字符的匹配规则如下：</p><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td><code>A*</code></td><td>任意个数字符</td><td>空，<code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr class="even"><td><code>A+</code></td><td>至少1个字符</td><td><code>A</code>，<code>AA</code>，<code>AAA</code>，……</td></tr><tr class="odd"><td><code>A?</code></td><td>0个或1个字符</td><td>空，<code>A</code></td></tr><tr class="even"><td><code>A&#123;3&#125;</code></td><td>指定个数字符</td><td><code>AAA</code></td></tr><tr class="odd"><td><code>A&#123;2,3&#125;</code></td><td>指定范围个数字符</td><td><code>AA</code>，<code>AAA</code></td></tr><tr class="even"><td><code>A&#123;2,&#125;</code></td><td>至少n个字符</td><td><code>AA</code>，<code>AAA</code>，<code>AAAA</code>，……</td></tr><tr class="odd"><td><code>A&#123;0,3&#125;</code></td><td>最多n个字符</td><td>空，<code>A</code>，<code>AA</code>，<code>AAA</code></td></tr></tbody></table><h3 id="三复杂匹配规则">三、复杂匹配规则：</h3><h4 id="匹配开头结尾">1、匹配开头结尾：</h4><p>​ 进行多行匹配时，用<code>^</code>表示开头，<code>$</code>表示结尾。例如，<code>^A\d&#123;3&#125;$</code>，可以匹配<code>"A001"</code>、<code>"A380"</code>。</p><h4 id="匹配指定范围">2、匹配指定范围：</h4><p>​ <strong>使用<code>[...]</code>可以匹配范围内的字符</strong>，例如，<code>[123456789]</code>可以匹配<code>1</code>~<code>9</code>，这样就可以写出上述电话号码的规则：<code>[123456789]\d&#123;6,7&#125;</code>。</p><p>​ 把所有字符全列出来太麻烦，<code>[...]</code>还有一种写法，直接写<code>[1-9]</code>就可以。</p><p>​ <strong>要匹配大小写不限的十六进制数，比如<code>1A2b3c</code>，我们可以这样写：<code>[0-9a-fA-F]</code>，它表示一共可以匹配以下任意范围的字符：</strong></p><ul><li><code>0-9</code>：字符<code>0</code>~<code>9</code>；</li><li><code>a-f</code>：字符<code>a</code>~<code>f</code>；</li><li><code>A-F</code>：字符<code>A</code>~<code>F</code>。</li></ul><p>​ <strong><code>[...]</code>还有一种排除法，即不包含指定范围的字符。假设我们要匹配任意字符，但不包括数字，可以写<code>[^1-9]&#123;3&#125;</code>：</strong></p><ul><li>可以匹配<code>"ABC"</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>可以匹配<code>"A00"</code>，因为不包含字符<code>1</code>~<code>9</code>；</li><li>不能匹配<code>"A01"</code>，因为包含字符<code>1</code>；</li><li>不能匹配<code>"A05"</code>，因为包含字符<code>5</code>。</li></ul><h4 id="或规则匹配">3、或规则匹配：</h4><p>​ 用<code>|</code>连接的两个正则规则是<em>或</em>规则，例如，<code>AB|CD</code>表示可以匹配<code>AB</code>或<code>CD</code>。</p><h4 id="使用括号">4、使用括号:</h4><p>​ 现在我们想要匹配字符串<code>learn java</code>、<code>learn php</code>和<code>learn go</code>怎么办？一个最简单的规则是<code>learn\sjava|learn\sphp|learn\sgo</code>，但是这个规则太复杂了，可以把公共部分提出来，然后用<code>(...)</code>把子规则括起来表示成<code>learn\\s(java|php|go)</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String re = <span class="string">&quot;learn\\s(java|php|go)&quot;</span>;</span><br></pre></td></tr></table></figure><h4 id="规则总结">5、规则总结：</h4><p>复杂匹配规则主要有：</p><table><thead><tr class="header"><th>正则表达式</th><th>规则</th><th>可以匹配</th></tr></thead><tbody><tr class="odd"><td>^</td><td>开头</td><td>字符串开头</td></tr><tr class="even"><td>$</td><td>结尾</td><td>字符串结束</td></tr><tr class="odd"><td>[ABC]</td><td>[…]内任意字符</td><td>A，B，C</td></tr><tr class="even"><td>[A-F0-9xy]</td><td>指定范围的字符</td><td><code>A</code>，……，<code>F</code>，<code>0</code>，……，<code>9</code>，<code>x</code>，<code>y</code></td></tr><tr class="odd"><td>[^A-F]</td><td>指定范围外的任意字符</td><td>非<code>A</code>~<code>F</code></td></tr><tr class="even"><td>AB|CD|EF</td><td>AB或CD或EF</td><td><code>AB</code>，<code>CD</code>，<code>EF</code></td></tr></tbody></table><h3 id="四分组匹配-提取子串">四、分组匹配 + 提取子串：</h3><p>​ <code>(...)</code>还有一个重要作用，就是分组匹配。</p><p>​ 我们来看一下如何用正则匹配<code>区号-电话号</code>码这个规则。利用前面讲到的匹配规则，写出来很容易：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\d&#123;3,4&#125;\-\d&#123;6,8&#125;</span><br></pre></td></tr></table></figure><p>​ 虽然这个正则匹配规则很简单，但是往往匹配成功后，下一步是提取区号和电话号码，分别存入数据库。于是问题来了：<strong>如何提取匹配的子串</strong>？</p><p>​ 当然可以用<code>String</code>提供的<code>indexOf()</code>和<code>substring()</code>这些方法，但它们从正则匹配的字符串中提取子串没有通用性，下一次要提取<code>learn\s(java|php)</code>还得改代码。</p><p>​ <strong>正确的方法是用<code>(...)</code>先把要提取的规则分组，把上述正则表达式变为<code>(\d&#123;3,4&#125;)\-(\d&#123;6,8&#125;)</code></strong>。然后引入<code>java.util.regex</code>包，用<code>Pattern</code>对象匹配，匹配后获得一个<code>Matcher</code>对象，如果匹配成功，就可以直接从<code>Matcher.group(index)</code>返回子串：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (m.matches()) &#123;</span><br><span class="line">            String g1 = m.group(<span class="number">1</span>);</span><br><span class="line">            String g2 = m.group(<span class="number">2</span>);</span><br><span class="line">            System.out.println(g1);</span><br><span class="line">            System.out.println(g2);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匹配失败!&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行上述代码，会得到两个匹配上的子串<code>010</code>和<code>12345678</code>。</p><p>​ 要特别注意，<code>Matcher.group(index)</code>方法的参数用1表示第一个子串，2表示第二个子串。如果我们传入0会得到什么呢？答案是<code>010-12345678</code>，即整个正则匹配到的字符串。</p><p>​ 我们在前面的代码中用到的正则表达式代码是<code>String.matches()</code>方法，而我们在分组提取的代码中用的是<code>java.util.regex</code>包里面的<code>Pattern</code>类和<code>Matcher</code>类。实际上这两种代码本质上是一样的，因为<code>String.matches()</code>方法内部调用的就是<code>Pattern</code>和<code>Matcher</code>类的方法。</p><p>​ 但是反复使用<code>String.matches()</code>对同一个正则表达式进行多次匹配效率较低，因为每次都会创建出一样的<code>Pattern</code>对象。完全可以先创建出一个<code>Pattern</code>对象，然后反复使用，就可以实现编译一次，多次匹配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d&#123;3,4&#125;)\\-(\\d&#123;7,8&#125;)&quot;</span>);</span><br><span class="line">        pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>).matches(); <span class="comment">// true</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;021-123456&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        pattern.matcher(<span class="string">&quot;022#1234567&quot;</span>).matches(); <span class="comment">// false</span></span><br><span class="line">        <span class="comment">// 获得Matcher对象:</span></span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;010-12345678&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            String whole = matcher.group(<span class="number">0</span>); <span class="comment">// &quot;010-12345678&quot;, 0表示匹配的整个字符串</span></span><br><span class="line">            String area = matcher.group(<span class="number">1</span>); <span class="comment">// &quot;010&quot;, 1表示匹配的第1个子串</span></span><br><span class="line">            String tel = matcher.group(<span class="number">2</span>); <span class="comment">// &quot;12345678&quot;, 2表示匹配的第2个子串</span></span><br><span class="line">            System.out.println(area);</span><br><span class="line">            System.out.println(tel);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 使用<code>Matcher</code>时，必须首先调用<code>matches()</code>判断是否匹配成功，匹配成功后，才能调用<code>group()</code>提取子串。</p><p>​ 利用提取子串的功能，我们轻松获得了区号和号码两部分。</p><h3 id="五非贪婪匹配">五、非贪婪匹配：</h3><p>先看一个简单的问题：</p><p>给定一个字符串表示的数字，判断该数字末尾<code>0</code>的个数。例如：</p><ul><li><code>"123000"</code>：3个<code>0</code></li><li><code>"10100"</code>：2个<code>0</code></li><li><code>"1001"</code>：0个<code>0</code></li></ul><p>可以很容易地写出该正则表达式：<code>(\d+)(0*)</code>，Java代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;1230000&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>然而打印的第二个子串是空字符串<code>""</code>。</p><p>实际上，我们期望分组匹配结果是：</p><table><thead><tr class="header"><th>input</th><th><code>\d+</code></th><th><code>0*</code></th></tr></thead><tbody><tr class="odd"><td>123000</td><td>"123"</td><td>"000"</td></tr><tr class="even"><td>10100</td><td>"101"</td><td>"00"</td></tr><tr class="odd"><td>1001</td><td>"1001"</td><td>""</td></tr></tbody></table><p>但实际的分组匹配结果是这样的：</p><table><thead><tr class="header"><th>input</th><th><code>\d+</code></th><th><code>0*</code></th></tr></thead><tbody><tr class="odd"><td>123000</td><td>"123000"</td><td>""</td></tr><tr class="even"><td>10100</td><td>"10100"</td><td>""</td></tr><tr class="odd"><td>1001</td><td>"1001"</td><td>""</td></tr></tbody></table><p>​ 仔细观察上述实际匹配结果，实际上它是完全合理的，因为<code>\d+</code>确实可以匹配后面任意个<code>0</code>。</p><p>​ <strong>这是因为正则表达式默认使用贪婪匹配：任何一个规则，它总是尽可能多地向后匹配，因此，<code>\d+</code>总是会把后面的<code>0</code>包含进来。</strong></p><p>​ <strong>要让<code>\d+</code>尽量少匹配，让<code>0*</code>尽量多匹配，我们就必须让<code>\d+</code>使用非贪婪匹配。在规则<code>\d+</code>后面加个<code>?</code>即可表示非贪婪匹配。我们改写正则表达式如下：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Pattern pattern = Pattern.compile(<span class="string">&quot;(\\d+?)(0*)&quot;</span>);</span><br><span class="line">        Matcher matcher = pattern.matcher(<span class="string">&quot;1230000&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (matcher.matches()) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;group1=&quot;</span> + matcher.group(<span class="number">1</span>)); <span class="comment">// &quot;123&quot;</span></span><br><span class="line">            System.out.println(<span class="string">&quot;group2=&quot;</span> + matcher.group(<span class="number">2</span>)); <span class="comment">// &quot;0000&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ <strong>因此，给定一个匹配规则，加上<code>?</code>后就变成了非贪婪匹配。</strong></p><p>​ <strong>我们再来看这个正则表达式<code>(\d??)(9*)</code>，注意<code>\d?</code>表示匹配0个或1个数字，后面第二个<code>?</code>表示非贪婪匹配，因此，给定字符串<code>"9999"</code>，匹配到的两个子串分别是<code>""</code>和<code>"9999"</code>，因为对于<code>\d?</code>来说，可以匹配1个<code>9</code>，也可以匹配0个<code>9</code>，但是因为后面的<code>?</code>表示非贪婪匹配，它就会尽可能少的匹配，结果是匹配了0个<code>9</code>。</strong></p><h3 id="六搜索和替换">六、搜索和替换：</h3><h4 id="分割字符串">1、分割字符串：</h4><p>​ 使用正则表达式分割字符串可以实现更加灵活的功能。<code>String.split()</code>方法传入的正是正则表达式。我们来看下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;a b c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a b  c&quot;.split(&quot;\\s&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;&quot;, &quot;c&quot; &#125;</span><br><span class="line">&quot;a, b ;; c&quot;.split(&quot;[\\,\\;\\s]+&quot;); // &#123; &quot;a&quot;, &quot;b&quot;, &quot;c&quot; &#125;</span><br></pre></td></tr></table></figure><p>​ 如果我们想让用户输入一组标签，然后把标签提取出来，因为用户的输入往往是不规范的，这时，使用合适的正则表达式，就可以消除多个空格、混合<code>,</code>和<code>;</code>这些不规范的输入，直接提取出规范的字符串。</p><h4 id="搜索字符串">2、搜索字符串：</h4><p>​ 使用正则表达式还可以搜索字符串，我们来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;the quick brown fox jumps over the lazy dog.&quot;</span>;</span><br><span class="line">        Pattern p = Pattern.compile(<span class="string">&quot;\\wo\\w&quot;</span>);</span><br><span class="line">        Matcher m = p.matcher(s);</span><br><span class="line">        <span class="keyword">while</span> (m.find()) &#123;</span><br><span class="line">            String sub = s.substring(m.start(), m.end());</span><br><span class="line">            System.out.println(sub);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 我们获取到<code>Matcher</code>对象后，不需要调用<code>matches()</code>方法（因为匹配整个串肯定返回false），而是反复调用<code>find()</code>方法，在整个串中搜索能匹配上<code>\\wo\\w</code>规则的子串，并打印出来。<strong>这种方式比<code>String.indexOf()</code>要灵活得多，因为我们搜索的规则是3个字符：中间必须是<code>o</code>，前后两个必须是字符<code>[A-Za-z0-9_]</code>。</strong></p><h4 id="替换字符串">3、替换字符串：</h4><p>​ 使用正则表达式替换字符串可以直接调用<code>String.replaceAll()</code>，它的第一个参数是正则表达式，第二个参数是待替换的字符串。我们还是来看例子：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String s = <span class="string">&quot;The     quick\t\t brown   fox  jumps   over the  lazy dog.&quot;</span>;</span><br><span class="line">        String r = s.replaceAll(<span class="string">&quot;\\s+&quot;</span>, <span class="string">&quot; &quot;</span>);</span><br><span class="line">        System.out.println(r); <span class="comment">// &quot;The quick brown fox jumps over the lazy dog.&quot;</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于正则表达式相关的内容。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>java系列笔记10——java单元测试JUnit</title>
    <link href="https://blog.slks.xyz/2022/02/02/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B010%E2%80%94java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://blog.slks.xyz/2022/02/02/Java%E7%AC%94%E8%AE%B0/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B010%E2%80%94java%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/</id>
    <published>2022-02-02T00:54:19.000Z</published>
    <updated>2022-02-02T02:37:46.000Z</updated>
    
    <content type="html"><![CDATA[<p>参考教程网址：https://www.liaoxuefeng.com/wiki/1252599548343744/1304048154181666</p><h3 id="一编写junit测试">一、编写JUnit测试：</h3><h4 id="什么是测试驱动开发">1、什么是测试驱动开发？</h4><p>​ 所谓测试驱动开发，是指先编写接口，紧接着编写测试。编写完测试后，我们才开始真正编写实现代码。在编写实现代码的过程中，一边写，一边测，什么时候测试全部通过了，那就表示编写的实现完成了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">    编写接口</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">    编写测试</span><br><span class="line">     │</span><br><span class="line">     ▼</span><br><span class="line">┌─&gt; 编写实现</span><br><span class="line">│    │</span><br><span class="line">│ N  ▼</span><br><span class="line">└── 运行测试</span><br><span class="line">     │ Y</span><br><span class="line">     ▼</span><br><span class="line">    任务完成</span><br></pre></td></tr></table></figure><h4 id="junit测试框架">2、JUnit测试框架：</h4><p>​ JUnit是一个开源的Java语言的单元测试框架，专门针对Java设计，使用最广泛。JUnit是事实上的单元测试的标准框架，任何Java开发者都应当学习并使用JUnit编写单元测试</p><p>​ 使用JUnit编写单元测试的好处在于，我们可以非常简单地组织测试代码，并随时运行它们，JUnit就会给出成功的测试和失败的测试，还可以生成测试报告，不仅包含测试的成功率，还可以统计测试的代码覆盖率，即被测试的代码本身有多少经过了测试。对于高质量的代码来说，测试覆盖率应该在80%以上。</p><h4 id="intellij中如何开启单元测试">3、IntelliJ中如何开启单元测试？</h4><p>​ 教程：https://blog.csdn.net/qq754772661/article/details/107790362</p><h4 id="单元测试文件怎么编写">4、单元测试文件怎么编写？</h4><p>​ 核心测试方法<code>testFact()</code>加上了<code>@Test</code>注解，这是JUnit要求的，它会把带有<code>@Test</code>的方法识别为测试方法。在测试方法内部，我们用<code>assertEquals(1, Factorial.fact(1))</code>表示，期望<code>Factorial.fact(1)</code>返回<code>1</code>。<code>assertEquals(expected, actual)</code>是最常用的测试方法，它在<code>Assertion</code>类中定义。<code>Assertion</code>还定义了其他断言方法，例如：</p><ul><li><code>assertTrue()</code>: 期待结果为<code>true</code></li><li><code>assertFalse()</code>: 期待结果为<code>false</code></li><li><code>assertNotNull()</code>: 期待结果为非<code>null</code></li><li><code>assertArrayEquals()</code>: 期待结果为数组并与期望数组每个元素的值均相等</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itranswarp.learnjava;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> org.junit.jupiter.api.Assertions.*;</span><br><span class="line"><span class="keyword">import</span> org.junit.jupiter.api.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FactorialTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testFact</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">1</span>, Factorial.fact(<span class="number">1</span>));</span><br><span class="line">        assertEquals(<span class="number">2</span>, Factorial.fact(<span class="number">2</span>));</span><br><span class="line">        assertEquals(<span class="number">6</span>, Factorial.fact(<span class="number">3</span>));</span><br><span class="line">        assertEquals(<span class="number">3628800</span>, Factorial.fact(<span class="number">10</span>));</span><br><span class="line">        assertEquals(<span class="number">2432902008176640000L</span>, Factorial.fact(<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写完成后，在编译器内直接选择运行该文件即可。</p><h4 id="单元测试的结果">5、单元测试的结果：</h4><ul><li>如果全部通过测试：</li></ul><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_02_10_13_50_410.png" alt="屏幕捕获_2022_02_02_10_13_50_410" /><figcaption aria-hidden="true">屏幕捕获_2022_02_02_10_13_50_410</figcaption></figure><ul><li>如果有案例通不过测试：</li></ul><figure><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_02_10_14_11_224.png" alt="屏幕捕获_2022_02_02_10_14_11_224" /><figcaption aria-hidden="true">屏幕捕获_2022_02_02_10_14_11_224</figcaption></figure><h4 id="单元测试的好处">6、单元测试的好处：</h4><p>​ 单元测试可以确保单个方法按照正确预期运行，如果修改了某个方法的代码，只需确保其对应的单元测试通过，即可认为改动正确。此外，测试代码本身就可以作为示例代码，用来演示如何调用该方法。</p><p>​ 使用JUnit进行单元测试，我们可以使用断言（<code>Assertion</code>）来测试期望结果，可以方便地组织和运行测试，并方便地查看测试结果。此外，<strong>JUnit既可以直接在IDE中运行，也可以方便地集成到Maven这些自动化工具中运行。</strong></p><p>在编写单元测试的时候，我们要遵循一定的规范：</p><p>​ 一是单元测试代码本身必须非常简单，能一下看明白，决不能再为测试代码编写测试；</p><p>​ 二是每个单元测试应当互相独立，不依赖运行的顺序；</p><p>​ <strong>三是测试时不但要覆盖常用测试用例，还要特别注意测试边界条件，例如输入为<code>0</code>，<code>null</code>，空字符串<code>""</code>等情况。</strong></p><h3 id="二使用fixture">二、使用Fixture</h3><p>​ 在一个单元测试中，我们经常编写多个<code>@Test</code>方法，来分组、分类对目标代码进行测试。在测试的时候，我们经常遇到一个对象需要初始化，测试完可能还需要清理的情况。如果每个<code>@Test</code>方法都写一遍这样的重复代码，显然比较麻烦。</p><p>​ <strong>JUnit提供了编写测试前准备、测试后清理的固定代码，我们称之为Fixture。</strong></p><ul><li>以下为要测试的代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Calculator</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">long</span> n = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n + x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sub</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        n = n - x;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 这个类的功能很简单，但是测试的时候，我们要先初始化对象，我们不必在每个测试方法中都写上初始化代码，而是<strong>通过<code>@BeforeEach</code>来初始化，通过<code>@AfterEach</code>来清理资源：</strong>如下所示</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CalculatorTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Calculator calculator;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">new</span> Calculator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@AfterEach</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">tearDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.calculator = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testAdd</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(<span class="number">100</span>, <span class="keyword">this</span>.calculator.add(<span class="number">100</span>));</span><br><span class="line">        assertEquals(<span class="number">150</span>, <span class="keyword">this</span>.calculator.add(<span class="number">50</span>));</span><br><span class="line">        assertEquals(<span class="number">130</span>, <span class="keyword">this</span>.calculator.add(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">testSub</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        assertEquals(-<span class="number">100</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">100</span>));</span><br><span class="line">        assertEquals(-<span class="number">150</span>, <span class="keyword">this</span>.calculator.sub(<span class="number">50</span>));</span><br><span class="line">        assertEquals(-<span class="number">130</span>, <span class="keyword">this</span>.calculator.sub(-<span class="number">20</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 还有一些资源初始化和清理可能更加繁琐，而且会耗费较长的时间，例如初始化数据库。**JUnit还提供了<code>@BeforeAll</code>和<code>@AfterAll</code>，它们在运行所有@Test前后运行。</p><p>​ 因为<code>@BeforeAll</code>和<code>@AfterAll</code>在所有<code>@Test</code>方法运行前后仅运行一次，因此，它们只能初始化静态变量。</p><p><strong>事实上，<code>@BeforeAll</code>和<code>@AfterAll</code>也只能标注在静态方法上。</strong></p><p><strong>因此，我们总结出编写Fixture的套路如下：</strong></p><ol type="1"><li>对于实例变量，在<code>@BeforeEach</code>中初始化，在<code>@AfterEach</code>中清理，它们在各个<code>@Test</code>方法中互不影响，因为是不同的实例；</li><li>对于静态变量，在<code>@BeforeAll</code>中初始化，在<code>@AfterAll</code>中清理，它们在各个<code>@Test</code>方法中均是唯一实例，会影响各个<code>@Test</code>方法。</li></ol><p>​ 大多数情况下，使用<code>@BeforeEach</code>和<code>@AfterEach</code>就足够了。只有某些测试资源初始化耗费时间太长，以至于我们不得不尽量“复用”时才会用到<code>@BeforeAll</code>和<code>@AfterAll</code>。</p><p>​ <strong>最后，注意到每次运行一个<code>@Test</code>方法前，JUnit首先创建一个<code>XxxTest</code>实例，因此，每个<code>@Test</code>方法内部的成员变量都是独立的，不能也无法把成员变量的状态从一个<code>@Test</code>方法带到另一个<code>@Test</code>方法。</strong></p><h3 id="三异常测试">三、异常测试：</h3><p>​ 对于可能抛出的异常进行测试，本身就是测试的重要环节。在编写JUnit测试的时候，除了正常的输入输出，我们还要特别针对可能导致异常的情况进行测试。示例如下：</p><ul><li>被测试代码如下：在方法入口，我们增加了对参数<code>n</code>的检查，如果为负数，则直接抛出<code>IllegalArgumentException</code>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Factorial</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">fact</span><span class="params">(<span class="keyword">long</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">long</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            r = r * i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>测试代码：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testNegative</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertThrows(IllegalArgumentException.class, () -&gt; &#123;</span><br><span class="line">        Factorial.fact(-<span class="number">1</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="四条件测试">四、条件测试：</h3><h4 id="disabled">1、<span class="citation" data-cites="Disabled">@Disabled</span></h4><p>​ 在运行测试的时候，有些时候，我们需要排出某些<code>@Test</code>方法，不要让它运行，这时，我们就可以给它标记一个<code>@Disabled</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Disabled</span></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testBug101</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这个测试不会运行</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​ 为什么我们不直接注释掉<code>@Test</code>，而是要加一个<code>@Disabled</code>？这是因为注释掉<code>@Test</code>，JUnit就不知道这是个测试方法，而加上<code>@Disabled</code>，JUnit仍然识别出这是个测试方法，只是暂时不运行。它会在测试结果中显示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Tests run: 68, Failures: 2, Errors: 0, Skipped: 5</span><br></pre></td></tr></table></figure><p>​ 类似<code>@Disabled</code>这种注解就称为条件测试，JUnit根据不同的条件注解，决定是否运行当前的<code>@Test</code>方法。</p><h4 id="enabledonos">2、<span class="citation" data-cites="EnabledOnOs">@EnabledOnOs</span></h4><p>给两个测试方法分别加上条件如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(OS.WINDOWS)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testWindows</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;C:\\test.ini&quot;</span>, config.getConfigFile(<span class="string">&quot;test.ini&quot;</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledOnOs(&#123; OS.LINUX, OS.MAC &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testLinuxAndMac</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    assertEquals(<span class="string">&quot;/usr/local/test.cfg&quot;</span>, config.getConfigFile(<span class="string">&quot;test.cfg&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>@EnableOnOs</code>就是一个条件测试判断。</p><p>在Windows平台执行的测试: <span class="citation" data-cites="EnabledOnOs">@EnabledOnOs</span>(OS.WINDOWS)</p><h4 id="其他条件测试">3、其他条件测试：</h4><p>只能在Java 9或更高版本执行的测试，可以加上<code>@DisabledOnJre(JRE.JAVA_8)</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@DisabledOnJre(JRE.JAVA_8)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnJava9OrAbove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is disabled on java 8</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>只能在64位操作系统上执行的测试，可以用<code>@EnabledIfSystemProperty</code>判断：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfSystemProperty(named = &quot;os.arch&quot;, matches = &quot;.*64.*&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOn64bitSystem</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on 64 bit system</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要传入环境变量<code>DEBUG=true</code>才能执行的测试，可以用<code>@EnabledIfEnvironmentVariable</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="meta">@EnabledIfEnvironmentVariable(named = &quot;DEBUG&quot;, matches = &quot;true&quot;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testOnlyOnDebugMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> this test is only run on DEBUG=true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="五参数化测试">五、参数化测试：</h3><p>如果待测试的输入和输出是一组数据： 可以把测试数据组织起来 用不同的测试数据调用相同的测试方法</p><p>参数化测试和普通测试稍微不同的地方在于，一个测试方法需要接收至少一个参数，然后，传入一组参数反复运行。</p><p>JUnit提供了一个<code>@ParameterizedTest</code>注解，用来进行参数化测试。</p><p>假设我们想对<code>Math.abs()</code>进行测试，先用一组正数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; 0, 1, 5, 100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbs</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>再用一组负数进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@ValueSource(ints = &#123; -1, -5, -100 &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testAbsNegative</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    assertEquals(-x, Math.abs(x));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意到参数化测试的注解是<code>@ParameterizedTest</code>，而不是普通的<code>@Test</code>。</p><p>实际的测试场景往往没有这么简单。假设我们自己编写了一个<code>StringUtils.capitalize()</code>方法，它会把字符串的第一个字母变为大写，后续字母变为小写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringUtils</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">capitalize</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.length() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Character.toUpperCase(s.charAt(<span class="number">0</span>)) + s.substring(<span class="number">1</span>).toLowerCase();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要用参数化测试的方法来测试，我们不但要给出输入，还要给出预期输出。因此，测试方法至少需要接收两个参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>现在问题来了：参数如何传入？</p><p>最简单的方法是通过<code>@MethodSource</code>注解，它允许我们编写一个同名的静态方法来提供测试参数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@MethodSource</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> List&lt;Arguments&gt; <span class="title">testCapitalize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> List.of( <span class="comment">// arguments:</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;abc&quot;</span>, <span class="string">&quot;Abc&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;APPLE&quot;</span>, <span class="string">&quot;Apple&quot;</span>), <span class="comment">//</span></span><br><span class="line">            Arguments.arguments(<span class="string">&quot;gooD&quot;</span>, <span class="string">&quot;Good&quot;</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面的代码很容易理解：静态方法<code>testCapitalize()</code>返回了一组测试参数，每个参数都包含两个<code>String</code>，正好作为测试方法的两个参数传入。</p><p>如果静态方法和测试方法的名称不同，<span class="citation" data-cites="MethodSource也允许指定方法名">@MethodSource也允许指定方法名</span>。但使用默认同名方法最方便。</p><p>另一种传入测试参数的方法是使用<code>@CsvSource</code>，它的每一个字符串表示一行，一行包含的若干参数用<code>,</code>分隔，因此，上述测试又可以改写如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvSource(&#123; &quot;abc, Abc&quot;, &quot;APPLE, Apple&quot;, &quot;gooD, Good&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalize</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果有成百上千的测试输入，那么，直接写<code>@CsvSource</code>就很不方便。这个时候，我们可以把测试数据提到一个独立的CSV文件中，然后标注上<code>@CsvFileSource</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ParameterizedTest</span></span><br><span class="line"><span class="meta">@CsvFileSource(resources = &#123; &quot;/test-capitalize.csv&quot; &#125;)</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">testCapitalizeUsingCsvFile</span><span class="params">(String input, String result)</span> </span>&#123;</span><br><span class="line">    assertEquals(result, StringUtils.capitalize(input));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>JUnit只在classpath中查找指定的CSV文件，因此，<code>test-capitalize.csv</code>这个文件要放到<code>test</code>目录下，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apple, Apple</span><br><span class="line">HELLO, Hello</span><br><span class="line">JUnit, Junit</span><br><span class="line">reSource, Resource</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记为java系列笔记关于java单元测试的相关内容，JUnit是常见的单元测试模块，单元测试就是针对最小的功能单元编写测试代码。Java程序最小的功能单元是方法，因此，对Java程序进行单元测试就是针对单个Java方法的测试。</summary>
    
    
    
    <category term="java系列笔记" scheme="https://blog.slks.xyz/categories/java%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="java" scheme="https://blog.slks.xyz/tags/java/"/>
    
  </entry>
  
</feed>
