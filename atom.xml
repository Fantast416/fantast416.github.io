<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-02-25T16:09:31.794Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>毕业相关事项</title>
    <link href="https://blog.slks.xyz/2022/02/26/f011ce01b274/"/>
    <id>https://blog.slks.xyz/2022/02/26/f011ce01b274/</id>
    <published>2022-02-26T15:52:19.000Z</published>
    <updated>2022-02-25T16:09:31.794Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="5f2832a9d17d20fa058514dfe360c6848d2427e84c6d3c3633ffec46b45dcfec">f638d67e356a706b7b082748a96249a9c6215665973a817d195d1e1476666dda00dede9801ee74c82cd7a946d96afe739c132c3adadb052f1b3812d2e382bbb9b67d1a06443ab4b4344bdab2822da6341e5da18560a52307d2bd1f9203199afbad5f76870d7d90ee0f0f579250a59e5260dc5a69a54d8400868d9b23518d413782354b3de38bab4b3070fda0443c74e65d1fdbcd6cb6466819e1e93168ec312c4fc45b115b918b99551b1ea7fbda3ba7675bd17f0712586c6fb48ed4e4522899cf6be56698e6e1f00004f7f70c858b25a7fc069f6b29200a5de2f6af4e968f215dd55c10559179ee9b1a30a0639086c17c71ab66bcb52dbaab7ffdb0db4a0f4d87ce6f666fe844b0d79d0e6086cce4d8fa10c0ca4553fcb5a0e692dd03f89de648462e1bd956ba1cf3594d22f18f7ab30ca2e70ddb923b8c47ff1991b9dc7a622da4928712167ea7bdfffd4a3a3b6d7881816af969fe1f931207e670ceafc5094fa19d37d53928af10ba79a60e2f1f909825b2b27d67631c02abad89f95d6e5d5f62058ce0df2313939939a19fc8c1f8e04cfd3b4d162621e78202ed3a4d0a9aa47ec85024c209860a31e14cb6f381aeeb146312b7ce3f34dc65e73ecfcfc691bd2f1c8e813eacbad5bce3f67bceba55b8f2547385e9328e8ed8940118b478166d50a7ad26772190613862beafc6f28df47cd2a16ef84e28c309a5b3877b87000d80d53446cc58ce33de76b01342272398b60e5920be949aec0e359b7cee75fe804ec381aba268dbad9914313f55f0c4958349505d73c0c4524cfef4571be0d3bbc26edf818344066669e96fb9d7fc88bd57a3ace92ab8deff47ff3e1b97c8638ed459ce3cfd6f41001f206e3e138a829131ec361d90d715cbe1c7b4ed2d3bdb1b4e3062edf350bcf4bdacacaea4b7693b57be9b2fb355dbf3efb2cbc4cee80c69f90818de2c5adb41b868b1885e413694861b46236889809844971258ef964b9a9204eaaa2715ea9e59dfc02d75527ae5a8450e455c5e29a576a41f996eec58c60aaddf9b00799424aade3e2678fc24cdac0afab8e5079f49991f9731f59638d8c9c6b27d872b6012904a26f7b65618eb3edfa0bf09cb1fe0a48a7f857d26bc7bacb66db70470e407ad81abd0f98f46cd1d396f303d4b9d4ae1a1697623e9ea5be4fd695ff120fd7205d3e6beb8467eb68200d095a9c3eb24613784d4b94f8bb4816391543d9e1b551d9f4d87fff20379e8c4657b2a3af725a5c05bc9d296ce3d9293db93a1772f1b8289c3b63132694e483b529e90164171fd3f1065fd5f6fd63f5e906f4c0fb8a6c07f60e94024cdcb3fba85d00b71ecc625c873c111d652749ff9cb7050b24ab1d1b9b1a6037db5190804a4ced4e6f2df1f1f0b2a7f53f6f4365568ab7204ab023231312577b44fa05789372aec3583bd5868cc1092fb7082ce7882650af227712ae75835a13729a2fe99b2a7a1f0c5d63ffa63cbf2ea7a071317567f9a74766e930e27bcc4b62dd01a44ffdf42f6ecf60edf6269956e9ea6b7ac121dd16829b91f169935fa20a8b4e156eae8e0e41ceadbdc4396d0e069fd7aa9b58646ec9114fd4eb3eb2cf101c0b090cfa1ae1b81529658b882e65f8d08ab4c68339372320ec34ceb42e243b6500247dda22a14eb73dd54c032a3195fda6ab4f90c8382e41b2aa6d325daac9b62ed42cdc7c997312e0c76842ce02b3f4a0b026f9fed63297f05b0c91a7abff2df2aa0785a6533bde998fa03008ad2bc0cd733505ce99fcb7c2be7783fac7502a25ba5e7193dac54b76b143695634643fe7372c694c2b3b76fa0aa9b1256adaf420e9cf03891e89af3e2636bbf0aff4522c01e64936d0d9e473f102f3035cb89fa98cd880b0f404b266ef49ac2ffe83b846019eb9d2675fe90881ec4d33f0cd963c6989f8ff82481e64760c52ea84fee0f7007d47c7fb9907427736b35ecf13b61cc157b7a5591ed7fa0555639a214e19a7df206871d585987c892feb9c77dbd27fa1885706c103c5fda6796f576b41c97252a92ff78d8e2498514f6c468b99527dc6482a6a09f1a54e43a3f948ee74321317a3ea08841a8b49f8ba547c693e9c2876fd9e8bd29c037f23e0c84bd06c272e1452f92d9e9126d16667bff55dc0e4f2b2f0d83bdbd5bd34855f09bf177881d55e1c74591b8510fdad8c360ec38af037e5ebcc54f9b4545630aa0438ea671678eeb609a1f11546362233951006497d6abbe9921e4b8a55390edc2e15c03812f017d6edd0af0bf5752a62deab5b6bd6472215fdd960e07e02dbf19b5ed1e2cf7034455269300846de5d098d7b592d03659e37f03504689288620d7f4dbd8fe2876f88792ea41e5e8f98c29a527d14d6d4b3d4816ac2dcb62779febd26bf0c2ffba1314c0b4db5639f5979415eeb81647b6f575f7a9a4be691d01215133f3c5d791e25d03148e41ebfa6f9a92e26fad06fc0d7c4c7b006719edc26aed0137f2f5703d3157a8567a9d152c57c4dd7ea8132204959f2a229b9e622ac6bbb5942dc67a6e8893b7fb776bcd2a19f54ad22688e00dbbbba64e2bdc57d1213a3b15e44400280c916c79540e6e1d9af6dd9fcf94a2754767673edf83ba5fcb74d704bf954015c2c26b24c3b8c766a5e66f76b47688bfc8d84adecbeca41f41ae92496ca399033740fe753f54b8c35084815a6c07f16f61907ef5745f4a5d94ea2de53f8e364a15e6b6f36d43274ade41aa0657f5464b852c4133e67d9c73b8fe681b49fac00cfdd439366e26d31ee688fbda787b94d1f97337be345f87e563f11ffbd9f219ab1889dd8abfceef5ac897a2158cd6e65fa9738270143107d6195b33d7ca3ad530a1d05fb5b17a67cb8f62edd390e5bda8d90ece8c79dcfc85b571eeb475fdf96b601f534536d7daca9ff288c6f1d22766dd086900e01e563dc96ab764fb78687970c21cc4974c159d133d5899fd366f4ff8a00691074a4bd4c25e25905663916ef86c29079f6306bf847a67f7f5051a004f30167d50c6a3d1d94b49a26b7a3d0f7334da0079838eb79e7a5f7f416acfeda2192e43bc0e391eb7cb1a12810f5961c5020e3c18f99e18acefdbf5f5b90470226028eb831bd1739324b4dea4c84d787ac78aa0ecc071d6a77819c79990838b769427f2e401b4e688cb8eb962f53eea7e291238e6e28a81072e176de3d9eabdb0a1876613bb0a6a49d0ca6444eaa33fcda09908e9242d127cec62b64ca6ca23a906028191bfae9f0a3957c383a1a52d3d97c0ab3cea3a43e028ebea5dc474398c4e9cdcc4643dca947452d1e3a8c3ba1f1caa2f29c42a6f87da10596ffa09aea92e747ffe7d0007d034fc06cac216f0aca717949d139fe8397f29f54701a390c4e2fc564c6c1092b1b09d94367751b0800cb13c06030d77957e460da7029af2cbf22a51e29867123fd26fecbcdb48cf5eff8a32e3fd9385bc2afbf951beb9f4dacd5f1d97bb659ffe8225ff235e472a2e51ef2cafdbfba7ae921ad7a13d4af862144d31a74d58ad9b9cb98509152214d47df7180072a52441d94720f531113cbbdc068642a87f5c430d9103d1d36ab341d8cac98ff015507a232a9d63dc7175ac428baaa10b5798e0f90912bd461761c0d00614dbd2c98ed3899ec42b28962c8a30069bf100a22905156aea8940e66f963fca1ec02886da6147fdba2cfc66be484c1b486114988e8def18576bb92777d11494a9aa4ab12c26cac966750aa2e5639902667b945d509d25842cc260ee0efb5dd337292ee932c2598e25ce73f73b62f5be5200e74c347468cc7a2459de6a407f9add47f17518e2cfba3e976cc449b062aac66f2c0569cae0a1404d120ec8007e7353f592f138e8c6a3e7babb98ff73cf6c149036771c42319ab889822ef528c7944600071f13dea99f3d57df4894f27fa1882ac9f4f32950a14f0484d7470dc1bfb720cbb651fc0e51e950058effaf243b698663340c7554c14906eb10f806e7d31f8bf912ad104360fda7027a59ce9953448538bf23ebeb5536c1679b9f7f79e1e8eafc147e1231b8e14f4777f12d15c9b08683c91024ff2e01f98be0bae2c262552869ea621eae1556e499d2870a5c736364103dafdf47fc77a61f93f792389984055c0b8b5da40cf280c6cd132b88ed95955ffd8de5a705316cf2ae5ceddd8953e6df3ca009b0c5c67d0eb8311c15ce97ce02f067dc6a05444bae4d19ddbd2f93ffcb96a42e0223ffb839540b0f8f1dab8c08a47e398ef28348f21597c6a0011d71ac050e9604332125700823b950211ed0e9d28b5cebf64f7b15941e07377b04d061471918e8565dcd11b6f07a304b6860803553fe25065f21e940caf82003f1f5bcce082ffdc10bab7be503e71d832d77f31b7dc594ae1cce624cef2f3a918c017a36b2fbd74989632aa24bd4ea5e81c0fab473c28164375de5829d3a4c394a2cef1d3ce178e76b4c1aac73df5a462894a6d7582b07066c511ff5bdafe23f1f380ef8b2aed8525de165373c06a9663fe8162bf487009ec690137a9f4226db26094aaba2b39efa8a5e10987681e55190a3a61dc9e1d865ff946165f378cee366825721d9c536ed985e6ee0ff206bcbe2f23f253d94695ef8810b19b51031e06de4e6f18ae7cb82f4b7ee68e9a54c850dc706e99b51d871e89c5cb3fb6a9e9c90762f437edb11670d66ac07937f316019aed2426ea82cc73335a24c1845a9683a3f250b95f79316231370598781ee3cc5a3a10b574dd067928d89830847462b1f91020c9a3dc0d1332f49be77efcd18f14a6b5d3ee85c96c5098e33351b4af5cf8bc2ed3ee296ecf391057130b7e4b8e33213615600b3ce15b628a99535a22940fbacf4376651017abd461082f32af78baf941d5da55d30d403cd4bd3464550e81f3b2245e404e3aca506adce3205d97aab271c992594e76e55aedd69bd2cfbd2d646fc7d2ab0e585ab06335962c7bc4967064b62ef4747ea477189b931824c18920a6e456e1af5e4bd3fe15f678ee03934f4315ae1b7e576fcd3d7275b2207644abd59a173f4dd66d68def20257578820c2d446661cffa0104c9acda08d36f0e2aa8fee67c20854cda102e9b63667104286e11278a8a340264342a51030f89cc047f586b2dbffcd29ac2f8912282d022b35c20723b0ae7ab18278305ece8e6ed7784859b6100743f6c3874a6813ea9d2ad507e9811ae780c3acfe1531c7be180bce82b1d777d9b060e6d41fa8c3e76e43862c77a630dd7f55bd4f7a3cce71da38a4bb673b88335ef5724d8cd59bf414df7cc5697426fed0d38cee91243a0571a74a22b9f8fe77079ee415ed17f82ea78a746978eb57d5ac5b01ee1556172fee235f4704ab4006a0caf56750d3fd72d0f4fdd30d266d92f1efe5b8c8d74b81197dd7091b900c0ac700f1fc4462eb5890e4a31d1d6003d2251153420019323660a71890f6e5285588f704a4d175be012a8f706ae42ad3b4a8f2ca4b8b128e4240393012564a6a06fd3f6ffc7470d485dcc8a99fb92186fdc8f7baec952cff401e48b449824193c73114753db2134cda83e5052af80308daae1407b448a5d1d300c417e09e4bf079a3524351b1dcd99b9b768d4eb3a19225056cb5e89c8cb258a1b40dcb032dcc1711d979ee7bd5fb9fac8c82574f57d10e7ae8648b06930714aeeb0fe29f5db88e8e39e51e8a8e892cea84c5049a137406965fac7b222fdbde7bb9c12b835ff4fb587d3370b9a6eb988ca04c8d82abf1d86ab35a571c318a284cb0f3a8817fc881686b1b9e5fa574e69d55ca271ad6f3308a0ac47a6f62dedf9cf6efa3bf081a3e384f48eb95c6a30c818df4a3dd2b698345323ef2d114b960f7b32168222589634567fa31a0dc1e08066047c2cd0d64c4fb70166c922a64d24a816075f0cec7eadf7dcd6bfee67b767c14aa53b569d35f00bbbbb7f92295c4e6ed3f790d2ee7865b7b33ba65fbb1b82e673f1016bba5982bef4cdcc5e109a4a7b5f9169c4b86d140d2b3c79f5529c3eccfb70dc60899bc612db8decc0ea4783dd839faddd0baa05781466ed168c8f1f7e582b24031a6991829d990c828413b8771033e3305489f06ec5a8a25c40c563be5a128467e204a186742713274f42d9d4c0523bdc26f30a1fb6f021bb70a833370f11b93c248270071409d3efa8bc83ad10b40d4b17404f96124f3ded698f9c3c65dc88045caddc063b195d10db10a3dfac1d1b2960ae35d602c2e454ceee12a658f4497bad153c2465031fc546de7bf0ae90e7457f7ce7f69642839e80a5ec8cdc2710f6141cfe6fce21fd28efc3fe15c0d0d8c5666af571c776ee5a1a18dfead4cac7cf3b549bc8fc3913ac87b2c96817e52f307be4017f79663108627368df7e8270f94238abd778a57e98a758a5697a14daa4f1ff5915ba9d6f3e3255c8dab29ad87037d0013b1e255dc86bf524ffc0dcd6845242dbd01bdbb9fef1ca1c7f077ab771f5a0acf44751d1995d6b1f590ab6067cf87af61136109002f9d1dab7fc23bab7782db96b07ffc798aa53097b5af9fc26de3ca80e08a06557539006d1da6dd2c88a5fa78d4b8a43d3213e6bca3f06ab31ba17edb0ca866bbdd7bb9cdeacf6d0fdfd5f09559df602443639d6da1eade2752f416f637b15a842786a734dacf6d26257c9f2996ddb24f62c1d3457de0ff5e2861f1f110069140a413dbaf4d4a95d7d3655ab8062c177e5f36478d6d9bf9655bb579d999304080f1d2190dfb21eb89ab79c68156f6fc694114a8229f7b40d06e70b41b3d20a308adf39666d507ba722e5a44e30a2a80c64c9ad620d1b82731ecbaf87f839fb5480d3297cb1c02a8614acb50c56faf3e15a033a0db9adf6ab44da455c3b5751401beef4a2045aee8c34b80f10e6f7438854b1b51d7bdfff7f9eaa25a9d345d7689dea4aa6c0eff8b55724bdb32c124d14a3400070f2db79ae4325acdb233a22a5e65991a3b479691300fd0f4d53133defbb41252ca22cb4b3efd37cbaa74d611f4fb24f464f80f81607715292e9afa6662d7409a987388d66ac99260c54d5dafc0dc5e96bf190e4e22240c3ef6f48895c3c918fb74d069835ba2a3397401eb105c957dc9ab5adbfa107d806bc04059441f759b2fce61a9e19f885b216066b2b14e82407810e5c2a81b61f377c232200799df4baa81af0317a360afa08f055c39cfe6b4aece0867d02cd2deac8e475ff15805b846ceaaf5ab2d67c50ff086be37d15dfb1347ce1ef4fdf53a6fa733a0108cfb342ff27e37c529d69a32fd3c39561234c0b6ecea95c2b5b47c8d34eaa7c4affaaf3219971d651380d1fb5b9939444bab86290c198cecd7ff32c420549147715386730e042446c4e0af1353d88831e67d52186507538210e3209772e48cec5158a4dc709386cf84a815ed65d9a9541c632ae9363b560b12cf1c984a3c68b544f5cf113dc9f5f617f0e43c8c200ee4d2122702ffe220133f7f534475ec84fcea421e3a93a363fb98c7ec65aad920da8dd7b551958c3b94d3df26bfdfa45a644399892fa50580c335ac0aa9a437ef4292ba3f74603439d55e0e3c73e4f8d07527272fe262fc3992fa25afad8c7f3aab2ab0392b27042405466bb93dfd4c9760851067f2ea7476ea4d3a3f494c5941bed0ac33cb62d7f331a2010e7b9d9ac7c71929d3bcc21a4a639ecc1d3cc0ba90e9f2ab68f2a365a179eeea0ec32085d96daa7c2b7b6ef519f275fb855d2d8c8089489abbb4c8998a4b59949ea4cddbcf507f5e59b851062ee589b4d2f56fe2ac1d8c048a6056f1d78a1f68038bc62e5b841b0f641fd440d4b1c9525cc3189104c011998b242cb6c4733672aaf2470da98847df09382a10a35827c345eb13182f6c1318ee28e40f61098d9d820e8f3775aa76fe9e3d847c739b712021d29051ff9bd6a0fac0e4bf00ae49d7b12c25776373d32303d3176e8f8c5beba28cb534302d73bc47f0cc89011b99d34f1b3ee37d450ca867e8b9f1acaae006b794fab18417dff1bf9f3151d50bacc52f375d3c2c0c9138aeec798b8e15e5beeab6bbc0441db94fc99eb8a390c6eb1a4bbabde29efd4c6222795308e737253e04650a7ac98145c8abf8226174474e87bbe8684f53a3e06bbb0dec52d6f3b6e11892f3e35394bb41ab6512ab5c53a620d8ed80e8c8c49abf9dccec239e36d811a5ce392010e60267bf2f0a360688cc3ce027a4fd9e7c3a6d09182a14b449e753ce64bccc4f56654a6baa324cab4bb35be719f4395f00616d1da9e77f77bfd1cec257a5c1d4fd3a727feb686dd911fee4aad98df2afd3f5fa688b51fb47a6e1afab089a9faa2556f57c132af5a0532ac5252ef1f4bf4eceaa2b6a47118e78a2190f5cc5015dd3612177e3a48c67cc5937dddf148c68dffafed2d2a4e7e189d085ac949859a50801759123bc9cd7cff17d269ccbde96aed8a3aa372f05d8e5beb8e3c607f650106d59b567a6f22b6e0fb8c83c0991217a1ead21bdb758695d4478f72f2b5d7c31a788266c65606f3ca552ef7cb45f7cf166005100efcb6dbe514ef23af96f01372df9240ebf920185a762886188a267a20f0f3bffea1dd5a5a4be2bcfae5f9f977facb27dd71e784a19e20d1142fafa22eaeee89e0580b86c946e16c9fee077073276bd7f79f0ef0b083b604083ef1d7766989760e67d99bc4df4c7ad2c378b9175938f397e331284791d17c1e3f22f34eacfd75d07e7821165b17be9d73fb97fc0285e02162d0a13cf0d7d5cb9872b4ef360a385f3766375f77702b6aa16ad90f9d738424cf967eea8c448ea15ae1519a83c3801edc45121179a81fcfde098005b7c270373542b02fe6118cadfe646481cd6ee343f4a8110645f5804185033e5b38048c5bb295b0d5e9cd365dcd1522ccdbb867ad5a4cf4abaf40b0c0de13e9de6c15ba8ed05f7fe1fe0b4895237e3732ad5e71998d240dd4629c6b8666372ea00c6401b10cf2c9518b49ad7b9c4c956df69350732f13f3038cc730d59f57897431827a1a6c65ad1e5657ca48171f8729a83059337068ea2baf0b1f6749cf4f2ccc0cb39f0eadac38153aa2ce921c78926380483902bee66386cd79478e6cc16ae8d65f548a543ad058b0f71978b9a9f021f9ca6cffe9e271b72f3ebc25b4b4bafcc58140748e31e7423023453d25ce7471b82a3cb9a09fe6870da78e34033f4ea9e250d45269d745f3d1d42279c5efe4ac8a0bcfbaf33a8a8e6d69c8919bab0714a45102099b279bceb1e2a1c24cae631563163725b9e54b608c981d42b4c5f4fe253d944cc7a03fa7792eb58ff17ed7a1905ea99b8d3e4a99686bb8ad2e988d2a5647e1f16307fe8651c3b0a485d70614eff2524136baa27c8fa02e0761c3b48da9f668b0ac1c8feb267b1382676996e7ff9eb6cc75dacd6fcb15d63889f3421481d0b52cf60bce76fd24eeae2a15c9e3390ea5deb67c86021164eefe8ae02d9802985933e3f6bbe25a9a6f57cb1f8c2445cb3ecca91ad446a26cbae57e760033ae7329399fbc681a811718d6a35de56af1f8b982b56294a18ec5a7e1b8cf6d75dc9f31d73bf8673ffb5d965374b4ca9198674ac89ed5aceeb3af0b79f52a1093761152f1909e2b6d20b18de6ab98e6aa4b54ac309d09bacd48601c22fdee1b0161079c193dd8d3c80098522b15c3292d45e636b91859e045e1d0fc9202788acd3a384953660d26b74f1763871a1c34100c7b7b106c09b6ab73cd22725f8087fd19ebc50834e9be6404f3c352b9c1cc77ea98183afd984953abc916705ed04ac52c6bac594b7daa269b3cea34099772fbf30d27b490b23795ce4dad46b86524044da88111426b6f0fd002875fbc42dea2f14bb477c52b6b4e53d9d2508058c9f26f15cad7f1efe1b399fbcdab1a19f3c6d39dc3b5f3c54b2e49e5d5bacc9e58cb86c51e2b74f65e0579d1a22c19403d754c5cf4eb2f6b9f870ba0018a89773c5a798dec5accb37d1d95e26674b51bdab32effa33c14bb94c7df4227f0b10f96a104b3a271af881281f32b64d0108028db98433b74dc86c23e0bc6ebf9b594668eb239e0823be3d966df937d700313d38d68cfc09db243d24d01b5115952cff2c904013285d1eaa93498f65cd25823bac3690ea1613e1b79918f6550cb9f779475815b203a1c6c0aec7389848883df5080442094090812526d5cc5cc9526b57c4d6c05c35f49ea8ed31b1eab13632b53e7fd1ae6486cccfd0f12a29c0cd12d26f371074c6212346c0d3496e17f43cef28c471f27efda27885cd5fa987948a77589844990175491d745b49b857c8284c62b9de5a89da372a101cf59b1de135c0fc0595b49eec50a1d83e44ccb8c3d99acf07fd41476916ef18f32b84551947a9d19269f864d4dd5192fc3525b88529be9a6f097f8e1625ba7e7a63a2f7eb1f567ca5bc62484717f87e0670b9cdd50a6dc6daf0acfbad251e751d6d9594f488541d4e3df05d0de1ad8bc32a21c704bd2de53f20f3f51df46d67641e139fefa1ecb10bf39fe64331152816b8ad6261f12afb872d6ceb5768b52fa235a71fccd73c3500c50c171407406702743ff8d231d6406d70836813c42c4fcee5703bcfd25fff475a8f648cf87a31031e04e656d1c2b9349d780e5ef17d1d354d9399f2f669fc25cd0d49c02376d6ff39314e254af26816f8c3b458499b577df2d941be0e11ad80d0ee2122588ecd71663c4ac26fcf0cb0944e9790b785d015686481e79a17dbfa9b6819fd0e13aca6f98be25c2544294b69d3d895e5b3ad436c51d896091d43b62b5df9de2d78c4c9e7ce780e74a5c222863ed67ebe99f76936950e3105b48620bebef1ba4c63b3b42df090873cc2e209a4e58ecc28df72ecf6c515598fab7a41a01678f6e1b9813f6a992bd7955aa954de54c0e080d66b454727d685ff44e6414cd50cd30b0b79a8104588c3f84100c765cd9783daa987d6ed2ee2f612ccf70bc76a151eb5fbd1cca51de262a790f2df71a8e160bbdaa7bf6d865c2d70d9e9eac47961a6bf9a2a12bd1f9e64fe9499de5069880b38c9ef9b49a67100123616eed81c1d66f4f0770a2d83220f1e815199e66bdf58555d52afd67a4d9d385412c4e685cd6629d2a9db947072b7712cd86fb84b944a27270d46efd74f099f4e689742dd09c04f2457791ac13bd6326263d20700f66cb7198347360cca1917dcf60b13ec63fe2aefd3999581dcfdca8dbd050967de6caa2a43bd300f99357ed9b01d80d22bdb7a26fe775c300c9fc7239fa8eb3f38fcb3ee67eeb16ac55a5d49ae7034ec55d32ea7165cab9688c91c28864e6d30c67dad0f5d95ed12c74a453176025a0e0b812ad3456102b5bce998066d47f599443ed0c57ac5b5ba9d7758ee3d7703fd833d7987f376ba7f23454dd4a0b7fb6c197a1b3786631f4b928c9b8327a60faefed546c05aab6fb42385e52b3edd579b555d2ae500198ba726c241b8e0b66898c188f9054bbcdec5e613c30228c72784b6ff62b3d976c308ebf3c063ea3dafb8a3623e341a8f2fefe395fd64c26f7a5905555db41ff050552ef0760c8c77238a8aa952a0bb8a623d1972fd0fb3b87fc5ccd10f6f70ae69ffe2e4421502882fc037ec0d54c000ae715418672392a5e32d0d95e5cc991682227525ce8cdfcdc9681d8c3f5e9200d5abda60579a7313fd6394ed1437700a95b9d88c36e4f873f3392f231bb8580bf139cb2f27dfba58b60079fa84f7d58b88a411f7b7b8c8dbc62092a4732c2f833ded758178f4fc7fad13a8056d6a9121086156d17ce51da1bd713ea94670063c413558a5c0467e1a072c473a29669fc76d7bd5f6324331542c58b059c9cc1074ba6c618394bb55a74e2f2cdc80dca372e4f911998b01234ac2d2626aff8fbf66c3a28f5aabcfa914e29b3da1c98f5115a735fa4b093d68df20bfae5cd20b4ab2ede0f828d92067f1adf5a4e36f085d24f25096f6a884a46fecad879517260b26eabb5803a2977b8f0ef6439984192700b69bc549ebfca15ff35142e54ed253ff7e5189a89bf33de28ddb95a40cbf8e89fbfaae18c11b5e10fa4a9b252df66d1a3fe4a41b14a61473dfb70ed6ab7367c383a33f81e35b40e2b3c4cc9ec45bb18bbf2f27073261de7c2c1a408eec6fb836646f9e7cebbed3acb38c9c5cee03dda20e1598a53a9f5d250d67845064e4fdd73e2d4675f9101651c171ee4708d3a9f7b023ae0a6a59606ba59ac95680988ce41179bbeab</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">年级大会，毕业相关事项</summary>
    
    
    
    <category term="其他内容" scheme="https://blog.slks.xyz/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>DFS系列——DFS多种形式变体整理</title>
    <link href="https://blog.slks.xyz/2022/02/26/3e00524469fb/"/>
    <id>https://blog.slks.xyz/2022/02/26/3e00524469fb/</id>
    <published>2022-02-26T03:06:19.000Z</published>
    <updated>2022-02-26T02:48:09.078Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-080.-含有-k-个元素的组合"><a href="https://leetcode-cn.com/problems/uUsW3B/">剑指 Offer II 080. 含有 k 个元素的组合</a></h4><p>​ 给定两个整数 <code>n</code> 和 <code>k</code>，返回 <code>1 ... n</code> 中所有可能的 <code>k</code> 个数的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">输入: n = 4, k = 2</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">  [2,4],</span><br><span class="line">  [3,4],</span><br><span class="line">  [2,3],</span><br><span class="line">  [1,2],</span><br><span class="line">  [1,3],</span><br><span class="line">  [1,4],</span><br><span class="line">]</span><br></pre></td></tr></table></figure><h5 id="解题思路">解题思路：</h5><p>​ 该题是最经典的无限制的DFS，注意剪枝来降低整体的时间复杂度。</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    <span class="keyword">int</span> k;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combine</span>(<span class="keyword">int</span> n, <span class="keyword">int</span> k) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="keyword">this</span>-&gt;k = k;</span><br><span class="line">        <span class="keyword">this</span>-&gt;n = n;</span><br><span class="line">        <span class="built_in">permute</span>(tmp,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> curr,<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">        <span class="comment">//curr代表当前 轮到的数字</span></span><br><span class="line">        <span class="comment">//count代表当前已经 放入集合中的数字个数</span></span><br><span class="line">        <span class="keyword">if</span>(count &gt; k) <span class="keyword">return</span>; <span class="comment">//剪枝</span></span><br><span class="line">        <span class="keyword">if</span>(curr == n+<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(count == k)&#123;</span><br><span class="line">                <span class="comment">//这轮完结了，将tmp添加进入curr中</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历两种情况 ： 要不要这个数字</span></span><br><span class="line">        <span class="comment">//Case1: 要这个数字</span></span><br><span class="line">        tmp.<span class="built_in">push_back</span>(curr);</span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count+<span class="number">1</span>);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Case2: 不要这个数字</span></span><br><span class="line">        <span class="built_in">permute</span>(tmp,curr+<span class="number">1</span>,count);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-081.-允许重复选择元素的组合"><a href="https://leetcode-cn.com/problems/Ygoe9J/">剑指 Offer II 081. 允许重复选择元素的组合</a></h4><p>​ 给定一个无重复元素的正整数数组 candidates 和一个正整数 target ，找出 candidates 中所有可以使数字和为目标数 target 的唯一组合。</p><p>​ candidates 中的数字可以无限制重复被选取。如果至少一个所选数字数量不同，则两种组合是不同的。</p><p>​ 对于给定的输入，保证和为 target 的唯一组合数少于 150 个。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [2,3,6,7], target = 7</span><br><span class="line">输出: [[7],[2,2,3]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-1">解题思路：</h5><p>​ 相比于上一题而言，该题允许重复选择元素，大致框架类似，但是在DFS的过程中，分支的选项需要改变，同样也是选择当前元素和不选择当前元素两条分支，之前无论选不选当前元素，下一轮递归的时候都会去判断下一个元素，而在本题中，如果选择当前元素，那么下一轮递归还应该是本元素。</p><h5 id="解题代码-1">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">        <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">        tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr);</span><br><span class="line">        tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-082.-含有重复元素集合的组合"><a href="https://leetcode-cn.com/problems/4sjJUc/">剑指 Offer II 082. 含有重复元素集合的组合</a></h4><p>​ 给定一个可能有重复数字的整数数组 candidates 和一个目标数 target ，找出 candidates 中所有可以使数字和为 target 的组合。</p><p>​ candidates 中的每个数字在每个组合中只能使用一次，解集不能包含重复的组合。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入: candidates = [10,1,2,7,6,1,5], target = 8,</span><br><span class="line">输出:</span><br><span class="line">[</span><br><span class="line">    [1,1,6],</span><br><span class="line">    [1,2,5],</span><br><span class="line">    [1,7],</span><br><span class="line">    [2,6]</span><br><span class="line">]</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="解题思路-2">解题思路：</h5><p>​ 本题跟上题不一样的点在于：本题每个元素都只能使用一次，但是可选的元素数组中会出现重复的元素，这也就意味着如果按照正常的DFS下来，是会出现重复的组合的。此处，我们按照如下思想来处理：</p><p>​ 我们先将它提供的整数数组进行排序，使其成为有序的数组。</p><p>​ 每一轮DFS的时候，记录上一轮有没有选择元素</p><ul><li><p>如果上一轮没有选择元素，并且当前元素和上一轮元素一样：那么该轮也只能选择 “不选择当前元素”，原因是如果两轮元素一致，"上一轮没选这一轮选了"，那么势必会和 "上一轮选了，这一轮不选"，这种情况产生重复。</p></li><li><p>如果上一轮选择了元素，那么该轮就可以正常操作：可以选择当前元素，也可以不选择当前元素。</p></li></ul><h5 id="解题代码-2">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">combinationSum2</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(candidates.<span class="built_in">begin</span>(),candidates.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">permute</span>(candidates,target,tmp,<span class="number">0</span>,<span class="number">0</span>,<span class="literal">true</span>);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">permute</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; candidates,<span class="keyword">int</span> target,vector&lt;<span class="keyword">int</span>&gt; &amp;tmp,<span class="keyword">int</span> sum,<span class="keyword">int</span> curr,<span class="keyword">bool</span> choose)</span></span>&#123;</span><br><span class="line">        <span class="comment">//当前vector，当前sum</span></span><br><span class="line">        <span class="keyword">if</span>(sum == target)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= candidates.<span class="built_in">size</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curr &gt;= <span class="number">1</span> &amp;&amp; candidates[curr] == candidates[curr<span class="number">-1</span>] &amp;&amp; !choose)&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="comment">//Case1: 不选择当前元素：</span></span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum,curr+<span class="number">1</span>,<span class="literal">false</span>);  </span><br><span class="line"></span><br><span class="line">            <span class="comment">// Case2: 选择当前元素：</span></span><br><span class="line">            <span class="keyword">if</span>(sum + candidates[curr] &gt; target) <span class="keyword">return</span>;</span><br><span class="line">            tmp.<span class="built_in">push_back</span>(candidates[curr]);</span><br><span class="line">            <span class="built_in">permute</span>(candidates,target,tmp,sum + candidates[curr],curr+<span class="number">1</span>,<span class="literal">true</span>);</span><br><span class="line">            tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-083.-没有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/VvJkup/">剑指 Offer II 083. 没有重复元素集合的全排列</a></h4><p>给定一个不含重复数字的整数数组 nums ，返回其 所有可能的全排列 。可以 按任意顺序 返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3]</span><br><span class="line">输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 6-10 &lt;= nums[i] &lt;= 10nums 中的所有整数 互不相同</code></pre><h5 id="解题思路-3">解题思路：</h5><p>​ 本题跟直接求1-n这n个数的全排列是一样的思想，基本就是每一轮确定第curr个数是什么，如果<code>curr==nums.size()</code>就输出该种可能。并且我们需要一个<code>hasInclude[]</code>数组记录，某个数有没有被访问过。</p><h5 id="解题代码-3">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-084.-含有重复元素集合的全排列"><a href="https://leetcode-cn.com/problems/7p8L0Z/">剑指 Offer II 084. 含有重复元素集合的全排列</a></h4><p>给定一个可包含重复数字的整数集合 nums ，按任意顺序 返回它所有不重复的全排列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：</span><br><span class="line">[[1,1,2],</span><br><span class="line"> [1,2,1],</span><br><span class="line"> [2,1,1]]</span><br></pre></td></tr></table></figure><h5 id="解题思路-4">解题思路：</h5><p>​ 084这题相对于083而言，就像是082相对于081而言，多了一个重复元素。我们就需要排除重复的信息。一种朴素的想法是，用hash表记录每一个全排列的情况，然后每产生一个全排列就去Hash表里找有没有一样的，这是一种方法，但时间复杂度肯定较高。</p><p>​ 比较优化的方法思想其实和082相似，也是需要先对数组进行排序，得到有序的nums.</p><p>​ 我们在DFS的时候，如果当前元素和前面元素一样，并且前面的元素还没有被选择，那么该元素也不在本轮被选择。原因也和082一致，如果前面的元素没被选，而当前元素被选了，势必会和正常流程中，"前面元素选了，当前元素未选"的排列造成重复。所以只有当前面的元素已经被使用了，确定好位置了，后面的相同的元素才有机会被使用。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">permuteUnique</span>(vector&lt;<span class="keyword">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="keyword">bool</span>&gt; hasInclude;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            hasInclude.<span class="built_in">push_back</span>(<span class="literal">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;<span class="keyword">int</span>&gt; tmp;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(),nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,tmp,nums,hasInclude,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> curr,vector&lt;<span class="keyword">int</span>&gt;&amp; tmp,vector&lt;<span class="keyword">int</span>&gt;&amp; nums,vector&lt;<span class="keyword">bool</span>&gt; &amp;hasInclude,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//确定第curr个数是什么</span></span><br><span class="line">        <span class="keyword">if</span>(curr == nums.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="comment">//代表到底了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= <span class="number">1</span> &amp;&amp; nums[i] == nums[i<span class="number">-1</span>] &amp;&amp; !hasInclude[i<span class="number">-1</span>])&#123;</span><br><span class="line">                <span class="comment">//前面元素和当前一样，并且前面的元素还没用掉，直接不选跳过</span></span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(!hasInclude[i])&#123;</span><br><span class="line">                hasInclude[i] = <span class="literal">true</span>;</span><br><span class="line">                tmp.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                <span class="built_in">dfs</span>(curr+<span class="number">1</span>,tmp,nums,hasInclude,res);</span><br><span class="line">                tmp.<span class="built_in">pop_back</span>();</span><br><span class="line">                hasInclude[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-085.-生成匹配的括号"><a href="https://leetcode-cn.com/problems/IDBivT/">剑指 Offer II 085. 生成匹配的括号</a></h4><p>正整数 <code>n</code> 代表生成括号的对数，请设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：n = 3</span><br><span class="line">输出：[&quot;((()))&quot;,&quot;(()())&quot;,&quot;(())()&quot;,&quot;()(())&quot;,&quot;()()()&quot;]</span><br></pre></td></tr></table></figure><h5 id="解题思路-5">解题思路：</h5><p>​ 这是一道比较有趣的DFS的题目，DFS分支的条件比较难想，整体代码较为简单。</p><p>​ 要想清楚，为什么此处我仅用两个Case就可以完成DFS分支的遍历，在最终输出的时候又做了哪些操作。</p><h5 id="解题代码-4">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        string tmp;</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>,n,tmp,res);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> left_curr,<span class="keyword">int</span> right_curr,<span class="keyword">int</span> n,string tmp,vector&lt;string&gt; &amp;res)</span></span>&#123;</span><br><span class="line">        <span class="comment">//left_curr当前加到第几个（了，right_curr 代表已经加了几个 ）</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr == n)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=right_curr;i&lt;n;i++)&#123;</span><br><span class="line">                tmp += <span class="string">&quot;)&quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//Case1: 仅加左括号</span></span><br><span class="line">        <span class="keyword">if</span>(left_curr &lt; n) <span class="built_in">dfs</span>(left_curr+<span class="number">1</span>,right_curr,n,tmp+<span class="string">&quot;(&quot;</span>,res);</span><br><span class="line">        <span class="comment">//Case2: 加一对右括号</span></span><br><span class="line">        <span class="keyword">if</span>(right_curr &lt; left_curr &amp;&amp; right_curr &lt; n) <span class="built_in">dfs</span>(left_curr,right_curr+<span class="number">1</span>,n,tmp+<span class="string">&quot;)&quot;</span>,res);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">包含几道经典DFS类型的题目，难度都不是很高，可以用于练手</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="DFS" scheme="https://blog.slks.xyz/tags/DFS/"/>
    
  </entry>
  
  <entry>
    <title>图系列——重建序列</title>
    <link href="https://blog.slks.xyz/2022/02/26/16bfad4011e0/"/>
    <id>https://blog.slks.xyz/2022/02/26/16bfad4011e0/</id>
    <published>2022-02-26T02:50:19.000Z</published>
    <updated>2022-02-26T02:57:50.418Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-115.-重建序列"><a href="https://leetcode-cn.com/problems/ur2n8P/">剑指 Offer II 115. 重建序列</a></h4><p>请判断原始的序列 org 是否可以从序列集 seqs 中唯一地 重建 。</p><p>序列 org 是 1 到 n 整数的排列，其中 1 ≤ n ≤ 10^4。重建 是指在序列集 seqs 中构建最短的公共超序列，即 seqs 中的任意序列都是该最短序列的子序列。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3]]</span><br><span class="line">输出: false</span><br><span class="line">解释：[1,2,3] 不是可以被重建的唯一的序列，因为 [1,3,2] 也是一个合法的序列。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释：可以重建的序列只有 [1,2]。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: org = [1,2,3], seqs = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: true</span><br><span class="line">解释：序列 [1,2], [1,3] 和 [2,3] 可以被唯一地重建为原始的序列 [1,2,3]。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= n &lt;= 10^4org 是数字 1 到 n 的一个排列1 &lt;= segs[i].length &lt;= 10^5seqs[i][j] 是 32 位有符号整数</code></pre><h5 id="解题思路">解题思路：</h5><p>​ 本题与<a href="https://blog.slks.xyz/2022/02/25/4e6244e39183/">[外星文字典](https://blog.slks.xyz/2022/02/25/4e6244e39183/)</a> 相似，都是通过序列seqs获取拓扑排序信息，然后依据拓扑排序，观察是否与org一致，从而达到题目要求目的。具体可以参照官方思路，本题因为已经过了一刷测试点，仅在此记录</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">sequenceReconstruction</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; org, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; seqs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = org.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">// 边集</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">edges</span>(n + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 入度</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="comment">// 记录seqs中的结点，可能有不在org里的这时候就要停了返回false</span></span><br><span class="line">        <span class="comment">// org 是一定是数字 1 到 n 的一个排列， 但seqs很自由</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">nodes</span><span class="params">(n + <span class="number">1</span>)</span></span>; </span><br><span class="line">        <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">const</span> vector&lt;<span class="keyword">int</span>&gt;&amp; seq : seqs) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; seq.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="comment">// 不再org范围了</span></span><br><span class="line">                <span class="keyword">if</span> (seq[i] &lt; <span class="number">0</span> || seq[i] &gt; n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="comment">// 记录出现结点数</span></span><br><span class="line">                <span class="keyword">if</span> (++nodes[seq[i]] == <span class="number">1</span>) cnt++;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                edges[seq[i - <span class="number">1</span>]].<span class="built_in">push_back</span>(seq[i]);</span><br><span class="line">                inDegree[seq[i]]++;</span><br><span class="line">            &#125;            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 结点数不同</span></span><br><span class="line">        <span class="keyword">if</span> (cnt != n) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">// 用队列和栈都可</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">if</span> (inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="comment">// 队列中有2个以上结点，就有2种以上可能不唯一了</span></span><br><span class="line">            <span class="keyword">if</span> (q.<span class="built_in">size</span>() &gt; <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            <span class="keyword">int</span> node = q.<span class="built_in">front</span>();</span><br><span class="line">            <span class="keyword">if</span> (org[index] != node) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            index++;   </span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= edges[node].<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> (--inDegree[edges[node][i - <span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                    q.<span class="built_in">push</span>(edges[node][i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index == n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，图的综合应用。一刷已过所有点，只是题目比较经典且综合，里面也有一些较坑的测试点，值得二刷，故在此记录</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="topological sort" scheme="https://blog.slks.xyz/tags/topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——值和下标之差都在给定范围内</title>
    <link href="https://blog.slks.xyz/2022/02/26/994b03ade281/"/>
    <id>https://blog.slks.xyz/2022/02/26/994b03ade281/</id>
    <published>2022-02-26T02:09:19.000Z</published>
    <updated>2022-02-26T02:22:32.934Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-057.-值和下标之差都在给定的范围内"><a href="https://leetcode-cn.com/problems/7WqeDu/">剑指 Offer II 057. 值和下标之差都在给定的范围内</a></h4><p>​ 给你一个整数数组 nums 和两个整数 k 和 t 。请你判断是否存在 两个不同下标 i 和 j，使得 abs(nums[i] - nums[j]) &lt;= t ，同时又满足 abs(i - j) &lt;= k 。</p><p>​ 如果存在则返回 true，不存在返回 false。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3,1], k = 3, t = 0</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,0,1,1], k = 1, t = 2</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,5,9,1,5,9], k = 2, t = 3</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>0 &lt;= nums.length &lt;= 2 * 10^4-2^31 &lt;= nums[i] &lt;= 2^31 - 10 &lt;= k &lt;= 10^40 &lt;= t &lt;= 2^31 - 1</code></pre><p>参考官方题解：https://leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</p><p><strong>解题思路</strong>：</p><p>​ 对于序列中每一个元素x左侧的最多k个元素而言，如果这k个元素中存在一个元素落在区间<code>[x-t,x+t]</code>中，那么就可以找到一对符合条件的元素。<strong>注意到对于两个相邻的元素而言，它们左侧的k个元素中有k-1个是重合的，所以可以考虑滑动窗口的思路，维护一个大小为k的滑动窗口，每次遍历到元素x的时候，滑动窗口中包含x前面的k个元素，我们只需要检查窗口中是否有元素满足要求即可。</strong></p><p>​ 此时，问题就来了：<strong>如果使用队列维护滑动窗口内的元素，由于元素是无序的，我们只能对于每个元素都遍历一次队列来检查是否有元素符合条件。</strong>如果数组的长度为 n，则使用队列的时间复杂度为 O(nk)，这样跟暴力求解没有区别了。所以我们需要一个数据结构能够来用于维护滑动窗口，该容器需要满足：</p><ul><li>支持添加+删除元素</li><li>内部元素有序，我们可以快速判断是否有满足条件的元素。（具体而言，对于元素 x，当我们希望判断滑动窗口中是否存在某个数 y 落在区间 <code>[x - t, x + t]</code>中，只需要判断滑动窗口中所有大于等于 x−t 的元素中的最小元素是否小于等于 x+t 即可。</li></ul><p><strong>注意</strong></p><p>​ 如果当前有序集合中存在相同元素，那么此时程序将直接返回 true。因此本题中的有序集合无需处理相同元素的情况。</p><h5 id="官方解题代码">官方解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">containsNearbyAlmostDuplicate</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k, <span class="keyword">int</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; rec;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter = rec.<span class="built_in">lower_bound</span>(<span class="built_in">max</span>(nums[i], INT_MIN + t) - t);</span><br><span class="line">            <span class="keyword">if</span> (iter != rec.<span class="built_in">end</span>() &amp;&amp; *iter &lt;= <span class="built_in">min</span>(nums[i], INT_MAX - t) + t) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            rec.<span class="built_in">insert</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= k) &#123;</span><br><span class="line">                rec.<span class="built_in">erase</span>(nums[i - k]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/7WqeDu/solution/zhi-he-xia-biao-zhi-chai-du-zai-gei-ding-94ei/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">利用滑动窗口 + 有序集合的思想，优化一道数组系列相关的题目，加深对滑动窗口的理解，不仅仅局限于单一形式。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>图系列——外星文字典</title>
    <link href="https://blog.slks.xyz/2022/02/25/4e6244e39183/"/>
    <id>https://blog.slks.xyz/2022/02/25/4e6244e39183/</id>
    <published>2022-02-25T10:11:19.000Z</published>
    <updated>2022-02-25T10:16:13.611Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-114.-外星文字典"><a href="https://leetcode-cn.com/problems/Jf1JuT/">剑指 Offer II 114. 外星文字典</a></h4><p>现有一种使用英语字母的外星文语言，这门语言的字母顺序与英语顺序不同。</p><p>给定一个字符串列表 words ，作为这门语言的词典，words 中的字符串已经 按这门新语言的字母顺序进行了排序</p><p>请你根据该词典还原出此语言中已知的字母顺序，并 按字母递增顺序 排列。若不存在合法字母顺序，返回 "" 。若存在多种可能的合法字母顺序，返回其中 任意一种 顺序即可。</p><p>字符串 s 字典顺序小于 字符串 t 有两种情况：</p><ul><li>在第一个不同字母处，如果 s 中的字母在这门外星语言的字母顺序中位于 t 中字母之前，那么 s 的字典顺序小于 t 。</li><li>如果前面 min(s.length, t.length) 字母都相同，那么 s.length &lt; t.length 时，s 的字典顺序也小于 t 。</li></ul><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;wrt&quot;,&quot;wrf&quot;,&quot;er&quot;,&quot;ett&quot;,&quot;rftt&quot;]</span><br><span class="line">输出：&quot;wertf&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;]</span><br><span class="line">输出：&quot;zx&quot;</span><br></pre></td></tr></table></figure><p><strong>示例 3：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;z&quot;,&quot;x&quot;,&quot;z&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：不存在合法字母顺序，因此返回 &quot;&quot; 。</span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 还是比较容易想到 建图 + 拓扑排序的。整体而言复杂度较高，但是思路应该比较清晰，主要过程就是分为两步：1、建图，从相邻的单词之间获取信息 2、拓扑排序，得到结果。</p><p>​ 其中两个工具函数比较重要：<strong>一个是常见的transform函数</strong>，能够以O(1)的时间复杂度，用哈希表给每个字符赋予一个ID，方便后续进行拓扑排序。<strong>另一个就是getInfo函数</strong>，其接受两个字符串s1和s2，已知s1&lt;s2的情况下，返回一个<code>vector&lt;char&gt;</code>，第一位代表状态，第二三位代表其能够从中得到的字符字典序信息。具体见代码注释：</p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;<span class="keyword">char</span>,<span class="keyword">int</span>&gt; char2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">char</span>&gt; int2char;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(<span class="keyword">char</span> c)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(char2int.<span class="built_in">find</span>(c) == char2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            char2int[c] = char2int.<span class="built_in">size</span>();</span><br><span class="line">            int2char[char2int.<span class="built_in">size</span>() - <span class="number">1</span>] = c;</span><br><span class="line">            <span class="keyword">return</span> char2int.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> char2int[c];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">string <span class="title">alienOrder</span><span class="params">(vector&lt;string&gt;&amp; words)</span> </span>&#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(<span class="number">26</span>);</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">bool</span>&gt; <span class="title">isVisited</span><span class="params">(<span class="number">26</span>*<span class="number">26</span>,<span class="literal">false</span>)</span></span>;</span><br><span class="line">        <span class="comment">//先把所有字符添加进去</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;words[i].<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">                <span class="built_in">transform</span>(words[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;words.<span class="built_in">size</span>()<span class="number">-1</span>;i++)&#123;</span><br><span class="line">            vector&lt;<span class="keyword">char</span>&gt; t = <span class="built_in">getInfo</span>(words[i],words[i+<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;2&#x27;</span>) <span class="keyword">continue</span>;  <span class="comment">// 仅长度不一样，无信息</span></span><br><span class="line">            <span class="keyword">if</span>(t[<span class="number">0</span>] == <span class="string">&#x27;0&#x27;</span>) <span class="keyword">return</span> <span class="string">&quot;&quot;</span>; <span class="comment">//直接不需要后续的操作了，因为已经违反规则了</span></span><br><span class="line">            <span class="comment">// t[1] &lt; t[2] , 构建图 , t[1] -&gt; t[2]</span></span><br><span class="line">            <span class="keyword">int</span> idx1 = <span class="built_in">transform</span>(t[<span class="number">1</span>]);</span><br><span class="line">            <span class="keyword">int</span> idx2 = <span class="built_in">transform</span>(t[<span class="number">2</span>]);</span><br><span class="line">            <span class="keyword">if</span>(!isVisited[idx1 * <span class="number">26</span> + idx2])&#123;  <span class="comment">//用于记录 idx1-&gt;idx2这个关系有没有添加过</span></span><br><span class="line">                isVisited[idx1 * <span class="number">26</span> + idx2] = <span class="literal">true</span>;</span><br><span class="line">                graph[idx1].<span class="built_in">push_back</span>(idx2);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//拓扑排序：</span></span><br><span class="line">        <span class="keyword">int</span> n = char2int.<span class="built_in">size</span>(); <span class="comment">// 节点个数</span></span><br><span class="line">        <span class="comment">// 如果图中有环，则不存在合理的情况 拓扑排序会失败。节点数不=n</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">inDegree</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="comment">//遍历每一个节点，计算入度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[i].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[i][j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对于所有入度为0的节点入队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(inDegree[i] == <span class="number">0</span>) q.<span class="built_in">push</span>(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            res += int2char[curr];</span><br><span class="line">            count++;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;graph[curr].<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                inDegree[graph[curr][j]]--;</span><br><span class="line">                <span class="keyword">if</span>(inDegree[graph[curr][j]] == <span class="number">0</span>) q.<span class="built_in">push</span>(graph[curr][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count == n) <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="string">&quot;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">char</span>&gt; <span class="title">getInfo</span><span class="params">(string &amp;s1,string &amp;s2)</span></span>&#123;</span><br><span class="line">        <span class="comment">// 该函数用于返回从字符串s1&lt;s2这个信息中获得的有用信息，第一位为状态判断位，供函数调用者判断状态</span></span><br><span class="line">        <span class="comment">// 0 - 代表排序有误：该状态代表 s1比s2长，且公共部分内容相同，但是却判断s1&lt;s2，调用者遇到此状态上层可直接返回不合理即可。</span></span><br><span class="line">        <span class="comment">// 1 - 代表有可用信息: t[1] 在 t[2] 前面</span></span><br><span class="line">        <span class="comment">// 2 - 代表无可用信息，代表 s1&lt;s2 仅因为长度不同导致，无法获取字符的前后顺序</span></span><br><span class="line">        vector&lt;<span class="keyword">char</span>&gt; res;</span><br><span class="line">        <span class="keyword">int</span> len1 = s1.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> len2 = s2.<span class="built_in">length</span>();</span><br><span class="line">        <span class="keyword">int</span> min_len = <span class="built_in">min</span>(len1,len2);</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;min_len;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s1[i] != s2[i])&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(<span class="string">&#x27;1&#x27;</span>);   <span class="comment">//第一位为状态判断位 1-代表有可用信息</span></span><br><span class="line">                res.<span class="built_in">push_back</span>(s1[i]);</span><br><span class="line">                res.<span class="built_in">push_back</span>(s2[i]);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &gt; len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            <span class="comment">//如果s1比s2长，且在公共部分没找到内容的话，已经就不可能了</span></span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;0&#x27;</span>); <span class="comment">//第一位为状态判断位 0-代表有信息：这个信息告诉我们排序已经不可能了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(len1 &lt;= len2 &amp;&amp; !flag)&#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(<span class="string">&#x27;2&#x27;</span>); <span class="comment">//第一位为状态判断位 2-代表无有用信息</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;  </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道困难难度的LeetCode算法题，图的综合应用。一刷已过所有点，只是题目比较经典且综合，里面也有一些较坑的测试点，值得二刷，故在此记录</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="topological sort" scheme="https://blog.slks.xyz/tags/topological-sort/"/>
    
  </entry>
  
  <entry>
    <title>BFS系列——单词演变(困难)</title>
    <link href="https://blog.slks.xyz/2022/02/24/64f7eff00abc/"/>
    <id>https://blog.slks.xyz/2022/02/24/64f7eff00abc/</id>
    <published>2022-02-24T15:09:19.000Z</published>
    <updated>2022-02-24T15:37:00.021Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-108.-单词演变"><a href="https://leetcode-cn.com/problems/om3reC/">剑指 Offer II 108. 单词演变</a></h4><p>在字典（单词列表） wordList 中，从单词 beginWord 和 endWord 的 转换序列 是一个按下述规格形成的序列：</p><pre><code>序列中第一个单词是 beginWord 。序列中最后一个单词是 endWord 。每次转换只能改变一个字母。转换过程中的中间单词必须是字典 wordList 中的单词。</code></pre><p>​ 给定两个长度相同但内容不同的单词 beginWord 和 endWord 和一个字典 wordList ，找到从 beginWord 到 endWord 的 最短转换序列 中的 单词数目 。如果不存在这样的转换序列，返回 0。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;,&quot;cog&quot;]</span><br><span class="line">输出：5</span><br><span class="line">解释：一个最短转换序列是 &quot;hit&quot; -&gt; &quot;hot&quot; -&gt; &quot;dot&quot; -&gt; &quot;dog&quot; -&gt; &quot;cog&quot;, 返回它的长度 5。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：beginWord = &quot;hit&quot;, endWord = &quot;cog&quot;, wordList = [&quot;hot&quot;,&quot;dot&quot;,&quot;dog&quot;,&quot;lot&quot;,&quot;log&quot;]</span><br><span class="line">输出：0</span><br><span class="line">解释：endWord &quot;cog&quot; 不在字典中，所以无法进行转换。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= beginWord.length &lt;= 10endWord.length == beginWord.length1 &lt;= wordList.length &lt;= 5000wordList[i].length == beginWord.lengthbeginWord、endWord 和 wordList[i] 由小写英文字母组成beginWord != endWordwordList 中的所有字符串 互不相同</code></pre><p>来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/om3reC 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 题目本身还是比较好理解的，最开始的思路也比较好想，就是将一个个单词赋予ID（使用Hash表），然后根据邻居关系建图，在知道起点与终点的情况下进行BFS即可。值得注意的点是：该题目作为一道困难的题目，时间限制卡的还是比较紧的。我们来看一下上述过程中可能耗费时间比较长的步骤：</p><ul><li>1、在建立图的时候，要判断单词与单词之间是不是邻居，就需要比较每个单词和每个单词是否只相差一个字母，时间复杂度为O(n^2 * C) , n为单词数量，C为单词长度。</li><li>2、在BFS搜索的时候，由于wordList长度上限为5000，整体来说还是比较大的一个图，需要耗费一定的时间。</li></ul><p>​ 针对上述两个点，都有对应得优化算法，比较经典的就是用于替代单向BFS的<strong>双向BFS</strong>，可以大大缩短BFS的搜寻时间。<strong>我最开始就是做了双向BFS的优化，但是还是超时了。超时代码如下：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isNeighbor</span><span class="params">(<span class="keyword">int</span> idx1,<span class="keyword">int</span> idx2)</span></span>&#123;</span><br><span class="line">        string str1 = int2str[idx1];</span><br><span class="line">        string str2 = int2str[idx2];</span><br><span class="line">        <span class="keyword">if</span>(str1.<span class="built_in">length</span>() != str2.<span class="built_in">length</span>()) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;str1.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(str1[i] != str2[i]) count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(count != <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,end))&#123;</span><br><span class="line">            graph[begin].<span class="built_in">push_back</span>(end);</span><br><span class="line">            graph[end].<span class="built_in">push_back</span>(begin);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//构建图</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="comment">//对于每个word均判断其和begin 或是 end是不是邻居，以及判断其和前面的wordList中的word是不是邻居</span></span><br><span class="line">            <span class="keyword">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(begin,wordIdx))&#123;</span><br><span class="line">                graph[begin].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(begin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(end,wordIdx))&#123;</span><br><span class="line">                graph[end].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                graph[wordIdx].<span class="built_in">push_back</span>(end);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> wordIdx2 = <span class="built_in">transform</span>(wordList[j]);</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isNeighbor</span>(wordIdx2,wordIdx))&#123;</span><br><span class="line">                    graph[wordIdx2].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">                    graph[wordIdx].<span class="built_in">push_back</span>(wordIdx2);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;graph.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[idx] + res[graph[idx][i]] + <span class="number">1</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>​ 针对于另外一个可优化的点，其实先前博客中也记录过，针对于这种仅差一个字符的字符串相似的情况，我们叫做“字符串的广义邻居”，在该文章中提及过：<a href="https://blog.slks.xyz/2022/02/08/4ccc50ba5a4e">奇妙应用—字符串的广义邻居</a></p><p>​ 在建图阶段，依据朴素的思路，就是像上面的代码一样枚举每一对单词的组合，判断它们是否恰好相差一个字符，以判断这两个单词对应的节点是否能够相连。但是这样效率太低，我们可以<strong>优化建图</strong>。</p><p>​ <strong>具体地，我们可以创建虚拟节点。对于单词 hit，我们创建三个虚拟节点<code>*it、h*t、hi*</code>，并让 hit 向这三个虚拟节点分别连一条边即可。如果一个单词能够转化为 hit，那么该单词必然会连接到这三个虚拟节点之一。对于每一个单词，我们枚举它连接到的虚拟节点，把该单词对应的 id 与这些虚拟节点对应的 id 相连即可。</strong></p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map&lt;string,<span class="keyword">int</span>&gt; str2int;</span><br><span class="line">    unordered_map&lt;<span class="keyword">int</span>,string&gt; int2str;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">transform</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(str2int.<span class="built_in">find</span>(str) == str2int.<span class="built_in">end</span>())&#123;</span><br><span class="line">            str2int[str] = str2int.<span class="built_in">size</span>();</span><br><span class="line">            int2str[str2int.<span class="built_in">size</span>()<span class="number">-1</span>] = str;</span><br><span class="line">            <span class="keyword">return</span> str2int.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> str2int[str];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">constructNode</span><span class="params">(<span class="keyword">int</span> wordIdx, vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; &amp;graph)</span></span>&#123;</span><br><span class="line">        <span class="comment">//构建字符串word的广义邻居（虚拟节点），让其和自己的真实节点相连</span></span><br><span class="line">        <span class="comment">//例如 word = dog ，那么构建广义邻居节点 *og,d*g,do*,让这三个节点和 dog节点相连</span></span><br><span class="line">        string word = int2str[wordIdx];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;word.<span class="built_in">length</span>();j++)&#123;</span><br><span class="line">            <span class="comment">//将每一位变成*，形成虚拟节点,和当前节点连接</span></span><br><span class="line">            string tmp = word;</span><br><span class="line">            tmp[j] = <span class="string">&#x27;*&#x27;</span>;</span><br><span class="line">            <span class="keyword">int</span> tmpIdx = <span class="built_in">transform</span>(tmp);</span><br><span class="line">            graph[tmpIdx].<span class="built_in">push_back</span>(wordIdx);</span><br><span class="line">            graph[wordIdx].<span class="built_in">push_back</span>(tmpIdx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ladderLength</span><span class="params">(string beginWord, string endWord, vector&lt;string&gt;&amp; wordList)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 先将所有的原始字符串加入Hash表中</span></span><br><span class="line">        <span class="keyword">int</span> begin = <span class="built_in">transform</span>(beginWord);</span><br><span class="line">        <span class="keyword">int</span> end = <span class="built_in">transform</span>(endWord);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++) <span class="built_in">transform</span>(wordList[i]);</span><br><span class="line">        <span class="comment">// 按照最坏情况分配空间</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">graph</span>(str2int.<span class="built_in">size</span>() * (wordList[<span class="number">0</span>].<span class="built_in">length</span>() + <span class="number">1</span>));   </span><br><span class="line">        <span class="comment">// 构建图，对于每一个节点，构建其的广义邻居以及自己的节点连接关系</span></span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="built_in">constructNode</span>(begin,graph);</span><br><span class="line">        <span class="built_in">constructNode</span>(end,graph);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;wordList.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> wordIdx = <span class="built_in">transform</span>(wordList[i]); </span><br><span class="line">            <span class="keyword">if</span>(wordIdx == end) flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(wordIdx == begin || wordIdx == end) <span class="keyword">continue</span>;  <span class="comment">//如果是beginWord或endWord就不需要处理了，已经处理过</span></span><br><span class="line">            <span class="built_in">constructNode</span>(wordIdx,graph);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>; <span class="comment">//如果终点不在列表中，则直接返回0</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 输出图代码，证明图构建正确</span></span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;str2int.size();i++)&#123;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; i &lt;&lt; &quot;-&quot; &lt;&lt; int2str[i] &lt;&lt; &quot; :&quot;;</span></span><br><span class="line">        <span class="comment">//     for(int j=0;j&lt;graph[i].size();j++)&#123;</span></span><br><span class="line">        <span class="comment">//         cout &lt;&lt; graph[i][j] &lt;&lt; &quot; &quot;;</span></span><br><span class="line">        <span class="comment">//     &#125;</span></span><br><span class="line">        <span class="comment">//     cout &lt;&lt; endl;</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//双向BFS</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vis</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(str2int.size())</span></span>;</span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q1; <span class="comment">//正向队列</span></span><br><span class="line">        queue&lt;<span class="keyword">int</span>&gt; q2; <span class="comment">//逆向队列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(begin);</span><br><span class="line">        q2.<span class="built_in">push</span>(end);</span><br><span class="line">        res[begin] = <span class="number">0</span>;</span><br><span class="line">        res[end] = <span class="number">0</span>;</span><br><span class="line">        vis[begin] = <span class="number">1</span>;</span><br><span class="line">        vis[end] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> idx;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;  <span class="comment">// 正向BFS</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                idx = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                idx = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;graph[idx].<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="comment">//入队</span></span><br><span class="line">                <span class="keyword">if</span>(vis[graph[idx][i]] == <span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//没访问过</span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(graph[idx][i]);</span><br><span class="line">                    res[graph[idx][i]] = res[idx] + <span class="number">1</span>;</span><br><span class="line">                    vis[graph[idx][i]] = vis[idx];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">if</span>(vis[graph[idx][i]]  + vis[idx] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="built_in"><span class="keyword">return</span></span> (res[idx] + res[graph[idx][i]] + <span class="number">1</span>) / <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">               </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，结合了字符串与BFS的优化技巧</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    <category term="字符串系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>则观云资源需求与分析</title>
    <link href="https://blog.slks.xyz/2022/02/24/7bbac004599f/"/>
    <id>https://blog.slks.xyz/2022/02/24/7bbac004599f/</id>
    <published>2022-02-24T13:52:19.000Z</published>
    <updated>2022-02-24T06:10:23.121Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="92a676e4bf82b4ce655ae5f31439de166224bfa67d2018f3a6874d694d565ab8">873f131ca1ff7e2c43970aa30a8cbe91558e1bd1b27fe5e295778a23f5da27616d05821cace9112a2c38b7c04f815fdea3db87b6c532f12ef5353821928ce95ac46291d124793317a1f1f9e02ad583463dbd72bc42dfcb0dde2aa116c317c374b95af43dc0935a8acaf6d034d929b1b7594462dcf6fa52d4553b14de2d3dd99ecc7bf7cfcfe66ae8227f5201a9b0126e951c2374f9588b69f2b6e1bf8d26c5470daa021e03c63b1e825c82cb726e502b8bf4865e61bfb182c9be8b992d2d4ecae5de513bb443eaeed4c1ea4f27ba47e21b9fe58c7382ba60b6f988c903c1ae425c57c4c5d583868a3089d70c066a51be942b2e1d3dfd12b50072ae4dab1e1cd122b16a98b0069b2686874c965fe50567aa0115165fc1ca8b81f85e0a873902fce98586721b39b70ae4e8d274587deed909ca01a60cba498eb87db0aec31ec2f5e5f6dcca1d5ed6780f161f04704c592a841b86cd31bcd6e418455b1558ded93dd06581723a84a4ba49a8329d223d19ceecc8ce049322d2f5e629e47cddfbeff725497cfa6498c0968a033b8fc81f9db4f44606928ce91ff31c63b3110a6cab3aeff483b580bf04b914f9da79e787ba3198e9a7e0cf4894fb492e20cd779d8de600ae5ad178bd6688972a5771ab2d37111ba213bd466b2374a3c26805179b4db8c01e31881c09c959e0358cc3deff75bc12e77efc791719c1cf14a04ed8f1fc6367af8511d0b8d8a1611e25e312c6a05d9b2252d24860514e891a8c525345e7d0be49c9ce48d80364e9ec7bca02aa3cc45045b4e94b3d68d988f79b8ea11ed962fac772fb31fcdb991dcdb7efcdbe65f92b2e7d600f238208b3385937c0fcba710c0c137b265b290b92a2e50ffe435dcb23f2eb35f008362d0ea1b11fe500af633a47fa783220c440f67937ef136458ddcaa8989b974c8281419d7a5bd5169bcde03a6f64d6f9108dcd5e57cdec12cfee9de517141001a79ad2d2cdcf031939d641bef46ad2b27be8c48bd0f29cebcc340076dd567f4d5ef0e7cf533677b9c3dd54003184c89a5ae13278ffb81ab042065214e0a48c1e6c9b3ccd155d82ac4c6a63c3eab2667c95780c35656ae31f83589fa4212a300d27a2005dadb3c19c78ab75658c0833529f47d49474baa2c3c19f0bdb1f612292a7c4cfcb9d7c010fc692b257f4d492a81c81ed28db371613550211f14ba52b58a01f8d19a3c1a74a4b7c9987f00f611059b7fe54729851c1cac332b90089ac8269cd0b1c1312ae8448242cfcb154d85e4f379910119d1c385b81298a76d706e6cc654eccedec5e27ff29270c21a57368275bd89b7066a2bc0ee283103eef6e62821a01476b0a5c27f3c8d16f637715b9827596af8970d74df3e2f7a514ee651f9a42459c89188f8f956f67fc778bd5205a06fee0197c73e56745d0a2ebc66dab2789eb6bd927502043bd05423d7067c8481d349302cfae8a15551fc1f79a4a8553ee8e2564e656bcf4b4edd5dbf5af1b077a6e0b1b2981020f0922a9a26dd8a547bb74b13d1718b207020ed0563835e6bf01c8f68ba29b495c0ad495d505f3ae34dfd71e31740db77328c1faa3d8d900b824ecfd5416c433d0d700ce548f78095f9134a9cffe30dd1aa3b4aeaa76361447df9afb81a231a33c721f74ee744ae85ed883865c52c7f8e1bfa2b7541d765baa36750faef20463697922be08aa9240a8ce6b80b67eb0ee665cb92020ace19a19ba4baa0dc98a72acfefa32e20453c37e475689befb16b1c047e2b7e52cb4d1af4da83743c2ce21ec89634557eb9d3b1e0839511a1642a419df0e6b72c6b5c1c59eec789df90f33e775a0128e4cdff0e453883b6f8d2cca077a699d29d8da9026d46680a2d37165dd30bd02b5de4266fb7f3c32de224b7b1874e41a48d97512cb003f1712a26b13d94b2fdb0c004d96b664033d979f38c17166fc10c5ac6d1437239f8d611081b541dcb4db6f1e0a24fcc9f89666efccf5489505a99714987c0864e07ceef35de5d3ee84dcc5b38e6c597ed9beb928e9f166d7890698337575cf68793bf2390450826ba4257e801a55f06bda72cad153d6979b559da47a157010945f781f68b898b096a2f6579b1c7af14731d4d56b87ee3d07f41393c1466b8c0af3c72dfd0491b1fd5e9aa02b30f67780100939a0ce49a7074c92103cdfb83cda5be43ce6baf0c9e68851ef68dd9a0f6bbf84343a919a43ebb81c29ea4a989a5ac1eca1224e9ff2d359b10e2e2c4dcdb5bdea7affe21ac86378640de6629ef9426b739c9a21f0b27169babfe159d4335ccd4d9dcdbf457bb488bacd1a50809a2c55f24ec8e14f29b45fd9ba94212c5f2fb75625a1bc0008749771c952dbfe0cefa46803da0f40b2b65d73af109ba08795412e7dcf5b1d67b33868877afa5c15231f6f1faea4c2f165cb699aee503b83f3161bbf1e40d933b588e30f776dca0a65fcccb46b82b0a3c74abb2d3b8b85355fca879b4fe4bfca44bbcfc0f33af54a3e73350c0c78e5edbbb69f18ffa62afe1a6cbba26a7853eab94456fb8f4502fd6b0f5989cd8976b5ea73784311798608edfb5d42901fbd4234b050aa8736f6446a4ada332d4d680df973f816fecff2b0cad0720982471482a87583c05b0704c0dd7985910a4c0cd520238304e0f010b6640831f4698226f6c69a89c716c429184ff9de624211214fe617d7f75c723fd95f38272614817abf97c7c8813f6c2ad13b9374f58070c7be87bef0857ea5c643bed7b8e04dc9c4dbe7cff866d20102bef69df0e063ed4dd7bfcba78c57d6ee3a2d0d35ad4e1deb66d0a20394daa2e4b513ddbf1da224b1102cbb0c96ae634047b374bb6fa757722f40e6a4c132efb4e18c203d9ad2efc8e021d8e5cac3fb94fdb664171b5da57161800650859b4a47eb66450cdb50df7ef29877529905030821faecd7d1c73b772e782d86b659005aabc848b56a5f2749e4989786b2e0827e864b9cd6fc554b5a4b5cf346b5b5dfb5a83e74d1aefaba9cbcbf4cde7f22a4dce57c4a45a86f5c49f1fdfe1666771871bf5fae6c1f02b8526c27facf71067318ddda88e722acbd99fd631b6623f459edceecf24da5a9bf53519d4f3cf7b8bb3b6613ae862c585ccb286835363a574206fdecdc64b64240d4063af3abc9a1baf0b715556e7f4913a79da06d8d54554acc2bf0112fc77d402a5544d3bf3f3828d746b82c13983f74b398d5065aeff96a3eb6c039388f7b1c4c251b86c2d0bec7bc29d175abeda5fa0b414085d54fd9dfa96a18fd4a613806f5759a87d844d076a8f252fa04ab1be068b280c4527b2a932f800485736134a5cb6cee5e6e36319742ed6662b07939c81bb95d5b7e4bea40028f9fc045cdb832dc02c024d1f4b1d645faf95da4161cd887e1fd137fbccfd413d57e9c9d160ba4bf792af8fb829225d60237ae0ad20537f54204b574b4f41bc46a8c86eb6f9c830b5938e67566451bf32ec916d18a6199137b21e4416934e0ea3a78fdfb3722b9d9b8bbf1554254eb0f5c61858bd8a005a7a92e6e660054f30beef9027a3e0cbf251fc20970f28f2d304cd871fd405fda40310c19d6eb39a6d4af4f5eca4b9795426cf81128f8c12cdbf5a3b1f14955f6d36b33337fdd97d3901c08145e646163d20cfad67ac63120fffc59223a70ec6fe3c8ea90bc1665d3cade844fc245ae0157fa7c5fc539ef97f60cc05f2793dcd9170c6b8a0ce88301b86553c452679e38920425a7562471b4dad1e90c2595670f97cba295dcb4b65540cb7228b14a9260f18e5867ed46769d870e29522faf503267cc6c34279488c262ba8ef3b780fa51538fa5090cf1988ea3fe1c35761274a9052dff48e5cf2eec46b5536443e140572f39666ad08baf65eeaa5f7692b417773882d8855e17b2562ffe85f8ecbbd599fdb49731e673cb6fa057ab3b348bb97e43957d109dd896425e12c72a5ff594c5f0f22825e53ad672d3e03e4d72643fdbba60787be88c04aa78124a73927ebe7e10795370cb7f3462f6ee64733fafe7b7410ebfbdda4ca331e50b334a9e3bce9d332e3975b3b6e158886a67d6feea681c8b754cf66f51e1eb88b8af996bf2dea22f0326f736f01a1690fa6e0a3112987fb58e64389667fbf7847bae15cb972a1d10c183aeb23dfbf4393633fcd04fcd65d8da4718c1db9f6a6bc567c42dd38a6bfa34bf2d7319548f05267f393f2dede0e4ffa7f353c6ac0b56962eb67120696618ef12922d9ea6840c2550dd2ed1b7ca194e388e836588a35b6f7d4e51d04d5489f0e1d92eaa2a4cbe9284f74054cb9951c40c8833287bbf8c0cfa3172bf8a18b92c77d9525f4fd24359efe0fa1fe3fb6b22e5dbc0780ea5b1c51d162f347f99bd9fbf231e2fddc668fb50aeb747c5b3a5ed07e27e2b4982a0d909fbe784ceddbadab9a416d9bfc68c286d19c90556bf11caa409d4c29a5aa0b6371b7e0a3d85202edf78396b06335790ecb8c65e221f1b15c0f52ab81e42df7ecfe6abae83de28616f1b69d6e1dd36fe045f841bf3b70024ec2fdb139d383609ddade7d3061ebc8ebc69c10d758b014636979d0c244838e89b5fb49f180fff652675871c6fa348fc7151570f7c0f43409a5fec7b4d9c302181099f779e34ff2121b4f6d3d767f8673186a14d4506c68a41cb0d8fd2d66bdae89e2b17c23b2a2ffa13704a89c5c144cca8c5088115ed57f9a12a5c11ed2c4d54e59564a86f65ad0ea3c77302a33a350e539630e33c84eea5c2b5890ce21146e6036db5ab588fb6f2f2aa7b3b9df7042f6583e610228133f4450b9e7d98296e412e63ac08ca42f81d3f94c51d3554152eebb60c9c986b80a2867d58a539beb2333386190154df83ae35798c45e3923c4816eadd4a23478ed30fd0c5f6d90cabf2b7228c1e653b13b706383140b61fc17a6fd11a3b9f8c84fab9e6e7670306fe7f1b01819fac5e4fb0dd537769ffd55a932d7cd8252ce14087b3acf206b10668f4f539f2c9a3766aba8c483356f6c52112a43e1b0941b76813ce2fcc7af998c6a5ee7a2599478bcd947550bbff8c7237d23954036e624e3c09d960944b484568412de86d8a9893519ad07cb5fd55cc25eee31b4b2d6440d5622b0d633391cc94ac02bd9b26113b043fe3cb00de4aa0b9c953eba043d424e796e1bac8aed59dcc74961898be29e8d7548588dd7bef59e0d8dfa99bd0500aee2d227a34105937f32c0b081a00cd66cffe4fc5fbd646f6961e936658145f74ebe1d8e0291030f673c589ee6193f909f10ac088ca51fe06bb77a1fdd4c38b8018a71c17f520120f329f19bfdc6b7b4f107e15d053dc0dd8ff80cda16aa04737f857eaef575ee7e6a47d8f2b4f881ccabdbb8fc9ca649943528ac01715673e4f95172b65b600271d509e03ccb7b57a22bec7ecf391f1724b59c63f28be0e9f51fa774dad7481a7e6d3dcdc62e00193754765bb7422ca9f57f2d08f5164b5afc5112c5d4734bc29162d4d404bf72a784332c533a817df841b2ac7965e07552351e3f78c54ea9b737f0948eef8e70b71a169268152d0dbfc75b77165284afc13f49c1bb6534d5266083724606d2c958aa4bd81a10e62bfcf3efb97a07e51efaba9dfde7245b8ea257adddee0326c90d5c50e62d4ddfb7f0f966ff7ce756cc72ab533594967d0ea2d55721bbe67d16a77535891c05152201206c560a1805a7ecf93d90e1760aa77a71461d72050ad444888865f5e26101c8a027f525b158c16117a62705289f373c00762e7cf4a163422f63ee805c2b532bfad5f3374eed2c6373b89b76c3ee0fc4e5bab6c1c70f63a12c89536d0f465fefb9f838a68405d9bc7771bc1b3b693c8d3b894850548159172e597b15225d6f86cb8b458431c8827b4c87aabb348ce874457001daf13be779c80bd592a25e25891c6c05a8b0e405e148fe7e0bfa8b16363e4e9b27099385d3dd39fe6b008a238376fc314b9adae78c4507c76d85c01e66d71b53e629bafd846b145e6b8375b817365d81de1a8798e7a10af8d6801841688cd5950bfe98a050e45082b0d762bce01cba872ec1ccc6be21732089b36110b5cad6dbb2fafff77298cc750b3a0204261fbe9a96e59f5176c25097d4ba72b771d2d0b35f273cb016c6cb623af3f93c4b0167c44beba87faa5d17fb97c6be91aba036feb60e9e305a8a8e35db085d75ff89fa6c87b96811db51bafad3b55de9a99afa7c970e105390259dbff2b606a5e437c2ba36313985919b19fc23425462d88b445cf18138fc959ddef95226669092b926ac1712088aa0e6550e56964190cc75d2b3cb547d06fb105a08c7cc2ecceaecd86bb0040e66b8957e28f7974535161101b27c75cca694447042f979dc1a70cb284cfaae9d9b5fe729753b281f5e627cf8a7366b88fd44df035065795a926c99cf49b3792cf83791c744042d849e0c6d59de0c1d4a41f051a82e570c448f23500d5d062639cc38c983b12d11baadb347adf5cf1d47b3ce5dcf8584fa8814e2dc1604fa67ddd4d92ac907b8c7cfde7c29b10b3da5deb0b764fae2fa850f96a1824e088299cfb8cbfc1f356cb01a21a66c50af52ddcf15439ab41a05f267611b61f89cfa383c0121527a7c9f1aba3a13ff1075ca75feea3d065dbc37bc42a3bb9f84c1e014e44a2b8200605c92b9d02433d8ccddf2ed257ccfd8ae16ba857f6e28da65e1280bb26252fcc6f5ffab20e82d3268ab2e2ef11370b5798cbce10388fe97607462fc43ea6878b0623c8f5581dcf631e1fd2a997fbfa5f886e98731b1192b226951980290e1349ed9438c68a0f263b4188945eb5b39899e5e6b878d0d01ec870bbe75fcc73491214f1e38e5b3874b628d9e079941bac25b782799dcf3e99032e9ea9502fefe00e94cc01038319df57d817d5ee612f5bb598115c0b9785dbd178549b9e62f483a473bfeafff88e08effaf446c526e54cd7ca713c5e23369261ef364dd0c16544c06c461bf060253454e2826a991fb17c78e1a54390cd1e5b683d8f9df11c9b53f56b1f5d9495b38ed1f9243e1809ed1dfb4d7eb5b3c2ba8e195127c1939d6524f27c30d8db4ba3968c9fbd03fb5b2334a5a989e2233760637be322a95d225c9c2808602efe99e7fa8eaf2c38121b23325ae85d89f2f8691d46a37d5d7a84b89c37f0c9f628933522af088a109865cf2566b0372ad560b8887237090613d1fca3ee391d227d1fe0fb25a28459456d03cb7e9a9d19ef1beca4d691ec87c839b47ca777bf9619418e991fe5ae9d764e196687fc66d766c60971dc7efd8764dd930c461d581b9be912b07a38e0d2d980195750d752c261d966f0d94397d93ebd9c1288dc30475973d16b69c2aa01a3a9c5f944e8aa2cad8ac12eac353fa6868ebce391a02abf6d44e076416730f0762ce29f018a5f1b903814cefda3f7920a23447090cdc2d5a8702146f309581fc313700f0a60fe6417f3af9f8fa06309ec81df232319ad84835b6d4393c784bc2618b6389a4abbed1613a6678bd68c48e69f3a4428edf11feef8931a7a55381687a3b4c77836cb043ddec2013e79f74299f743b250665b7280f722aa2dd14a5eb389839ccfd1210d3081b5771e409d272298e7b5fc90be5d035f981653dc7a258266327473be1067bb49aeeb75f2ee7b2eb995def2dfd3dfcba0dba5ffe56d71624b683f92aed94fa1cc9ba08a4edd2c948ace096ffe6bd1e7af1a84342afd538cd3de75bab499979f0c338c47688a3c7f9bb001791aa2542705822883bab8c12d7f5d42ae3141839623c6e2ca84992c2565a34fe491de807db7bc6cde59da9f3c6550cac998db2da05419aff8a6a013db12d7219b3684439e290b59582b40cd288e5ef5f105e29bd97f2bb8aa8621cc0dd817bc9341c2dc23eda8cd0bd33ed3bcc0d63d27f6782781eba2f26da0f822941ab43c4551933b448c3cef2198811f638d8842d0f8a375cb979a83afd53e9bc1ebb7681eb69f04db4c846e201193445eb291a6355b42d7107d8ee4805e52cd9bd79a5ad2b3191aa532367ded99cc6d386083592a797074bf269cea9c4b6f1b265e2976b67aa50bfce88a296a5631bf90582a8c65df31ff3b1dde07a5907866079fe3efc1f0ae7a64fe6d92d21d2542f64cf315798834e2060cd6a4b4e2c1c75a7d28d43bdf85675d4d9e3c7ec769f08c9d83fef1c8b2ef86857a53f8072f6f8d8a963b678009d8b124874c2f3ac4c57bd8654dd587d73f61eb7e30b0f8e38dafe8b09ea63c7f55cbb87891f308441b6d75315a43982ecf3fd3bf71e798579012ca2ed00406b816330ba1018f1a3220728b2a4f25723a515fe8f85160705e8d09743233148a4f1109eef97a43a957e46babeb58f0778293a00f1554aa87c6b924acae3054e516356ca7b5c66a7c8c98312ef4f4fdf9160f1c2b2fca92fae0bf75d8e20b1d9fa6cd37de9a9a98b556a170c8a927ed2d30ebd054a79410a604668dbdc22d3124a684a33d54ad85e45a54730a62be947d922d201caaaaa744d52087a061e6dbb239dd4e7fdc7cb12fa05567145d1dbb8ed4ca5953615f60a2f9395e883c9792d8465344345ecef77e4274b2e4bc8473652338c5d6520d91e5681d6ffafe2aa3102375a1f877dc9af288c65787c60a25c93eb676081a8c0cf112de250d583ac887c39a1c617537297e94787fa28eb6e66d7370d8e694252167dbe35dfcab35479c60c42eb32ba583ac3a720d50048f230eaf77d6321c7afe96300ea3103031ab2664ac521bb9224b6d51e888a2823a0280bd3eaed2a12ff6ed7212592f43830e803581b7807849795c84bba68d1b9c23bda9d751beb0d838eed68ff2b4b4f43db35c008267df2ccb079419aa4c42870d9e7a01937cd02ce0e2036921b48456b12f1fd01dac36ea931a7009c7f03b63f1186c230e44426964893b3b05a10c5d2d8bb7fccaae958ec31b65eb27fe10a8c16b4e47d97a3b2bb30e81530bbbb97e5895e996c762b9c29c4754b3a67cfcee8b1b5bea9dcf35a6cc84191e7bd530487f06a09b3d36b06ddb9505ef738526f61ffdd51f18334c127f361135187d455ddbaf08dabb051c97d11f75f80873d3b7513ecbb37edf97afb0733e61b4b5bd0312be0e4e8499947be5373c5964f33b34630d5e688d13cb5ecdd981d6eb2ebb91e149e1058b696f860a22ed7b58285e2746fdd27d3ab67d2d904d76b089208a21226eca6061e70a0f3cbca8f287e16690c0fd9003485667a097e91e8e16d02242f0e905ad8295dd4d4ccf8bff1a278a519808e60820125a6cedfee846415fe16dda42fc01c8804dfdd5e1f66f4cb78c2d90b39636810f4b47927608f721b28b346691cfbb600db9ac2a2711aee7b1c3ce24a1906bb63923bbed14d40a39a7cc8e81729c3e29ae5f46fb92b4520f59fab28ea1c66dddfb164f16a12405cfecf0822d163fe41c2968cd4ccccf0bd109fe385f03f31d52f5160aad5ca4c50e001db25e783a7c4ae0cb673596c3ee9d317d5199c75115f101c023b61651f3815a8a0a0f9e355e034ea976ced619dfe1e1040f25f62be02d329a544234106a1a851936458bd5a913b56ee8b021fc916cc15cde6cef4383c456f76705189c65692473b6b241b4955ccf6399512d21d26373faff804d66d2c0aea6f7fb20d6b9d25b5b1e9ac394d972a1329cfa925f18e3e6f039f5c8a4c5c0d518f219191679f84db673157f3943eb0632eee3aff6614a93154b72e1137e1f269144826c73222e0602106ce47d559c515c2e9d53e4a743260789fe05ae11ba212cd504d2d59e5605a34f30942b1973a82c04cbbf21efe4dc58a6c8f2b6cd4fc620ee42e41cb98aa43559b8a22d58823fa9edf5a5f8f50112909a52e1c11e533a17d60743fe7dac25e038537a15b36e8caf8cc69b8a79de52d9bf72cbc90eccecbed9e7dc7b1d6cd6c14f3498668e20fbd1cfac8341da461ff07232d999e0fc11aae6debac9e4c1a4d023043b7ceabc4daf1404e277918e044e86fe522a03990adb549812753c9994569ef4ea74dab38bff83e68feeaaf7c3287f23ecc1fcffa0f2a88fdf792bcf74a43131a977d89de0fbb51601f2fc30ab882ad4c241c602993d0a2df4113e486e83652f8f658e84f6f48d8ac23dcdf94982b540508831fe53059f764269520411adf501c4f7ccd30df30d920c6ebb8e69a60ebe23ee4932fa10dffc48ba081d1b850d03f4234ee6816621c8efd5390523eef7726fff343124a3eee829b233fa29a803f47314d12ebe2d08f78cda78e81c8909fdc0e66326c27bb76a03fe9354282b1427f2d32fc28991086d25975e3d619f6fa38535f63d03dcd80feaa5325222f15acda4d5d43d46c121cda6e118edf563317e17b758e90639dbd034fcde5796d93e3800fdaacd7d51fbb78c30a51c10ea8aa3ec062893d20a738812c35b79a6eb613a2f3ad0fbed059dedab8483c53ff159d47a6516c1f7b2e7c83b1dda424adc9f969059e511dd3cc18fb81da657bf801bdbf1d12e7f5997cea3e552373beb2ae1418a27a22dfc83ad4271e1fa1676eaaca43f2e3b5fddb5cd8aba589c2c4a4f64e427dec490c00664c3dc74b7d205f2c8f21ebc753c7d712ac4d7808ef3a6e05714ef52882d8070848a395419505e3e87925faf3e20d5eba6ec8f15740e2f47d039fedfabdabf7753fac76c1e2631a672f4b4928dded96e8b50da7e6bb6b6c5574dd6d09443d0947ac3fe46742b49ae520e767cda9f943b88ddc8fe05ede0a359cfd86f164e3e793d287216c465786c8de6a66a06c6b55e9c6a2c9b9e83c2b835916ceef0cb1e10acf482da2044b7d76142c1da8e01442a62a9bc</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">内部文档，则观云资源需求与分析</summary>
    
    
    
    <category term="其他内容" scheme="https://blog.slks.xyz/categories/%E5%85%B6%E4%BB%96%E5%86%85%E5%AE%B9/"/>
    
    
  </entry>
  
  <entry>
    <title>动态规划——背包问题应用</title>
    <link href="https://blog.slks.xyz/2022/02/24/46f0b3257e29/"/>
    <id>https://blog.slks.xyz/2022/02/24/46f0b3257e29/</id>
    <published>2022-02-24T01:40:23.000Z</published>
    <updated>2022-02-24T15:31:21.424Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-102.-加减的目标值"><a href="https://leetcode-cn.com/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值</a></h4><p>给定一个正整数数组 nums 和一个整数 target 。</p><p>向数组中的每个整数前添加 '+' 或 '-' ，然后串联起所有整数，可以构造一个 表达式：</p><ul><li>例如，nums = [2, 1] ，可以在 2 之前添加 '+' ，在 1 之前添加 '-' ，然后串联起来得到表达式 "+2-1"</li></ul><p>返回可以通过上述方法构造的、运算结果等于 target 的不同 表达式 的数目。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,1,1,1], target = 3</span><br><span class="line">输出：5</span><br><span class="line">解释：一共有 5 种方法让最终目标和为 3.</span><br><span class="line">-1 + 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 - 1 + 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 - 1 + 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 - 1 + 1 = 3</span><br><span class="line">+1 + 1 + 1 + 1 - 1 = 3</span><br></pre></td></tr></table></figure><p><strong>提示</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1</span> &lt;= nums.length &lt;= <span class="number">20</span></span><br><span class="line"><span class="number">0</span> &lt;= nums[i] &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">0</span> &lt;= <span class="built_in">sum</span>(nums[i]) &lt;= <span class="number">1000</span></span><br><span class="line"><span class="number">-1000</span> &lt;= target &lt;= <span class="number">1000</span></span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 在本题的背景下，<strong>一开始的错误思路：</strong>利用动态规划的思想，定义二维数组res，<code>res[i][j]</code>代表前<code>i</code>个数，按照题目所给规则，计算得到<code>target = j</code>的方法数目。然后状态转移方程如下 <code>res[i][j] = res[i-1][j-ele] + res[i-1][j+ele]</code>，<code>ele</code>是第<code>i</code>个元素。这个思路基于的思想就是：第<code>i</code>个元素，我们可以给它添加<code>+</code>或者<code>-</code>号，这样的话和为前<code>i</code>个元素计算得到<code>target</code>为<code>j</code>的方法数只有两种可能的路径，就是前<code>i-1</code>个元素。</p><p>​ 但是代码写着写着，发现一个不太对的地方，那就是target目标是有可能负的，也就是说，我们需要初始化的<code>j</code>的维度需要代表从<code>-1000~target</code>，但是这样还不能解决问题，因为有可能<code>j-ele</code>是比<code>-1000</code>小的，小多少无从可知，所以我们就没有办法进行比较高效的动态规划。</p><p>​ <strong>正确思路</strong>： 我们可以将上述问题转化为，从前<code>i</code>个数字中，选取一定的数字，使得和为<code>j</code>，可能的方法数量。这个和上面的区别在于，我们不再考虑添加正负号，而是直接把上述问题转换为了一个背包问题。因为我们知道，如果正数和为<code>j</code>，那么剩余的负数和为<code>sum-j</code>，<code>sum</code>为<code>nums</code>数组中所有元素的和。那么最后只需要满足如下公式：<code>2 * j - sum = target</code>，就可以得到我们需要的对应方法的数量。也就是说，我们如果定义二维数组<code>res</code>，代表前<code>i</code>个数，选取一定数字，得到和为<code>j</code>的方法数目，那么我们最后<code>res[nums.size()][(sum + target) / 2]</code>即为我们所需要的答案。（注：如果<code>sum+target</code>是奇数，那么必定不存在任何一种方法）。</p><p>以下为动态规划的几个重要内容：</p><h5 id="动态规划思想"><strong>动态规划思想</strong>：</h5><pre><code>`res[i][j]`，代表前`i`个数，选取一定数字，得到和为`j`的方法数目</code></pre><h5 id="初始化状态"><strong>初始化状态</strong>：</h5><pre><code>`res[0][0-target] `都置为0，且 `res[0][0]` 置为 1</code></pre><h5 id="状态转移方程"><strong>状态转移方程</strong>：</h5><p>​ <code>res[i][j] = res[i-1][j] + res[i-1][j-ele] (if j - ele &gt;= 0)</code></p><p>​ <code>res[i][j] = res[i-1][j] (if j - ele &lt; 0)</code></p><p>​ <code>ele = nums[i-1]</code></p><h5 id="代码如下"><strong>代码如下</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findTargetSumWays</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((sum+target) % <span class="number">2</span> != <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> need_size = (sum + target) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(nums.<span class="built_in">size</span>()+<span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(need_size+<span class="number">1</span>));</span><br><span class="line">        <span class="comment">//初始化状态： res[0][0-target] 都置为0，且 res[0][0] 置为 1</span></span><br><span class="line">        <span class="comment">//状态转移： res[i][j] = res[i-1][j] + res[i-1][j-ele] 前提是 j-ele 存在</span></span><br><span class="line">        <span class="comment">//如果j-ele 不存在 res[i][j] = res[i-1][j] </span></span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ele = nums[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=need_size;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j] + res[i<span class="number">-1</span>][j-ele];</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[nums.<span class="built_in">size</span>()][need_size];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="剑指-offer-ii-103.-最少的硬币数目"><a href="https://leetcode-cn.com/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a></h4><p>给定不同面额的硬币 coins 和一个总金额 amount。编写一个函数来计算可以凑成总金额所需的最少的硬币个数。如果没有任何一种硬币组合能组成总金额，返回 -1。</p><p>你可以认为每种硬币的数量是无限的。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：coins = [1, 2, 5], amount = 11</span><br><span class="line">输出：3 </span><br><span class="line">解释：11 = 5 + 5 + 1</span><br></pre></td></tr></table></figure><h5 id="解题思路-1"><strong>解题思路</strong>：</h5><p>其实本题就是一道完全背包问题，稍加转换即可：</p><h5 id="定义"><strong>定义</strong>：</h5><pre><code>前`i`个硬币，构成金额`j`，所需要的最少的硬币个数为 `res[i][j]`</code></pre><h5 id="初始化状态-1"><strong>初始化状态</strong>：</h5><pre><code>`res[0][0-amount] = -1  res[0][0] = 0`</code></pre><h5 id="状态转移"><strong>状态转移</strong>：</h5><pre><code>`res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )`</code></pre><p>需要注意的是，因为我们初始化不存在解的值为-1，所以在后续状态转移判定的时候，情况较多，具体见代码：</p><h5 id="解题代码">解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前i个硬币，构成金额j，所需要的最少的硬币个数为 res[i][j]</span></span><br><span class="line">        <span class="comment">// 初始化状态： res[0][0-amount] = -1  res[0][0] = 0</span></span><br><span class="line">        <span class="comment">// 状态转移： res[i][j] = min( res[i][j-ele] + 1 , res[i-1][j] )</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(coins.<span class="built_in">size</span>() + <span class="number">1</span>,vector&lt;<span class="keyword">int</span>&gt;(amount+<span class="number">1</span>,<span class="number">-1</span>));</span><br><span class="line">        res[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=coins.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> ele = coins[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;=amount;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(j &gt;= ele)&#123;</span><br><span class="line">                    <span class="keyword">int</span> r1 = res[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">int</span> r2 = res[i][j-ele];</span><br><span class="line">                    <span class="keyword">if</span>(r1 == <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 不存在 , r2 存在，那么参照r2 + 1</span></span><br><span class="line">                        res[i][j] = r2+<span class="number">1</span>;</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 == <span class="number">-1</span>)&#123; <span class="comment">// r1 存在 , r2 不存在，那么参照 r1</span></span><br><span class="line">                        res[i][j] = r1; </span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(r1 != <span class="number">-1</span> &amp;&amp; r2 != <span class="number">-1</span>)&#123;  <span class="comment">// r1 存在 , r2 存在，那么参照min(r2+1,r1)</span></span><br><span class="line">                        res[i][j] = <span class="built_in">min</span>(r1,r2+<span class="number">1</span>);</span><br><span class="line">                    &#125;<span class="keyword">else</span>&#123;   <span class="comment">// r1 不存在 , r2 不存在，那么也不存在  = -1</span></span><br><span class="line">                        res[i][j] = <span class="number">-1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    res[i][j] = res[i<span class="number">-1</span>][j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[coins.<span class="built_in">size</span>()][amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录两道LeetCode算法题，思路上需要拐一个脑筋急转弯。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记3——优化器类的代码实现（下）</title>
    <link href="https://blog.slks.xyz/2022/02/23/d882ea577954/"/>
    <id>https://blog.slks.xyz/2022/02/23/d882ea577954/</id>
    <published>2022-02-23T04:17:19.000Z</published>
    <updated>2022-02-28T02:36:02.086Z</updated>
    
    <content type="html"><![CDATA[<h4 id="六momentum冲量优化器的实现">六、Momentum冲量优化器的实现：</h4><h5 id="公式">1、公式：</h5><p>​ 由于先前的梯度下降法的速度向量v只依赖于当前的梯度，而不参考历史梯度，很容易让优化器陷入Critical Point中。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/6E1655AA36BAFF6E77328731A966D476.jpg" style="zoom:33%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Momentum</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    冲量法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, momentum=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 衰减系数，默认为0.9</span></span><br><span class="line">        self.momentum = momentum</span><br><span class="line">        <span class="comment"># 积累历史速度的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史速度，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.v:</span><br><span class="line">                    self.v[node] = - self.learning_rate * gradient</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史速度</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的速度</span></span><br><span class="line">                    self.v[node] = self.momentum * self.v[node] - self.learning_rate * gradient</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value + self.v[node])</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="七adagrad优化器的实现">七、AdaGrad优化器的实现：</h4><h5 id="公式-1">1、公式：</h5><p>​ <strong>针对梯度的每个分量各自的历史，采用不同的学习率。</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B02ADB3A208B90C7E30118C018E24361.jpg" style="zoom: 25%;" /></p><p>​ s 是 一个和梯度同维度的向量，<strong>其会在各个分量上累加历史梯度各个分量的平方</strong>。<strong>更新梯度时，求s各个分量的平方根,然后用学习率去除，得到自适应的一个向量，里面每个分量代表的就是各个分量对应的合适的学习率</strong>，将这个向量与梯度向量做内积，就可以得到一个合理的下降方向。从严格意义上来讲，这已经不是再向梯度的反方向下降了。<span class="math inline">\(\epsilon\)</span>是用于防止除数为0.</p><p>​ <span class="math inline">\(\bigotimes\)</span> 代表向量内各个分量分别相乘，将会得到一个和原来向量维度一致的新向量</p><h5 id="代码-1">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AdaGrad</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    不同分量，自适应学习率</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                </span><br><span class="line">                <span class="comment"># 该节点没有历史的向量s，也就是说如果是第一次对该节点更新梯度</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient,<span class="number">2</span>)</span><br><span class="line">                <span class="keyword">else</span>: <span class="comment"># 如果该节点有历史累积的向量s</span></span><br><span class="line">                    <span class="comment"># 更新当前节点的历史累积的s</span></span><br><span class="line">                    self.s[node] = self.s[node] + np.power(gradient,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 利用计算所得的速度 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="八rmsprop优化器的实现">八、RMSProp优化器的实现：</h4><h5 id="公式-2">1、公式：</h5><p>​ AdaGrad累积了全部的历史梯度，而我们其实应该更多地考虑近期地历史梯度。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/35459FAB3F235381D94DED311CECB887.jpg" style="zoom:25%;" /></p><p>​ <span class="math inline">\(\beta\)</span> 为衰减系数，一般为0.9</p><h5 id="代码-2">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RMSProp</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    RMSProp优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta=<span class="number">0.9</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta = beta</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    self.s[node] = self.beta * self.s[node] + (<span class="number">1</span> - self.beta) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               gradient / (np.sqrt(self.s[node] + self.epsilon)))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="九adam优化器的实现">九、Adam优化器的实现：</h4><h5 id="公式-3">1、公式：</h5><p>​ 集大成者，结合冲量与RMSProp的思想：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F34B46DEC057822E872DE8B45F0EDB3F.jpg" style="zoom:25%;" /></p><h5 id="代码-3">2、代码：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Adam</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    Adam优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span>, beta1=<span class="number">0.9</span>,beta2=<span class="number">0.99</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line"></span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line">        <span class="comment"># 极小量，为了防止除数为0</span></span><br><span class="line">        self.epsilon = <span class="number">1e-10</span></span><br><span class="line">        <span class="comment"># 衰减系数1</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta1 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta1 = beta1</span><br><span class="line">        <span class="comment"># 衰减系数2</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="number">0.0</span> &lt; beta2 &lt; <span class="number">1.0</span></span><br><span class="line">        self.beta2 = beta2</span><br><span class="line">        <span class="comment"># 积累历史梯度向量的字典</span></span><br><span class="line">        self.s = <span class="built_in">dict</span>()</span><br><span class="line">        <span class="comment"># 积累历史速度向量的字典</span></span><br><span class="line">        self.v = <span class="built_in">dict</span>()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 滑动加权累积梯度各分量的平方和</span></span><br><span class="line">                <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.s:</span><br><span class="line">                    self.s[node] = np.power(gradient, <span class="number">2</span>) <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                    self.v[node] = gradient <span class="comment"># 注意此处不要乘系数</span></span><br><span class="line">                <span class="keyword">else</span>:</span><br><span class="line">                    <span class="comment"># 梯度累积</span></span><br><span class="line">                    self.v[node] = self.beta1 * self.v[node] + (<span class="number">1</span> - self.beta1) * gradient</span><br><span class="line"></span><br><span class="line">                    <span class="comment"># 各分量平方累积</span></span><br><span class="line">                    self.s[node] = self.beta2 * self.s[node] + (<span class="number">1</span> - self.beta2) * np.power(gradient, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">                <span class="comment"># 更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate *</span><br><span class="line">                               self.v[node] / np.sqrt(self.s[node] + self.epsilon))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文续上半篇，实现一些常见的梯度下降优化器类。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title>用Python搭建深度学习框架系列笔记3——优化器类的代码实现（上）</title>
    <link href="https://blog.slks.xyz/2022/02/23/c051c3782dfb/"/>
    <id>https://blog.slks.xyz/2022/02/23/c051c3782dfb/</id>
    <published>2022-02-23T04:17:19.000Z</published>
    <updated>2022-02-28T02:35:02.686Z</updated>
    
    <content type="html"><![CDATA[<p><strong>前言</strong>： 优化器的理论部分以及各种常见的优化器可以参见如下博客：<a href="https://blog.slks.xyz/2022/02/11/ced858ce48dc/">机器学习基础系列笔记16——常见的梯度下降优化器整理</a></p><p>本文所讲的是如何使用Python搭建优化器类，从而帮助实现整个机器学习的训练过程。</p><h4 id="一在不封装优化器的时候如何在计算图上执行梯度下降法">一、在不封装优化器的时候，如何在计算图上执行梯度下降法？</h4><p>当我们还没有明确提出优化器这个概念的时候，我们遵循如下过程去在计算图上执行梯度下降来优化损失函数：</p><ul><li>1）对结果节点的上游变量节点(Variable)赋值或初始化【包括输入向量节点和训练参数节点】</li><li>2）在结果节点上调用forward，计算出它的值，数据前向传播</li><li>3）在所有需要训练的变量节点( Variable, trainable = True )上调用backward方法，梯度反向传播，计算出结果节点对该节点的雅可比矩阵。【仅包括训练参数节点】</li><li>4）根据变量节点的jacobi属性中的值，从变量节点的当前值中减去 用学习率 * 梯度的值即为更新后的值。</li><li>5）清除所有节点的value和jacobi属性，回到第2步</li></ul><h4 id="二优化器的封装">二、优化器的封装</h4><p>​ 其实，优化器所实现的功能就是上述训练过程中对可训练的变量节点的值进行优化的过程。但是由于，可能存在各种多种多样的优化器，为了便于外层用户使用，代码的整洁，我们需要将优化器的功能封装起来，然后进行使用。</p><p>​ 抽象而言，整个更新计算图中变量的普适流程可以抽象为3步：</p><ul><li>调用Loss节点的Forward方法，这会递归调用所有上游节点的forward方法进行前向传播</li><li>对于计算图中需要更新的变量节点，利用Backward方法，计算出Loss节点对他们的雅可比矩阵</li><li>使用雅可比矩阵，根据梯度下降法更新参数节点。</li></ul><p>​ 当然，在理论部分已经知道了，会有不同形式的梯度下降方法，那么在实现中，自然而然的解决方案就是：**将上述流程封装进入一个抽象类：Optimizer中，然后将不同的算法封装进不同的子类里面，实现各自个性化的部分。</p><h4 id="三优化器基类optimizer类">三、优化器基类（Optimizer类）：</h4><h5 id="part1构造函数">Part1：构造函数</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Optimizer</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    优化器基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        优化器的构造函数接受计算图对象，目标节点对象(往往就是Loss函数损失值节点，为了方便期间，该框架只支持优化一个目标节点，且我们暂时假设该目标节点最终结果为标量)以及学习率</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(target, Node) <span class="keyword">and</span> <span class="built_in">isinstance</span>(graph, Graph)</span><br><span class="line">        self.graph = graph</span><br><span class="line">        self.target = target</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 为每个参与训练的节点累加一个Mini Batch的全部样本的梯度（具体作用见后）</span></span><br><span class="line">        self.acc_gradient = <span class="built_in">dict</span>()</span><br><span class="line">        self.acc_no = <span class="number">0</span></span><br></pre></td></tr></table></figure><h5 id="part2核心函数">Part2：核心函数</h5><h6 id="核心函数1forward_backward">核心函数1：forward_backward()</h6><p>​ 该函数抽象了先前我们所说的优化器普适流程中的前两步，完成前向传播计算结果节点target的值，然后遍历所有的计算图中的节点，找到那些<strong>需要训练的变量节点</strong>，然后对它们执行backward，求出结果节点对这些变量节点的雅可比矩阵。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">forward_backward</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       前向传播计算结果节点的值并反向传播计算结果节点对各个节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       <span class="comment"># 清除计算图中所有节点的雅可比矩阵</span></span><br><span class="line">       self.graph.clear_jacobi()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 前向传播计算结果节点</span></span><br><span class="line">       self.target.forward()</span><br><span class="line"></span><br><span class="line">       <span class="comment"># 反向传播计算雅可比矩阵</span></span><br><span class="line">       <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">           <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">               node.backward(self.target)</span><br><span class="line"></span><br><span class="line">               <span class="comment"># 我们会得到 目标节点对参数节点的雅可比矩阵，将其转置以后即为目标节点对某变量节点的梯度</span></span><br><span class="line">               <span class="comment"># 目标节点（如果是标量的话）对节点值的雅可比是一个行向量，其转置是梯度（列向量）</span></span><br><span class="line">               <span class="comment"># 这里将梯度reshape成与节点值相同的形状，好对节点值进行更新。</span></span><br><span class="line">               <span class="comment"># node 节点的 shape 应当是一个矩阵，矩阵中元素为 N 个。</span></span><br><span class="line">               <span class="comment"># 从 目标节点 对 node 节点的雅可比矩阵相当于是 N维 -》 1维的变换</span></span><br><span class="line">               <span class="comment"># 故而 jacobi 的 shape 应该是 1 * N 维，所以要将其Reshape成Node节点形状，才方便对Node节点中的各个值进行梯度的累加。</span></span><br><span class="line">               gradient = node.jacobi.T.reshape(node.shape())</span><br><span class="line">               <span class="comment"># 如果该节点不在acc_gradient里面，就新建一个key-value</span></span><br><span class="line">               <span class="keyword">if</span> node <span class="keyword">not</span> <span class="keyword">in</span> self.acc_gradient:</span><br><span class="line">                   self.acc_gradient[node] = gradient</span><br><span class="line">               <span class="keyword">else</span>: <span class="comment"># 如果该节点已经在acc_gradient里面，就将梯度进行一个累加</span></span><br><span class="line">                   self.acc_gradient[node] += gradient</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h6 id="核心函数2update">核心函数2：update()：</h6><p>​ 该函数封装了优化过程的第三步，参数更新。在Optimizer类中，update方法调用_update这个抽象方法，其具体的方法由具体的子类覆写。执行完参数的更新以后，我们需要将先前累积的梯度给清零。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self, var_gradients=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="comment"># 该部分作用暂时还未解释，用于分布式训练，该处暂时无用，可以忽略</span></span><br><span class="line">      <span class="keyword">if</span> var_gradients <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">          self.apply_gradients(var_gradients)</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 执行更新</span></span><br><span class="line">      self._update()</span><br><span class="line"></span><br><span class="line">      <span class="comment"># 清除累加梯度</span></span><br><span class="line">      self.acc_gradient.clear()</span><br><span class="line">      self.acc_no = <span class="number">0</span></span><br><span class="line">  </span><br><span class="line"><span class="meta">  @abc.abstractmethod</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      抽象方法，执行具体的梯度更新算法，由子类实现</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="part3入口函数">Part3：入口函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">one_step</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算并累加样本的梯度</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line">    self.forward_backward()</span><br><span class="line">    self.acc_no += <span class="number">1</span></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="part4-其他辅助函数">Part4: 其他辅助函数：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">apply_gradients</span>(<span class="params">self, node_gradients_dict, summarize=<span class="literal">False</span>, acc_no=<span class="literal">None</span></span>):</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">此处暂时先不提这个函数，用于分布式训练</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_gradient</span>(<span class="params">self, node</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回样本的平均梯度</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">assert</span> node <span class="keyword">in</span> self.acc_gradient</span><br><span class="line">       <span class="keyword">return</span> self.acc_gradient[node] / self.acc_no</span><br></pre></td></tr></table></figure><h4 id="四bgd和sgd和mbgd的数学表达">四、BGD和SGD和MBGD的数学表达：</h4><h5 id="bgd">1、BGD</h5><p>​ 计算所有样本的平均损失值对参数的梯度，由于求梯度的过程是线性运算，所以<strong>所有样本的平均损失值对参数的梯度就等于每个样本的损失值对参数的梯度的平均：如下公式所示</strong> <span class="math display">\[\grad(\frac{1}{N}\sum_{i=1}^Nloss{(w|x_i)} ) = \frac{1}{N}\sum_{i=1}^N \grad(loss{(w|x_i)} )\]</span> ​ 所以，在实现中，我们可以以此计算出训练集中每个样本的损失值对参数的梯度，然后再求这些梯度的平均值。这也是为什么在Optimizer的基类中，我们需要设置<code>self.acc_gradient</code>用于累加每个样本的梯度，然后设置<code>self.acc_no</code>记录累加的样本的数量。</p><h5 id="sgd">2、 SGD</h5><p>​ 每计算一个样本的损失值，然后就进行参数的更新。</p><h5 id="mbgd">3、MBGD</h5><p>​ 以一部分样本的损失之进行计算。</p><h5 id="总结">总结：</h5><p>​ 所以，其实针对于以上三种，在代码实现泛化的时候，我们可以用批大小来进行泛化。batch size = 1即为SGD，反之极端为BDG。在代码中，其实就是 调用 <code>batch_size</code> 次 <code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p><h4 id="五matrixslow优化器mbgd实现-其他框架实现方式">五、MatrixSlow优化器MBGD实现 &amp; 其他框架实现方式：</h4><h5 id="优化器mbgd实现">1、 优化器MBGD实现</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GradientDescent</span>(<span class="params">Optimizer</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    梯度下降优化器</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, graph, target, learning_rate=<span class="number">0.01</span></span>):</span></span><br><span class="line"></span><br><span class="line">        Optimizer.__init__(self, graph, target)</span><br><span class="line">        self.learning_rate = learning_rate</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">_update</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        朴素梯度下降法</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.graph.nodes:</span><br><span class="line">            <span class="keyword">if</span> <span class="built_in">isinstance</span>(node, Variable) <span class="keyword">and</span> node.trainable:</span><br><span class="line">                <span class="comment"># 取得该节点在当前批的平均梯度</span></span><br><span class="line">                gradient = self.get_gradient(node)</span><br><span class="line">                <span class="comment"># 用朴素梯度下降法更新变量节点的值</span></span><br><span class="line">                node.set_value(node.value - self.learning_rate * gradient)</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ 按照上述非常简单好理解的代码实现，我们可以将整一个优化训练代码的过程简化如下：就是像上一段中描述的那样，调用 <code>batch_size</code> 次 <code>one_step()</code>函数，然后等到一个Batch的样本梯度累加结束后，再调用<code>update</code>函数即可，<code>update</code>函数会调用子类的<code>_update</code>函数，子类的<code>_update</code>函数中，会调用<code>get_gradient</code>函数，来得到样本的平均梯度然后进行处理。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">optimizer = ms.optimizer.Adam(ms.default_graph, loss, learning_rate)</span><br><span class="line"></span><br><span class="line">mini_batch_size = <span class="number">8</span></span><br><span class="line">cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 训练执行50个epoch</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的前4列（除最后一列的所有列），构造3x1矩阵对象</span></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 取第i个样本的最后一列，是该样本的性别标签（1男，-1女），构造1x1矩阵对象</span></span><br><span class="line">        l = np.mat(train_set[i, -<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将特征赋给x节点，将标签赋给label节点</span></span><br><span class="line">        x.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 优化器执行一次前向传播和一次后向传播</span></span><br><span class="line">        optimizer.one_step()</span><br><span class="line">        cur_batch_size += <span class="number">1</span></span><br><span class="line">        <span class="comment"># 当积累到一个mini batch的时候，完成一次参数更新</span></span><br><span class="line">        <span class="keyword">if</span> (cur_batch_size == mini_batch_size):</span><br><span class="line">            optimizer.update()</span><br><span class="line">            cur_batch_size = <span class="number">0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="built_in">len</span>(train_set)):</span><br><span class="line"></span><br><span class="line">        features = np.mat(train_set[i, :-<span class="number">1</span>]).T</span><br><span class="line">        x.set_value(features)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        pred.append(predict.value[<span class="number">0</span>, <span class="number">0</span>])  <span class="comment"># 模型的预测结果：1男，0女</span></span><br><span class="line"></span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span>  <span class="comment"># 将1/0结果转化成1/-1结果，好与训练标签的约定一致</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 判断预测结果与样本标签相同的数量与训练集总数量之比，即模型预测的正确率</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line"></span><br><span class="line">    <span class="comment"># 打印当前epoch数和模型在训练集上的正确率</span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="其他框架对于minibatch的实现方式">2、 其他框架对于MiniBatch的实现方式：</h5><p>​ 其实，上述MatrixSlow实现MiniBatch梯度计算的方式，并不是工业上最佳的。但是我认为是在学习的过程中比较好的方式。其把 MiniBatch样本和计算图完全分隔开，概念很清晰。<strong>那么在一些工业级的框架中，一般是怎么做的呢？</strong></p><p>​ 在其他一些框架中（比如<strong>Pytorch</strong>），可能会用一个变量节点来存储整批样本，<strong>比如样本为n维向量，批大小维m，那么就用一个<span class="math inline">\(m \times n\)</span>的矩阵来存储。</strong>后续计算节点的计算都是对存储数据矩阵的每一行进行的，<strong>然后这一整批的数据都会在计算图里像前面流动，直到损失值节点</strong></p><p>​ 总结来说，就是以下几步：</p><ul><li>添加一个维度，用一个变量节点存储整个minibatch的样本</li><li>前向传播对整个batch的样本计算</li><li>以平均损失值节点为目标节点</li><li>以平均损失之节点对参数的梯度更新参数。</li></ul><p>​ 这样子的好处在于什么呢？<strong>这种方法所进行计算的性能更好，可以在高效率的利用GPU的并行计算能力，并且能够支持高阶的张量。</strong></p><p>​ 以下代码是书中，对于先前的AdaLine的寻阿联例子，如果使用工业框架的方法，应当是如何训练的，给出了一个示例（没有进行封装）：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> sys</span><br><span class="line">sys.path.append(<span class="string">&#x27;../..&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matrixslow <span class="keyword">as</span> ms</span><br><span class="line"></span><br><span class="line"><span class="comment"># 构造训练集</span></span><br><span class="line">male_heights = np.random.normal(<span class="number">171</span>, <span class="number">6</span>, <span class="number">500</span>)</span><br><span class="line">female_heights = np.random.normal(<span class="number">158</span>, <span class="number">5</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_weights = np.random.normal(<span class="number">70</span>, <span class="number">10</span>, <span class="number">500</span>)</span><br><span class="line">female_weights = np.random.normal(<span class="number">57</span>, <span class="number">8</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_bfrs = np.random.normal(<span class="number">16</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line">female_bfrs = np.random.normal(<span class="number">22</span>, <span class="number">2</span>, <span class="number">500</span>)</span><br><span class="line"></span><br><span class="line">male_labels = [<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line">female_labels = [-<span class="number">1</span>] * <span class="number">500</span></span><br><span class="line"></span><br><span class="line">train_set = np.array([np.concatenate((male_heights, female_heights)),</span><br><span class="line">                      np.concatenate((male_weights, female_weights)),</span><br><span class="line">                      np.concatenate((male_bfrs, female_bfrs)),</span><br><span class="line">                      np.concatenate((male_labels, female_labels))]).T</span><br><span class="line"></span><br><span class="line"><span class="comment"># 随机打乱样本顺序</span></span><br><span class="line">np.random.shuffle(train_set)</span><br><span class="line"><span class="comment"># 批大小</span></span><br><span class="line">batch_size = <span class="number">10</span></span><br><span class="line"><span class="comment"># batch_size x 3矩阵，每行保存一个样本，整个节点保存一个mini batch的样本</span></span><br><span class="line">X = ms.core.Variable(dim=(batch_size, <span class="number">3</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 保存一个mini batch的样本的类别标签</span></span><br><span class="line">label = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line"><span class="comment"># 权值向量，3x1矩阵</span></span><br><span class="line">w = ms.core.Variable(dim=(<span class="number">3</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 阈值</span></span><br><span class="line">b = ms.core.Variable(dim=(<span class="number">1</span>, <span class="number">1</span>), init=<span class="literal">True</span>, trainable=<span class="literal">True</span>)</span><br><span class="line"><span class="comment"># 全1向量，维数是batch_size，不可训练</span></span><br><span class="line">ones = ms.core.Variable(dim=(batch_size, <span class="number">1</span>), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">ones.set_value(np.mat(np.ones(batch_size)).T)</span><br><span class="line"><span class="comment"># 用阈值（标量）乘以全1向量</span></span><br><span class="line">bias = ms.ops.ScalarMultiply(b, ones)</span><br><span class="line"><span class="comment"># 对一个mini batch的样本计算输出</span></span><br><span class="line">output = ms.ops.Add(ms.ops.MatMul(X, w), bias)</span><br><span class="line">predict = ms.ops.Step(output)</span><br><span class="line"><span class="comment"># 一个mini batch的样本的损失函数</span></span><br><span class="line">loss = ms.ops.loss.PerceptionLoss(ms.ops.Multiply(label, output))</span><br><span class="line"><span class="comment"># 一个mini batch的平均损失</span></span><br><span class="line">B =  ms.core.Variable(dim=(<span class="number">1</span>, batch_size), init=<span class="literal">False</span>, trainable=<span class="literal">False</span>)</span><br><span class="line">B.set_value(<span class="number">1</span> / batch_size * np.mat(np.ones(batch_size)))</span><br><span class="line">mean_loss = ms.ops.MatMul(B, loss)</span><br><span class="line"><span class="comment"># 学习率</span></span><br><span class="line">learning_rate = <span class="number">0.0001</span></span><br><span class="line"><span class="comment"># 训练，这个步骤之后没啥区别</span></span><br><span class="line"><span class="keyword">for</span> epoch <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">50</span>):</span><br><span class="line">    <span class="comment"># 遍历训练集中的样本</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的特征</span></span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        <span class="comment"># 取一个mini batch的样本的标签</span></span><br><span class="line">        l = np.mat(train_set[i:i + batch_size, -<span class="number">1</span>]).T</span><br><span class="line">        <span class="comment"># 将特征赋给X节点，将标签赋给label节点</span></span><br><span class="line">        X.set_value(features)</span><br><span class="line">        label.set_value(l)</span><br><span class="line">        <span class="comment"># 在平均损失节点上执行前向传播</span></span><br><span class="line">        mean_loss.forward()</span><br><span class="line">        <span class="comment"># 在参数节点上执行反向传播</span></span><br><span class="line">        w.backward(mean_loss)</span><br><span class="line">        b.backward(mean_loss)</span><br><span class="line">        <span class="comment"># 更新参数</span></span><br><span class="line">        w.set_value(w.value - learning_rate * w.jacobi.T.reshape(w.shape()))</span><br><span class="line">        b.set_value(b.value - learning_rate * b.jacobi.T.reshape(b.shape()))</span><br><span class="line">        ms.default_graph.clear_jacobi()</span><br><span class="line">    <span class="comment"># 每个epoch结束后评价模型的正确率</span></span><br><span class="line">    pred = []</span><br><span class="line">    <span class="comment"># 遍历训练集，计算当前模型对每个样本的预测值</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> np.arange(<span class="number">0</span>, <span class="built_in">len</span>(train_set), batch_size):</span><br><span class="line">        features = np.mat(train_set[i:i + batch_size, :-<span class="number">1</span>])</span><br><span class="line">        X.set_value(features)</span><br><span class="line">        <span class="comment"># 在模型的predict节点上执行前向传播</span></span><br><span class="line">        predict.forward()</span><br><span class="line">        <span class="comment"># 当前模型对一个mini batch的样本的预测结果</span></span><br><span class="line">        pred.extend(predict.value.A.ravel())</span><br><span class="line">    pred = np.array(pred) * <span class="number">2</span> - <span class="number">1</span></span><br><span class="line">    accuracy = (train_set[:, -<span class="number">1</span>] == pred).astype(np.<span class="built_in">int</span>).<span class="built_in">sum</span>() / <span class="built_in">len</span>(train_set)</span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;epoch: &#123;:d&#125;, accuracy: &#123;:.3f&#125;&quot;</span>.<span class="built_in">format</span>(epoch + <span class="number">1</span>, accuracy))</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本文记录使用Python搭建深度学习框架，实现其中优化器类的代码，包含优化器基类的抽象和需要执行的任务，以及最基本的MBGD优化器的实现，还跟Pytorch的实现方式进行了比对。</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Python搭建简易框架笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Python%E6%90%AD%E5%BB%BA%E7%AE%80%E6%98%93%E6%A1%86%E6%9E%B6%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Framework" scheme="https://blog.slks.xyz/tags/Framework/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://blog.slks.xyz/2022/02/22/d7df43b9d92e/"/>
    <id>https://blog.slks.xyz/2022/02/22/d7df43b9d92e/</id>
    <published>2022-02-22T15:10:11.560Z</published>
    <updated>2022-02-27T15:02:28.943Z</updated>
    
    <content type="html"><![CDATA[<p>title: 用Python搭建深度学习框架系列笔记2——计算图、前向传播、反向传播与自动微分的代码实现 date: 2022/02/22 23:11:19 categories: - [⓵ 深度学习笔记,Basic系列笔记] - [⓵ 深度学习笔记,Python搭建简易框架笔记] description: 本文结合上一节中的理论部分，使用Python搭建深度学习框架，实现其中最为基础核心的计算图、前向传播、反向传播以及自动微分的代码，对各个类以及其内的函数做了详细的介绍。 tags: - Framework</p><p>​ 首先，我们看完上一节的理论以后，应该需要知晓在上述过程中，我们需要在代码中实现的最核心的节点相关的类如下所示，我们以以下这张经典的计算图来分析：</p><p>​ 其中，存储整个图我们需要一个类，<strong>也就是计算图类</strong>，然后图中又有许多类型的节点，第一种类型的节点是<strong>变量节点</strong>，也就是x、w这种，是无父节点的，第二种类型是<strong>Op操作符节点</strong>，也就是+、x这种节点，剩下的就是普通的中间节点。故而我们需要实现的类如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/屏幕捕获_2022_02_10_15_03_30_21.png" /></p><p>​</p><ul><li><strong>Node类（基类-非抽象类）</strong><ul><li>普通中间节点（直接使用Node类即可）</li><li>变量节点（继承Node类，无父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识）</li><li><strong>Op操作符节点（继承Node类，抽象类，然后根据不同的运算符定义类来继承它，其他运算符类需要实现两个方法：compute 和 get_jacobi，</strong>分别用于<strong>根据父节点的值计算本节点的值</strong>，以及<strong>计算本节点对某个父节点的雅可比矩阵</strong>）。</li></ul></li><li><strong>Graph计算图类</strong></li></ul><p>接下来，我们来一一看它们的实现代码：</p><h3 id="graph计算图类-一些基本函数">1、Graph计算图类 （一些基本函数）</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Graph</span>:</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.nodes = []  <span class="comment"># 计算图内的节点的列表</span></span><br><span class="line">        self.name_scope = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">add_node</span>(<span class="params">self, node</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        添加节点</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        self.nodes.append(node)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        清除图中全部节点的雅可比矩阵</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.clear_jacobi()</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        重置图中全部节点的值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="keyword">for</span> node <span class="keyword">in</span> self.nodes:</span><br><span class="line">            node.reset_value(<span class="literal">False</span>)  <span class="comment"># 每个节点不递归清除自己的子节点的值</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">node_count</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">len</span>(self.nodes)</span><br><span class="line">    </span><br><span class="line"><span class="comment"># 全局默认计算图</span></span><br><span class="line">default_graph = Graph()</span><br></pre></td></tr></table></figure><h3 id="node类基类---非抽象类">2、Node类（基类 - 非抽象类）</h3><ul><li><strong>Part1：构造函数</strong><ul><li>此部分较好理解，做一些初始化，将节点添加到计算图的list里，然后将该节点添加到父节点的子节点列表中。</li><li>需要注意的是：构造函数需要传入两个参数，第一个参数是父节点列表，第二个参数是一些参数列表</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Node</span>(<span class="params"><span class="built_in">object</span></span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    计算图节点类基类</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, *parents, **kargs</span>):</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 计算图对象，默认为全局对象default_graph</span></span><br><span class="line">        self.kargs = kargs</span><br><span class="line">        self.graph = kargs.get(<span class="string">&#x27;graph&#x27;</span>, default_graph) <span class="comment"># 节点所属的计算图，默认为 全局计算图default_graph</span></span><br><span class="line">        self.need_save = kargs.get(<span class="string">&#x27;need_save&#x27;</span>, <span class="literal">True</span>)  <span class="comment"># 是否需要被保存</span></span><br><span class="line">        self.gen_node_name(**kargs)     <span class="comment"># 依据参数生成节点名称，节点名称在模型保存和导入时会用到</span></span><br><span class="line"></span><br><span class="line">        self.parents = <span class="built_in">list</span>(parents)  <span class="comment"># 父节点列表</span></span><br><span class="line">        self.children = []  <span class="comment"># 子节点列表</span></span><br><span class="line">        self.value = <span class="literal">None</span>  <span class="comment"># 本节点的值，Numpy的Matrix类</span></span><br><span class="line">        self.jacobi = <span class="literal">None</span>  <span class="comment"># 结果节点对本节点的雅可比矩阵</span></span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到父节点的子节点列表中</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            parent.children.append(self)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 将本节点添加到计算图中</span></span><br><span class="line">        self.graph.add_node(self)</span><br></pre></td></tr></table></figure><ul><li><strong>Part2: 常见函数</strong>:<ul><li>此部分也是Node类中一些基本的工具型函数，其中gen_node_name就是在构造函数中生成节点名称用的。</li><li>dimension 和 shape 函数是用来返回节点值的维度的</li><li>reset_value 递归重置该节点 + 该节点下游的节点的值</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_parents</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的父节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.parents</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get_children</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       获取本节点的子节点</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.children</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">gen_node_name</span>(<span class="params">self, **kargs</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       生成节点名称，如果用户不指定，则根据节点类型生成类似于&quot;MatMul:3&quot;的节点名，</span></span><br><span class="line"><span class="string">       如果指定了name_scope，则生成类似&quot;Hidden/MatMul:3&quot;的节点名</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.name = kargs.get(<span class="string">&#x27;name&#x27;</span>, <span class="string">&#x27;&#123;&#125;:&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(</span><br><span class="line">           self.__class__.__name__, self.graph.node_count()))</span><br><span class="line">       <span class="keyword">if</span> self.graph.name_scope:</span><br><span class="line">           self.name = <span class="string">&#x27;&#123;&#125;/&#123;&#125;&#x27;</span>.<span class="built_in">format</span>(self.graph.name_scope, self.name)</span><br><span class="line">       <span class="function"><span class="keyword">def</span> <span class="title">clear_jacobi</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       清空结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       self.jacobi = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">dimension</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值展平成向量后的维数</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape[<span class="number">0</span>] * self.value.shape[<span class="number">1</span>]</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">shape</span>(<span class="params">self</span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       返回本节点的值作为矩阵的形状：（行数，列数）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line">       <span class="keyword">return</span> self.value.shape</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">reset_value</span>(<span class="params">self, recursive=<span class="literal">True</span></span>):</span></span><br><span class="line">       <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">       重置本节点的值，并递归重置本节点的下游节点的值。（因为如果本节点的值被重置了，所有下游子节点的值也就都失去了意义，下游子节点的值是依赖于该节点进行计算的）</span></span><br><span class="line"><span class="string">       &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">       self.value = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> recursive:</span><br><span class="line">           <span class="keyword">for</span> child <span class="keyword">in</span> self.children:</span><br><span class="line">               child.reset_value()</span><br></pre></td></tr></table></figure><ul><li><strong>Part3：虚函数</strong>：<ul><li>这两个函数，是等会儿 操作符节点需要重载的函数内容，在forward和backword中有用到。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，根据父节点的值计算本节点的值，用于前向传播中计算该节点的值</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@abc.abstractmethod</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    抽象方法，计算本节点对某个父节点的雅可比矩阵的计算，因为计算父节点的雅可比矩阵可能需要该父节点以及其他父节点的值，所以只能够在子节点中完成。父节点调用子节点的getjacobi方法，就可以得到子节点对自己的雅可比矩阵。</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><ul><li><strong>Part4：核心函数</strong>：<ul><li>forward() 和 backward() 函数, 都是以递归的形式进行计算，请注意这边的两个函数的含义和pytorch库中的同名函数含义相差较大，不要搞混。</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span>(<span class="params">self</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      前向传播计算本节点的值，若父节点的值未被计算，则递归调用父节点的forward方法</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">for</span> node <span class="keyword">in</span> self.parents:</span><br><span class="line">          <span class="keyword">if</span> node.value <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">              node.forward()</span><br><span class="line"><span class="comment"># 递归完成，所有父节点的值都就位了，调用子类已经覆写好的compute函数，根据父节点的值计算该节点值，例如如果该节点是 + 号 类节点，compute函数中，就会书写将所有的父节点的值相加的过程。</span></span><br><span class="line">      self.compute()</span><br><span class="line"></span><br><span class="line">  <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">  属性jacobi用于保存最终结果对自己的雅可比矩阵，在代码一开始先判断自己的jacobi属性是否为None,如果不是说明最终结果对自己的雅可比矩阵已经计算过了（因为一次反向传播中，某个节点可能被多次访问）。</span></span><br><span class="line"><span class="string">  result参数传进来的是最终的结果节点。</span></span><br><span class="line"><span class="string">  &quot;&quot;&quot;</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">backward</span>(<span class="params">self, result</span>):</span></span><br><span class="line">      <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">      反向传播，计算结果节点对本节点的雅可比矩阵</span></span><br><span class="line"><span class="string">      &quot;&quot;&quot;</span></span><br><span class="line">      <span class="keyword">if</span> self.jacobi <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">          <span class="keyword">if</span> self <span class="keyword">is</span> result:  <span class="comment"># 如果本节点自身就是最终的结果节点</span></span><br><span class="line">              self.jacobi = np.mat(np.eye(self.dimension()))  <span class="comment">#构造一个维度正确的单位矩阵即可</span></span><br><span class="line">          <span class="keyword">else</span>:   <span class="comment"># 如果本节点不是最终的结果节点，而是正常的一个节点</span></span><br><span class="line">              self.jacobi = np.mat(  <span class="comment"># 先构造一个维度正确的全为0的矩阵，作为之后的累加器</span></span><br><span class="line">                  np.zeros((result.dimension(), self.dimension())))</span><br><span class="line"><span class="comment"># 然后遍历所有子节点</span></span><br><span class="line">              <span class="keyword">for</span> child <span class="keyword">in</span> self.get_children():</span><br><span class="line">                   <span class="comment"># 如果子节点的值不为空，说明它在本次的计算路径上，因为对于某些复杂的计算图而言，有些节点可能不在某次前向传播的计算路径上，它们是无关的节点。</span></span><br><span class="line">                  <span class="keyword">if</span> child.value <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">                      <span class="comment"># 递归调用child的backward()方法，得到最终结果对子节点的雅可比，再乘上 子节点对该节点的雅可比，就得到了最终结果对该节点的雅可比，将其累加到之前初始化好的全为0的矩阵中。</span></span><br><span class="line">                      self.jacobi += child.backward(result) * child.get_jacobi(self)</span><br><span class="line"><span class="comment"># 返回雅可比矩阵即可</span></span><br><span class="line">      <span class="keyword">return</span> self.jacobi</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="变量节点继承自node类">3、变量节点（继承自Node类）：</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Variable</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    变量节点</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self, dim, init=<span class="literal">False</span>, trainable=<span class="literal">True</span>, **kargs</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        变量节点没有父节点，构造函数接受变量的形状，是否初始化以及是否参与训练的标识</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        Node.__init__(self,  **kargs)</span><br><span class="line">        self.dim = dim</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># 如果需要初始化，则以正态分布随机初始化变量的值</span></span><br><span class="line">        <span class="comment"># 像保存样本和标签的节点不用初始化，而保存参数的节点需要初始化</span></span><br><span class="line">        <span class="keyword">if</span> init:</span><br><span class="line">            self.value = np.mat(np.random.normal(<span class="number">0</span>, <span class="number">0.001</span>, self.dim))</span><br><span class="line">            </span><br><span class="line">        <span class="comment"># 变量节点是否参与训练，比如样本和标签不参与训练，可以不计算它们的雅可比矩阵，而参数参与训练，就需要计算雅可比矩阵。</span></span><br><span class="line">        self.trainable = trainable</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">set_value</span>(<span class="params">self, value</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        为变量赋值</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        <span class="comment"># 判定赋值的值matrix 是不是和dim一致</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">isinstance</span>(value, np.matrix) <span class="keyword">and</span> value.shape == self.dim</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 先重置该节点及所有下游节点的值，然后再对该节点进行赋值</span></span><br><span class="line">        self.reset_value()</span><br><span class="line">        self.value = value</span><br></pre></td></tr></table></figure><h3 id="运算符操作子节点继承自node类需要覆写compute和get_jacobi两个函数">4、运算符操作子节点（继承自Node类，需要覆写compute和get_jacobi两个函数）</h3><p>抽象类如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Operator</span>(<span class="params">Node</span>):</span></span><br><span class="line">    <span class="string">&#x27;&#x27;&#x27;</span></span><br><span class="line"><span class="string">    定义操作符抽象类</span></span><br><span class="line"><span class="string">    &#x27;&#x27;&#x27;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><h5 id="定义-add-操作符">1） 定义 Add 操作符：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Add</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    （多个）矩阵加法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"><span class="comment">## 根据父节点的值计算本节点的值</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="comment"># assert len(self.parents) == 2 and self.parents[0].shape() == self.parents[1].shape()</span></span><br><span class="line">        self.value = np.mat(np.zeros(self.parents[<span class="number">0</span>].shape()))</span><br><span class="line"><span class="comment"># 把所有的父节点的值相加，就是正向传播计算的值</span></span><br><span class="line">        <span class="keyword">for</span> parent <span class="keyword">in</span> self.parents:</span><br><span class="line">            self.value += parent.value</span><br><span class="line">            </span><br><span class="line"><span class="comment">## 计算本节点对某个父节点的雅可比矩阵的计算</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.mat(np.eye(self.dimension()))  <span class="comment"># 矩阵之和对其中任一个矩阵的雅可比矩阵是单位矩阵</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">## 比如说： 父节点为矩阵 A，B(维度为 3 * 2)，子节点为矩阵 A + B（维度为3 * 2）</span></span><br><span class="line"><span class="comment">## 子节点为 Add操作符节点</span></span><br><span class="line"><span class="comment">## 那么这样一个映射函数就是 6维向量 -》映射到-》 6维向量 的映射函数</span></span><br><span class="line"><span class="comment">## A 展平 [ a1 a2 a3 a4 a5 a6 ] B 展平 [ b1 b2 b3 b4 b5 b6]  均为6维向量</span></span><br><span class="line"><span class="comment">## A+B 展平 [a1+b1 a2+b2 a3+b3 a4+b4 a5+b5 a6+b6] 6维向量</span></span><br><span class="line"><span class="comment">## 最终得到的雅可比矩阵是 6 * 6 的单位阵</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [d(a1+b1)/d(a1) d(a1+b1)/d(a2) d(a1+b1)/d(a3) d(a1+b1)/d(a4) d(a1+b1)/d(a5) d(a1+b1)/d(a6)  ]</span></span><br><span class="line"><span class="string">   [d(a2+b2)/d(a1) d(a2+b2)/d(a2) d(a2+b2)/d(a3) d(a2+b2)/d(a4) d(a2+b2)/d(a5) d(a2+b2)/d(a6)  ]</span></span><br><span class="line"><span class="string">    ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">        ……………………………………………………………………………………………………………………………………………………………………………………………………………………</span></span><br><span class="line"><span class="string">   [d(a6+b6)/d(a1) d(a6+b6)/d(a2) d(a6+b6)/d(a3) d(a6+b6)/d(a4) d(a6+b6)/d(a5) d(a6+b6)/d(a6)  ]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">   [1 0 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 1 0 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 1 0 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 1 0 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 1 0]</span></span><br><span class="line"><span class="string">   [0 0 0 0 0 1]</span></span><br><span class="line"><span class="string">&quot;&quot;&quot;</span></span><br></pre></td></tr></table></figure><h5 id="定义-matmul-操作符">2） 定义 Matmul 操作符：</h5><p>推导如下：</p><ul><li><p>定义矩阵A： 形状为 M x N</p></li><li><p>定义矩阵B： 形状为 N x K</p></li><li><p>矩阵乘法得到的结果C： 形状为 M X K</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/92352E558AF386F3CEFAE57985019633.jpg" /></p><p>​ 我们先求解<strong>矩阵C对矩阵A的雅可比矩阵</strong>：</p><p>​ 我们将矩阵乘法视为多到多映射，如下：以左矩阵A为自变量，以右矩阵B为常量，将矩阵A视为 <span class="math inline">\(M \times N\)</span> 维的向量，将映射的结果矩阵C视为 <span class="math inline">\(M \times K\)</span> 维的向量。如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/202202271a.png" style="zoom: 50%;" /></p><p>​ 最终获得的雅可比矩阵的第一行，就是C矩阵的第1个元素，分别对A 的 MN 个元素求导：得到的如下所示：C的第一个分量对A的第一行元素的偏导数就是B的第一列，对A其余元素的偏导数是0，所以雅可比矩阵的第一行如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/F9061B9E26F869EA36F4575B07A65B27.jpg" style="zoom: 25%;" /></p><p>​ 第二行同理，如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/BD69F402E360C2A1B6CCD85DF5881C28.jpg" style="zoom:25%;" /></p><p>​ 一直到雅可比矩阵的第K行，都是这样的规律。然后接下去雅可比矩阵的K+1行是这样的：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/7FFCABE5A3D35DAAD995E76633F94DDE.jpg" style="zoom:25%;" /></p><p>​ 我们会发现一个规律，如下所示，也就是最终的结论：C对A的雅可比矩阵如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/15BB5E4AF6FBE51D7701F361B7BE64FE.jpg" /></p><p>​ <span class="math inline">\(B^T 是 B的转置\)</span>，我们把 m 个 形状为 <span class="math inline">\(K \times N\)</span> 的<span class="math inline">\(B^T\)</span>矩阵放在对角线上，得到一个 <span class="math inline">\(MK \times MN\)</span> 的矩阵。</p><p>​</p><p>​ 然后来看<strong>矩阵C对矩阵B的雅可比矩阵</strong>：</p><p>​ 同样我们将矩阵乘法视为多到多映射，如下：以左矩阵A为常量，以右矩阵B为自变量，将矩阵B视为 <span class="math inline">\(N \times K\)</span> 维的向量，将映射的结果矩阵C视为 <span class="math inline">\(M \times K\)</span> 维的向量。如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/2022020272258.png" style="zoom:33%;" /></p><p>​ 这是一个NK维向量，C对B的雅可比矩阵是<span class="math inline">\(MK \times NK\)</span> 的矩阵。C的第一个分量对B的第1列元素的偏导数就是A的第一行，所以雅可比矩阵的第1行如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/C165EA4E4C9DE67CF1EE6AF9551DB327.jpg" style="zoom: 33%;" /></p><p>​ 雅可比矩阵的第2行如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/B504A835005C3AAF0BA61984E976F3F9.jpg" style="zoom: 33%;" /></p><p>​ 这一行中每个长度维k的段的第2个元素是A的第1行的对应元素，其余元素维0.以此类推，雅可比矩阵的前k行是一个<span class="math inline">\(k \times NK\)</span>的矩阵，包含横着排列的N个对角阵。整个雅可比矩阵由M个这样的矩阵竖着摞在一起构成。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/64F57EE82EDE412BA304CD345F290E57.jpg" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MatMul</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    矩阵乘法</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        <span class="keyword">assert</span> <span class="built_in">len</span>(self.parents) == <span class="number">2</span> <span class="keyword">and</span> self.parents[<span class="number">0</span>].shape()[</span><br><span class="line">            <span class="number">1</span>] == self.parents[<span class="number">1</span>].shape()[<span class="number">0</span>]</span><br><span class="line">        self.value = self.parents[<span class="number">0</span>].value * self.parents[<span class="number">1</span>].value</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">        将矩阵乘法视作映射，求映射对参与计算的矩阵的雅克比矩阵。</span></span><br><span class="line"><span class="string">        &quot;&quot;&quot;</span></span><br><span class="line">        zeros = np.mat(np.zeros((self.dimension(), parent.dimension())))</span><br><span class="line">        <span class="keyword">if</span> parent <span class="keyword">is</span> self.parents[<span class="number">0</span>]:  <span class="comment"># C对A的雅可比矩阵</span></span><br><span class="line">            <span class="keyword">return</span> fill_diagonal(zeros, self.parents[<span class="number">1</span>].value.T)</span><br><span class="line">        <span class="keyword">else</span>:<span class="comment"># C对B的雅可比矩阵</span></span><br><span class="line">            jacobi = fill_diagonal(zeros, self.parents[<span class="number">0</span>].value)</span><br><span class="line">            row_sort = np.arange(self.dimension()).reshape(</span><br><span class="line">                self.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            col_sort = np.arange(parent.dimension()).reshape(</span><br><span class="line">                parent.shape()[::-<span class="number">1</span>]).T.ravel()</span><br><span class="line">            <span class="keyword">return</span> jacobi[row_sort, :][:, col_sort]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h5 id="定义-relu-操作符">3） <strong>定义 ReLU 操作符：</strong></h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReLU</span>(<span class="params">Operator</span>):</span></span><br><span class="line">    <span class="string">&quot;&quot;&quot;</span></span><br><span class="line"><span class="string">    对矩阵的元素施加ReLU函数</span></span><br><span class="line"><span class="string">    &quot;&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    nslope = <span class="number">0.1</span>  <span class="comment"># 负半轴的斜率</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">compute</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.value = np.mat(np.where(</span><br><span class="line">            self.parents[<span class="number">0</span>].value &gt; <span class="number">0.0</span>,</span><br><span class="line">            self.parents[<span class="number">0</span>].value,</span><br><span class="line">            self.nslope * self.parents[<span class="number">0</span>].value)</span><br><span class="line">        )</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">get_jacobi</span>(<span class="params">self, parent</span>):</span></span><br><span class="line">        <span class="keyword">return</span> np.diag(np.where(self.parents[<span class="number">0</span>].value.A1 &gt; <span class="number">0.0</span>, <span class="number">1.0</span>, self.nslope))</span><br></pre></td></tr></table></figure><p><strong>参考资料：</strong></p><p>代码实现参考：https://github.com/zc911/MatrixSlow</p><p>1、《用python实现深度学习框架》张觉非、陈震</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;title: 用Python搭建深度学习框架系列笔记2——计算图、前向传播、反向传播与自动微分的代码实现 date: 2022/02/22 23:11:19 categories: - [⓵ 深度学习笔记,Basic系列笔记] - [⓵ 深度学习笔记,Python搭建简易框</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>BFS系列——开密码锁</title>
    <link href="https://blog.slks.xyz/2022/02/22/2c663a313e31/"/>
    <id>https://blog.slks.xyz/2022/02/22/2c663a313e31/</id>
    <published>2022-02-22T06:06:19.000Z</published>
    <updated>2022-02-24T15:37:55.129Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-109.-开密码锁"><a href="https://leetcode-cn.com/problems/zlDJc7/">剑指 Offer II 109. 开密码锁</a></h4><p>​ 一个密码锁由 4 个环形拨轮组成，每个拨轮都有 10 个数字： '0', '1', '2', '3', '4', '5', '6', '7', '8', '9' 。每个拨轮可以自由旋转：例如把 '9' 变为 '0'，'0' 变为 '9' 。每次旋转都只能旋转一个拨轮的一位数字。</p><p>​ 锁的初始数字为 '0000' ，一个代表四个拨轮的数字的字符串。</p><p>​ 列表 deadends 包含了一组死亡数字，一旦拨轮的数字和列表里的任何一个元素相同，这个锁将会被永久锁定，无法再被旋转。</p><p>​ 字符串 target 代表可以解锁的数字，请给出解锁需要的最小旋转次数，如果无论如何不能解锁，返回 -1 。</p><ul><li>示例 1:</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：deadends = [&quot;0201&quot;,&quot;0101&quot;,&quot;0102&quot;,&quot;1212&quot;,&quot;2002&quot;], target = &quot;0202&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： 可能的移动序列为 &quot;0000&quot; -&gt; &quot;1000&quot; -&gt; &quot;1100&quot; -&gt; &quot;1200&quot; -&gt; &quot;1201&quot; -&gt; &quot;1202&quot; -&gt; &quot;0202&quot;。</span><br><span class="line">注意 &quot;0000&quot; -&gt; &quot;0001&quot; -&gt; &quot;0002&quot; -&gt; &quot;0102&quot; -&gt; &quot;0202&quot; 这样的序列是不能解锁的，因为当拨动到 &quot;0102&quot; 时这个锁就会被锁定。</span><br></pre></td></tr></table></figure><h5 id="解题思路1单向bfs"><strong>解题思路1：单向BFS</strong>：</h5><p>​ 本题可以采用BFS搜索进行求解，但是由于每一个数字，其对应的领居有高达8个，再不断的扩展的过程中，搜索的空间会非常大，就会导致比较大的复杂度。在本题的BFS过程中，需要注意的是，还有死亡数字列表，一种方案是我们可以使用哈希表存储死亡数字，在每次遍历获取邻居的时候，判断是否为死亡数字，如果为死亡数字，那么就不将其考虑在内。这样子需要多出一定的空间和时间来进行处理。</p><p>​ 其实，我们可以不需要额外的空间来进行处理。因为在BFS的过程中，我们会记录哪些节点被访问过，就不要重复入队，故而，只需要提前将所有的死亡数字，都设定为已经被访问过，那么就不会被考虑在内。</p><h5 id="解题代码1"><strong>解题代码1</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; dead;</span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++) dead[deadends[i]] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(dead.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != dead.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);</span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            string curr = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dead.<span class="built_in">find</span>(neighbor[i]) != dead.<span class="built_in">end</span>()) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(target) == res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> res[target];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.31.38.png" /></p><p>​ 此方法花费的执行用时和内存消耗都是下下选。</p><h5 id="解题思路2双向bfs"><strong>解题思路2：双向BFS</strong>：</h5><p>​ 双向bfs适用于知道起点和终点的状态下使用，从起点和终点两个方向开始进行搜索，可以非常大的提高单个bfs的搜索效率</p><p>​ 同样，实现也是通过队列的方式，可以设置两个队列，一个队列保存从起点开始搜索的状态，另一个队列用来保存从终点开始搜索的状态，如果某一个状态下出现相交的情况，那么就出现了答案，用一张图来进行说明如下所示：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/jevyd2TPC7FX6GA.png" alt="jevyd2TPC7FX6GA" style="zoom: 33%;" /></p><p>​ 具体如何实现判断相遇，见如下的代码：我们构建vis，代表某个字符串的位置是否被访问过。这个在单向的BFS中，我们不需要设置，因为我们可以通过res这个Hash表有没有某个元素来进行判断，实际上此处的vis起到的也并不是判断有没有被访问过的作用（后面代码还是通过res中有没有某个元素来判断的），此处的vis最大的作用是记录某个节点是被正向搜索访问过，还是被反向搜索访问过，如果被正向访问过设置为1，被反向搜索访问过设置为2。</p><p>​ 同时，在每一遍while中，我们扩展<strong>较小的搜索队列</strong>，并利用flag记录扩展的是前向还是反向。如果在遍历某一轮的领居的过程中，发现：curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了。</p><h5 id="解题代码2">解题代码2：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(vector&lt;string&gt;&amp; deadends, string target)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//构建hash表，方便进行查询结果</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//构建vis，代表某个字符串的位置是否被访问过 被正向访问过为1，被反向搜索访问过为2</span></span><br><span class="line">        unordered_map&lt;string,<span class="keyword">int</span>&gt; vis;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;deadends.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            res[deadends[i]] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(res.<span class="built_in">find</span>(<span class="string">&quot;0000&quot;</span>) != res.<span class="built_in">end</span>()) <span class="keyword">return</span> <span class="number">-1</span>; </span><br><span class="line">        <span class="keyword">if</span>(target == <span class="string">&quot;0000&quot;</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//开启广度优先搜索</span></span><br><span class="line">        queue&lt;string&gt; q1;  <span class="comment">//前向搜索序列</span></span><br><span class="line">        queue&lt;string&gt; q2;  <span class="comment">//反向搜索序列</span></span><br><span class="line">        q1.<span class="built_in">push</span>(<span class="string">&quot;0000&quot;</span>);   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        q2.<span class="built_in">push</span>(target);   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        res[<span class="string">&quot;0000&quot;</span>] = <span class="number">0</span>;   <span class="comment">//前向搜索初始化</span></span><br><span class="line">        res[target] = <span class="number">0</span>;   <span class="comment">//反向搜索初始化</span></span><br><span class="line">        vis[<span class="string">&quot;0000&quot;</span>] = <span class="number">1</span>; <span class="comment">//前向搜索初始化</span></span><br><span class="line">        vis[target] = <span class="number">2</span>; <span class="comment">//反向搜索初始化</span></span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() &amp;&amp; !q2.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="comment">//在每一遍while中，我们扩展 较小的搜索队列,利用flag记录扩展的是前向还是反向</span></span><br><span class="line">            string curr;</span><br><span class="line">            <span class="keyword">bool</span> flag;</span><br><span class="line">            <span class="keyword">if</span>(q1.<span class="built_in">size</span>() &lt; q2.<span class="built_in">size</span>())&#123;</span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                curr = q1.<span class="built_in">front</span>();</span><br><span class="line">                q1.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                flag = <span class="literal">false</span>;</span><br><span class="line">                curr = q2.<span class="built_in">front</span>();</span><br><span class="line">                q2.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//将curr的16个领居全部进入队列，并更新结果表，(如果存在dead点，则不进入队列)</span></span><br><span class="line">            vector&lt;string&gt; neighbor = <span class="built_in">getNeighbor</span>(curr);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;neighbor.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res.<span class="built_in">find</span>(neighbor[i]) == res.<span class="built_in">end</span>())&#123; <span class="comment">//如果这个领居点从来没被访问过 </span></span><br><span class="line">                    <span class="keyword">if</span>(flag) q1.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    <span class="keyword">else</span> q2.<span class="built_in">push</span>(neighbor[i]);</span><br><span class="line">                    res[neighbor[i]] = res[curr] + <span class="number">1</span>;</span><br><span class="line">                    vis[neighbor[i]] = vis[curr];  <span class="comment">//继承当前访问的队列编号，1为正向，2为反向</span></span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;  <span class="comment">//如果这个领居点被访问过：</span></span><br><span class="line">                    <span class="keyword">if</span>(vis[neighbor[i]] + vis[curr] == <span class="number">3</span>)&#123;</span><br><span class="line">                        <span class="comment">//如果curr点和领居点的vst相加=3，意味着两者一个是正向搜索序列，一个是逆向搜索序列，相遇了，所以此时我们可以返回结果，不用继续下去了</span></span><br><span class="line">                        <span class="keyword">return</span> res[curr] + res[neighbor[i]] + <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">getNeighbor</span><span class="params">(string str)</span></span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">            string tmp = str;</span><br><span class="line">            <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;0&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;9&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;1&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(tmp[i] == <span class="string">&#x27;9&#x27;</span>)&#123;</span><br><span class="line">                tmp[i] = <span class="string">&#x27;8&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                tmp[i] = tmp[i] + <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">                tmp[i] = tmp[i] - <span class="number">2</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(tmp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-22%20下午2.30.39.png" /></p><p>可以看到，使用双向BFS比先前的单向BFS节省了非常多的时间与空间复杂度。</p>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，其中记录了BFS的进阶技巧。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
  </entry>
  
  <entry>
    <title>DFS系列——最长递增路径</title>
    <link href="https://blog.slks.xyz/2022/02/22/cd538be761a4/"/>
    <id>https://blog.slks.xyz/2022/02/22/cd538be761a4/</id>
    <published>2022-02-22T06:06:19.000Z</published>
    <updated>2022-02-25T08:25:56.588Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-112.-最长递增路径"><a href="https://leetcode-cn.com/problems/fpTFWP/">剑指 Offer II 112. 最长递增路径</a></h4><p>​ 给定一个 m x n 整数矩阵 matrix ，找出其中 最长递增路径 的长度。</p><p>​ 对于每个单元格，你可以往上，下，左，右四个方向移动。 不能 在 对角线 方向上移动或移动到 边界外（即不允许环绕）。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径为 [1, 2, 6, 9]。</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/grid1.jpg" /></p><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]</span><br><span class="line">输出：4 </span><br><span class="line">解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/tmp-grid.jpg" /></p><p>参考：https://leetcode-cn.com/problems/fpTFWP/solution/zui-chang-di-zeng-lu-jing-by-leetcode-so-1chr/</p><h5 id="解题思路1dfs进阶记忆化深度优先搜索">解题思路1：DFS进阶—记忆化深度优先搜索：</h5><p>​ 拿到题目以后，将其看作一个图，然后从一个单元格开始进行深度优先搜索，即可找到从该单元格开始的最长递增路径。对每个单元格分别进行深度优先搜索之后，即可得到矩阵中的最长递增路径的长度。这是一个非常朴素且好用的办法，但是仔细想一下以后，时间复杂度肯定是指数级的，会超出时间限制，所以需要优化。</p><p>​ 常见的优化方式，就是<strong>记忆化深度优先搜索</strong>，思路如下：</p><p>​ <strong>朴素深度优先搜索的时间复杂度过高的原因是进行了大量的重复计算，同一个单元格会被访问多次，每次访问都要重新计算。由于同一个单元格对应的最长递增路径的长度是固定不变的，因此可以使用记忆化的方法进行优化</strong>。用矩阵 <code>res</code>作为缓存矩阵，已经计算过的单元格的结果存储到缓存矩阵中。</p><p>​ 使用记忆化深度优先搜索，当访问到一个单元格<code>(i,j)</code>时，如果 <code>res[i][j] != 0</code>，说明该单元格的结果已经计算过，则直接从缓存中读取结果，如果 <code>res[i][j] == 0</code>，说明该单元格的结果尚未被计算过，则进行搜索，并将计算得到的结果存入缓存中。</p><p>​ 遍历完矩阵中的所有单元格之后，即可得到矩阵中的最长递增路径的长度。</p><h5 id="解题代码1">解题代码1：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; dirs = &#123;&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;&#125;; <span class="comment">//四个邻居坐标</span></span><br><span class="line">    <span class="keyword">int</span> m;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> dis = <span class="built_in">dfs</span>(i,j,matrix,res);</span><br><span class="line">                <span class="keyword">if</span>(dis &gt; max) max = dis;</span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> row,<span class="keyword">int</span> column,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix,vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; res)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//如果已经计算过该点的值，我们直接返回(相比于传统的DFS，其实就多了这一步)</span></span><br><span class="line">        <span class="keyword">if</span> (res[row][column] != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> res[row][column];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果该点的值没有计算过，先将该点的值 +1，代表路径长度为1.</span></span><br><span class="line">        ++res[row][column];</span><br><span class="line">        <span class="comment">//遍历4个周围的邻居，进行递归，深度优先遍历</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; ++i) &#123;</span><br><span class="line">            <span class="keyword">int</span> new_row = row + dirs[i][<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> new_column = column + dirs[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (new_row &gt;= <span class="number">0</span> &amp;&amp; new_row &lt; m &amp;&amp; </span><br><span class="line">                new_column &gt;= <span class="number">0</span> &amp;&amp; new_column &lt; n &amp;&amp; </span><br><span class="line">                matrix[new_row][new_column] &gt; matrix[row][column]        <span class="comment">//如果周围比该点大，则进行深度遍历</span></span><br><span class="line">            )&#123;</span><br><span class="line">                <span class="comment">//最终的结果 为当前的最长递增路径 和 周围邻居的最长路径 + 1，两者中大的那个值</span></span><br><span class="line">                res[row][column] = <span class="built_in">max</span>(res[row][column], <span class="built_in">dfs</span>(new_row, new_column,matrix, res) + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[row][column];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路2动态规划拓扑排序">解题思路2：动态规划（拓扑排序）</h5><p>​ 一开始，我看到此题，没有想到去优化DFS，而是直接转到了动态规划的思路上，刚开始觉得这题如果使用动态规划非常方便，每个节点它的最长递增路径，无非就是周围的邻居中，选一个最长递增路径最大，并且比自己值大的节点 + 1，就可以了，即<code>res[i][j]=max&#123;res[x][y]&#125;+1 (其中(x,y)与(i,j)在矩阵中相邻且matrix[x][y] &gt; matrix[i][j])</code>。</p><p>​ 事实确实是这样，但是没想到此题如果使用动态规划，关键问题并不是状态转移方程，而是初始化条件和如何去进行状态转移.按照通常的思路,我想到了从左上角向右下角遍历,此时仅考虑左边和上面的点,然后从右下角至左上角遍历,此时仅考虑右边和下面的点,这样子由于缓存的关系相当于也考虑了周围的四个邻居,类似于<a href="https://blog.slks.xyz/2022/02/21/80b7b127a404/">图系列——矩阵中的距离</a>这道题目的动态规划方法,代码如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = matrix.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="comment">//从左上角向右下角遍历</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> ele = matrix[i][j];</span><br><span class="line">                <span class="comment">//检查邻居的值，如果左边和上面的值符合递增效果，则叠加</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查上方</span></span><br><span class="line">                    <span class="keyword">int</span> ele_up = matrix[i<span class="number">-1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(ele_up &gt; ele) res[i][j] = <span class="built_in">max</span>(res[i][j] , res[i<span class="number">-1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=<span class="number">0</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查左方</span></span><br><span class="line">                    <span class="keyword">int</span> ele_left = matrix[i][j<span class="number">-1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(ele_left &gt; ele) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i][j<span class="number">-1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=m<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=n<span class="number">-1</span>;j&gt;=e;j--)&#123;</span><br><span class="line">                <span class="keyword">int</span> ele = matrix[i][j];</span><br><span class="line">                <span class="comment">//检查邻居的值，如果左边和上面的值符合递增效果，则叠加</span></span><br><span class="line">                <span class="keyword">if</span>(i!=m<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查下方</span></span><br><span class="line">                    <span class="keyword">int</span> ele_down = matrix[i+<span class="number">1</span>][j];</span><br><span class="line">                    <span class="keyword">if</span>(ele_down &gt; ele) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i+<span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(j!=n<span class="number">-1</span>)&#123;</span><br><span class="line">                    <span class="comment">//检查右方</span></span><br><span class="line">                    <span class="keyword">int</span> ele_right = matrix[i][j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(ele_right &gt; ele ) res[i][j] =  <span class="built_in">max</span>(res[i][j] ,res[i][j+<span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> max = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(res[i][j] &gt; max) max = res[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>​ <strong>但这个题目这样子做是会出问题的,具体出问题的原因我也搞清楚了,大致是因为某个元素更新后,会导致先前已经通过该元素更新的元素变得无效,但是思考了很久,至今还是没有完全想通,为什么<矩阵中的距离>这道题目可以用这种方式递归,而该题目无法用这种形式递归</strong></p><p>​ <strong>我们先看正确方法:这题的关键在于如何定义初始化状态和计算流程:</strong></p><p>​ 动态规划除了状态定义和状态转移方程，还需要考虑边界情况。这里的边界情况是什么呢？</p><p>​ 如果一个单元格的值比它的所有相邻单元格的值都要大，那么这个单元格对应的最长递增路径是 1，这就是边界条件。这个边界条件并不直观，而是<strong>需要根据矩阵中的每个单元格的值找到作为边界条件的单元格</strong>。</p><p>​ 仍然使用方法一的思想，将矩阵看成一个有向图，计算每个单元格对应的出度，即有多少条边从该单元格出发。对于作为边界条件的单元格，该单元格的值比所有的相邻单元格的值都要大，因此作为边界条件的单元格的出度都是 0。</p><p>​ <strong>基于出度的概念，可以使用拓扑排序求解。从所有出度为 0 的单元格开始广度优先搜索，每一轮搜索都会遍历当前层的所有单元格，更新其余单元格的出度，并将出度变为 0 的单元格加入下一层搜索。当搜索结束时，搜索的总层数即为矩阵中的最长递增路径的长度。</strong></p><h5 id="解题代码2官方代码">解题代码2(官方代码):</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> <span class="keyword">int</span> dirs[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">-1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">0</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">    <span class="keyword">int</span> rows, columns;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestIncreasingPath</span><span class="params">(vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; &amp;matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        rows = matrix.<span class="built_in">size</span>();</span><br><span class="line">        columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">auto</span> outdegrees = vector&lt; vector&lt;<span class="keyword">int</span>&gt; &gt; (rows, vector &lt;<span class="keyword">int</span>&gt; (columns));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = i + dirs[k][<span class="number">0</span>], newColumn = j + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &gt; matrix[i][j]) &#123;</span><br><span class="line">                        ++outdegrees[i][j];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        queue &lt; pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; &gt; q;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows; ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; columns; ++j) &#123;</span><br><span class="line">                <span class="keyword">if</span> (outdegrees[i][j] == <span class="number">0</span>) &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i, j&#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (!q.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            ++ans;</span><br><span class="line">            <span class="keyword">int</span> size = q.<span class="built_in">size</span>();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">                <span class="keyword">auto</span> cell = q.<span class="built_in">front</span>(); q.<span class="built_in">pop</span>();</span><br><span class="line">                <span class="keyword">int</span> row = cell.first, column = cell.second;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">4</span>; ++k) &#123;</span><br><span class="line">                    <span class="keyword">int</span> newRow = row + dirs[k][<span class="number">0</span>], newColumn = column + dirs[k][<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span> (newRow &gt;= <span class="number">0</span> &amp;&amp; newRow &lt; rows &amp;&amp; newColumn &gt;= <span class="number">0</span> &amp;&amp; newColumn &lt; columns &amp;&amp; matrix[newRow][newColumn] &lt; matrix[row][column]) &#123;</span><br><span class="line">                        --outdegrees[newRow][newColumn];</span><br><span class="line">                        <span class="keyword">if</span> (outdegrees[newRow][newColumn] == <span class="number">0</span>) &#123;</span><br><span class="line">                            q.<span class="built_in">push</span>(&#123;newRow, newColumn&#125;);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">作者：LeetCode-Solution</span><br><span class="line">链接：https:<span class="comment">//leetcode-cn.com/problems/fpTFWP/solution/zui-chang-di-zeng-lu-jing-by-leetcode-so-1chr/</span></span><br><span class="line">来源：力扣（LeetCode）</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，其中记录了DFS的进阶技巧，同时该题也可以使用动态规划求解，和一般的动态规划不一样的是，该题使用动态规划，状态转移方程很好得出，但是如何去进行状态转移的计算以及什么是初始状态是一个难题。整理完此题对动态规划整个的理解能够更深一步</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="DFS" scheme="https://blog.slks.xyz/tags/DFS/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>图系列——多余的边（DSU应用）</title>
    <link href="https://blog.slks.xyz/2022/02/21/0f9e9b187c29/"/>
    <id>https://blog.slks.xyz/2022/02/21/0f9e9b187c29/</id>
    <published>2022-02-21T08:29:19.000Z</published>
    <updated>2022-02-24T15:35:37.173Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-118.-多余的边"><a href="https://leetcode-cn.com/problems/7LpjUW/">剑指 Offer II 118. 多余的边</a></h4><p>​ 树可以看成是一个连通且 无环 的 无向 图。</p><p>​ 给定往一棵 n 个节点 (节点值 1～n) 的树中添加一条边后的图。添加的边的两个顶点包含在 1 到 n 中间，且这条附加的边不属于树中已存在的边。图的信息记录于长度为 n 的二维数组 edges ，edges[i] = [ai, bi] 表示图中在 ai 和 bi 之间存在一条边。</p><p>​ 请找出一条可以删去的边，删除后可使得剩余部分是一个有着 n 个节点的树。如果有多个答案，则返回数组 edges 中最后出现的边。</p><p><strong>示例 1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626676174-hOEVUL-image.png" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: edges = [[1,2],[1,3],[2,3]]</span><br><span class="line">输出: [2,3]</span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 一开始，我的思路是找到一种方法，能够判断一个图有无环。毫无疑问，我们可以使用拓扑排序去进行这个思路，但是这样子的话，对于每删掉一条边就要进行一次拓扑排序来判断，时间复杂度无疑是比较高的。</p><p>​ 这个时候，查看官方解答，原来这类题目还可以使用<strong>并查集</strong>来做：</p><p>​ 初始时，每个节点都属于不同的连通分量。遍历每一条边，判断这条边连接的两个顶点是否属于相同的连通分量。</p><ul><li>如果两个顶点属于不同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间不连通，因此当前的边不会导致环出现，合并这两个顶点的连通分量。</li><li>如果两个顶点属于相同的连通分量，则说明在遍历到当前的边之前，这两个顶点之间已经连通，因此当前的边导致环出现，为多余的边，将当前的边作为答案返回。</li></ul><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">findRedundantConnection</span><span class="params">(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; edges)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">root</span><span class="params">(<span class="number">1001</span>,<span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i =<span class="number">0</span>;i&lt;edges.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">bool</span> res = <span class="built_in">unionTwo</span>(edges[i][<span class="number">0</span>],edges[i][<span class="number">1</span>],root);</span><br><span class="line">            <span class="keyword">if</span>(!res) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> edges[i]; </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getRoot</span><span class="params">(<span class="keyword">int</span> index,vector&lt;<span class="keyword">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root[index] != <span class="number">-1</span>)&#123;</span><br><span class="line">            index = root[index];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">unionTwo</span><span class="params">(<span class="keyword">int</span> index1,<span class="keyword">int</span> index2,vector&lt;<span class="keyword">int</span>&gt; &amp;root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> root1 = <span class="built_in">getRoot</span>(index1,root);</span><br><span class="line">        <span class="keyword">int</span> root2 = <span class="built_in">getRoot</span>(index2,root);</span><br><span class="line">        <span class="keyword">if</span>(root1 != root2)&#123;</span><br><span class="line">            root[root1] = root2;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，与图有关</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
    <category term="DSU" scheme="https://blog.slks.xyz/tags/DSU/"/>
    
  </entry>
  
  <entry>
    <title>图系列——矩阵中的距离</title>
    <link href="https://blog.slks.xyz/2022/02/21/80b7b127a404/"/>
    <id>https://blog.slks.xyz/2022/02/21/80b7b127a404/</id>
    <published>2022-02-21T08:29:19.000Z</published>
    <updated>2022-02-25T07:39:07.217Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-107.-矩阵中的距离"><a href="https://leetcode-cn.com/problems/2bCMpM/">剑指 Offer II 107. 矩阵中的距离</a></h4><p>​ 给定一个由 0 和 1 组成的矩阵 mat ，请输出一个大小相同的矩阵，其中每一个格子是 mat 中对应位置元素到最近的 0 的距离。</p><p>​ 两个相邻元素间的距离为 1 。</p><p><strong>示例 1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/1626667201-NCWmuP-image.png" alt="img" style="zoom: 50%;" /></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：mat = [[0,0,0],[0,1,0],[0,0,0]]</span><br><span class="line">输出：[[0,0,0],[0,1,0],[0,0,0]]</span><br></pre></td></tr></table></figure><h5 id="解题思路1多源bfs"><strong>解题思路1:多源BFS</strong></h5><p>​ 一开始看这题，应当能够较快的反应使用BFS进行解答，但核心的问题在于，如果使用传统 的BFS进行解答，起点是任意一个节点，终点为任意一个值为0的节点，我们需要做很多遍BFS才能够解决问题。</p><p>​ 故而，本题中所涉及到的是一个叫做<strong>多源BFS</strong>的方法，其实多源的BFS和单源BFS非常相似，在上述问题中，整体思路如下：首先我们遍历整个矩阵，将所有的值为0的节点得出结果，并加入到队列中去。我们采用逆向思维的方法，将这些值为0的节点全部放入队列中，且这些值为0的节点对应的结果距离也为0，后续经由它们扩散得到的别的点的距离，是在它们的距离0的基础上逐渐进行叠加的，直到扩散至全图范围，我们的多源BFS也就完成了。</p><p>​ 有一个可能会令人担忧的问题：那就是如果某一个点一开始被遍历到，设定好值以后，后面再作为别人的领居北遍历到的时候，会不会要设定的值比之前设定的值小呢？这是不可能的，因为我们采用的是BFS，一层层像波纹一样向外扩散，后遍历到的设定的值，必定大于或等于先前设定的值。所以不需要担心。</p><h5 id="解题代码"><strong>解题代码：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; neighbor = &#123; &#123;<span class="number">-1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125; &#125;;</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">int</span> n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">res</span>(m,vector&lt;<span class="keyword">int</span>&gt;(n,<span class="number">-1</span>)); <span class="comment">//初始化为-1，代表未访问过的点</span></span><br><span class="line">        queue&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; q;</span><br><span class="line">        <span class="comment">// 初始化那些0的点，res也应当为0，将他们入队</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(mat[i][j] == <span class="number">0</span>)&#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(&#123;i,j&#125;);</span><br><span class="line">                    res[i][j] = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            <span class="keyword">int</span> x = q.<span class="built_in">front</span>().first;</span><br><span class="line">            <span class="keyword">int</span> y = q.<span class="built_in">front</span>().second;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)&#123;</span><br><span class="line">                <span class="keyword">int</span> new_x = x + neighbor[i][<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">int</span> new_y = y + neighbor[i][<span class="number">1</span>];</span><br><span class="line">              <span class="comment">//如果节点不合法，或者节点已经访问过了，直接跳过</span></span><br><span class="line">                <span class="keyword">if</span>(new_x &lt; <span class="number">0</span> || new_x &gt;= m || new_y &lt; <span class="number">0</span> || new_y &gt;= n || res[new_x][new_y] != <span class="number">-1</span>) <span class="keyword">continue</span>;</span><br><span class="line">              <span class="comment">//计算res，push进入</span></span><br><span class="line">                res[new_x][new_y] = res[x][y] + <span class="number">1</span>;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;new_x,new_y&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解题思路2动态规划"><strong>解题思路2:动态规划</strong></h5><p>​ <strong>采用DP，状态转移方程如下：</strong> <span class="math display">\[f(i,j) =  1 + min(\ f(i − 1, j),\  f(i, j − 1),\ f(i + 1, j), \ f(i, j + 1) \ \ )\ \ \ \ \  if (matrix[i][j] == 1)\]</span></p><p><span class="math display">\[f(i,j)=  0 \ \ \ \ \ \   if (matrix[i][j] == 0)\]</span></p><p>​ 此时，我们需要注意，按照上述状态转移方程，我们好像没有一个办法遍历<code>i，j</code>，能够保证满足，在计算<span class="math inline">\(f(i,j)\)</span>前，我们一定已经获知了<span class="math inline">\(f(i-1,j)\)</span> 和<span class="math inline">\(f(i+1,j)\)</span> 和<span class="math inline">\(f(i,j-1)\)</span> 和<span class="math inline">\(f(i,j+1)\)</span>这四个节点的状态。所以，我们需要分两步来进行计算遍历，先从左上角往右下角计算一遍，计算的时候仅考虑 <span class="math inline">\(f(i-1,j)\)</span> 和<span class="math inline">\(f(i,j-1)\)</span> 这两个节点。再从右下角往左上角计算一遍，计算的时候仅考虑 <span class="math inline">\(f(i+1,j)\)</span> 和<span class="math inline">\(f(i,j+1)\)</span> 这两个节点。由于在前面一遍遍历中，会将结果存在<span class="math inline">\(f(i,j)\)</span>中，再第二轮遍历的时候，只要将那两个节点和当前节点比较，就相当于完成了和上一轮遍历中的两个节点比较。故而能够达到和上述状态转移方程一致的效果，具体请看代码：</p><h5 id="解题代码-1"><strong>解题代码：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">updateMatrix</span>(vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt;&amp; mat) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = mat.<span class="built_in">size</span>(), n = mat[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">dp</span>(m, vector&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) </span><br><span class="line">                dp[i][j] = mat[i][j] == <span class="number">0</span> ? <span class="number">0</span> : <span class="number">1e7</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 从左上角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i - <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j - <span class="number">1</span> &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">mibn</span>(dp[i][j], dp[i][j - <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从右下角开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = m - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = n - <span class="number">1</span>; j &gt;= <span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i + <span class="number">1</span> &lt; m) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (j + <span class="number">1</span> &lt; n) &#123;</span><br><span class="line">                    dp[i][j] = <span class="built_in">min</span>(dp[i][j], dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">一道LeetCode算法题，与图有关</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="DFS与BFS系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/DFS%E4%B8%8EBFS%E7%B3%BB%E5%88%97/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    <category term="图系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%9B%BE%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="BFS" scheme="https://blog.slks.xyz/tags/BFS/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="graph" scheme="https://blog.slks.xyz/tags/graph/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——排列的数目</title>
    <link href="https://blog.slks.xyz/2022/02/21/9ee9d017b9d4/"/>
    <id>https://blog.slks.xyz/2022/02/21/9ee9d017b9d4/</id>
    <published>2022-02-21T07:47:19.000Z</published>
    <updated>2022-02-24T15:33:16.939Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-104.-排列的数目"><a href="https://leetcode-cn.com/problems/D0F0SV/">剑指 Offer II 104. 排列的数目</a></h4><p>​ 给定一个由 不同 正整数组成的数组 nums ，和一个目标整数 target 。请从 nums 中找出并返回总和为 target 的元素组合的个数。数组中的数字可以在一次排列中出现任意次，但是顺序不同的序列被视作不同的组合。</p><p>​ 题目数据保证答案符合 32 位整数范围。</p><ul><li>示例 1：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,2,3], target = 4</span><br><span class="line">输出：7</span><br><span class="line">解释：</span><br><span class="line">所有可能的组合为：</span><br><span class="line">(1, 1, 1, 1)</span><br><span class="line">(1, 1, 2)</span><br><span class="line">(1, 2, 1)</span><br><span class="line">(1, 3)</span><br><span class="line">(2, 1, 1)</span><br><span class="line">(2, 2)</span><br><span class="line">(3, 1)</span><br><span class="line">请注意，顺序不同的序列被视作不同的组合。</span><br></pre></td></tr></table></figure><p>提示：</p><pre><code>1 &lt;= nums.length &lt;= 2001 &lt;= nums[i] &lt;= 1000nums 中的所有元素 互不相同1 &lt;= target &lt;= 1000</code></pre><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>参考官方解答： https://leetcode-cn.com/problems/D0F0SV/solution/pai-lie-de-shu-mu-by-leetcode-solution-og7w/</p><p>​ 该题目中，比较棘手的问题，是我们需要计算排列数目，一开始看到题目，还是想着背包问题的解法，被背包问题局限死了思路，总想着先计算组合数目，再计算排列数目，但后来发现并不是很合理，如果需要这样子的话，我不仅需要记录组合的数目，我还要计算每一组组合是什么，以便后续根据其内容计算排列数目。</p><p>​ 其实，跳出整一个背包问题的思路，我们采用动态规划的思想去思考：假设我们定义<code>res[i][j]</code>为前<code>i</code>个元素，达到<code>target=j</code>所有的排列数目，然后去思考转移方程，好像没法做，因为其并不能考虑排列，而是考虑的组合数目。故而正确的思路应当如下：</p><h5 id="定义"><strong>定义</strong>：</h5><pre><code>`res[target]`为达到目标整数target，可以出现的排列个数</code></pre><h5 id="初始化"><strong>初始化</strong>：</h5><pre><code>`res[0] = 1`，因为，要想达到目标整数0，只有一种排列方式，就是什么都不选。毕竟每一个元素都大于0.</code></pre><h5 id="状态转移分析"><strong>状态转移分析</strong>：</h5><pre><code>状态转移较为麻烦，对于`res[i]`而言，如何通过子问题的解来进行计算目标为`i`时候的排列数呢？</code></pre><p>​ 对于一个排列而言，肯定存在最后一个数，我们假定最后这个数为<code>num</code>,这个数肯定是<code>nums</code>中的一个。那么这个排列前面的这些数，它们的和就是<code>i - num</code>，也就是说<code>res[i-num]</code>所记录的排列数量，其中的每个排列，加上最后那个数num，会形成一个新的排列，这个排列就是满足<code>target = i</code>中的一个排列，所以<code>res[i] = res[i-num]</code>，这对吗？这不完全对！我们的<code>res[i]</code>的来源可不仅仅一个num，之前说了我们假定最后这个数为<code>num</code>，其实最后这个数可以是<code>nums</code>中的任意一个数，也就是说，我们要遍历<code>nums</code>中的所有数，看某一个数能不能作为最后一个数（只要num &lt;= i即可），如果能，那么<code>res[i] += res[i-num]</code>。最终，<code>res[i]</code>应该是一系列的数值加和得到的结果。</p><h5 id="状态转移方程"><strong>状态转移方程</strong>：</h5><p>​ <code>res[i] = sum&#123; res[i-num] for each num in nums &#125; ( num &lt;= i)</code></p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">combinationSum4</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(target+<span class="number">1</span>)</span></span>;</span><br><span class="line">        res[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=target;i++)&#123;</span><br><span class="line">            <span class="keyword">unsigned</span> <span class="keyword">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> num = nums[j];</span><br><span class="line">                <span class="keyword">if</span>(num &lt;= i)&#123;</span><br><span class="line">                    tmp += res[i-num];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res[i] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[target];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="进阶问题"><strong>进阶问题：</strong></h5><pre><code>如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？</code></pre><h5 id="解答"><strong>解答</strong>：</h5><pre><code>如果给定的数组中含有负数，则会导致出现无限长度的排列。</code></pre><p>​ 例如，假设数组 nums 中含有正整数 a 和负整数 −b（其中 a&gt;0,b&gt;0,−b&lt;0），则有 a×b+(−b)×a=0，对于任意一个元素之和等于 target 的排列，在该排列的后面添加 b 个 a 和 a 个 −b 之后，得到的新排列的元素之和仍然等于 target，而且还可以在新排列的后面继续 b 个 a 和 a 个 −b。因此只要存在元素之和等于 target 的排列，就能构造出无限长度的排列。</p><p>​ 如果允许负数出现，则必须限制排列的最大长度，避免出现无限长度的排列，才能计算排列数</p>]]></content>
    
    
    <summary type="html">本篇笔记记录经典的背包问题系列解题思路及方法，可以活用至许多相似题目</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——经典背包问题及扩展</title>
    <link href="https://blog.slks.xyz/2022/02/21/8eca8d666ea6/"/>
    <id>https://blog.slks.xyz/2022/02/21/8eca8d666ea6/</id>
    <published>2022-02-21T07:47:19.000Z</published>
    <updated>2022-02-24T10:19:28.425Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一背包问题简介">一、背包问题简介</h3><p>​ 背包问题其实分很多种，此类问题的一般描述为：能否选择若干物品，使它们刚好放满一个容量为 t 的背包。在该篇博文中，我对其进行了详细的梳理。</p><ul><li><p>若每种物品可以选择拿一部分，则为<strong>分数背包问题</strong>，可以使用贪婪解决。</p></li><li><p>若每种物品只有一个，只能拿或者不拿，则为<strong>0-1背包问题</strong>，贪婪无法得到最优解，需用DP。</p></li><li><p>若每个物品的个数有限，则为<strong>多重背包问题</strong>；</p></li><li><p>若每个物品的个数无限，则为<strong>完全背包问题</strong>。</p></li></ul><h3 id="二分数背包问题">二、分数背包问题：</h3><p>​ 分数背包问题思路非常简单，采用贪婪的思路，我们只需要先计算每一种物品，它的性价比，然后进行排序，拿性价比高的物品，直到背包被装满即可。 <span class="math display">\[性价比 = 物品总价值 / 物品总体积\]</span></p><h3 id="三0-1背包问题">三、0-1背包问题：</h3><h4 id="题目描述">题目描述：</h4><p>​ 一共有N件物品，第i（i从1开始）件物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析">分析：</h4><p>​ 如果采用暴力穷举的方式，每件物品都存在装入和不装入两种情况，所以总的时间复杂度是O(2^N)，这是不可接受的。而使用动态规划可以将复杂度降至O(NW)。我们的<strong>目标是书包内物品的总价值，而变量是物品和书包的限重</strong>，所以我们可有如下解决方案</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p><ol type="1"><li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li><li>装入第 i 件物品（前提是能装下），即 <code>dp[i−1][j−w[i]] + v[i]</code>。</li></ol></li><li><p>``` dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])        if( j &gt;= w[i] ) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">    从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">    第 i 件物品装入或者不装入而获得的最大价值完全可以由前面 i-1 件物品的最大价值决定，暴力枚举忽略了这个事实</span><br><span class="line"></span><br><span class="line">- 核心代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;W;j++)</span><br><span class="line">  dp[i][j] = max(dp[i−1][j], dp[i−1][j−w[i]]+v[i])</span><br></pre></td></tr></table></figure></p></li></ul></li></ul><h4 id="题目示例">题目示例：</h4><p>​ <a href="https://leetcode-cn.com/problems/YaVDxD/">剑指 Offer II 102. 加减的目标值</a></p><h3 id="四完全背包问题">四、完全背包问题：</h3><h4 id="题目描述-1">题目描述：</h4><p>​ 完全背包（unbounded knapsack problem）与01背包不同就是每种物品可以有无限多个：一共有N种物品，每种物品有无限多个，第i（i从1开始）种物品的重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析思路1">分析思路1：</h4><p>​ 大体的规则与初始化状态都和0-1背包问题一致，在状态转移方程处有所区别：</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li><p>当 i &gt; 0 时<code>dp[i][j]</code> 有两种情况：</p><ol type="1"><li>不装入第i件物品，即<code>dp[i-1][j]</code> ；</li><li>装入第i种物品，此时和0-1背包不太一样，因为每种物品有无限个（但注意书包限重是有限的），所以此时不应该转移到<code>dp[i−1][j−w[i]]</code>而应该转移到<code>dp[i][j−w[i]]</code>，即装入第 i种商品后还可以再继续装入第i种商品。</li></ol></li><li><p>``` dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) if( j &gt;= w[i] ) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">  此解法时间复杂度为O(NW)</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br></pre></td></tr></table></figure> for(int i=0;i&lt;n;i++) for(int j=0;j&lt;W;j++) dp[i][j] = max(dp[i−1][j], dp[i][j−w[i]]+v[i]) <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">#### 分析思路2：</span><br><span class="line"></span><br><span class="line">​我们从装入第 `i `种物品多少件出发，0-1背包只有两种情况即取0件和取1件，而这里是取0件、1件、2件...直到超过限重（k &gt; j/w[i]），所以状态转移方程为：</span><br><span class="line"></span><br><span class="line">- 定义规则如下：与0-1相同</span><br><span class="line">  - `dp[i][j]` 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中  `0&lt;=i&lt;=N, 0&lt;=j&lt;=W`</span><br><span class="line"></span><br><span class="line">- 初始化状态：与0-1相同</span><br><span class="line"></span><br><span class="line">  - 将`dp[0][0...W]`初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</span><br><span class="line"></span><br><span class="line">- 状态转移方程：</span><br><span class="line"></span><br><span class="line">  - ```text</span><br><span class="line">    # k为装入第i种物品的件数, k &lt;= j/w[i]</span><br><span class="line">    dp[i][j] = max&#123;(dp[i-1][j − k*w[i]] + k*v[i]) for every k&#125;</span><br></pre></td></tr></table></figure></p><p>从上述方程中，我们知晓<code>dp[i][j]</code>的值只与<code>dp[i-1][0,...,j-1]</code>有关，就可以开始书写动态规划代码</p></li></ul></li><li><p>伪代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;W;j++)</span><br><span class="line">        <span class="keyword">for</span>（<span class="keyword">int</span> k = <span class="number">0</span>;k&lt;j/w[i];k++)  <span class="comment">// j / w[i] 为可以装进的最大数目</span></span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j], dp[i][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li></ul><h4 id="题目示例-1">题目示例：</h4><p>​ <a href="https://leetcode-cn.com/problems/gaM7Ch/">剑指 Offer II 103. 最少的硬币数目</a></p><h3 id="五多重背包问题">五、多重背包问题：</h3><h4 id="题目描述-2">题目描述：</h4><p>​ 多重背包（bounded knapsack problem）与前面不同就是<strong>每种物品是有限个</strong>：一共有N种物品，第i（i从1开始）种物品的数量为n[i]，重量为w[i]，价值为v[i]。在总重量不超过背包承载上限W的情况下，能够装入背包的最大价值是多少？</p><h4 id="分析-1">分析：</h4><p>​ 大体的规则与初始化状态都和完全背包的分析2角度一致，就是在状态转移方程处的k的大小有了一个更高的限制。</p><ul><li><p>定义规则如下：</p><ul><li><code>dp[i][j]</code> 表示将前i件物品装进限重为j的背包可以获得的最大价值,其中 <code>0&lt;=i&lt;=N, 0&lt;=j&lt;=W</code></li></ul></li><li><p>初始化状态：</p><ul><li>将<code>dp[0][0...W]</code>初始化为0，表示将前0个物品（即没有物品）装入书包的最大价值为0。</li></ul></li><li><p>状态转移方程：</p><ul><li>```text # k为装入第i种物品的件数, k &lt;= min(n[i], j/w[i]) dp[i][j] = max{(dp[i-1][j − k<em>w[i]] + k</em>v[i]) for every k} <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">  从上述方程中，我们知晓`dp[i][j]`的值只与`dp[i-1][0,...,j-1]`有关，就可以开始书写动态规划代码，</span><br><span class="line"></span><br><span class="line">- 伪代码：</span><br><span class="line"></span><br><span class="line">  ```C++</span><br><span class="line">  for(int i=0;i&lt;n;i++)</span><br><span class="line">  for(int j=0;j&lt;W;j++)</span><br><span class="line">          for（int k = 0;k&lt;min(n[i], j/w[i]);k++)  // min(n[i], j/w[i]) 为可以装进的背包的最大数目</span><br><span class="line">              dp[i][j] = max(dp[i-1][j], dp[i-1][j−k*w[i]]+k*v[i])</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="六备注">六、备注：</h3><p>​ 上述所有的算法，由于状态转移方程的特殊性，所以其实在空间复杂度上是可以进行优化的，我们可以使用<strong>滚动数组</strong>的方法来进行优化，就比如最普通的0-1问题，使用滚动数组优化后，我们可以仅用一个一维数组来存储结果，丢掉原先二维数组的第1个维度。</p><p>​ 但是需要注意的是，在对j遍历的时候，必须逆向枚举，这是为了防止上一层循环的<code>dp[0,...,j-1]</code>被覆盖。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dp[<span class="number">0</span>,...,W] = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> i = <span class="number">1</span>,...,N</span><br><span class="line">    <span class="keyword">for</span> j = W,...,w[i] <span class="comment">// 必须逆向枚举!!!</span></span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j−w[i]]+v[i])</span><br></pre></td></tr></table></figure><p>参考：<strong>https://zhuanlan.zhihu.com/p/93857890</strong></p>]]></content>
    
    
    <summary type="html">本篇笔记记录经典的背包问题系列解题思路及方法，可以活用至许多相似题目</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="knapsack problem" scheme="https://blog.slks.xyz/tags/knapsack-problem/"/>
    
  </entry>
  
  <entry>
    <title>字符串交织问题</title>
    <link href="https://blog.slks.xyz/2022/02/21/f178664086c4/"/>
    <id>https://blog.slks.xyz/2022/02/21/f178664086c4/</id>
    <published>2022-02-21T06:36:19.000Z</published>
    <updated>2022-02-24T15:36:49.298Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-096.-字符串交织"><a href="https://leetcode-cn.com/problems/IY6buf/">剑指 Offer II 096. 字符串交织</a></h4><p>给定三个字符串 s1、s2、s3，请判断 s3 能不能由 s1 和 s2 交织（交错） 组成。</p><p>两个字符串 s 和 t 交织 的定义与过程如下，其中每个字符串都会被分割成若干 非空 子字符串：</p><pre><code>s = s1 + s2 + ... + snt = t1 + t2 + ... + tm|n - m| &lt;= 1交织 是 s1 + t1 + s2 + t2 + s3 + t3 + ... 或者 t1 + s1 + t2 + s2 + t3 + s3 + ...</code></pre><p>提示：a + b 意味着字符串 a 和 b 连接。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s1 = &quot;aabcc&quot;, s2 = &quot;dbbca&quot;, s3 = &quot;aadbbcbcac&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><h5 id="解题思路1"><strong>解题思路1</strong>：</h5><p>​ 该题其实可以使用非常方便的回溯法思想进行解题，利用递归的形式：我们定义三个指针i，j，k，分别指向三个字符串，如果s1[i] == s3[k]，那么递归处理(i+1,j,k+1)。同理，如果s2[j] == s3[k]，那么递归处理(i,j+1,k+1)。递归边界是：如果i，j，k都到达了字符串的最后，就代表能够完成字符串交织。</p><h5 id="代码如下"><strong>代码如下：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此时，会出现一个严重的问题，对于一些较长的序列来说，会通不过，运行超时。这是因为，这个回溯法，在分支进行的过程中，是很容易出现非常多的分支，并且会容易递归很多次的。所以，对于一些已经递归过的i，j，k结果，我们需要直接让它返回，不要继续递归计算，也就是对回溯法进行剪枝的操作。</p><h5 id="优化代码如下"><strong>优化代码如下：</strong></h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m; </span><br><span class="line">        <span class="built_in">backtrace</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">return</span> flag;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">backtrace</span><span class="params">(<span class="keyword">int</span> i,<span class="keyword">int</span> j,<span class="keyword">int</span> k,string &amp;s1, string &amp;s2, string &amp;s3,unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == s1.<span class="built_in">length</span>() &amp;&amp; j == s2.<span class="built_in">length</span>() &amp;&amp; k == s3.<span class="built_in">length</span>())&#123;</span><br><span class="line">            <span class="keyword">this</span>-&gt;flag = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> checkpoint = i * <span class="number">100</span> + j * <span class="number">10</span> + k;</span><br><span class="line">        <span class="keyword">if</span>(m.<span class="built_in">find</span>(checkpoint) != m.<span class="built_in">end</span>()) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">else</span> m[checkpoint] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;s1.<span class="built_in">length</span>() &amp;&amp; s1[i] == s3[k]) <span class="built_in">backtrace</span>(i+<span class="number">1</span>,j,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">        <span class="keyword">if</span>(j&lt;s2.<span class="built_in">length</span>() &amp;&amp; s2[j] == s3[k]) <span class="built_in">backtrace</span>(i,j+<span class="number">1</span>,k+<span class="number">1</span>,s1,s2,s3,m);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/mac/截屏2022-02-21%20下午2.48.28.png" /></p><h5 id="解题思路2dynamic-programming-动态规划"><strong>解题思路2：Dynamic Programming 动态规划</strong></h5><p><strong>参考题解：</strong>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offerguan-jie-de-ge-ren-li-jie-gpspb/</p><p>https://leetcode-cn.com/problems/IY6buf/solution/jian-zhi-offer-2-mian-shi-ti-96-shu-zhon-5kc7/</p><p>​ 可以把题目进行一定的等效转换。约定从s1和s2中按从头到尾的顺序，依次取出一个字符（每次可以从s1中取，也可以从s2中取），加入字符串s3中，这样s3一定是s1和s2交错组成的结果。</p><p>​ 那么问题就转换为在按顺序取的情况下，s1的前i个字符和s2的前jjj个字符是否能构成s3的前i+j个字符？</p><h6 id="状态转移方程用fij表示s10i和s20j能否组成s30ij1"><strong>状态转移方程</strong>：用f(i,j)表示s1[0:i]和s2[0:j]能否组成s3[0:i+j+1]</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if s3[i+j+1] == s1[i]</span><br><span class="line">    f(i,j) = f(i-1,j)</span><br><span class="line">if s3[i+j+1] == s2[j]</span><br><span class="line">    f(i,j) = f(i,j-1)</span><br><span class="line">if s3[i+j+1] == s1[i] == s2[j]</span><br><span class="line">    f(i,j) = f(i-1,j) || f(i,j-1)</span><br></pre></td></tr></table></figure><h6 id="状态转移方程的原理-对于字符串s30ij1的最后一个字符"><strong>状态转移方程的原理:</strong> 对于字符串s3[0:i+j+1]的最后一个字符：</h6><ul><li>如果该字符等于s1最后一个字符，原问题变为子问题1： s3[0:i+j]是否可以由s1[0:i-1]与s2[0:j]构成；</li><li>如果该字符等于s2最后一个字符，原问题变为子问题2： s3[0:i+j]可以由s1[0:i]与s2[0:j-1]构成。</li><li>如果该字符等于s2最后一个字符，也等于s1最后一个字符，那么子问题1和子问题2中任何一个成立，都可以推出原问题成立</li></ul><p><strong>其余注意初始状态即可</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isInterleave</span><span class="params">(string s1, string s2, string s3)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(s1.<span class="built_in">size</span>() + s2.<span class="built_in">size</span>() != s3.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">dp</span>(s1.<span class="built_in">size</span>() + <span class="number">1</span>, vector&lt;<span class="keyword">bool</span>&gt;(s2.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="literal">false</span>));</span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>() &amp;&amp; s2[j] == s3[j]; ++j) &#123;</span><br><span class="line">            dp[<span class="number">0</span>][j + <span class="number">1</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>() &amp;&amp; s1[i] == s3[i]; ++i) &#123;</span><br><span class="line">            dp[i + <span class="number">1</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; s1.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; s2.<span class="built_in">size</span>(); ++j) &#123; </span><br><span class="line">                <span class="keyword">char</span> ch1 = s1[i];</span><br><span class="line">                <span class="keyword">char</span> ch2 = s2[j];</span><br><span class="line">                <span class="keyword">char</span> ch3 = s3[i + j + <span class="number">1</span>];</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = ((ch1 == ch3) &amp;&amp; dp[i][j + <span class="number">1</span>]) || ((ch2 == ch3) &amp;&amp; dp[i + <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> dp[s1.<span class="built_in">size</span>()][s2.<span class="built_in">size</span>()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCode题目，题目核心为字符串的交织。提供2种解题思路</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    <category term="字符串系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
    <category term="string" scheme="https://blog.slks.xyz/tags/string/"/>
    
  </entry>
  
  <entry>
    <title>数组系列——最长斐波那契数列</title>
    <link href="https://blog.slks.xyz/2022/02/21/aa9aa6191741/"/>
    <id>https://blog.slks.xyz/2022/02/21/aa9aa6191741/</id>
    <published>2022-02-21T05:47:19.000Z</published>
    <updated>2022-02-24T15:35:30.806Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-093.-最长斐波那契数列"><a href="https://leetcode-cn.com/problems/Q91FMA/">剑指 Offer II 093. 最长斐波那契数列</a></h4><p>如果序列 X_1, X_2, ..., X_n 满足下列条件，就说它是 斐波那契式 的：</p><pre><code>n &gt;= 3对于所有 i + 2 &lt;= n，都有 X_i + X_&#123;i+1&#125; = X_&#123;i+2&#125;</code></pre><p>给定一个严格递增的正整数数组形成序列 arr ，找到 arr 中最长的斐波那契式的子序列的长度。如果一个不存在，返回 0 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,2,3,4,5,6,7,8]</span><br><span class="line">输出: 5</span><br><span class="line">解释: 最长的斐波那契式子序列为 [1,2,3,5,8] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: arr = [1,3,7,11,12,14,18]</span><br><span class="line">输出: 3</span><br><span class="line">解释: 最长的斐波那契式子序列有 [1,11,12]、[3,11,14] 以及 [7,11,18] 。</span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 本题在LeetCode上，大多采用动态规划的方法解决，我借鉴了部分思路后，发现其实可以用与动态规划时间复杂度类似的算法解决。如下所示：</p><p>​ <strong>对于一个斐波那契数列来说，其性质给它带来了一个非常重要特性：也就是我们只要知道斐波那契数列中的最后两个数，或者前两个数，亦或者中间的任意的连续的两个数，我们就能够确定一整个斐波那契数列的元素</strong></p><p>​ 举例而言，我们知道一个斐波那契数列中，有两个连续的数为5，8，那么整个斐波那契数列前面可能拥有的数为3，再前面可能的数为2，再前面可能的数为1。反之，再后面的数为13，再后面的数为21，等等。</p><p>​ 之所以称之为可能的数，是因为我们并不知道斐波那契数列的长度，所以可能不存在这些数。放到这道题目中，我们可以用两个指针，i和j，遍历arr中所有的元素，例如：当i=2，j=4的时候，我们就假设arr[i]和arr[j]是斐波那契数列的最后两个数，然后循环的向前计算，观察arr中是否有满足条件的前面的数。</p><p>​ 遍历整个数列的时间复杂度为O(n^2)，而查找arr中是否有满足条件的数，我们可以使用Hash表来完成，先再代码开始处，用O(n)的时间，进行插入，后续查找都只需要O(1)的时间。</p><h5 id="解题代码"><strong>解题代码</strong>：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lenLongestFibSubseq</span><span class="params">(vector&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = arr.<span class="built_in">size</span>();</span><br><span class="line">      <span class="comment">//构建hash表，以便后续查找</span></span><br><span class="line">        unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            m[arr[i]] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="comment">//遍历i，j，计算以arr[i]和arr[j]为最后两个元素的斐波那契数列的长度</span></span><br><span class="line">        <span class="keyword">int</span> maxLen = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;n;j++)&#123;</span><br><span class="line">                <span class="keyword">int</span> res = <span class="built_in">calculateMaxLen</span>(arr[i],arr[j],m);</span><br><span class="line">                <span class="keyword">if</span>( res &gt; maxLen)&#123;</span><br><span class="line">                    maxLen = res;</span><br><span class="line">                &#125;   </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxLen;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMaxLen</span><span class="params">(<span class="keyword">int</span> ele1,<span class="keyword">int</span> ele2,unordered_map&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; &amp;m)</span></span>&#123;</span><br><span class="line">        <span class="keyword">bool</span> flag = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> len = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">            <span class="comment">// 如果找不到的话，退出循环</span></span><br><span class="line">            <span class="keyword">if</span>(ele2 - ele1 &gt;= ele1) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(m.<span class="built_in">find</span>(ele2-ele1) == m.<span class="built_in">end</span>()) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">//如果找到了,迭代：继续循环</span></span><br><span class="line">                flag = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">int</span> tmp = ele2-ele1;</span><br><span class="line">                ele2 = ele1;</span><br><span class="line">                ele1 = tmp;</span><br><span class="line">                len++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!flag) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">讲解最长斐波那契数列问题的非dp解法与思路</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="数组系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%95%B0%E7%BB%84%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="array" scheme="https://blog.slks.xyz/tags/array/"/>
    
  </entry>
  
  <entry>
    <title>动态规划——最少回文分割问题（待更新）</title>
    <link href="https://blog.slks.xyz/2022/02/18/52df1a6e55af/"/>
    <id>https://blog.slks.xyz/2022/02/18/52df1a6e55af/</id>
    <published>2022-02-18T02:41:19.000Z</published>
    <updated>2022-02-25T02:07:09.864Z</updated>
    
    <content type="html"><![CDATA[<h4 id="剑指-offer-ii-094.-最少回文分割"><a href="https://leetcode-cn.com/problems/omKAoA/">剑指 Offer II 094. 最少回文分割</a></h4><p>给定一个字符串 <code>s</code>，请将 <code>s</code> 分割成一些子串，使每个子串都是回文串。</p><p>返回符合要求的 <strong>最少分割次数</strong> 。</p><p><strong>示例 1：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;aab&quot;</span><br><span class="line">输出：1</span><br><span class="line">解释：只需一次分割就可将 s 分割成 [&quot;aa&quot;,&quot;b&quot;] 这样两个回文子串。</span><br></pre></td></tr></table></figure><p><strong>示例 2：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;a&quot;</span><br><span class="line">输出：0</span><br></pre></td></tr></table></figure><h5 id="解题思路"><strong>解题思路</strong>：</h5><p>​ 其内部其实含有两个DP子问题：</p><ul><li>1、字符串所有的子串，它们是不是回文串。即 s[i, j] 这一段是不是回文字符串</li><li>2、如何分割能够有最少的分割次数</li></ul><h5 id="子问题1"><strong>子问题1：</strong></h5><p>​ 我们用一个二维数组 isPalindrome 来进行记录，初始化为false。按照len长度进行遍历：状态转移方程如下所示： <span class="math display">\[s[i][j] = true  \ \ \ \ \ (len = 1)\]</span></p><p><span class="math display">\[s[i][j] = (s[i] == s[j])  \ \ \ \ \ (len = 2)\]</span></p><p><span class="math display">\[s[i][j] = (s[i] == s[j] \ \ \ \&amp;\&amp; \ \ \ isPalindrome[i+1][j-1])  \ \ \ \ (len &gt; 2)\]</span></p><h5 id="代码1">代码1：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line"><span class="comment">// 初始化全false</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line"><span class="comment">// 长度为1的是回文串</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line"><span class="comment">// 从长度为2的子串开始枚举[left, right]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">    <span class="comment">// 左端点</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left + len &lt;= n; ++left) &#123;</span><br><span class="line">        <span class="comment">// 右端点</span></span><br><span class="line">        <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// 长度为2就是这俩是否相等</span></span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]);</span><br><span class="line">        <span class="comment">// 长度大于2, 端点相同的同时，内侧也要是回文</span></span><br><span class="line">        <span class="keyword">if</span> (len &gt; <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]) &amp;&amp; isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="子问题2"><strong>子问题2：</strong></h5><p>​ 我们用一维数组存储，字符串从「起点字符」到「第 i 个字符」组成的子串，最少需要多少分割次数。<code>dp[i]</code> 为将 <code>[0,i]</code> 这一段字符分割为若干回文串的最小分割次数，状态转移方程如下：</p><ul><li><p>从「起点字符」到「第 i 个字符」能形成回文串。那么最小分割次数为 0，此时有 <code>dp[i] = 0</code>； <span class="math display">\[dp[i] = 0 \ \ \ \ \ ( isPalindrome[0][i] == true)\]</span></p></li><li><p>从「起点字符」到「第 i 个字符」不能形成回文串。此时我们需要枚举左端点<code>l</code>，如果<code>[l, i]</code> 这一段是回文串的话，那么有 <code>dp[i] = dp[l- 1] + 1</code> ( 满足回文要求的左端点位置 l 可能有很多个，取最小</p></li></ul><p><span class="math display">\[dp[i] = min(dp[l_0-1],dp[l_1-1],……,dp[l_{i} - 1]  ) + 1 \ \ \ ( isPalindrome[0][i] == false)(l_i = i)\]</span></p><h5 id="代码2">代码2：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// n = s.length()</span></span><br><span class="line"><span class="comment">//2、res[i]代表从「起点字符」到「第 i 个字符」组成的子串要分割成回文串最少的分割次数</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">    <span class="keyword">if</span>(isPalindrome[<span class="number">0</span>][i]) res[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">int</span> min = <span class="number">1e9</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=i;l++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[l][i] &amp;&amp; res[l<span class="number">-1</span>] &lt; min)&#123;</span><br><span class="line">                min = res[l<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res[i] = min + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="总解题代码">总解题代码：</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCut</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//1、需要预先知道 i - j 的字符串是不是回文串 ( i &lt; j) </span></span><br><span class="line">        <span class="comment">//isPalindrome[i][j] 代表 i - j 子串</span></span><br><span class="line">        <span class="keyword">int</span> n = s.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">// 初始化全false</span></span><br><span class="line">        vector&lt;vector&lt;<span class="keyword">bool</span>&gt;&gt; <span class="built_in">isPalindrome</span>(n, vector&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="comment">// 长度为1的是回文串</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) isPalindrome[i][i] = <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">// 从长度为2的子串开始枚举[left, right]</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= n; ++len)&#123;</span><br><span class="line">            <span class="comment">// 左端点</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>; left + len &lt;= n; ++left) &#123;</span><br><span class="line">                <span class="comment">// 右端点</span></span><br><span class="line">                <span class="keyword">int</span> right = left + len - <span class="number">1</span>;</span><br><span class="line">                <span class="comment">// 长度为2就是这俩是否相等</span></span><br><span class="line">                <span class="keyword">if</span> (len == <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]);</span><br><span class="line">                <span class="comment">// 长度大于2, 端点相同的同时，内侧也要是回文</span></span><br><span class="line">                <span class="keyword">if</span> (len &gt; <span class="number">2</span>) isPalindrome[left][right] = (s[left] == s[right]) &amp;&amp; isPalindrome[left + <span class="number">1</span>][right - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//2、res[i]代表从「起点字符」到「第 i 个字符」组成的子串要分割成回文串最少的分割次数</span></span><br><span class="line">        <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">res</span><span class="params">(n)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(isPalindrome[<span class="number">0</span>][i]) res[i] = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">int</span> min = <span class="number">1e9</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l=<span class="number">0</span>;l&lt;=i;l++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(isPalindrome[l][i] &amp;&amp; res[l<span class="number">-1</span>] &lt; min)&#123;</span><br><span class="line">                        min = res[l<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                res[i] = min + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res[n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">本篇笔记记录一道LeetCzuizui题目，题目核心为动态规划。</summary>
    
    
    
    <category term="⓷ 算法类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="动态规划系列" scheme="https://blog.slks.xyz/categories/%E2%93%B7-%E7%AE%97%E6%B3%95%E7%B1%BB%E7%AC%94%E8%AE%B0/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%B3%BB%E5%88%97/"/>
    
    
    <category term="leetcode" scheme="https://blog.slks.xyz/tags/leetcode/"/>
    
    <category term="dynamic programming" scheme="https://blog.slks.xyz/tags/dynamic-programming/"/>
    
  </entry>
  
</feed>
