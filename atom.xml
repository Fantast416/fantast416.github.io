<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Fantast&#39;s Blog</title>
  
  
  <link href="https://blog.slks.xyz/atom.xml" rel="self"/>
  
  <link href="https://blog.slks.xyz/"/>
  <updated>2022-05-01T08:11:32.000Z</updated>
  <id>https://blog.slks.xyz/</id>
  
  <author>
    <name>Fantast</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>计网微课堂Chap2——物理层原理</title>
    <link href="https://blog.slks.xyz/2022/05/01/81ac33552c19/"/>
    <id>https://blog.slks.xyz/2022/05/01/81ac33552c19/</id>
    <published>2022-05-01T01:36:19.000Z</published>
    <updated>2022-05-01T08:11:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=14</p><h4 id="一物理层的基本概念">一、物理层的基本概念：</h4><p>​解决在各种传输媒体上传输比特0和1流的问题，从而给数据链路层提供透明的传输比特流的服务。</p><p>​ <strong>物理层为数据链路层屏蔽了各种传输媒体的差异。</strong></p><p>物理层协议的主要任务：</p><ul><li>机械特性：指明接口所用接线器的形状和尺寸、引脚数目和排列、固定和锁定装置。</li><li>电气特性：指明在接口电缆的各条线上出现的电压的范围。</li><li>功能特性：指明某条线上出现的某一国平的电压表示何种意义。</li><li>过程特性：指明对于不同功能的各种可能事件的出现顺序。</li></ul><p>由于物理层传输媒体众多，物理层协议众多，主要需要把握以上四个任务。</p><h4 id="二物理层下面的传输媒体">二、物理层下面的传输媒体：</h4><h5 id="导引型传输媒体固体线缆">1、导引型传输媒体（固体线缆）</h5><ul><li>同轴电缆：</li></ul><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220501094821175.png" style="zoom:50%;" /></p><ul><li>双绞线：<ul><li>常用于局域网传输</li></ul></li></ul><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501094949365.png" /></p><ul><li><p>光纤：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095410880.png" /></p><ul><li>通信容量大（25000~30000GHz的带宽）</li><li>传输损耗小，远距离传输时更加经济。</li><li>抗雷电和电磁干扰性能好。这在大电流脉冲干扰的环境下尤为重要。</li><li>无串音干扰，保密性好，不易被窃听。</li><li>体积小，重量轻。</li><li>割接需要专用设备</li><li>接口价格较贵</li></ul></li><li><p>电力线</p></li></ul><h5id="非导引型传输媒体自由空间电磁波">2、非导引型传输媒体（自由空间，电磁波）</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095538393.png" style="zoom: 67%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095701647.png" style="zoom:67%;" /></p><ul><li>无线电波：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095636403.png" /></p><ul><li><p>微波：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501095750323.png" /></p></li><li><p>红外线：</p><ul><li>电视、空调等遥控器</li><li>点对点无线传输，</li><li>直线传输，中间不能有障碍物，</li><li>传输距离短传输速率低（4Mb/s~16Mb/s）</li></ul></li></ul><h4 id="三传输方式">三、传输方式：</h4><h5 id="串行传输和并行传输">1、串行传输和并行传输：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100428195.png" style="zoom:67%;" /></p><h5 id="同步传输与异步传输">2、同步传输与异步传输：</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100542991.png" /></p><ul><li><p>同步传输比特流逐一发送，接收方在比特信号的中间时刻进行检测，由于不同设备的时钟频率不一样，容易产生时钟误差累积，导致比特信号的误检测。所以我们需要一种方法实现收发双方时钟同步：</p><ul><li><p>外同步：在收发双方之间添加一条单独的时钟信号线</p></li><li><p>内同步：发送端将时钟同步信号编码到发送数据中一起传输（例如传统以太网采用的曼彻斯特编码）</p></li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501100823960.png" /></p><ul><li>异步传输以字节为单位，接收端仅在每个字节的起始处对字节内的比特实现同步，故而需要在字节前后加上起始位和结束位。</li></ul><h5 id="单工半双工全双工">3、单工、半双工、全双工：</h5><ul><li>单工示例：广播</li><li>半双工示例：对讲机</li><li>全双工示例：电话</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501101002739.png" /></p><h4 id="四编码与调制">四、编码与调制：</h4><p>​<strong>计算机中二进制数据是运送消息的实体，计算机的网卡会将二进制的数据调制成电信号，</strong>通过网线发送出去。信源发送的原始电信号成为基带信号，其又分为数字基带信号与模拟基带信号。</p><p>​ 信号需要在信道中进行传输，信道又分数字信道和模拟信道。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501134907767.png" /></p><ul><li><p>码元：代表不同离散数值的基本波形。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135008970.png" style="zoom:50%;" /></p></li><li><p>计算机网络中，常用的是将数字信号编码或调制后在信道中进行传输</p></li></ul><h4 id="五常用编码">五、常用编码：</h4><ul><li>归零编码：自同步，但编码效率低。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135231432.png" /></p><ul><li><p>曼彻斯特编码：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135335053.png" /></p></li><li><p>曼彻斯特差分编码：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135411267.png" /></p></li></ul><h4 id="六常用调制方法">六、常用调制方法：</h4><ul><li>基本调制方法，1个码元只能包含1个比特信息</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135556799.png" style="zoom:50%;" /></p><ul><li><p>混合调制：</p><p>正交振幅调制QAM:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501135724678.png" style="zoom:50%;" /></p></li><li><p>12种相位</p></li><li><p>每种相位有1或2种振幅可选,故可以调制出16种码元（波形）</p></li><li><p>每种码元可以对应表示4个比特</p></li><li><p>码元与4个比特的对应关系采用格雷码，即任意两个码元只有一个比特不同</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501155644426.png" style="zoom:50%;" /></p><h4 id="七信道的极限容量">七、信道的极限容量：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501155815683.png" style="zoom: 50%;" /></p><h5 id="奈氏准则"><strong>1、奈氏准则：</strong></h5><h5id="在假定的理想条件下为了避免码间串扰码元的传输速率是有上限的"><strong>在假定的理想条件下，为了避免码间串扰，码元的传输速率是有上限的。</strong></h5><ul><li><p>理想低通信道的最高码元传输速率=2W Baud=2W码元/秒</p></li><li><p>理想带通信道的最高码元传输速率=W Baud =W码元/秒</p></li><li><p>W：信道带宽（单位为Hz）</p></li><li><p>Baud：波特，即码元/秒</p></li></ul><p><strong>码元传输速率又称为波特率</strong>：</p><ul><li>当1个码元只携带一比特的信息量时，波特率 = 比特率</li><li>当1个码元携带 N 比特的信息量时，波特率 = 比特率 / N</li></ul><p><strong>要提高信息传输速率（比特率），就必须设法使每一个码元能携带更多个比特的信息量。</strong></p><p><strong>实际的信道所能传输的最高码元速率，要明显低于奈氏准则给出的这个上限数值。</strong></p><h5 id="香农公式">2、香农公式：</h5><p>​按照上述公式所说，难道只要采用更好的调制方法，使得码元可以携带更多的比特，就能无限制地提高信息的传输速率？</p><p>​答案是否定的。因为<strong>信道的极限信息传输速率还要受限于实际的信号在信道中传输时的信噪比。</strong></p><p><strong>香农公式</strong>：</p><p>​带宽受限且有高斯白噪声干扰的信道的<strong>极限信息传输速率如下</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501160421428.png" style="zoom: 67%;" /></p><p><strong>信道带宽或信道中信噪比越大，信息的极限传输速率越高。</strong></p>]]></content>
    
    
    <summary type="html">计网微课堂Chap2——物理层原理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Computer Network" scheme="https://blog.slks.xyz/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>计网微课堂Chap3——数据链路层原理</title>
    <link href="https://blog.slks.xyz/2022/05/01/cb7d0a0dd4f3/"/>
    <id>https://blog.slks.xyz/2022/05/01/cb7d0a0dd4f3/</id>
    <published>2022-05-01T01:36:19.000Z</published>
    <updated>2022-07-12T06:05:58.273Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=21</p><h4 id="一数据链路层概述">一、数据链路层概述:</h4><p><strong>链路</strong>：从一个结点到相邻节点的一段物理线路，而中间没有任何其他的交换节点</p><h5id="点对点信道数据链路层中的三个重要问题">1、点对点信道数据链路层中的<strong>三个重要问题</strong>：</h5><ul><li>封装成帧<ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518094607556.png" /></li></ul></li><li>差错检测<ul><li>帧在传输过程中，可能会出现冲突，导致误码。</li><li>接收端主机通过<strong>检错码</strong>来判别帧在传输过程中是否有误码</li></ul></li><li>可靠传输<ul><li>数据链路层向上层提供可靠传输服务，如果帧出错了需要丢弃，那么就需要一种机制来保证接收方的主机仍然能够收到丢弃了帧的副本。</li></ul></li></ul><h5id="共享式局域网使用广播信号的数据链路层">2、共享式局域网(使用广播信号的数据链路层)</h5><ul><li>CSMA/CD</li></ul><h5 id="交换式局域网">3、交换式局域网</h5><ul><li>交换机如何转发帧？网桥和交换机的工作原理</li><li>集线器与交换机的区别</li></ul><h5 id="无线局域网">4、无线局域网</h5><ul><li>CSMA/CA</li></ul><h4 id="二封装成帧">二、封装成帧：</h4><ul><li><strong>帧定界</strong>：帧头和帧尾的作用之一就是帧定界，接收方的数据链路层可以通过帧定界标志将物理层交付的比特流变成帧。但并不是所有数据链路层帧格式都有帧定界标志。</li><li>以太网MAC帧：<ul><li>没有帧定界标识符，其交付给物理层后会加上前导码，并且规定了帧间传输间隔时间为96比特时间</li></ul></li><li><strong>透明传输：</strong>指数据链路层对上层交付的传输数据没有任何限制，就好像数据链路层不存在一样。<strong>注意</strong>：没有限制指对上层交付的数据没有任何要求，比如说不能包含某些字符<ul><li>面向字节的物理链路使用字节填充（或称字符填充）的方法实现透明传输。【添加转义符号】</li><li>面向比特的物理链路使用比特填充的方法实现透明传输。【零比特填充法】</li></ul></li><li>考虑到差错控制等多种因素，每一种数据链路层协议都规定了帧的数据部分的长度上限，即最大传送单元MTU（MaximumTransfer Unit）。</li></ul><h4 id="三差错检测">三、差错检测：</h4><ul><li><p><strong>奇偶校验</strong>：在待发送的数据后面添加1位奇偶校验位，使得整个数据中的1个数为奇数或偶数</p><ul><li>如果偶数个位发生误码，无法检测出，误码率较高</li></ul></li><li><p><strong>循环冗余校验CRC</strong>：（广泛应用）收发双方约定好一个生成多项式G(x)，发送方基于待发送的数据和生成多项式计算出差错检测码，并将其添加到传输数据的后面进行传输。</p><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220518155614124.png" style="zoom:50%;" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518155639797.png" /></p><p>示例：待发送信息为101001，生成多项式为<spanclass="math inline">\(G(x) =x^3 + x^2 + 1\)</span>,求余数</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518155840739.png" style="zoom:50%;" /></p></li><li><p><strong>注意</strong>：检错码只能检错，而不能纠错。在计算机网络中通常采用检错重传方式来纠正传输中的差错，或者仅仅是丢弃检测到差错的帧，<strong>这取决于数据链路层向其上层提供的是可靠传输服务还是不可靠传输服务。</strong></p></li></ul><h4 id="四可靠传输的基本概念">四、可靠传输的基本概念：</h4><ul><li><p>若数据链路层向上层提供不可靠传输服务：仅仅丢弃有误码的帧</p></li><li><p>若数据链路层向上层提供可靠传输服务：想办法实现发送端发送什么，接收端就收到神恶魔</p></li></ul><p>​<strong>一般情况下，有线链路的误码率比较低，为了减小开销，并不要求数据链路层向上提供可靠传输服务。即使出现了误码，可靠传输的问题由其上层处理。</strong></p><p>​<strong>无线链路易受干扰，误码率比较高，因此要求数据链路层必须向上层提供可靠传输服务。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518160641668.png" /></p><h4id="五可靠传输的实现机制1停止等待协议stop-wait">五、可靠传输的实现机制1——停止等待协议StopWait：</h4><h5 id="基本机制">1、基本机制：</h5><p>​此处提及的实现机制与六七种的实现机制并不局限于数据链路层，可以应用到计算机网络体系结构的任意一层。</p><ul><li>Case1：针对传输错误的情况，通过ACK和NAK来告知发送方是否传输正确。</li><li>Case2：针对发送方数据丢失的情况，发送方需要一个定时器，如果一定时间内接收不到确认帧则需要重传上一个数据包。</li><li>Case3：针对接收方返回的确认帧丢失的情况：发送方会重传数据包，接收方如何确认不是重复数据包呢？通过单个比特来编码数据包0或1，给数据分组编号</li><li>Case4：针对接收方返回的确认帧重复的情况：给确认帧加上编号，使用比特0或1来标识。</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518163736899.png" /></p><p>​接收端检测到数据分组有误码时，将其丢弃并等待发送方的超时重传。但对于误码率较高的点对点链路，为使发送方尽早重传，也可给发送方发送NAK分组。</p><p>​为了让接收方能够判断所收到的数据分组是否是重复的，需要给数据分组编号。由于停止-等待协议的停等特性，只需1个比特编号就够了，即编号0和1。</p><p>​为了让发送方能够判断所收到的ACK分组是否是重复的，需要给ACK分组编号，所用比特数量与数据分组编号所用比特数量一样。<strong>数据链路层一般不会出现ACK分组迟到的情况，因此在数据链路层实现停止-等待协议可以不用给ACK分组编号。</strong></p><ul><li>超时计时器设置的重传时间应仔细选择。一般可将重传时间选为略大于“从发送方到接收方的平均往返时间"。<ul><li>在数据链路层点对点的往返时间比较确定，重传时间比较好设定。</li><li>然而在运输层，由于端到端往返时间非常不确定，设置合适的重传时间有时并不容易。</li></ul></li></ul><h5 id="信道利用率">2、信道利用率：</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518172223346.png" /></p><p>​当往返时延RTT远大于数据帧发送时延时（比如使用卫星链路），会导致信道利用率非常低</p><h4id="六可靠传输的实现机制2回退n帧协议">六、可靠传输的实现机制2——回退N帧协议：</h4><p>​停等式协议信道利用率十分低，为提高信道利用率，可以使用流水线发送数据的形式.在此基础上通过发送窗口来限制发送接收即为回退N帧协议.</p><p>首先,假设如下：</p><ul><li>采用3个比特给分组遍序号，序号为0-7</li><li>发送窗口的尺寸为<spanclass="math inline">\(W_T\)</span>，取值范围应为<spanclass="math inline">\(1 至 2^3-1\)</span>本例取5</li><li>接收窗口的尺寸为<span class="math inline">\(W_R = 1\)</span></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518215743424.png" /></p><p>接收到确认分组后，发送方发送窗口向后滑动</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518220042728.png" style="zoom:50%;" /></p><p><strong>累积确认</strong>：<strong>接收方不一定要对收到的数据分组逐个发送确认，</strong>而是可以在收到几个数据分组后（由具体实现决定），对按序到达的最后一个数据分组发送确认。<strong><spanclass="math inline">\(ACK_n\)</span>表示序号为n及以前的所有数据分组都已正确接收。</strong></p><p><strong>有差错情况</strong>：假设现在数据包5、6、7、0、1被发送送往接收方，数据包5产生误码，那么数据包5将被丢弃，接收窗口对应的序号为5，故数据包6、7、0、1也因为序号不匹配而被丢弃。然后接收方回向发送方发回最后一个确认的序号的ACK帧，即<spanclass="math inline">\(ACK_4\)</span>。发送方收到<spanclass="math inline">\(ACK_4\)</span>后，收到重复的确认，就知道之前所发送的数据分组出现了差错，就可以开始重传。</p><p><strong>当通信线路质量不好时，回退N帧协议的信道利用率并不比停止：等待协议高。</strong></p><p><strong>如果<spanclass="math inline">\(W_T\)</span>超过其大小上限，就会导致接收方没法分辨新、旧数据分组。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220518220819263.png" /></p><h4id="七可靠传输的实现机制3选择重传协议">七、可靠传输的实现机制3——选择重传协议：</h4><p>​回退N帧协议<strong>接收窗口尺寸</strong>只能为1，一个数据分组的误码会导致后续多个分组无法按序接收而丢弃。</p><p>​为了进一步提高性能，<strong>可设法只重传出现误码的数据分组。</strong>因此，接收窗口的尺寸W：不应再于1（而应大于1），以便接收方先收下失序到达但无误码并且序号落在接收窗口内的那些数据分组，等到所缺分组收齐后再一并送交上层。这就是选择重传协议。</p><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704151242946.png"alt="image-20220704151242946" /><figcaption aria-hidden="true">image-20220704151242946</figcaption></figure><ul><li><p>发送窗口与接收窗口的尺寸限制：</p><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704152510668.png"alt="image-20220704152510668" /><figcaption aria-hidden="true">image-20220704152510668</figcaption></figure></li><li><p>总结：</p><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704154038765.png"alt="image-20220704154038765" /><figcaption aria-hidden="true">image-20220704154038765</figcaption></figure></li></ul><h4 id="八点对点协议ppp">八、点对点协议PPP：</h4><p>​ 点对点协议PPP（Point-to-PointProtocol）是目前使用最广泛的点对点数据链路层协议。广泛应用于广域网路由器之间的交换。</p><p><strong>PPP协议为在点对点链路传输各种协议数据报提供了一个标准方法，主要由以下三部分构成：</strong></p><ul><li>对各种协议数据报的封装方法</li><li>链路控制协议LCP：用于建立、配置以及测试数据链路的连接</li><li>一套网络控制协议NCPs：其中的每一个协议支持不同的网络层协议</li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704170505457.png"alt="image-20220704170505457" /><figcaption aria-hidden="true">image-20220704170505457</figcaption></figure><p><strong>透明传输</strong>：取决于使用的数据链路</p><p><strong>差错检测</strong>：使用CRC来计算该字段的取值</p><p>接收方每收到一个PPP帧，就进行CRC检验。若CRC检验正确，就收下这个帧；反之，就丢弃这个帧。使用PPP的数据链路层向上不提供可靠传输服务。</p><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220704171056851.png"alt="image-20220704171056851" /><figcaption aria-hidden="true">image-20220704171056851</figcaption></figure><h4 id="九媒体接入控制">九、媒体接入控制 ：</h4><p>​共享信道要着重考虑的一个问题就是<strong>如何协调多个发送和接收站点对一个共享传输媒体的占用</strong>，即媒体接入控制MAC（MediumAccess Control）。</p><ul><li>静态划分信道</li><li>动态接入控制-随机接入</li></ul><p><strong>随着技术的发展，交换技术的成熟和成本的降低，具有更高性能的使用点对点链路和链路层交换机的交换式局域网在有线领域已完全取代了共享式局域网，但由于无线信道的广播天性，无线局域网仍然使用的是共享媒体技术。</strong></p><h5 id="静态划分信道">1、静态划分信道：</h5><ul><li>频分复用、时分复用、波分复用（光载波）</li><li>码分复用：</li></ul><p>​与FDM和TDM不同，CDM的每一个用户可以在同样的时间使用同样的频带进行通信。</p><p>​由于各用户使用经过特殊挑选的不同码型，因此各用户之间不会造成干扰。</p><h5id="动态接入控制csmacd协议-载波监听多址接入碰撞检测早期总线式以太网使用广播信道的有线局域网采用的机制">2、动态接入控制——CSMA/CD协议（载波监听多址接入/碰撞检测）早期总线式以太网（使用广播信道的有线局域网）采用的机制</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215138023.png" /></p><ul><li><strong>争用期的概念</strong>：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215431183.png" /></p><ul><li><strong>最小帧长</strong>：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215734966.png" /></p><ul><li><p><strong>最大帧长</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215824549.png" /></p></li><li><p><strong>截断二进制指数退避算法</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709215937630.png" /></p></li><li><p><strong>帧发送流程</strong>：</p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220244808.png" /></p><ul><li><p><strong>帧接收流程</strong>：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220327190.png" /></p></li></ul><p>注：CSMA/CD协议曾经用于各种总线结构以太网和双绞线以太网的早期版本中。现在的以太网基于交换机和全双工连接，不会有碰撞，因此没有必要使用CSMA/CD协议。</p><h5id="动态接入控制csmaca协议载波监听多址接入碰撞避免使用广播信道的无线局域网802.11无线局域网使用的协议">3、动态接入控制——CSMA/CA协议（载波监听多址接入/碰撞避免）使用广播信道的无线局域网（802.11无线局域网）使用的协议</h5><p>​在无线局域网中，不能使用碰撞检测CD，原因如下：口由于无线信道的传输条件特殊，其信号强度的动态范围非常大，无线网卡上接收到的信号，强度往往会远远小于发送信号的强度（可能相差百万倍）。如果要在无线网卡上实现碰撞检测CD，对硬件的要求非常高。即使能够在硬件上实现无线局域网的碰撞检测功能，但由于无线电波传播的特殊性（存在<strong>隐蔽站问题</strong>），进行碰撞检测的意义也不大。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220829915.png" style="zoom: 67%;" /></p><ul><li><p>帧间间隔IFS：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709220922160.png" style="zoom:67%;" /></p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709221000176.png" alt="image-20220709221000176" style="zoom:67%;" /></p><ul><li><p><strong>CSMA/CA工作原理：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220709221319393.png" style="zoom:67%;" /></p></li></ul><p>​1、为何源站检测到信道空闲后，仍然要等待一个DIFS帧间间隔再发送数据帧？</p><p><strong>就是考虑到可能有其他的站有高优先级的帧要发送。若有，就要让高优先级帧先发送。</strong></p><p>​2、为何目的站接收到第一帧以后，要等待一个SIFS帧间间隔再发送数据帧？</p><p><strong>SIFS是最短的帧间间隔，用来分隔开属于一次对话的各帧。在这段时间内，一个站点应当能够从发送方式切换到接收方式。</strong></p><p>​3、为何其他站再检测到信道忙转为空闲且经过DIFS时间后，还要退避一段随机时间才能使用信道？</p><p><strong>防止多个站点同时发送数据而产生碰撞。</strong></p><ul><li><p><strong>退避算法</strong>：</p><p>​当站点检测到信道是空闲的，并且所发送的数据帧不是成功发送完上一个数据帧之后立即连续发送的数据帧，则不使用退避算法。</p><p><strong>以下情况必须使用退避算法：</strong></p><ul><li>在发送数据帧之前检测到信道处于忙状态时；</li><li>在每一次重传一个数据帧时；</li><li>在每一次成功发送后要连续发送下一个帧时（这是为了避免一个站点长时间占用信道）。</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133229589.png" /></p><ul><li>CSMA/CA 示例：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133457488.png" /></p><ul><li><p><strong>802.11信道预约机制：RTS帧和CTS帧</strong></p><ul><li><p>（1）源站在发送数据帧之前先发送一个短的控制帧，称为请求发送RTS（RequestToSend），它包括<strong>源地址、目的地址以及这次通信（包括相应的确认帧）所需的持续时间</strong>。</p></li><li><p>（2）若目的站正确收到源站发来的RTS帧，且媒体空闲，就发送一个响应控制帧，称为允许发送CTS（ClearTo Send），它也包括这次通信所需的持续时间（从RTS帧中将此持续时间复制到CTS帧中）。</p></li><li><p>（3）源站收到CTS帧后，再等待一段时间SIFS后，就可发送其数据帧。</p></li><li><p>（4）若目的站正确收到了源站发来的数据帧，在等待时间SIFS后，就向源站发送确认帧ACK。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711133923678.png" /></p></li><li><p><strong>除源站和目的站以外的其他各站，在收到CTS帧（或数据帧）后就推迟接入到无线局域网中。这样就保证了源站和目的站之间的通信不会受到其他站的干扰。</strong>如果RTS帧发生碰撞，源站就收不到CTS帧，需执行退避算法重传RTS帧。</p></li><li><p>由于RTS帧和CTS帧很短，发送碰撞的概率、碰撞产生的开销及本身的开销都很小。而对于一般的数据帧，其<strong>发送时延往往大于传播时延（因为是局域网）</strong>，碰撞的概率很大，且一旦发生碰撞而导致数据帧重发，则浪费的时间就很多，因此用很小的代价对信道进行预约往往是值得的。</p></li></ul></li><li><p><strong>802.11虚拟载波监听机制：数据帧也能携带通信所需时间</strong></p><ul><li>由于利用虚拟载波监听机制，站点只要监听到RTS帧、CTS帧或数据帧中的任何一个，就能知道信道被占用的持续时间，而不需要真正监听到信道上的信号，因此虚拟载波监听机制能减少隐蔽站带来的碰撞问题。</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711134106642.png" style="zoom: 67%;" /></p><h4 id="十mac地址">十、MAC地址 ：</h4><ul><li>当<strong>多个主机连接在同一个广播信道上</strong>，要想实现两个主机之间的通信，则每个主机都必须有一个唯一的标识，即一个数据链路层地址。</li><li>在每个主机发送的帧中必须携带标识发送主机和接收主机的地址。由于这类地址是用于<strong>媒体接入控制MAC（MediaAccess Control）</strong>，因此这类地址被称为MAC地址；</li></ul><p><strong>一般情况下，用户主机会包含两个网络适配器：有线局域网适配器（有线网卡）和无线局域网适配器（无线网卡）。每个网络适配器都有一个全球唯一的MAC地址。而交换机和路由器往往拥有更多的网络接口，所以会拥有更多的MAC地址。综上所述，严格来说，MAC地址是对网络上各接口的唯一标识，而不是对网络上各设备的唯一标识。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711163330450.png" /></p><h4 id="十一ip地址">十一、IP地址 ：</h4><p><strong>IP地址是因特网（Internet）上的主机和路由器所使用的地址</strong>，用于标识两部分信息：</p><ul><li>网络编号：标识因特网上数以百万计的网络</li><li>主机编号：标识同一网络上不同主机（或路由器各接口）</li></ul><p>​<strong>很显然，之前介绍的MAC地址不具备区分不同网络的功能。如果只是一个单独的网络，不接入因特网，可以只使用MAC地址（这不是一般用户的应用方式）。如果主机所在的网络要接入因特网，则IP地址和MAC地址都需要使用。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711164732641.png" /></p><h4id="十二地址解析协议arp协议仅能在一段链路或一个网络下使用">十二、地址解析协议ARP协议：（仅能在一段链路或一个网络下使用）</h4><p>现在面临这样一个问题：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165421809.png" /></p><p><strong>ARP高速缓存表</strong>：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165459322.png" style="zoom: 67%;" /></p><p>​在主机B想要给主机C发送数据包时，首先会查找自己的ARP高速缓存，发现没有主机C的IP地址和MAC地址的转换记录，此时便会发送如下所示ARP请求报文：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165839100.png" /></p><p>当广播帧到达C时：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711165949206.png" style="zoom:67%;" /></p><ul><li><p>主机C先将B的IP地址与MAC地址记录到自己的ARP高速缓存表中；</p></li><li><p>随后给B发送ARP响应，以告知自己的MAC地址。</p></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170027736.png" style="zoom: 80%;" /></p><p>总线上A、B收到单播帧后：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170135425.png" /></p><p>​主机B的网卡将帧交付上层的ARP解析进程，其将C的IP地址与MAC地址记录到自己的ARP高速缓存表中。</p><ul><li>ARP高速缓存的记录类型有两种</li></ul><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711170244005.png"alt="image-20220711170244005" /><figcaption aria-hidden="true">image-20220711170244005</figcaption></figure><h4 id="十三集线器与交换机">十三、集线器与交换机</h4><ul><li><strong>集线器</strong><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711172230039.png"alt="image-20220711172230039" /></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711173900724.png" style="zoom: 67%;" /></p><ul><li><strong>交换机：</strong></li></ul><p>​以太网交换机通常都有多个接口。每个接口都可以直接与一台主机或另一个以太网交换机相连。一般都工作在<strong>全双工方式</strong>。</p><p>​以太网交换机具有并行性，能同时连通多对接口，使多对主机能同时通信，无碰撞（不使用CSMA/CD协议）。</p><p>​以太网交换机工作在数据链路层（也包括物理层），<strong>它收到帧后，在帧交换表中查找帧的目的MAC地址所对应的接口号，然后通过该接口转发帧。</strong></p><p>​<strong>以太网交换机是一种即插即用设备，其内部的帧交换表是通过自学习算法自动地逐渐建立起来的。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711181652815.png" /></p><h4id="十四以太网交换机自学习和转发帧流程">十四、以太网交换机自学习和转发帧流程</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711222156764.png" /></p><p>​<strong>主机A要给主机B发送一个帧，首先到达以太网交换机1，以太网交换机1首先进行登记，将MAC地址A和对应接口1记录到帧交换表中，然后查找目的地址B，如果找不到，则进行盲目泛洪，将帧转发给其他的所有接口。如果找到了，则转发至对应接口</strong>以此类推</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220711223207055.png" alt="image-20220711223207055" style="zoom:67%;" /></p><p>​<strong>主机G给主机A发送一个帧，帧沿着总线到达A和交换机接口1，主机A接收该帧，交换机1查找表，发现应当转发至接口1，但此时这个帧就是来源于接口1，故以太网交换机1就会丢弃该帧</strong></p><ul><li><strong>注意：每条记录都有自己的有效时间，到期自动删除！这是因为MAC地址与交换机接口的对应关系并不是永久性的！</strong></li></ul><h4id="十五以太网交换机的生成树协议stp">十五、以太网交换机的生成树协议STP</h4><p>​如图所示，如果AB的链路或者BC的链路出现问题，则互相之间就无法通信。那么如何提高以太网的可靠性？</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712094950883.png" alt="image-20220712094950883" style="zoom:67%;" /></p><p>​<strong>添加冗余链路可以提高以太网的可靠性</strong>，但是，冗余链路也会带来负面效应——形成网络环路。</p><p>​ <strong>网络环路</strong>会带来以下问题：</p><ul><li><p>广播风暴：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712095252611.png" /></p><p>广播帧将会在交换机之间反复转发，大量消耗网络资源。</p></li><li><p>主机会收到重复的广播帧</p></li><li><p>交换机的帧交换表震荡漂移</p></li></ul><p>​ <strong>故而以太网交换机使用生成树协议STP（Spanning TreeProtocol），可以在增加冗余链路来提高网络可靠性的同时又避免网络环路带来的各种问题。</strong></p><p>​不论交换机之间采用怎样的物理连接，交换机都能够自动计算并构建一个逻辑上没有环路的网络，其逻辑拓扑结构必须是树型的（无逻辑环路）；（如下图所示）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712095713041.png" style="zoom:50%;" /></p><p>​<strong>当首次连接交换机或网络物理拓扑发生变化时（有可能是人为改变或故障），交换机都将进行生成树的重新计算。</strong></p><h4 id="十六虚拟局域网vlan">十六、虚拟局域网VLAN</h4><p>​随着交换式以太网规模的扩大，广播域相应扩大。巨大的广播域会带来很多弊端，比如广播风暴，难以管理和维护等。</p><p><strong>分割广播域的方法</strong>：</p><ul><li><p>使用路由器分割广播域（因为路由器默认情况下不对广播帧进行转发）</p></li><li><p>虚拟局域网技术VLAN：</p><p>虚拟局域网VLAN（Virtual Local AreaNetwork）是一种将局域网内的设备划分成与物理位置无关的逻辑组的技术，这些逻辑组具有某些共同的需求。</p><p><strong>同一VLAN之间可以广播通信，不同VLAN之间不可以广播通信</strong></p></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220712134553537.png" /></p><p><strong>VLAN的实现机制</strong>：</p><p>​ VLAN基于交换机实现，需要交换机满足两个条件：</p><ul><li>支持IEEE802.1q帧，其对MAC帧格式进行了扩展，插入了4字节的VLAN标识<ul><li>802.1Q帧是由交换机来处理的，而不是用户主机来处理的。</li><li>当交换机收到普通的以太网帧时，会将其插入4字节的VLAN标记转变为802.1Q帧，简称“打标签”</li><li>当交换机转发802.1Q帧时，可能会删除其4字节VLAN标记转变为普通以太网帧，简称“去标签"”。</li></ul></li><li>交换机的端口类型有三种<ul><li><strong>Access：</strong>一般用于连接用户计算机，只能属于一个VLAN，Access端口的PVID值与端口所属VLAN的ID相同（默认为1）<ul><li>接收处理方法：<strong>一般只接受“未打标签”的普通以太网MAC帧。</strong>根据接收帧的端口的PVID给帧“打标签”，即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>发送处理方法：<strong>若帧中的VID与端囗的PVID相等，则“去标签”并转发该帧；否则不转发。</strong></li></ul></li><li><strong>Trunk：</strong>一般用于交换机之间或交换机与路由器之间的互联，其可以属于多个VLAN。用户可以设置Trunk端口的PVID值。默认情况下，Trunk端口的PVID值为1。<ul><li>接收处理方法：<ul><li>接收“未打标签”的帧，<strong>根据接收帧的端口的PVID给帧“打标签”，</strong>即插入4字节VLAN标记字段，字段中的VID取值与端口的PVID取值相等。</li><li>接收”已打标签“的帧，</li></ul></li><li>发送处理方法：<ul><li><strong>对VID等于PVID的帧</strong>，“去标签”再转发；</li><li><strong>对VID不等于PVID的帧</strong>，直接转发；</li></ul></li></ul></li><li><strong>Hybrid：</strong>Hybrid端口既可用于交换机之间或交换机与路由器之间的互连（同Trunk端口），也可用于交换机与用户计算机之间的互连（同Access端口）<ul><li>接收处理方法：（同Trunk端口）</li><li>发送处理方法：<ul><li>查看帧的VID是否在端囗的“去标签”列表中：</li><li>若存在，则“去标签”后再转发；</li><li>若不存在，则直接转发；</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    
    <summary type="html">计网微课堂Chap3——数据链路层原理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Computer Network" scheme="https://blog.slks.xyz/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>清华操作系统课程Chapter1—操作系统概述</title>
    <link href="https://blog.slks.xyz/2022/04/28/7c4029518fb7/"/>
    <id>https://blog.slks.xyz/2022/04/28/7c4029518fb7/</id>
    <published>2022-04-28T09:48:19.000Z</published>
    <updated>2022-04-30T07:58:56.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="section"></h3>]]></content>
    
    
    <summary type="html">包含清华操作系统课程Chapter1的笔记</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <link href="https://blog.slks.xyz/2022/04/27/87bb1a3b00a2/"/>
    <id>https://blog.slks.xyz/2022/04/27/87bb1a3b00a2/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:59:03.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一电子计算机组成">一、电子计算机组成：</h4><h5 id="控制电路">1、控制电路</h5><p>​ 计算机控制电路开关发展历程：电磁继电器——真空管——晶体管</p><p>​ 发展趋势：每秒开关次数更大，更不容易损坏，体积更小</p><ul><li>硅谷的名字来由？晶体管的主要制作来源是硅</li></ul><h5id="为什么电子计算机是二进制表示">2、为什么电子计算机是二进制表示？</h5><p>​1、晶体管本身是不仅可以有电流流过和不流过两种状态，还可以表示电流大小，所以早期电子计算机可能采用三进制、五进制。但是由于状态太多，晶体管变化太快，很容易导致信号混杂出现问题。</p><p>​ 2、布尔代数的理论完善。</p><h5 id="逻辑门">3、逻辑门：</h5><p>​我们可以通过二进制的形式，使用晶体管来构建逻辑门。可以构建更为复杂的逻辑电路。我们可以搭建最基础的AND/ OR / NOT / XOR 逻辑门，从而构建更为复杂的逻辑门。</p><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220427175830177.png" alt="“与”逻辑电路" style="zoom:25%;" /></p><h5 id="计算机如何存储">4、计算机如何存储？</h5><p>​使用True和False表示二进制数的0和1。计算机中使用二进制数进行存储和计算。</p><p>​<strong>整数表示：</strong>使用第一位表示数字的正负，1是负，0为正。</p><p>​<strong>浮点数表示：</strong>IEEE754标准，使用科学计数的形式进行存储。</p><p>​ 32位浮点数：1 + 8 + 23 （正负 + 指数 + 数字）</p><p>​ <strong>ASCII码：</strong>8位，用于表示各种各样的英文符号。</p><p>​<strong>Unicode编码：</strong>设计与1992年，解决了不同国家不同标准的问题。最常见的Unicode是16位，完全足够所有语言、表情进行使用。</p><h5 id="计算机如何计算">5、计算机如何计算：</h5><p>​ <strong>算数逻辑单元ALU</strong>：计算机里负责运算的组件</p>]]></content>
    
    
    <summary type="html">计算机科学速成课笔记1，包含P1-P10集内容，电子计算机、布尔逻辑、逻辑门、二进制、算术逻辑单元、寄存器、内存、中央处理器、指令和程序、高级CPU设计、早期编程方式等</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机科学课" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE/"/>
    
    
    <category term="Computer Science" scheme="https://blog.slks.xyz/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>计算机科学笔记1——P1~P10集内容笔记</title>
    <link href="https://blog.slks.xyz/2022/04/27/698edcb24aab/"/>
    <id>https://blog.slks.xyz/2022/04/27/698edcb24aab/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:58:59.000Z</updated>
    
    <content type="html"><![CDATA[]]></content>
    
    
    <summary type="html">计算机科学速成课笔记1，包含P1-P10集内容，电子计算机、布尔逻辑、逻辑门、二进制、算术逻辑单元、寄存器、内存、中央处理器、指令和程序、高级CPU设计、早期编程方式等</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机科学课" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6%E8%AF%BE/"/>
    
    
    <category term="Computer Science" scheme="https://blog.slks.xyz/tags/Computer-Science/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理Chapter1—概述</title>
    <link href="https://blog.slks.xyz/2022/04/27/5b4ea41fcadf/"/>
    <id>https://blog.slks.xyz/2022/04/27/5b4ea41fcadf/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T16:07:24.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1BE411D7ii</p><h4 id="一计算机硬件发展">一、计算机硬件发展：</h4><p>​ 电子管时代——晶体管时代——中小规模集成电路——大规模集成电路</p><h4id="二计算机硬件的基本组成冯诺依曼-现代计算机">二、计算机硬件的基本组成（冯诺依曼&amp; 现代计算机）</h4><h5 id="冯诺依曼的计算机工作原理">1、冯诺依曼的计算机工作原理：</h5><ul><li><strong>存储程序：</strong>指将指令<strong>以二进制代码的形式事先输入计算机的主存储器，</strong>然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。</li><li><strong>程序控制：</strong>按指令地址访问存储器并取出指令，经译码依次产生指令执行所需的控制信号，实现对计算的控制，完成指令的功能。</li></ul><h5 id="冯诺依曼的计算机的组成">2、冯诺依曼的计算机的组成：</h5><ul><li><p>硬件系统总览：</p><ul><li><p>主机：CPU（运算器【算数运算、逻辑运算】 +控制器【指挥程序运行】）、内存</p></li><li><p>外设：输入输出设备（将信息转换成机器能识别的形式）、外存储器</p></li><li><p>总线：地址线、数据线、控制线</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430165516086.png" style="zoom: 50%;" /></p><p><strong>在计算机系统中，软件和硬件在逻辑上是等效的</strong></p></li></ul></li><li><p>特点：</p><ul><li><p>计算机由五大部件组成【如下图】</p></li><li><p>指令和数据以同等地位存于存储器，可按照地址寻访</p></li><li><p>指令和数据用二进制标识</p></li><li><p>指令由操作码和地址码组成</p></li><li><p>存储程序</p></li></ul></li></ul><p>​<strong>以运算器为中心</strong>，数据的传输都要经过运算器进行中转</p><h5 id="现代计算机的组成">3、现代计算机的组成：</h5><p>​相比于冯诺依曼计算机，现代计算机以<strong>存储器为核心</strong>，如下图所示</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170456159.png" style="zoom:50%;" /></p><p>由于运算器和控制器联系很紧密，在现代的大规模集成电路中，运算器和控制器往往会被集成到一个芯片中，即我们熟知的CPU。</p><p>故：<strong>CPU = 运算器 +控制器</strong>，简化后的现代计算机结构如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170613131.png" alt="image-20220430170613131" style="zoom:50%;" /></p><p>各个专业名词的区分：</p><ul><li>主存一般指主存储器，比如手机中经常写的运行内存RAM就是指主存储器</li><li>辅存一般指 像机械硬盘、固态硬盘等外部IO设备</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430170848656.png" style="zoom:50%;" /></p><h4 id="三各个硬件部件">三、各个硬件部件</h4><h5 id="主存储器的基本组成">1、主存储器的基本组成</h5><h6 id="总览">1）总览</h6><ul><li>1、存储体：用于存放数据</li><li>2、MAR 存储地址寄存器、3、MDR 存储数据寄存器：<ul><li>CPU将地址放到MAR中，主存储器根据MAR中的地址，去存储体中拿到这个数据，然后把这个数据写入MDR中，CPU通过数据线路从MDR中取走数据。</li></ul></li><li>示意图：</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430171815662.png" style="zoom:50%;" /></p><h6 id="存储体">2）存储体：</h6><p>​ 存储体由许多存储单元组成。</p><ul><li>存储单元：每个存储单元中将会存放一串二进制代码，每个存储单元会对应一个地址</li><li>存储字：存储单元中二进制代码的组合</li><li>存储字长：存储单元中二进制代码的位数（常见的有8bit,16bit,32bit,64bit）</li><li>存储元：存储二进制的电子元件，每个存储元可以存1bit【电容】</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430172031137.png" style="zoom:50%;" /></p><h6 id="marmdr">3）MAR、MDR</h6><p>​ MAR的位数反映了存储单元的个数（因为要指明地址）</p><p>​ MDR的位数 = 存储字长,即一个存储单元可以存储二进制代码的位数</p><h5 id="运算器的基本组成">2、运算器的基本组成</h5><p>​ 用于实现算术运算、逻辑运算，由三个寄存器和算术逻辑单元组成</p><p><img src="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220430204256104.png" style="zoom:50%;" /></p><ul><li>ACC：累加器，用于存放操作数或运算结果</li><li>MQ（Multiple-Quotient）：乘商寄存器，在乘、陈运算时，用于存放操作数或运算结果。</li><li>X：通用的操作数寄存器，用于存放操作数</li><li>ALU: 算术逻辑单元，通过内部复杂的电路实现算数运算、逻辑运算</li></ul><h5 id="控制器的基本组成">3、控制器的基本组成</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430204642685.png" style="zoom:50%;" /></p><ul><li>CU：控制单元，分析指令，给出控制信号</li><li>IR：指令寄存器，存放当前执行的指令</li><li>PC：程序计数器，存放下一条指令地址，有自动+1的功能。</li></ul><p>我们的计算机每完成一条指令，需要有以下三个步骤：</p><ul><li>取指令，由PC配合执行</li><li>分析指令，由IR配合执行</li><li>执行指令，由CU配合执行</li></ul><h4 id="四计算机的工作过程示例">四、计算机的工作过程示例</h4><p>​ <strong>步骤1：</strong>高级语言 —》 编译装入主存</p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213423487.png" /></p><p>​ <strong>步骤2</strong>：完成指令的示例过程：</p><p>​ 初始：指令、数据存入主存，PC指向第一条指令</p><p>​步骤概述：从主存中取指令放入IR、PC自动加1、CU分析指令、CU指挥其他部件执行指令<imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213124210.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213216295.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213523337.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430213547286.png" /></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501000330518.png" /></p><p>总结：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220501000641611.png" style="zoom:67%;" /></p><h4 id="三计算机系统性能评价">三、计算机系统性能评价</h4><h5 id="非时间指标">1、非时间指标：</h5><ul><li><p>1）机器字长：指机器一次能处理的二进制位数</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110326661.png" style="zoom: 67%;" /></p><ul><li>由加法器、寄存器的位数决定；</li><li>一般与内部寄存器的位数相等（字长）；</li><li>字长越长，表示数据的范围就越大，精确度越高；</li><li>目前常见的有32位和64位字长。</li></ul></li><li><p>2）总线宽度：数据总线一次能够并行传送的最大信息位数</p><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429110651202.png" /></p><ul><li>一般指运算器与存储器之间的数据总线位数。有些计算机内部与外部数据总线宽度不一致：</li></ul></li><li><p>3）主存容量与存储带宽</p><ul><li><strong>主存容量：</strong>一台计算机贮存所包含的存储单元总数</li><li><strong>存储带宽：</strong>指单位时间内与贮存交换的二进制信息量</li></ul></li></ul><h5 id="时间指标">2、时间指标：</h5><ul><li>主频f / 时钟周期T，外频与倍频<ul><li>主频f：CPU内核工作的时钟频率</li><li>时钟周期T：</li></ul></li></ul>]]></content>
    
    
    <summary type="html">王道计算机组成原理</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机组成原理" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/"/>
    
    
    <category term="Computer Composition" scheme="https://blog.slks.xyz/tags/Computer-Composition/"/>
    
  </entry>
  
  <entry>
    <title>计网微课堂Chap1——计网基础知识与概述</title>
    <link href="https://blog.slks.xyz/2022/04/27/dcdee696a9ce/"/>
    <id>https://blog.slks.xyz/2022/04/27/dcdee696a9ce/</id>
    <published>2022-04-27T09:43:19.000Z</published>
    <updated>2022-04-30T07:59:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>视频地址：https://www.bilibili.com/video/BV1c4411d7jb?p=2</p><h4 id="一网络互联网和因特网概述">一、网络、互联网和因特网概述：</h4><p>1、网络（Network）由若干结点（Node）和连接这些结点的链路（Link）组成。</p><p>2、多个网络可以通过路由器互联，就构成了一个覆盖范围更大的网络，即<strong>互联网</strong></p><p>3、<strong>因特网</strong>是世界山给最大的互联网。</p><h4 id="二因特网发展阶段">二、因特网发展阶段：</h4><p>1、从单个网络ARPANET向互联网发展</p><p>2、逐步构成三级结构的因特网</p><p>3、逐步形成多层次ISP结构的因特网（ISP：因特网服务提供者）</p><h4 id="三因特网服务提供者isp">三、因特网服务提供者ISP：</h4><p>​ ISP拥有接入因特网的能力，个人或企业需要向ISP申请IP。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140348424.png" /></p><h4id="四基于isp的三层结构的因特网">四、基于ISP的三层结构的因特网：</h4><ul><li>第一层：国际性区域</li><li>第二层：区域性或国家性覆盖规模</li><li>第三层：本地范围</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428140515599.png" style="zoom: 33%;" /></p><p>​一个个人主机在接入因特网后也可以成为一个ISP，只要使用路由器等内容将其他主机连入即可。</p><h4 id="五因特网的标准化工作">五、因特网的标准化工作：</h4><p>​因特网在制定其标准上的一个很大的特点是<strong>面向公众。</strong></p><p>​ 因特网所有的RFC（Request ForComments）技术文档都可从因特网上免费下载；</p><p>​因特网协会ISOC是一个国际性组织，它负责对因特网进行全面管理，以及在世界范围内促进其发展和使用。</p><h4 id="六因特网的组成">六、因特网的组成：</h4><ul><li>边缘部分：<ul><li>由所有连接在因特网上的主机组成。这部分是用户直接使用的，用来进行通信（传送数据、音频或视频）和资源共享。</li></ul></li><li>核心部分：<ul><li>由大量网络和连接这些网络的路由器组成。这部分是为边缘部分提供服务的（<strong>提供连通性和交换</strong>）。</li></ul></li></ul><h4 id="七三种交换方式">七、三种交换方式：</h4><h5 id="电路交换-circuit-switching">1、电路交换 Circuit Switching</h5><p>​当电话数量增多时，无法使得两两电话机之间接通，只能使用电话交换机来完成电话机之间两两的通信任务。</p><p>​<strong>电话交换机接通电话线的方式称为电路交换；</strong>从通信资源的分配角度来看，<strong>交换（Switching）就是按照某种方式动态地分配传输线路的资源；</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141032502.png" alt="image-20220428141032502" style="zoom:33%;" /></p><p><strong>电路交换的三个步骤</strong>：</p><ul><li><p>建立连接：分配通信资源（一条固定的物理连接，在双方通信时不会被其他用户占用）</p></li><li><p>通话（一直占用通信资源）</p></li><li><p>释放连接（归还通信资源）</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428141314096.png" style="zoom: 33%;" /></p><p>​当使用电路交换来传送计算机数据时，其线路的传输效率往往很低。<strong>这是由于计算机的数据往往是突发的出现在链路上的</strong></p></li></ul><h5 id="分组交换-packet-switching">2、分组交换 Packet Switching</h5><p>​ <strong>路由器是分组交换中最重要的设备</strong></p><p>发送方：</p><ul><li>构造分组 + 发送分组</li></ul><p>路由器：</p><ul><li>缓存分组 + 转发分组</li></ul><p>接收方：</p><ul><li>接受分组 + 还原报文</li></ul><h5 id="报文交换">3、报文交换：</h5><p>​大致与分组交换一致，但是报文交换<strong>不限制报文的大小，也就要求转发的中间节点有足够的缓存空间</strong>，而分组交换是会把整个报文分成一个个分组，从而进行传输。</p><h5 id="对比">4、对比：</h5><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428142115539.png" alt="image-20220428142115539" style="zoom:50%;" /></p><ul><li>电路交换：<ul><li>通信延时小、有序传输、无冲突、适用范围广（传输模拟、数字信号都可）、实时性强</li><li>建立连接时间长，线路独占，使用效率低、灵活性差（只要中间有一个点出错就要重新拨号）</li></ul></li><li>报文交换：<ul><li>无需建立连接</li><li>动态分配线路（节点交换机会先存储整个报文，再选择合适的空闲路径转发报文）</li><li>提高线路利用率，可靠性。</li><li>提供多目标服务</li><li>存在转发时延、需要较大存储缓存空间、需要传输额外信息量（报文头等）</li></ul></li><li>分组交换：<ul><li>优点：报文交换所拥有的所有优点，同时简化了存储管理，因为分组的大小固定，所有缓冲区大小也会固定，方便管理。加速传输、减少出错概率和重发数据量（如果出错，只需要重传出错分组即可）</li><li>缺点：存在转发时延、需要较大存储缓存空间、需要传输额外信息量（控制信息等）。</li></ul></li><li>分组交换中：<ul><li>对于数据报服务而言：存在失序、丢序、或者重复分组的问题</li><li>对于虚电路服务而言：存在呼叫建立、数据传输、虚电路释放三个过程</li></ul></li></ul><h4 id="八计算机网络分类">八、计算机网络分类：</h4><ul><li>按照覆盖范围分类：<ul><li>广域网WAN（覆盖范围最广，用于高速长途传输）</li><li>城域网MAN（通常作为城市骨干网）</li><li>局域网LAN</li><li>个域网PAN</li></ul></li><li>按拓扑结构分类：<ul><li>总线型网络</li><li>星型网络</li><li>环型网络</li><li>网状型网络</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428150509644.png" style="zoom:50%;" /></p><h4 id="九计算机网络的性能指标">九、计算机网络的性能指标：</h4><h5 id="速率">1、速率</h5><p>​连接在计算机网络上的<strong>主机在数字信道上传送比特的速率</strong>，也称为比特率或数据率。</p><h5 id="带宽">2、带宽</h5><ul><li>在模拟信号系统中的意义：<ul><li>信号所包含的各种不同频率成分所占据的频率范围；</li><li>单位：Hz ，带宽3.1Hz( 300Hz ~ 3.4kHz)</li></ul></li><li>在计算机网络中的意义：<ul><li>用来表示<strong>网络的通信线路所能传送数据的能力</strong>，因此<strong>网络带宽表示在单位时间内从网络中的某一点到另一点所能通过的“最高数据率”；</strong></li><li>单位：b/s</li></ul></li></ul><h5 id="吞吐量">3、吞吐量</h5><p>​ 吞吐量表示在单位时间内通过某个网络（或信道、接口）的数据量。</p><p>​ 吞吐量受网络的带宽或额定速率的限制</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173106779.png" style="zoom: 50%;" /></p><h5 id="时延">4、时延</h5><p>​网络时延由三部分组成：发送时延、传播时延、处理时延，计算公式如下所示：（处理时延一般不做计算）</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173416712.png" /></p><h5 id="时延带宽积">5、时延带宽积</h5><ul><li><p>时延带宽积 = 传播时延 * 带宽</p><p>若发送端连续发送数据，则在所发送的第一个比特即将到达终点时，发送端就已经发送了时延带宽积个比特；</p></li></ul><p>​ 链路的时延带宽积又称为以比特为单位的链路长度。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173800437.png" style="zoom:50%;" /></p><h5 id="往返时间-rtt">6、往返时间 RTT</h5><p>​ 从源主机到目标主机，直到源主机收到目标主机的答复所花费的时间</p><p>​<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428173913426.png" style="zoom: 67%;" /></p><h5 id="利用率">7、利用率</h5><ul><li>信道利用率<ul><li>用来表示某信道有百分之几的时间是被利用的（有数据通过）。</li></ul></li><li>网络利用率<ul><li>全网络的信道利用率的加权平均。</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220428174105464.png" /></p><h5 id="丢包率">8、丢包率</h5><p>​是指在一定的时间范围内，<strong>传输过程中丢失的分组数量与总分组数量的比率。</strong></p><p>​ <strong>分组丢失一般有两种情况</strong>：</p><ul><li>分组在传输过程中出现误码，被节点丢弃</li><li>分组到达一台队列已满的分组交换机时被丢弃，在通信量较大时就可能造成网络拥塞。</li></ul><p>因此，丢包率反映了网络的拥塞情况：</p><ul><li>无拥塞时路径丢包率为0</li><li>轻度拥塞时路径丢包率为1%~4%</li><li>严重拥塞时路径丢包率为5%~15%</li></ul><h4 id="十计算机网络体系结构">十、计算机网络体系结构：</h4><h5 id="常见的计算机网络体系结构">1、常见的计算机网络体系结构：</h5><p>​ OSI体系结构 （法律上的国际标准）、TCP/IP体系结构（事实上的国际标准）</p><ul><li>OSI协议制定较为复杂，运行效率低，层次划分并不合理，被TCP/IP体系代替</li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160500448.png" style="zoom:50%;" /></p><p>​如果用户主机需要接入因特网，必须含有TCP/IP协议族。路由器也需要含有TCP/IP协议族，但是往往路由器只具有网际层和网络接口层。</p><p>​TCP/IP的网络接口层并没有做过多规定，可以兼容多种网络接口，如有线网络、WIFI接口等。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429160803014.png" style="zoom:50%;" /></p><p>​使用IP协议互联不同的网络接口，为向其上的TCP协议和UDP协议提供网络互联服务，TCP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供可靠传输的服务，而UDP协议在享受IP提供的网络互联服务基础上，可向应用层部分协议提供不可靠传输的服务。</p><h5 id="计网结构分层的必要性">2、计网结构分层的必要性：</h5><p>在实现计算机网络的过程中常见需要考虑的问题，并将相应问题划分给相应的层去进行处理：</p><p><strong>情况1：</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161416991.png" alt="两台直连计算机间的传输" style="zoom:50%;" /></p><ul><li><p>物理层问题</p><ul><li><p>采用何种传输媒体</p></li><li><p>采用怎样的物理接口</p></li><li><p>使用怎样的信号表示比特0和比特1</p></li></ul></li></ul><p><strong>情况2：在上述问题解决前提下，考虑如下总线型网络：（现在已经不常用了）</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429161454976.png" alt="总线型网络" style="zoom:50%;" /></p><ul><li><p>数据链路层问题：</p><ul><li><p>如何标识网络中各主机（主机编址问题，例如MAC地址）</p></li><li><p>如何从信号所标识的一连串比特流中区分出<strong>地址和数据</strong></p></li><li><p>如何协调各个主机争用总线</p></li><li><p>使用以太网交换机将多台主机互联形成的交换式以太网中：以太网交换机是如何实现的</p></li></ul></li></ul><p><strong>情况3：解决以上问题后，分组就可以在一组网络中传输了，然而我们日常使用的因特网更为复杂，其是由许多路由器将多个网络进行互连起来的互联网，考虑如下由3个路由器和4个网络构成的小型互联网</strong></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162242434.png" alt="=" style="zoom:50%;" /></p><ul><li><p>网络层:</p><ul><li><p>如何标识各个网络以及网络中的各主机（网络和主机共同编址的问题，如IP地址）</p></li><li><p>分组从源主机到目的主机可走路径不止一条，路由器应当如何转发分组，如何进行路由选择</p></li></ul></li></ul><p><strong>情况4：解决以上问题后，可以实现分组在网络两主机间传输的问题，对于计算机网络应用而言远远不够，对于一台主机而言，可能存在多个进程</strong></p><ul><li><p>运输层</p><ul><li><p><strong>如何标识与网络通信相关的应用进程</strong>，即解决进程之间基于网络的通信问题</p></li><li><p>出现传输错误时，如何处理？（某个分组在传输过程中出现误码，或由于路由器繁忙丢弃分组）</p></li></ul></li></ul><p><strong>情况5：解决上述问题后，可以实现进程之间，基于网络的通信，在此基础上，制定应用层协议，根据协议内容完成特定网络应用即可</strong></p><ul><li>应用层<ul><li>支持万维网应用的HTTP</li><li>支持邮件服务的SMTP</li><li>……</li></ul></li></ul><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429162801442.png" style="zoom:50%;" /></p><h5 id="分层思想举例">3、分层思想举例：</h5><video src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/2022_04_29_19_04_47_435.mp4"></video><h5 id="专用术语">4、专用术语：</h5><ul><li>实体：任何可发送或接收信息的硬件或软件进程。</li><li>对等实体：收发双发相同层次中的实体<ul><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202752020.png" style="zoom:50%;" /></li></ul></li><li>协议：控制两个对等实体<strong>进行逻辑通信</strong>的规则的集合。<ul><li>协议的三要素：<ul><li>语法：定义所交换信息的格式</li><li>语义：定义收发双方所要完成的操作</li><li>同步：定义收发双方的时序关系（ 例如 TCP客户端与TCP服务器之间的时序关系，状态转换）</li></ul></li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429202822644.png" style="zoom:50%;" /></li></ul></li><li>服务：在协议的控制下，两个对等实体间的逻辑通信使得本层能够向上一层提供服务。<ul><li>要实现本层协议，还需要使用下面一层所提供的服务。</li><li>协议是“水平的"，服务是“垂直的"。</li><li>实体看得见相邻下层所提供的服务，但并不知道实现该服务的具体协议。也就是说，下面的协议对上面的实体是“透明”的。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203246032.png" /></li></ul></li><li>服务访问点：在同一系统中相邻两层的实体交换信息的逻辑接口，用于区分不同的服务类型。</li><li>服务原语：上层使用下层所提供的服务必须通过与下层交换一些命令，这些命令称为服务原语。</li><li>协议数据单元PDU：对等层次之间传送的数据包称为该层的<strong>协议数据单元</strong>。<ul><li>比特流、帧、IP数据报、TCP报文段、UDP用户数据报、报文</li><li><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220429203352501.png" style="zoom:67%;" /></li></ul></li><li>服务数据单元SDU：同一系统内，层与层之间交换的数据包称为服务数据单元。</li></ul><h4 id="十一习题">十一、习题：</h4><h5 id="section">1、</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113545991.png" /></p><h5 id="section-1">2、</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430113940223.png" /></p><h5 id="section-2">3、</h5><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220430114621627.png" /></p>]]></content>
    
    
    <summary type="html">计网微课堂Chap1——计网基础知识与概述</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="计算机网络" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
    
    
    <category term="Computer Network" scheme="https://blog.slks.xyz/tags/Computer-Network/"/>
    
  </entry>
  
  <entry>
    <title>《Not All Tokens Are Equal Human-centric Visual Analysis via Token Clustering Transformer》</title>
    <link href="https://blog.slks.xyz/2022/04/24/22e32ee5ba59/"/>
    <id>https://blog.slks.xyz/2022/04/24/22e32ee5ba59/</id>
    <published>2022-04-24T09:12:19.000Z</published>
    <updated>2022-04-27T11:15:30.000Z</updated>
    
    <content type="html"><![CDATA[<h4id="论文名称not-all-tokens-are-equal-human-centric-visual-analysis-via-token-clustering-transformer">论文名称：《NotAll Tokens Are Equal Human-centric Visual Analysis via Token ClusteringTransformer》</h4><h4 id="论文地址-httparxiv.orgabs2204.08680">论文地址：http://arxiv.org/abs/2204.08680</h4><h2 id="关键词">1、关键词：</h2><p>​ Dynamic Token</p><h2 id="摘要">2、摘要：</h2><p>​ViT在许多计算机视觉任务中取得了巨大的成功。大多数方法通过将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。​然而，在以人为中心的视觉任务中，并不是所有区域都同等重要，例如，人体需要一个带有许多token的精细表示，而图像背景可以由少量token建模。​为了解决这个问题，论文提出了一种新的ViT，称为令牌聚类转换器(TCFormer)，它通过渐进聚类来合并token，其中token可以从不同的位置以灵活的形状和大小合并。</p><p>​TCFormer中的令牌不仅可以关注重要区域，还可以调整令牌形状以适应语义概念，并对包含关键细节的区域采用精细分辨率，有利于捕获详细信息。</p><h2 id="领域背景">3、领域背景：</h2><p>​ 暂略</p><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​为了解决传统ViT中，大多将图像分割成规则的固定patches并将每个patch作为一个token来生成视觉token。然而在以人为中心的视觉任务中，并不是所有区域都同等重要，所以论文提出了一种新的ViT(TCFormer)，它通过渐进的令牌聚类生成TOKENS。</p><p>​TCFormer在每个阶段动态生成TOKENS。如图所示，它能够生成具有不同位置、大小和形状的Token。首先，与基于网格的标记不同，聚类后的标记不局限于规则形状，可以专注于重要的区域，如人体。其次，TCFormer动态生成具有适当大小的令牌来表示不同的区域。比如说：<strong>对于充满重要细节(如人脸)的区域，分配更小尺寸的令牌。而仅有单个token(例如，图中的蓝色标记)被用来表示背景的大片区域。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424202223439.png" /></p><p>​ 在TCFormer中，特征图中的每个像素在第一阶段被初始化为一个visiontoken，其token区域就是像素所覆盖的区域。我们逐步合并语义相近的token，在不同阶段得到不同数量的token。</p><p>​ 为此，我们精心设计了一个聚类令牌合并(CTM)块：</p><ul><li>首先，给定上一阶段的tokens，CTM模块使用k-nearest-neighbor baseddensity peaks clustering聚类算法对token进行分组。</li><li>那些被分到一组的tokens，会合并到一个单独的token，其值为所有特征的平均值。</li><li>最后，将tokens输入到一个transformerblock中进行特征聚合。最终合并得到的token区域是所有输入导transformerblock中的tokens的并集。</li></ul><p>​多阶段特征的聚合已经被证明有利于以人为中心的分析。大多数之前的研究将视觉token转换为特征图，并以特征图的形式聚合特征。然而，当我们将动态视觉token转换为特征图时，多个token可能位于同一个像素网格中，导致细节丢失。​为了解决这一问题，我们提出了一种多阶段令牌聚合(MTA)块，它能够有效地保存所有阶段的图像细节。具体来说：</p><ul><li>MTA从最后一个阶段的令牌开始，然后从前一个阶段逐步上采样tokens并聚合token特征，直到聚合所有阶段的特征。聚合的tokens与特征映射中的像素一一对应，并被reshape为特征映射以进行后续处理。</li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203340869.png" /><strong>概述：</strong>TCFormer由4个阶段和一个(MTA)头组成。每个阶段包含几个堆叠的Transformer块。在两个相邻的阶段之间，插入一个(CTM)块，以合并令牌并为下一个阶段生成令牌。最后MTA头将所有阶段的token特征聚集起来，并输出最终的热图</p><h4 id="核心1-transformer-block">1） 核心1： Transformer Block：</h4><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220424203928917.png" style="zoom:50%;" /></p><p>​ 采用Spatial Reduction层来降低计算复杂度。SpatialReduction层首先将视觉token转换为特征映射，然后通过跨卷积层降低特征映射分辨率。处理后的特征图中的像素，比视觉标记要少得多，被作为K和V输入到多头注意模块。多头注意模块在token之间聚合特征。​我们利用Depth-WiseConvolution来捕获局部特征和位置信息，并去除显式位置嵌入。</p><h4 id="核心2-clustering-based-token-merge-ctm-block">2） 核心2：Clustering-based Token Merge (CTM) Block：</h4><p>​如图所示，我们的CTM块有两个过程，即Clustering和特征Merge。我们使用通过Clustering来将visiontokens归到一定数量的聚类中.</p><ul><li>Clustering<ul><li>在Clustering过程中，我们使用了一种基于k近邻密度峰值聚类算法(DPC-KNN)的变体。</li><li>给定一组令牌X，我们根据其k近邻计算每个令牌的局部密度ρ:</li><li>然后，对于每个令牌，我们 计算距离作为它与任何其他具有更高局部密度的令牌之间的最小距离。对于局部密度最高的token，其指示器设置为它与任何其他标记之间的最大距离。</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150522682.png" /></li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150412421.png" /></li><li>δi 是距离指示指标 ，ρi 是局部密度指标</li><li>我们将δi 和 ρi 结合起来，得到每个token的得分为 ρi×δi。</li><li>分数越高，成为集群中心的可能性就越大。我们通过选择得分最高的token来确定聚类中心，然后根据特征距离将其他标记分配到最近的聚类中心。</li></ul></li><li>Merge</li></ul><p>​对于token特征的合并，一种直观的方法是直接对一个聚类中的token特征进行平均。但是，即使是语义意义相似的符号，其重要性也不完全相同。论文引入了一个重要度评分P来明确表示每个token的重要性，它是由token的特征估计的。然后在token重要性的指导下，对token特征进行平均:</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425150756742.png" /></p><p>​ 其中<span class="math inline">\(C_i\)</span>表示第<spanclass="math inline">\(i\)</span>个聚类的集合，<spanclass="math inline">\(x_j\)</span>和<spanclass="math inline">\(p_j\)</span>分别为原始token特征和对应的重要性得分，yi为合并后token的特征。合并令牌的令牌区域是原始令牌区域的并集。</p><ul><li><p>Final</p><p>最终合并好的令牌作为查询Q被送入一个TransformerBlock，原始的Token用作K和V。为了保证重要的token对输出的贡献更大，在注意力机制中增加重要性权重P，如下所示:</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425151005438.png" style="zoom:50%;" /></p><p>引入token重要性评分使我们的CTM块在合并视觉标记时能够专注于关键的图像特征</p></li></ul><h4 id="核心3-multi-stage-token-aggregation-mta-head">3） 核心3：Multi-stage Token Aggregation (MTA) Head：</h4><p>​之前的研究证明了在以人为中心的视觉任务中，在多个阶段中进行特征聚合的好处。为了聚合特性，我们提出了一种基于Transformer的多阶段令牌聚合(MTA)头，它能够维护所有阶段的细节信息。</p><p>​ 下图(a)显示了令牌上采样过程。在令牌合并过程中(章节3.3)，每个令牌被分配到一个聚类，每个聚类由一个合并的令牌表示。我们记录原始token和合并token之间的关系。在token上采样过程中，我们利用所记录的信息将合并的token特征复制到相应的上采样token中。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425152443159.png" style="zoom:67%;" /></p><p>​ MTAHead将上一阶段的token特征添加到上采样的视觉token。然后，视觉token进入一个Transformer块。这样的处理是逐步执行的，直到所有的视觉token被聚合。最终的token，其token表示的区域是高分辨率特征图中的单个像素，可以很容易地重构为特征图进行进一步处理。</p><p>​ 整体而言，有点像UFormer的那种形式。</p>]]></content>
    
    
    <summary type="html">论文提出了一种新的ViT，称为令牌聚类转换器(TCFormer)，它通过渐进聚类来合并token，其中token可以从不同的位置以灵活的形状和大小合并。TCFormer中的令牌不仅可以关注重要区域，还可以调整令牌形状以适应语义概念，并对包含关键细节的区域采用精细分辨率，有利于捕获详细信息。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>《Vision Transformer with Deformable Attention》</title>
    <link href="https://blog.slks.xyz/2022/04/24/503bff4618b7/"/>
    <id>https://blog.slks.xyz/2022/04/24/503bff4618b7/</id>
    <published>2022-04-24T09:12:19.000Z</published>
    <updated>2022-04-27T11:15:19.000Z</updated>
    
    <content type="html"><![CDATA[<h4id="论文名称vision-transformer-with-deformable-attention">论文名称：《VisionTransformer with Deformable Attention》</h4><h4 id="论文地址-httparxiv.orgabs2201.00520">论文地址：http://arxiv.org/abs/2201.00520</h4><h2 id="关键词">1、关键词：</h2><p>​ Deformable Attention</p><h2 id="摘要">2、摘要：</h2><p>​Transformer最近在各种视觉任务中表现优异。全局的感知域使Transformer模型比CNN具有更强的表示能力。​然而，简单地扩大感受野也引起了一些问题。一方面，使用较为密集的注意力，例如在ViT中，会导致过多的内存和计算成本，并且功能可能会受到超出兴趣区域的无关部分的影响。另一方面，在PVT或SwinTransformer中采用的较为稀疏的注意机制是与数据无关的，这可能会限制对于长距离关系的建模能力。​为了缓解这些问题，论文提出了一种新的可变形的SelfAttention模块，在自我注意模块中，KV键值对与数据相关。这种灵活的方案使SelfAttention模块能够关注相关区域，并捕获更多的信息特性。 ​大量实验表明，我们的模型在综合基准上取得了持续改进的结果。</p><p>【类似于DCN对于普通卷积的改进思想】</p><h2 id="研究背景">3、研究背景：</h2><p>​Transformer最初是为了解决自然语言处理任务而引入的。近年来，它在计算机视觉领域显示出巨大的潜力。VisionTransformer(ViT)这项开创性的工作，将多个Transformer块堆叠起来，以处理不重叠的图像patches序列，从而产生用于图像分类的无卷积模型。与CNN模型相比，基于transformer的模型具有更大的接受域，擅长建模远程依赖关系，在大量训练数据和模型参数的情况下具有更优越的性能。</p><p>​ 然而，在视觉识别中过多的注意力是一把双刃剑，存在着多方面的弊端。</p><p>​具体来说，如果每个查询patch要参与的Key数过多，会导致计算成本高、收敛速度慢，并增加过拟合的风险。为了避免过度的注意力计算，现有的研究都利用精心设计的高效注意力模式来降低计算复杂度。其中以SwinTransformer和金字塔视觉转换器(PVT)作为两个最经典的方式。</p><p>​理想情况下，我们期望对于一个给定Query而言，Key和Value的选择应该是具有弹性的，这样才能避免因为人工指定的稀疏注意模式中存在的问题。</p><p>​事实上，在cnn的文献中，学习卷积滤波器的可变形感受野已被证明可以有效地在数据依赖的基础上选择性地关注更有信息的区域，也就是DCN变形卷积。</p><p>​CNN中DCN的思想如果直接应用在SelfAttention机制中，会导致不合理的高内存/计算复杂度。由可变形偏移引入的开销是Patches数量的二次方。​因此，尽管最近的一些工作研究了Transformer中的变形机制的思想，但由于计算成本高，它们都没有将其作为构建像DCN这样强大的骨干网络的基本构件。它们的变形机制要么被用于Head网络中，要么作为预处理层对后续骨干网络中的Patches进行采样。</p><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​基于上述研究背景，该论文提出了一个简单高效的可变形自我注意模块，并通过该模块构造了一个强大的金字塔形式的骨干网络，名为DeformableAttention Transformer(DAT)，用于图像分类和各种密集预测任务。 ​与DCN学习整个featuremap中不同像素的不同偏移量不同，论文提出的方法基于这样一个思想：对于不同的查询，全局attention通常会导致对于不同的Query来说，都是近乎相同的attention模式。于是论文提出，网络通过学习几组与Query无关的偏移量，将键和值移到重要区域。</p><p>​ 该设计既具有线性空间复杂性，又引入了变形的注意模式。</p><p>​ 具体来说，对于每个注意力模块：</p><ul><li>参考点首先作为统一的网格生成，这些网格在输入数据中是相同的。</li><li>然后，一个offset网络以query特征为输入，生成所有参考点对应的偏移量。</li><li>通过这种方式，候选 键/值向重要区域转移，从而使原来的self-attention模块具有更高的灵活性和效率，从而捕捉到更多的信息特征。</li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425194741367.png" /></p><p>​ 现有的ViT，特别是PVT和SwinTransformer试图解决过度关注的挑战。前者的下采样技术会导致严重的信息丢失，而后者的滑动窗口注意力会导致接收域的缓慢增长，这限制了对大对象建模的潜力。​因此，需要一种与数据相关的稀疏Attention机制来灵活地建模相关特征，这导致DCN中首次提出了可变形机制。</p><p>​然而，在Transformer模型中简单地实现DCN并不是一个微不足道的问题。在DCN中，featuremap上的每个元素单独学习其偏移量，其中在<span class="math inline">\(H\times W \times C\)</span> 的特征图上的<span class="math inline">\(3\times 3\)</span>可变形卷积的空间复杂度为<span class="math inline">\(9\times H \times W \timesC\)</span>。如果我们直接在Attention模块中应用同样的机制，空间复杂度将急剧上升到<spanclass="math inline">\(N_qN_kC\)</span>，其中<spanclass="math inline">\(N_q,N_k\)</span>为Query和Key的数量，通常与特征图的size：<spanclass="math inline">\(HW\)</span>具有相同的比例，带来近似双二次复杂度。</p><h4 id="核心机制1-deformable-attention">1）核心机制1： DeformableAttention</h4><p>​ 具体来说，我们提出了在特征图中重要区域的指导下，使用可变形Attention来有效地建模tokens之间的关系。​这些被视为重要的区域是由偏移网络从查询中学习到的多组变形采样点来确定的。我们对特征图中的sample特征应用双线性差值，然后在将插值后的特征送入Key和Value的映射矩阵中，得到变形后的Key和Value。​最后，应用标准的多头注意力机制对采样点Key进行查询，并从变形的Value中聚合特征。​此外，变形点的位置提供了一个更强大的相对位置偏差，以促进DeformableAttention的学习。这个会在第二个核心机制中讨论。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425201030829.png" /></p><ul><li><p><strong>Input:</strong> 特征图: <span class="math inline">\(x \inR^{H \times W \times C}\)</span></p></li><li><p><strong>Step1:</strong>根据特征图建立全局的网格参考点，网格的尺寸是由输入特征图依据因子r下采样得到的。网格<span class="math inline">\(p \in R^{H_G \times W_G \times C}\)</span>,<span class="math inline">\(H_G = H /r , W_G = W /r\)</span></p></li><li><p><strong>Step2:</strong> 参考点的值为网格的线性二维坐标：<spanclass="math inline">\(\{(0,0),……,(H_G-1,W_G-1)\}\)</span>，我们将这些值根据网格的大小Normalize归一化到[-1,+1]之间。(-1,-1)代表最左上角的网格点，(+1,+1)代表最右下角的网格点。</p></li><li><p><strong>Step3:</strong>为了获得每个参考点的偏移量Offset，特征图通过映射矩阵<spanclass="math inline">\(W_q\)</span>得到<spanclass="math inline">\(q\)</span>，然后将<spanclass="math inline">\(q\)</span>喂入一个轻量级的子网络<spanclass="math inline">\(\theta_{offset}\)</span>中，得到每个Q的Offsets。</p><p>（注：为了稳定训练过程，我们将网格点p的振幅用一些预定义的因素s来缩放以防止过大的偏移，具体公式如下：使用<spanclass="math inline">\(s\times tanh(offset_p)\)</span> 代替 <spanclass="math inline">\(offset_p\)</span></p></li><li><p><strong>Step4:</strong>将Step2得到的参考点值和Step3得到的Offset相加，得到变形后的网格参考点DeformedPoints。</p></li><li><p><strong>Step5:</strong>在变形后的网格参考点的位置进行特征采样，使用BilinearInterpolation作为采样函数<spanclass="math inline">\(\phi\)</span>，将采样后的变形特征作为Key和Value，然后经过投影矩阵<spanclass="math inline">\(W_v\)</span>和<spanclass="math inline">\(W_k\)</span>，得到<span class="math inline">\(\hatv\)</span>和<span class="math inline">\(\hat k\)</span>。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202601636.png" style="zoom:67%;" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220425202654922.png" style="zoom: 67%;" /></p><p><span class="math inline">\(g(a,b) = max(0,1-|a-b|)\)</span>，<spanclass="math inline">\((r_x,r_y)\)</span>代表z上所有的位置索引。</p><p>​因为函数g使得只有在4个最接近(px,py)的点上才会是非零，所以可以将等式(8)简化为4个位置的加权平均值</p></li><li><p><strong>Step6</strong>:</p><p>​对q,k,v应用相对位置偏差编码R，然后再经过经典的多头注意力层。单层的输出如下：最后，每个head输出的特征拼接在一起，然后经过Wo进行投影，得到最终输出。<img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100345837.png" style="zoom:67%;" /></p></li></ul><h4 id="核心机制2offset-generation">2）核心机制2：Offset Generation</h4><p>​先前说道，Offset使用一个子网络进行生成，这个自网络接受Query特征，然后输出参考点的偏移值。考虑到每个参考点覆盖了一个局部的<spanclass="math inline">\(s \timess\)</span>的区域，为了学习到合理的偏移量，生成网络还需要对局部特征进行感知。因此，具体做法如下：</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220426100823173.png" style="zoom: 67%;" /></p><p>​ 输入特征先通过 一个 <span class="math inline">\(5\times5\)</span>的depthwise卷积层，来捕获局部特征。然后，应用GELU激活层，以及<spanclass="math inline">\(1\times1\)</span>的卷积层。注意：我们没有使用<spanclass="math inline">\(1\times1\)</span>的卷积层中的Bias，是为了避免所有位置的强制位移。</p><p>其中：<strong>模仿MHSA设计了Offset Group的机制：</strong></p><p>​ 为了提高变形参考点的多样性，我们遵循MHSA（MultiHead SelfAttention）中类似的范式，将特征通道划分为G组。 ​每个组的特征使用共享的子网络参数分别产生相应的偏移量。在实际操作中，注意模块的Head数：M，将会是OffsetGroup中Group数：G的数倍，以确保多个注意头能被分配给一组变形Key和Value。</p><h4 id="核心机制3-deformable-relative-position-bias">3）核心机制3：Deformable Relative Position Bias</h4><p>​相对位置偏差对每对查询和键之间的相对位置进行编码，用空间信息来增加普遍的注意。考虑一个<spanclass="math inline">\(H \timesW\)</span>的特征图，相对位置偏差应该在<spanclass="math inline">\([-H,H]和[-W,W]\)</span>间。</p><p>​因为我们的可变形的注意力，有keys的连续位置，我们在正则化的范围内计算位置偏差，即在<spanclass="math inline">\([-1,+1]\)</span>之间。然后，我们对SwinTransformer中的 BiasTable 应用插值函数，来覆盖所有可能的offset值。</p>]]></content>
    
    
    <summary type="html">该论文提出了一个简单高效的可变形自我注意模块，并通过该模块构造了一个强大的金字塔形式的骨干网络，名为Deformable Attention Transformer(DAT)，用于图像分类和各种密集预测任务。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>论文略读笔记——CVPR2022 Transformer相关（1）</title>
    <link href="https://blog.slks.xyz/2022/04/22/1076c1e77e53/"/>
    <id>https://blog.slks.xyz/2022/04/22/1076c1e77e53/</id>
    <published>2022-04-22T00:51:19.000Z</published>
    <updated>2022-04-23T00:41:24.000Z</updated>
    
    <content type="html"><![CDATA[<h2id="一论文名称batchformer-learning-to-explore-sample-relationships-for-robust-representation-learning">一、论文名称：《BatchFormer:Learning to Explore Sample Relationships for Robust RepresentationLearning》</h2><p>论文地址： https://arxiv.org/abs/2203.01522</p><h4 id="关键词">1、关键词：</h4><p>​ deep representation learning 深度表征学习</p><h4 id="摘要">2、摘要：</h4><p>​尽管深度神经网络取得了成功，但由于数据不平衡、不可见分布、域漂移等数据稀缺问题，深度表征学习仍面临许多挑战。为了解决上述问题，已经设计了各种方法以一种普通的方式(即从输入函数或损失函数的角度)探索样本关系，但未能探索具有样本关系学习的深度神经网络的内部结构。受此启发，<strong>我们建议使深度神经网络本身具有从每个小批中学习样本间关系的能力。</strong></p><p>​<strong>我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。通过这样做，所提出的方法可以实现不同样本之间的协作，例如，头类样本也可以有助于尾类的学习以进行长尾识别。</strong></p><p>​<strong>此外，为了减少训练和测试之间的差距，我们在训练过程中使用或不使用BatchFormer共享分类器，从而可以在测试过程中删除。</strong></p><h4 id="主要设计思想">3、主要设计思想：</h4><p>​我们引入了一个模块BatchFormer，然后将其应用到每个mini-batch的batch维度上，以隐式地探索训练期间的样本间关系。</p><p>​对于深度神经网络来说，由于训练和推理的差距，在批处理维度上进行学习并不容易。因此，为了探索用于鲁棒表示学习的样本关系，我们建议通过样本关系学习的结构改进来增强深度神经网络。</p><p>​<strong>具体来说，我们试图通过在批维度中引入一个Transformer来捕获和建模每个小批训练数据样本中的样本关系，此外，为了减少训练和测试之间的差距，我们在BatchFormer模块之前和之后使用一个共享分类器来强制批不变学习。这样，BatchFormer模块只在训练过程中需要使用，即不需要改变深度神经网络的推理结构。</strong></p><p>​从优化的角度来看，BatchFormer实现了小批量样本所有特征的信息传播。</p><p>​因此，所有的样本都可以帮助学习任何类别的对象，而这可能会从整个小批量中含蓄地用幻觉特征丰富当前的训练样本</p><h4 id="具体方法与网络架构">4、具体方法与网络架构：</h4><p>​设计了一个简单而有效的模块，称为BatchFormer，这是一个即插即用模块，用于探索每个小批中的样本关系.</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422091934114.png" /></p><p>​具体来说，骨干网首先用来学习单个数据样本的表示，即在每个小批量中，不同样本之间不存在交互。在此之后，我们引入了一个新的模块，利用Transformer中的交叉注意机制对不同样本之间的关系进行建模，我们将其称为Batchtransformer或BatchFormer模块。然后，BatchFormer的输出被用作最终分类器的输入。</p><p>​为了满足训练和测试之间的差距，我们还在BatchFormer模块之前使用了一个辅助分类器，<strong>即通过共享最终分类器和辅助分类器之间的权值，</strong>我们可以将从样本关系中学习到的知识转移到骨干和辅助分类器。因此，在测试时我们可以去掉BatchFormer，直接使用辅助分类器进行分类。</p><p>​ 多头注意层已被广泛用于从Channel和Spatial维度建模关系</p><p>​<strong>因此，我们认为它也可以被扩展以探索Batch维度中的关系。因此，与变压器层的典型使用不同，BatchFormer的输入将首先被重构，以使变压器层能够处理输入数据的批处理维度。</strong>​通过这样做，变压器层中的自我注意机制就变成了BatchFormer不同样本之间的交叉注意。</p><ul><li>测试时的差别：<ul><li>由于我们不能为测试假定批处理统计信息，例如样本关系，因此在BatchFormer模块之前和之后的特性之间可能存在差距。</li><li>因此，除了最终的分类器，我们还引入了一个新的辅助分类器，既可以学习最终的分类器，又可以保持BatchFormer之前的特征。</li><li>为了实现这一点，我们只需在辅助分类器和最终分类器之间共享参数/权重。我们将这种简单而有效的策略称为“共享分类器”。有了提议的“共享分类器”，我们可以在测试期间删除BatchFormer模块，同时仍然受益于使用BatchFormer的示例关系学习。</li></ul></li><li><imgsrc="C:\Users\14012\AppData\Roaming\Typora\typora-user-images\image-20220422093222300.png" /></li></ul><h4 id="梯度传播过程及视角">5、梯度传播过程及视角：</h4><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093240599.png" /></p><p>​直观上，没有BatchFormer，所有损失只传播梯度在相应的样本和类别。与其他示例相比，BatchFormer(虚线)具有梯度，如图所示。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422093454357.png" /></p><p>​ 从梯度优化的角度来看，Li还根据样本Xj(j !=i)对网络进行了优化，这与没有BatchFormer的模型有显著的差异。换句话说，Xj(j!= i)可以看作yi的一个虚拟样本，其中yi是Xi的标签。</p><p>​ 我们认为BatchFormer和Mixup都可以看作是数据依赖的扩充。</p><p>​BatchFormer隐式地通过交叉注意模块从样本的附近分布中提取虚拟示例。</p><p>​从这个角度来看，BatchFormer通过小批量样品之间的关系建模，隐式增加了每个标签yi的N- 1虚拟样本。</p><h2id="二论文名称beyond-fixation-dynamic-window-visual-transformer">二、论文名称：《BeyondFixation: Dynamic Window Visual Transformer》</h2><p>论文地址：https://arxiv.org/abs/2203.12856</p><h4 id="关键词-1">1、关键词：</h4><p>​ Dynamic Window</p><h4 id="摘要-1">2、摘要：</h4><p>​近年来，人们对视觉变压器的兴趣越来越大，主要是通过将自我注意的计算限制在局部窗口来降低计算成本。目前大多数工作默认使用固定的单尺度窗口进行建模，忽略了窗口大小对模型性能的影响。然而，这可能会限制这些基于窗口的模型对多尺度信息的建模潜力。</p><p>​<strong>使用动态多尺度窗口来探索窗口设置对模型性能影响的上限。在DW-ViT中，通过将不同大小的窗口分配给不同的WMSA来获得多尺度信息。然后，通过对多尺度窗口分支分配不同的权重来动态融合信息。</strong></p><h4 id="主要设计思想-1">3、主要设计思想：</h4><p>​Swin提出将自我注意的计算限制在局部窗口，以降低计算复杂度，并取得了一定的效果。这种局部窗口自我注意很快吸引了大量的注意.然而，大多数这些方法默认使用固定的单尺度窗口(例如，win= 7)。 ​ 以下问题随之产生:</p><ul><li>这个窗口大小是最佳的吗?</li><li>更大的窗口意味着更好的性能吗?</li><li>多尺度窗口是否比单尺度窗口更有优势?</li><li>此外，动态多尺度窗口会产生更好的结果吗?</li></ul><p>作者实验后得出：</p><p>​<strong>随着窗口大小的增加，模型的性能得到了显著的提高，但这并不是绝对单调的。此外，很难从多个可选窗口大小中选择最佳窗口大小。而不同图层的最佳窗口设置也可能不同。一个自然的想法是将来自不同规模窗口的信息混合用于预测任务。</strong></p><p>​基于这一思想，我们设计了一种基于窗口的ViT的多尺度窗口多头自关注(MSW-MSA)机制。</p><p>​<strong>在DW-ViT中，我们首先通过给变压器中多头自注意的不同头组分配不同的尺度窗口来获得多尺度信息。然后，通过对多尺度窗口分支分配权重，实现信息的动态融合。具体来说，在DW-ViT中，MSW-MSA负责多尺度窗口信息的提取，而DMSW负责这些多尺度信息的动态增强。通过以上两部分，DW-ViT可以动态地提高模型的多尺度信息建模能力，同时保证相对较低的计算复杂度。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422095955551.png" /></p><h4 id="具体方法与网络架构-1">4、具体方法与网络架构：</h4><p>​ <imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100027793.png"alt="DW-ViT网络结构图" /></p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422100222424.png" alt="DWM模块示意图" style="zoom:150%;" /></p><p>​如图5所示，我们设计的多尺度窗口自关注模块主要由两部分组成:多尺度窗口多头自关注模块(MSW-MSA)和动态多尺度窗口模块(DMSW)。</p><h5 id="msw-msa模块">1） MSW-MSA模块</h5><p>​将MSA的多头h均匀分成nwin组，在不同尺度的窗口上进行多头自我注意，获取多尺度窗口信息。</p><p>​ 将每个窗口展开为一个长度为wini ×wini的令牌序列，作为MSW-MSA的第i支W-MSA 的输入。</p><p>​ 将W- msa的输出在空间维数上重构为H × W，最终输出维数为H × W ×Cnwin。</p><p>​最后这些分支的输出在通道维度上被连接起来，并用作整个MSW-MSA模块的输出。</p><h5 id="dmsw模块">2） DMSW模块：</h5><p>​这个过程分为两个主要步骤:Fuse和Select。前者负责整合所有分支的信息，后者根据全局信息为每个分支生成相应的权值，完成分支信息的融合。</p><ul><li>Fuse主要由池化层<span class="math inline">\(F_{gp}\)</span> 和两对全连接层<span class="math inline">\(F_{fc}\)</span> 和 激活层<spanclass="math inline">\(F_a\)</span>组成。</li><li>Select 主要由两部分组成：<ul><li>第一部分由一组全连通层<span class="math inline">\(F_{\alpha} =\{F_{\alpha_i},i=1,2,……,n_{win}\}\)</span>和softmax层为每个分支生成相应的权值</li><li>第二部分包含两个线性映射层<spanclass="math inline">\(F_{fc}\)</span>，用于恢复融合特征的通道维数。</li></ul></li><li>最终还有一个Res的过程</li></ul><h3id="三论文名称mixformer-mixing-features-across-windows-and-dimensions">三、论文名称：《MixFormer:Mixing Features across Windows and Dimensions》</h3><p>论文地址：https://arxiv.org/abs/2204.02557</p><h4 id="关键词-2">1、关键词：</h4><p>​ Mix</p><h4 id="摘要-2">2、摘要：</h4><p>​局部窗口自我注意在视觉任务中表现突出，<strong>但存在接收野有限和建模能力弱的问题。</strong>这主要是因为它在非重叠窗口中执行自我注意，并在通道维度上共享权重。​我们提出的MixFormer找到一个解决方案。首先，我们将局部窗口自关注与深度卷积并行设计，建模跨窗口连接，以扩大接收域。其次，我们提出跨分支的双向交互，以在渠道和空间维度上提供互补的线索。​这两种设计集成在一起，以实现窗口和尺寸之间的高效特征混合。</p><h4 id="主要设计思想-2">3、主要设计思想：</h4><p>​我们提出了混合块。首先，我们将局部窗口自关注与深度卷积相结合，但以并行的方式。并行设计通过同时模拟窗口内和窗口间的关系来扩大接收域。其次，我们引入跨分支的双向交互(如图1中的蓝色箭头所示)。这些交互抵消了权重共享机制造成的限制，通过为局部窗口自关注和深度卷积提供互补线索，增强了通道维和空间维的建模能力。综合以上设计，实现窗口和尺寸之间的互补特征混合。</p><p>​</p><h4 id="具体方法与网络架构-2">4、具体方法与网络架构：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422205646202.png" /></p><p>​ 我们的混合块(图1)在标准的基于窗口的注意块上增加了两个关键设计:</p><ul><li><ol type="1"><li>采用并行设计，将局部窗口自我注意和深度卷积结合起来</li></ol></li><li>(2)引入跨分支的双向交互。用于解决 局部窗口自我注意中有限的接受域和薄弱的建模能力 的问题。</li></ul><h5 id="并行设计">1 并行设计</h5><p>​虽然在非重叠窗口内执行自我注意可以提高计算效率，但由于没有提取跨窗口连接，它会导致有限的接收域。考虑到<strong>卷积层是用来模拟局部关系的，我们选择了一种有效的方法(深度卷积)来连接窗口。</strong></p><p>​在本文中，我们提出了一种并行设计，通过同时建模窗口内和窗口间关系来扩大接收野</p><p>​如图1所示，局部窗口自关注和深度卷积位于两条平行路径上。具体来说，它们使用不同的窗口大小。本地窗口自我注意采用7 ×7窗口，遵循前人的工作，而在深度卷积中，考虑到效率，采用了一个较小的核大小3x 3。</p><p>​ 它们的输出被不同的归一化层[1,27]归一化，并通过拼接进行合并。 ​合并后的特征被发送到后续的前馈网络(FFN)，跨信道混合学习到的关系，生成最终的输出特征。</p><p><strong>好处</strong>：首先，将局部窗口的自我关注与跨分支的深度卷积结合起来，建模跨窗口的连接，解决有限的接受域问题。其次，并行设计同时建模窗口内和窗口间的关系，为跨分支的特征交织提供机会，并实现更好的特征表示学习。</p><h5 id="双向交互">2 双向交互</h5><p>​通常，共享权值限制了共享维度上的建模能力。解决这一困境的常见方法是生成与数据相关的权重，就像在动态网络中所做的那样。局部窗口自关注在空间维度上动态计算权值，同时跨Channel共享权值，导致在Channel 维度上建模能力弱。</p><p>​ 为了提高局部窗口自关注在 Channel维度上的建模能力，我们尝试生成基于Channel 的动态权值。考虑到深度卷积在关注Channel的同时，在Spatial维度上共享权重,它可以为局部窗口的自我注意提供补充线索，反之亦然。因此，我们提出了双向交互(如图1和图2所示)，以增强在Channel和Spatial维度上对局部窗口自我关注和的建模能力。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220422210802291.png" /></p><h5 id="channel交互设计">Channel交互设计</h5><p>​对于通道交互，我们遵循SE层[24]的设计，如图2所示。通道交互包括一个全局平均池化层，然后是两个连续的1X1卷积层，它们之间有归一化(BN[27])和激活(GELU[20])。​最后，我们在C维度上使用sigmoid来产生注意。虽然我们的通道交互与SE层[24]具有相同的设计，但它们在两个方面有所不同:</p><p>（1）注意模块的输入不同。我们的通道交互的输入来自另一个并行分支，而SE层在同一个分支中执行。（2）我们只将通道交互应用于local windowself-attention中的值，而不是像SE层那样将其应用于模块的输出。</p><h5 id="spatial交互设计">Spatial交互设计</h5><p>​ 我们还采用了一种简单的设计，它由两个1 X1卷积层组成，其次是BN[27]和GELU[20]。 ​这两层将通道的数量减少到一个。最后，采用sigmoid层生成空间注意图。与我们在通道交互中所做的一样，空间注意是由另一个分支产生的，其中应用了本地窗口自我注意模块。​它比深度3 X 3卷积具有更大的核大小(7 X7)，并且侧重于空间维度，为深度卷积分支提供了强有力的空间线索。</p>]]></content>
    
    
    <summary type="html">此篇略读笔记包含3篇CVPR中与Transformer相关的论文略读记录，可以用于提供改进Transformer的灵感。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
    <category term="CVPR2022" scheme="https://blog.slks.xyz/tags/CVPR2022/"/>
    
  </entry>
  
  <entry>
    <title>2.3.2 经典问题（生产者-消费者等）</title>
    <link href="https://blog.slks.xyz/2022/04/15/ef402168a5bd/"/>
    <id>https://blog.slks.xyz/2022/04/15/ef402168a5bd/</id>
    <published>2022-04-15T03:43:00.000Z</published>
    <updated>2022-04-30T07:58:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=19</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.3.2节的内容，含生产者-消费者等经典问题</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>2.3.1 进程同步与进程互斥及信号量机制</title>
    <link href="https://blog.slks.xyz/2022/04/13/c34143b1b4b5/"/>
    <id>https://blog.slks.xyz/2022/04/13/c34143b1b4b5/</id>
    <published>2022-04-13T03:43:00.000Z</published>
    <updated>2022-04-30T07:58:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=18</p><h3 id="一进程同步与进程互斥">一、进程同步与进程互斥</h3><h4 id="进程同步">1、进程同步</h4><p>​同步亦称<strong>直接制约关系</strong>，它是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而产生的制约关系。进程间的直接制约关系就是源于它们之间的相互合作。</p><p>​ 例如：必须按照写进程然后再读进程的数据进行。</p><h4 id="进程互斥">2、进程互斥</h4><p>​我们把一个时间段内只允许一个进程使用的资源称为临界资源。多物理设备（比如摄像头、打印机）都属于临界资源。此外还有许多变量、数据、内存缓冲区等都属于临界资源。</p><p>​对临界资源的访问，<strong>必须互斥地进行。</strong>互斥，亦称<strong>间接制约关系</strong>。进程互斥指当一个进程访问某临界资源时，另一个想要访问该临界资源的进程必须等待。当前访问临界资源的进程访问结束，释放该资源之后，另一个进程才能去访问临界资源。</p><h4 id="对临界资源的互斥访问">3、对临界资源的互斥访问：</h4><p>在逻辑上分为4个部分：</p><ul><li>进入区<ul><li>负责检查是否可进入临界区，若可进入，则应设置正在访问临界资源的标志（可理解为“上锁”），以阻止其他进程同时进入临界区</li></ul></li><li>临界区<ul><li>访问临界资源的那段代码</li></ul></li><li>退出区<ul><li>负责解除正在访问临界资源的标志（可理解为“解销”）</li></ul></li><li>剩余区<ul><li>做其他处理</li></ul></li></ul><h4 id="进程互斥需要遵循的原则">4、进程互斥需要遵循的原则：</h4><p>为了实现对临界资源的互斥访问，同时保证系统整体性能，需要遵循以下原则：</p><p>​1.空闲让进。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区；</p><p>​2.忙则等待。当已有进程进入临界区时，其他试图进入临界区的进程必须等待；</p><p>​3.有限等待。对请求访问的进程，应保证能在有限时间内进入临界区（保证不会饥饿）；</p><p>​4.让权等待。当进程不能进入临界区时，应立即释放处理机，防止进程忙等待。</p><h3 id="二进程互斥的软件实现方法">二、进程互斥的软件实现方法：</h3><h4 id="单标志法">1、单标志法：</h4><p>​<strong>算法思想：</strong>两个进程在访问完临界区后会把使用临界区的权限转交给另一个进程。也就是说每个进程进入临界区的权限只能被另一个进程赋予</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412173137552.png" /></p><ul><li>这种必须“轮流访问”带来的问题是，如果此时允许进入临界区的进程是Po，而PO一直不访问临界区，那么虽然此时临界区空闲，但是并不允许P1访问。</li><li><strong>因此，单标志法存在的主要问题是：违背“空闲让进”原则。</strong></li></ul><h4 id="双标志先检查法">2、双标志先检查法</h4><p>​</p><h4 id="双标志后检查法">3、双标志后检查法</h4><h4 id="peterson算法">4、Peterson算法</h4>]]></content>
    
    
    <summary type="html">包含王道课程第2.3节的内容，含进程同步与进程互斥及信号量机制等内容</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>字体生成论文研究进度</title>
    <link href="https://blog.slks.xyz/2022/04/01/f225f383e158/"/>
    <id>https://blog.slks.xyz/2022/04/01/f225f383e158/</id>
    <published>2022-04-01T15:09:19.000Z</published>
    <updated>2022-04-16T03:39:19.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="f490f6d4eff128b6f8c23e395e0b13f44dd14e197fc50f16d44b6fec836d5931">1557a4d06c41b8b7cb942a6d0525c027cbeeadc10caf98a45705387558304bb469290ed727bac22c14368bef657fb469dfaa63f24918c0cff3b2760cd4c7e41d903d1a82d66af59312cac4cac46cf8eb876b40a6bca879a6bb5005f2de6cb7700621bad9f290d26f23d98ad7d10aad36bec4e6306e0626ed5b58ff9d6c87b6b9fb9358b7c8663eb4e3f6b73813f33f206cb37ad8174d4a8dec552525d1b17d29a7ff9a69af1c0464d7be2cd47663a8511470a8a9ecf52a3eea3d24def5ef2b867aabfebd01f658d97f48cb62241de8f7a8c19ea8bc92d6c680ec59bc38b048d425d487212984d3aa9277e8bafa990fdb34d8a30bc941854858dcbd2c49e5f28f21e8ba546f2f0da3365f940432813ee29c950135eadb5b7ed325594771d8ec8a9d1f3ad8cf5cc9eae23197303a55f47176df2e97551922502deccc82ba3a0d0fa712a9261862f2788aace95a046bffc7cce1f66e50a2c6021f4cfc9cd90935fbb6ec3c290ffa4add6317fab63a83f5691b98f8d19efca83ec4ffbd8614b8e7ac3a4260a007377813591b13e3737b007a82ef659ab4845a4799af73318bfedd75e021f0cee0157996154ee0b0d89a5481f558e1ea747d3de2bffa3166672fac1271864c41d9dbc04032d309ab8a8324d0df005f78c8f05a18e52d005529009028238e2e96252ca2ef67df0c8bb09b9894362b07c22ed169e86ba234b046d063a31a0dc8f90ad0cd26dc956e5280d31639778338271930a6aa2a2a4fcc6fe161b45a9a85fd07125410a1633279d8c785ab1913ad30f45a18498b3fb2829dd6f067a17c541be12a01e37c08c82707915cbfb4e002bf5025e5d81f5fa08ce6bf18c3184420ff1921e17f4126b1f10ebc8e7395006f2a552f0c0c37ef4b17c2138b950e4574c440a94e9bd4e400277723250738f15e2d9bbf5e2116f22848e8102dc33ac5d504f10f4a7f3d18f2687064f51f963e819f143fdf829a9d4db46e025d1d774c60ec1e91eca7e55241e8fe4fb65bb309cfa0f612aa9422a90d9ac32ece2d4ba42db909f0efd04c39637eb5e351870d5f1d12e57dda4f141f9f11058392e3f5f378451f43884cceaf6e78ec090bbf3eaf9f919ecc6d0d84b01f1be6501f387c8daacebaa9c608e9bcabc8790e3c1cb980add9e6fb12430856ede148fd91c08f7485709962926e803d404c3c7a7f38fd0ef69e9c4a32f491d49234a74432572a5090c296002c73df41a4ed7bcfd4bc6d23ba76427aa950f5128a0455186d99b9a09cf6789e31f76f8938a95d8e861be3b1f051b1af3a674a08677aa18071301825dcfb11697eae002fa97923a9ee69ad49ab4b3ba810ade6c531b4a79f4c0befa976492d07ded5cb76ace66549c6c40f7e4927fe047273209af3269d43d4905b4c271ce055d131103b7bc6bb7fe95d94f338b1e2a31a90e512eb78fbfe8469b69718a88307a747af389488f2d91fd56813772a3e6c47de32f4ae1e0fe965f791663fa3173d62c91644df73790f4ff69fba0170822a1ef6cb002f7e2a1179ec3c6ac8fb8f138ad559c2ffb4938d0a710d78d62ebb23944ae7255d6a6a3eecf42d65a95f6adb81f85952df61009dfc7477c9fe7228478a902c5fc3ddcb883dd4975a19f59ad4bf0b1ef764536efeecc05dcf770806e90809f6698e4575294da06eb572d6c224c03a0711d84ed672dde635e459697ba656dac1ba45a831f42bb618e0b8fec82eb048869dc25e32748d1cbd62069b10b52ea4a07640142bb989a33eadf9672c17a80e88328d20704a54fc7a2714c339717b286d7981e643ec7d4b6cc15c2e071390341a281de9143f1e24a1ba629221a707b69c80a2ca9f094c7d9ac03335d7e218eefe70f727e2722b8fb97393e0f9a6353fdb707beafa0f757512e806cc385fdcbb7a6bad6d0dde17bf69fe942694ead75e3fef7d1128d59bba906687e0fa41d2c5adda355b8beaab883286c47ad6a7935b4d036c683a27e003c07a6c671a4b5bf4ab53186d38e6b33062a44d06bad09cbc1fabe988b57e55f879cfc52a48a3122b85aa3cbdeb48fcdaaf94296cbc36c01e36baa2fe7f949bef7d33fa5ef3c4d389b202f0838b69bc5d0ed3f1394795785c66cd0a747454f5a1399b9d92c8f99a77cf57d076a26926921ff5c8197a4a885243cb34ce767b60e9f245801b12f26031a04fe4328d2797c2cf89401fd2175cd14c67aabbbd136babd04d29aa82d8ca0d1cafe077dad0cdf3388733c9ee25d4b35b64bba9e08d8c8ba76794d1fdaeb04698e65ca41db67949d35d2c397123ffc1952a230ab01eaab37b123d12c3b4ea86e1a35148bdd509196a1b11b94f7abc212664e048b6973f6bb0017907e7efbb27541b4d2e1d716e04bc604babb71480d50734739670e3223ccbcaa4262d018c9b95d0a836dc8fd0671aa9adbc636dccdf1a9900c72273a3e1c515a4388028aeafc9a40c278ba0412abf4015a3b12974704e0a2fe7c3cbb7ec3fc4daf29c429127f91fc7b7f506a0270cbdd3c58b07a637ddabc02b9221ed0ea1c8f0810fdd468017f05a24345cd00a3ba386fa7b8c518d992cf3aaf8a79f19a2ed8608c07d06f753c99c9aa3aa3533cf953e77c7bf1a618e2f27312484a43e066ee4bfe2d466bc6f4f8edab0c0ef1dbbc67ac4567d0d0caba0d28016e3ed175c99760f18ef52da6b4439ce583a602f770519a0e5b51afadd40555fafaa5ce1fca1fcad4719415e24768a8f20e499df0ae6470725b9eff2620b05c9e6e9ea3f5ebaf0ce68f61a7d490055fe37751d95d68377ab85ebc1d0a7fd7b442cb6072ceb86c0924a05b543e812d2e8e4f356401d7159fc7a21ac96260f4ae955820bca21c4acb3fdae05d173dace8314e19951f6f124fe423f91024cdf37d0e204543a3091c59d33fbdbda6c8972ac935b64eaba4fd416b03c03ba1dc8c55b8c11ecbc13d7fe7d0291e791da4f296d6e1d88a9ac411003fac452f1b46d269896cebb2c509719309ff7709c2cd9af21c774e3c9f08fb35395b94b26425fb5e45bf3e2c8280650041dffadffb2c34c5ed0e524f1dc9aa40fce6e468410537ba94cee8bcfbcbf0353f5a762a834ee2bb5c0e9a5c4dd8c917a847435444d4f9d33079bb6734eb4a98e22ad71346eec0132955e314951125e75f7103b7c3ef355592ad38c19a7c315215ac4b8be62211e9de5861e2d1dcee6a51090401dcdcb4099624335e58169a57268cfcb4d2f41e1dfa88f39c75b1695c70ae4fd6050beb6302eebaeb6d6a803830336ee92e95d2ce4e7a8b9b7aa5dd47bb6407ad3e36950c100aede82aebf699f08f70b62e1dfa50b01396f2be85393aa07852c093d7b69fa4862ce0ef60329ec0fcd416de1b9d479d7aa332de7dc01b474368e84d60f39161fc67f2b07f61b04be956424c8e451dad46365faafb4465f8d451e62d3fe766dfb221f1a70980d5758f476eef24ac1f8d2caac580b408f2171575e698c2fd12e466fc7d45cb653cebf8799ceb658e0dbf40bef8edc696a809d141f2b75348d04bab8aa089ff4248f83fd0779926e912ad6c82f6b0af284bc2cd9e11b54b429c868e90c07e73a6bd619916c9bc2e327868dd10a301093aee43d806daf59c6b8e7043afcf7cfdd3fa7ae79aad1b622e9bfb108e3a455828c2c2fec2104101521cee7d2475a55000b6d5c22054c591774eb3aae62e1db8707002ee75677a33b1d7f7a885a97311eceff5ef2cbdd7698da1e3c2fac51c933f96209442681db84800ee1d89ea7377c46c09e7daac64a025245fa6a595caf6d1929c1327f6467cc213fb500a3f68a35122feeb20bac0a103e4796e5dfb8be3735404e07d57f21e1348fe0d9c33509a6478ae6633e103ca91feacf073a3205b225347e66865afc10a701835c36f32300e7161c2994ab08de939bd5de7ab73b941d19c5fd8c09dfbf691bc63d2170d6906b84a0a8db17e19f4773d9ca159bcaf99eb65437489c4e700eda4d245f560522c07562701efd7c8e2e32f45babe30163086d26d47b39ac7e85626c206bc4237dfac9429ed9a86ab5d003ac6f72a4aa60275fc0e48421d9bf4a463b12ee7f177c2e24daf3b328674371add4a53541779ba630c65e9f9fffb20ca8ce56971110d7754ac06047715efc3686d26fe48f012fd58124b6d6df9ec48cde85e88186377aac90aa5127e8f713f6184b71ee8e4a292937f16f080beaefe3361bd75f5c388f7a38e78fbd4b02e1b29801f11145f9de4d3dbbd7755c69b6eddd0fce30fc4340b92632823672bc9e1487f20b709951f45df5d16177c7c4650d0d1c515d6aff984b4971bc82d6ad77e51e75e825b58b5d11aa8a0b3dda15bb83f31fd2e4e7510de5430181fece3add3b5eeb4933b3c3a3791a741a9f722104336308b335786f9fbf9b3f723eca78ead99c66989a6d670c4f1b258f8ac919a7f94d4c363e02d0416a0ae22fefde72d4735d0b80b8e8aa83644987f13c80ecfabd0ed22fa069f7acb2a83a24cedfafccaf394b9cf4c9b03ac2feb7031632e9fbb30b940ba4a0e2de53004caab755c9534e723b4cc6bcc60e54ad911b442d8b9c9a4a8f6763a9f081243659b47a24cc6338390d23946ee0164b30967142610116332f56cde7db6f2daeacb12c30c038bdb5237f3f9c42eb7dd663fa087736f22fdf05080ffa45fe5fb9c615ae00bbf09eb2510eb373a699e5f5962547d949689862216c4192b6ae6031ef9fd3aa371e9ca9a3295689c25e5fb79b99d346f6da797d002e75b3cdc00c57575d223f34bf68f08e7ab2eb4008c979f6383c9d477fb9a3e1ab53d13a91daa2f19a38e9fc0e12aa2a5df9c22d78b22a889184f0401b192f826ce9310b8c68a5598971c12eeabbc295b4d4453de6831141f45d571f5921b3f85079746c5155d3a35cc42a5fe4cc6977e840d6be74b53319b045596bcf749eed8da82be7f1c6f936c5de1b23f465e90d214b69041f532bd1dd88a43c4fcaa3008bfe9851b718fdaefb3e13250e68eeffcf81db7d34bb8f70fb9ffa88dff8e16ab79f8e1034c067123bc9fb66d14d6bf46afe66a0f450d5423746e937ed07bca09c57ba91ec9c5e5815bc5c8a32ea1db6c302a35facfb8bdc6b862e71d65636cefa270d95fa347c9823be59a0c9417f60d2ed67b8785f856ea2d9e048aa7268902e11598fda3bcd39f52adbcd44e268390bcf9973cb8b944fd1960b577687c5b4e86a2997f3e619715e007d9ab31dd677c4281c664ce7b5469f06e28e856f22ef62cfe95302a40fe42a16f666796e4e770901f21d721d63638b9f45c2313e20e0ac139157d80cf580afa4496f20fe85fc426cf8705f4be4919090758c3325de703e9d0081bbf50d2afbe83543b93c195e07def8f34776d11fb0c756ef40ede73663a12368fb3f1c4e55421fa946b797d882d273274ba821d71a6f93ecbc03aed844915bcd8aafa216a4726adc56a755251d806f7f83c4206ecb932cf420e5cd7bc7389e6854c8b015d71cef2b8a40ab49c471299fb802ff6e9b7c8430a07d90a77a920d501a09e9caba863221e29cb1e7231949327e29e907636f3d157108f4908a12b026dce46a1da809d45fdbf270b59e184d8628df5ce958b3adba4fae387965e478bcbab63a1421b7df5754fc27b5cc14646264d4ddffb063828e7e25bfdf83c581d58dd74788773ca428698b5d6fd46262d2f02555a14bac6a4ee60dc727713b5f85ebec1d23910f39ea85feaa7b7e6ab13f9dab626ad218f027fe2b43c5cdcbf53f6898b644bf13cad3d3bd7c14656660f0d327c052f012871e9c6bf41dc8457653df9ffcb0c26a696a8feb3c0a9952ddd025cde585204166ad2669f91c6a0a937c8562585b9003924622f7d2bc317389dc3ddec19c8980cc2e59d821ddba53615f061d262678b7b7713f52ea40ef12e4fe0ee5a9a338d66d6440c50c7eb13379ac3580da2574dd9fab111273ee68c1ac56b598cefdb154c1c4e78e00a7aa82b317883a5a6e689fd071b734b6c482b1dcfb190de4819724acf30499c192fc908c5721072b908635d509a5966c399809329acc0727066ab852eb2db99af278c804b3a4548374accabe91274035d7f15d46f8f76b16f9c4ef167c24042490da7fe0d3f6ee446976b118279397627ed23d5995aad439f7f5e1993f3f15e9c8bace901a6f7dcd62075705385653bf17476b369618af5a94c9e290fca4bf9fa0562a616bd1f515a0935bb9f102fa600629d195e85c45e1dcafabc243e295665f510bcf862a1f34fe24ec7f66cc1c5ed3a1001f042b0860fea84e0ce9e4397137ee8c1d174224d2dbb1343b7e9073821e3f3d296d4bfe4f760447631f6c36cbe35bc3571687572ad714d350bc6a4d850c8b229534f643b18079ab04f609daac0d626a3469b6f53fb36e1bf6fb9edba4f7759ef47108820e61ad2139ac5abebe02d143aee1aac859eb14b85d626ee563148799fbe718038e042a0bcacdc9f807c537e0f4998f30cc0cf89fed226e07964fb29ce934ebdcec140b9f7b05cce7d5c6a607e1a3d4919e572fe58874552607440919d5a4fd88d4f86ceb9297396da5945c558c9f7750b7ec161461cec373dcc2eb32ff3f50fe7556d4fc76b343340e04602142bd528b3133cf43ad5b284f27b69689c539642382163e59cfde59a816e68d1d26cf9cd9a79ef7b8dc2a6d42a39d6c13aa76620da6740bfc9bec628108a357576b397ed1fca004a6f9d73290b1cdfcff2fc60089dc6142a45e1aeb49e8c816a368156e10179cec538ef0ae075c2cda37644f59134e259da190cd1faee883136451af3c09869c47bf92fc20082f249a45a51cd2e06828b6b19c0bf5cc9cd31513b0cf8550f4663290c29a34c3340779df57a029784e443d0d83ecbe9b02ae27ed3ac8348ffc2ad0d6eb84ad5d3ec25c86d633913847b92d670d868a64526ffd2515dc88537f490558d11204bb6f212dad15d4d5c03891c3ef00861e44296410cb23e7b1fc01348557ca64d87cc840ca74fba4cd07f1f412eb85bad3033cc3631f6cbf81d7667200003767784947a38d0351bbc85dd08f8bddcc992d3a10ca8abba0c0f7b152e2ea35ee4bb1484338037a29ff9e00bc8fc8fe91949c23f759849675f8e95e7eb777da28c3600d8c322dd3e1323dfe13deac921e38053436260001746a5f67dc92fa29ddd5c9b34a83cd12008bfe0f1f0e7757f8ffc768fc3c4a01d00df7367ae93915596b1a7415403f0e84274454d2930edb66a303bdb10fabf7be9a8d5c3642e80236b49c5119740896226fc7518bc198fad8be3b031a0237599f821a060d07c668ad23073c4ebea6329e640b073a571c2991666b63a79ff019570c2c0b14c6afc336d992349894cca1db80e46204756d7d301e86d66f682e0d899607c5afdd8631ca51c941c2dd71348da367cbee6386cb27ef982731c92a72cad6ed6199f49ef7d65da85999695783ee29bc427f93cf15646eb6ed8d453aa193591e32bd861e7fac62265993eb5c8087132e3d8bea229f066841bf3ede3015695e0216d17ae0eada638d28e11bb5f76fe0da18809bfe83f21061ddcaa3b9835a1fa16d8d5ab9441ec3bbd64b22b36581b15525100f79e86e2217ab24505168b6710f7b1c4680b76a769de32aa6306c19a721a83b6df9f6690a8b43d25f491110259de1717a01db232c8bd56b36b5985923d3f5682db9b484cee9432f32d75fe8425ea0aa476ece0986d3755dbd475f95b15600b6bdd18e414e865bd952ca7e9d1032b774d0f0613905c016f906371784e0e4d48b39a7068aeb70ef5cd5c30c86756ccd01bdfb1ef076a6e76bf46888cc6e7eab8f10f26139f9abfd2cdd3a08fae5db925df506c9b30d0e7f8d10845debf4e9bdd4c9617fead37bab5d6cdabfc86893a3e0fe373de13860318f5e711f87a5168b09b6b630f9babe385e34a4822f48a1492841ff914a188052e5a26e2c0d3714fb7412390900d7036f4cd7cd2a017f4db9c2d5c5b224685d868c94e37f5352f7c17b14eb7bfc2ad380ac75f1a9d47038086cebd8b363107348251dd80c5baab6ce35bac1231949a43f7ac5b8aa9974ef49f8f728b464d8e948bc7a51349d0d79ce82b7457b15b626e3f483ce11453de74be0d9e68054321b537b57bd9b941854ae7e6171ceb4fb860f33dd478a0f23c4e57f8db51ee5d26b50164e696a842170998a6e401914b833e494b284d14afe73f2023be88b18e5c980fa4f4fa837134f582ea850d4d354a33da91d5d576eb17a2f00e4eb06e0847856ae845b64e200737b44a63c82d595e7c9673385f0cbfba514e73335e45bdf9de3a303d9087be57a7fdfa26f66197381eb977bf2f3e0538bb82e83137eb0b3003ae9e7ab65fa75611985ffcb8c5c18b5e920b89cc9745aa17f62c0b530390820d0bc2d70173bcba06443abbe645d320b3c3e57c0aaace8e0d1d0889791091ad7103cc6506f79142064cda2c34e1e89f8b141cfc812f03b71c89c686d2c2ac432ba11f3811e4e18b188b099d843e6e2c21d99bed95e5ddd12b51df0e84ecf8a5a9b0be4e0315bf702783d32283d28798846c15586a473268e8c61ca0f598190780c2c0b7d5db3e4b1fef37dd1a619979dc1ba9411f1f7867df2cc952f4925aab542d1bec25c3498d4618e141611daf17f0bfec0ebca2c3fe3a41d484fe198d6f13fdf1f6ad921d8257f6ea26a02cd8759e8be76aaa285b428a001a254b36dfeac65aa0b30798decccaa5983c8bfe2deaf163a6d1be4d8bfbb27a283d1a1331a979e4cdf9b216b1f82597c0cbaea4aeb5e3d062ece79e9ddd76040c02c7e0c0af4c091ff0d9056d46ce6b40e7730f9f151bab2fb7c8773a1160164d4b512748b5e0866c6b68ac494cb833506e7e2d7722315133fff8295841e1c672d5b18cc775c0be4605358ba1bfcfeef5d69de194ec9c9082e22e6c7ea9c168844d12f734f02080ecafb0d8a5446ec1661c9a80fc72829322c626df2d55c46355d958d1ded286c4cf163549c0fb5e9a9396dcd7eb857047538acdeaf4a4862a4994e38697664b31baa24861f7822c68e1f97d1f880d0308959f1605fed18589f412edd6c0e7fe0912d73337c4467fe4d299bc40efc863ef29666c2e1b094eafc88788b63a51ad5080013fe9b9922486ec3408dabb6aebc95291d8dee2bc120406161076049ddb71a3b87c7dd0b5e32c054ef38c73c3fdfc730d17062a2baaef8fdf19c15f0a5affda581cb0e07d39ce15f242bdff89ef539b69cefc691dae5259a2364dea76353298453e8751bf6193a0de6e0a6b0c678bece9ee54518c3d30ebe95c1df456101c9d52d149310f41bc2587584d102492d4864a6df55b60a2264602d30d02740edabb574b93b4c7ab23f0c30c89e60829972d663ae7b493726a15419b88a4812817de34ff4561b70638c909ec55debf03180f76564e807be3005f1a472477dd02062bef43d96cc9867dc1f2fd445b4d74d6901bccbc6d03f71eb88bc0a97055a9fdc796d25185083174d673420a1fed53642cc055878ec2059015fb8678ea9dfd4445f26d71fd529282e73880999058de5050258974c1f6949a66006f78dde2a097c3eb9c1ac863ef683662f77bb0a53677d87af675d2d93057c93233bcfb1b54f2eb5a7b432d30bf4b71af6833064c1d9381e58f50cfe334c31653bfffd099d84a37d5e544836fbe7e2bc19dbad13d3f7dad18e31f7e295f2ceac01fa39180dbf817b15efad01379a4bd6e81470b85a04862b48755e4f1d6c959b6d94114f27ebe0e24fcf8d3e40ff5da01b3b72a3d2d2d8a7ffbc4aeb5331d0d3684f8be5d4d48316026f45df634b8938c336799c27023833d67ed9363afc3dbdf3db0593a10b00cf24055d0348623540be1c30ffbbd43e9cb7f50d8605e44231c64df2a0b518a8a3110e908b53edbf83bdbd32c4e128d5fed12a2bee6220f0faaa0ec5f07c65edc6a88fe5fa5c5bc7f1ecbb0f362298b72facb48adb83c3d8d707ec3fc7883d6ab5f50b6d022555cdf3782c4b71718925e722f779e069b010a41437e6f85651ff5e8d3b8adbfa6606afac8966dce53909d08047034eff0fb8b03ed275b349f6e31667302ac4b4e1904f89374a1b4da0b8bb51806be747e13fb89b69d8f4cf1e8db8484233d3505a8dcb17a09f08354ecb2bf7e9abf243ac4a573545cddb60126260cdca26f4343e87a56a8c5ce95ddc7ba8f3c4690d3d0eaa4963aecce8fe4b2ecb740ea8ed140186040380d51ca7bf146405e7c20298468b66868c8c54bdc4ef20d5f930f512e20cfde7336608c54c094a4b26168fce225551305e53124cffdea17af778e5c91bfee4f54ffa3904dba95e12e2ab3410e2efc94f04919f322d57ada05f1766aba019df8dde45174f555df82dfd577d6bf1d0156361685934d5db47781ec306d21133bb804d681a6b8a59072c274d65931cffa1b580d7a28140a4248f8470e4fc4336c83deaa752eb4a71fd8fe541fc31f5f01aa00e0657c75989a4767a69f17d06229f5b2cea466c8a38d46c5000a24869c519decff81c1b6e96ad448000746e294bcde4d2e3fd5dbc28eca3d09c7a7a73ba2fea7be3f7d0c17a13de552af929df3d0fea29b75bc3b1a4c6146289df0c52a97f9b3e552a417a5ec88ac5067dfe368e457a004c35036a617da6f3434003905551fff6d77336b813b2af4b90f792ad486373403b0c80459dc29f5911ca89e940b15d7cc20b72c9e12dc4fcd0a258d8ff89bf75257fc0f9dbdaea4e4c8dfa776becbdbdc64b09a915b18d6960ad54e78238cba555358a0267ee39924846201f1233774283b22efd33f1fe14ef286a754c3cf7172c1981484a7ffe1673a6e30609ecb32909206cc1c3046401870d3b10fe2ebb04f05a62d09340784e91b170529497868e7fec0c7687da90f8c45a97716906368f169c728effdf3d94eaa6822ee2dfa6c0e4e7520d8bf2125e0ca416f299e26db08e71a4f0d353310950bd4eae7235292744b218dd4d6f22cd4c61eba3df2e6b1649ffe83207b46d46cf9816739178f1cb587a7ca1125d0c715cccd3d1ee2262d0edf724dd907412b1405c67c10cfd084984bf3c2ae470173aeca8459779910bed14b0ea8210f751db4d0b7cafb40ec5e156e271d8b2fe0ea84a252b894ff1fdec04b208774307a10b7d22cac0c453360a6fbe2497ad808707dc16343909e0acb4adddf342a881d29ec7f97533a921f3a53e8ee8d117f44787dee0b1a4869d0482250fffb5168d9f40cd36a852f11bd5857d3f46849578ecc2d849216f530fa16e7a36c13f7a648e76d22990a5875e55686b67c33968e6e549f5f943eb3d843305f01a0af7bd3579a3549dedddac797b9b7d20ddb7ceeb8d11d23aa6fad0e2e8c6b2befd812aaa8a220a3c69a4977d00f3efe1d0ee40bf0ccc98ae</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">里面包含了字体生成毕业论文研究进度及讨论进展记录</summary>
    
    
    
    <category term="⓪ 项目笔记" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
    <category term="字体生成项目" scheme="https://blog.slks.xyz/categories/%E2%93%AA-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/%E5%AD%97%E4%BD%93%E7%94%9F%E6%88%90%E9%A1%B9%E7%9B%AE/"/>
    
    
    <category term="Font Generation" scheme="https://blog.slks.xyz/tags/Font-Generation/"/>
    
  </entry>
  
  <entry>
    <title>GPU占用清除</title>
    <link href="https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/"/>
    <id>https://blog.slks.xyz/2022/03/30/18c6bc9e09ef/</id>
    <published>2022-03-30T13:47:19.000Z</published>
    <updated>2022-03-30T15:27:03.000Z</updated>
    
    <content type="html"><![CDATA[<p>当服务器上的显卡如果被奇怪的进程占用了，但是nvidia-smi并没有显示的时候，可以使用如下命令清除</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fuser -v /dev/nvidia*</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">描述了GPU占用清除的命令</summary>
    
    
    
    <category term="⓺ 工具使用类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BA-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="GPU" scheme="https://blog.slks.xyz/tags/GPU/"/>
    
  </entry>
  
  <entry>
    <title>Pytorch学习笔记12——分布式DDP基本概念</title>
    <link href="https://blog.slks.xyz/2022/03/29/5a94914aa20a/"/>
    <id>https://blog.slks.xyz/2022/03/29/5a94914aa20a/</id>
    <published>2022-03-29T08:48:19.000Z</published>
    <updated>2022-03-29T12:47:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="node">1、Node</h4><p>​ 物理节点，就是一台机器，节点内部可以有多个GPU(一台机器有多卡)。</p><h4 id="rank-local_rank">2、Rank &amp; Local_Rank</h4><p>​用于表示进程的序号，用于进程间通信。每一个进程对应了一个rank。rank=0的进程就是master进程。</p><p>​rank是指在整个分布式任务中进程的序号；local_rank是指<strong>在一台机器上(一个node上)进程的相对序号</strong>，例如机器一上有0,1,2,3,4,5,6,7，机器二上也有0,1,2,3,4,5,6,7。local_rank在node之间相互独立。</p><h4 id="n_nodes">3、n_nodes</h4><p>​ 物理节点数量</p><h4 id="node_rank">4、node_rank</h4><p>​ 物理节点的序号</p><h4 id="nproc_per_node">5、nproc_per_node</h4><p>​ 每个物理节点上面进程的数量</p><h4 id="world-size">6、world size</h4><p>​ 全局（一个分布式任务）中，进程的数量</p><p>​每个node包含16个GPU，且nproc_per_node=8，n_nodes=3，机器的node_rank=5，请问world_size是多少？</p><p>​ 答案：world_size = 3*8 = 24</p><p><imgsrc="https://img-blog.csdnimg.cn/20210811144558161.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2h4eGp4dw==,size_16,color_FFFFFF,t_70" /></p>]]></content>
    
    
    <summary type="html">PyTorch 中，关于多卡多服务器进行分布式训练的一些基本概念</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Pytorch系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Pytorch%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Pytorch" scheme="https://blog.slks.xyz/tags/Pytorch/"/>
    
  </entry>
  
  <entry>
    <title>机器学习基础系列笔记19——EMA指数滑动平均原理</title>
    <link href="https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/"/>
    <id>https://blog.slks.xyz/2022/03/27/6de89f1d1ae9/</id>
    <published>2022-03-27T01:44:19.000Z</published>
    <updated>2022-03-17T02:33:55.000Z</updated>
    
    <content type="html"><![CDATA[<p>​ 在训练神经网络时，通常会使用一个叫 Exponential Moving Average (EMA)的方法，中文名叫指数滑动平均。它的意义在于利用滑动平均的参数来<strong>提高模型在测试数据上的健壮性</strong>。</p><h4 id="一什么是滑动平均">一、什么是滑动平均？</h4><p>​ 滑动平均(exponential movingaverage)，或者叫做指数加权平均(exponentially weighted movingaverage)，可以用来估计变量的局部均值，使得变量的更新与一段时间内的历史取值有关。</p><p>​ 首先我们假设一个训练参数a，它在不同的epoch结束后的值分别为： <spanclass="math display">\[a_1,a_2,a_3,……,a_t\]</span> ​ <spanclass="math inline">\(a_1\)</span>代表第1轮epoch迭代结束后，可训练参数a的值，以此类推。</p><p>​ 然后，我们假设不同的epoch结束后，滑动平均的值分别为： <spanclass="math display">\[mv_1,mv_2,mv_3,……,mv_t\]</span> ​ <spanclass="math inline">\(mv_1\)</span>代表第1轮epoch迭代结束后，滑动平均mv的值，以此类推。</p><p>​ 滑动平均计算的递推式如下： <span class="math display">\[mv_t = decay * mv_{t-1} + (1-decay)*a_t\]</span> ​其中，decay为衰减率，用于控制模型更新的速度。递推式中其实就是利用加权的思想，把新的a和先前的平均，做了一个相加。我们可以发现，再很多轮之后，有些离<spanclass="math inline">\(a_t\)</span>很远的a,它已经乘了很多遍decay，相当于权重为0，也就是不影响最新的<spanclass="math inline">\(mv_t\)</span>的值了。</p><p>​ 从直观意义上来看，我们可以把<spanclass="math inline">\(a_1,a_2,a_3,……,a_t\)</span>看作是t个位置，然后想象有一个长度为k的窗口，从最前面开始向后滑动。为了方便说明，我们先假设k=3。最开始的时候，窗口把<spanclass="math inline">\(a_1\)</span>涵括在内，然后一个epoch过后窗口右移，现在窗口内有<spanclass="math inline">\(a_1,a_2\)</span>，再一个epoch过后窗口再右移，现在窗口内有<spanclass="math inline">\(a_1,a_2,a_3\)</span>，再一个epoch过后窗口再右移，此时由于窗口长度为3，所以<spanclass="math inline">\(a_1\)</span>就不在窗口内了，窗口内的元素为<spanclass="math inline">\(a_2,a_3,a_4\)</span>，从公式上来讲就是在此时，由于<spanclass="math inline">\(a_1\)</span>已经乘了较多遍数的decay衰减系数了，所以其的系数接近于0了，不会再影响窗口内计算的值了。</p><p>​ 故此称为滑动平均。</p><h4 id="二更为公式化的解读">二、更为公式化的解读：</h4><p>EMA 在实现时如下所述：</p><p>​ Exponential Moving Average 对每一个变量（ <spanclass="math inline">\(variable\)</span> ）会维护一个影子变量（ <spanclass="math inline">\(shadow\_variable\)</span>），这个影子变量的初始值就是相应变量的初始值，而每次运行变量更新时，影子变量的值会更新为：<span class="math display">\[shadow\_variable = decay * shadow\_variable + (1-decay) * variable\]</span> ​ 其中：<spanclass="math inline">\(variable\)</span>为每一轮结束时，训练参数的值；<spanclass="math inline">\(shadow\_variable\)</span>为影子变量；<spanclass="math inline">\(decay\)</span>为衰减速率。</p><p>​ decay 决定了影子变量的更新速度，decay越大影子变量越趋于稳定。在实际运用中，decay一般会设成非常接近 1的数（比如0.999或0.9999）。</p><p>​ 为了使得影子变量在训练前期可以更新更快，Exponential Moving Average还提供了 num_updates 参数动态设置 decay 的大小。如果在初始化 ExponentialMoving Average 时提供了 num_updates 参数，那么每次使用的衰减率将是：<span class="math display">\[decay = min\{decay,\frac{1+num\_updates}{10+num\_updates}\}\]</span></p><h4 id="三什么时候用到ema">三、什么时候用到EMA？</h4><p>请注意：</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​ <strong>EMA不参与实际的训练过程，是用在测试过程的</strong>！</p><p>​在训练过程中，EMA只是以一个记录者的身份，在进行记录。实际的实现中，如果你在正常训练的网络是network['C']，那么你可以再实例化一个新的网络，叫做network['C_EMA'],其最初和network['C']一模一样，但是network['C_EMA']并不参与实际记录，其里面的参数只是用来记录滑动平均！！！<strong>（这就是DG-Font代码中，network['C_EMA']的作用）</strong></p><p>​EMA作用是<strong>使得模型在测试数据上更加健壮，有更好的鲁棒性。或者是最后save模型时存储ema的值，取最近n次的近似平均值，使模型具备更好的测试指标(accuracy)等，更强的泛化能力。</strong></p><p>参考：</p><p>https://zhuanlan.zhihu.com/p/51672655</p><p>https://zhuanlan.zhihu.com/p/343210667</p>]]></content>
    
    
    <summary type="html">整理了EMA指数滑动平均的原理，以及pytorch训练中的实现</summary>
    
    
    
    <category term="⓵ 深度学习笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    <category term="Basic系列笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B5-%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Basic%E7%B3%BB%E5%88%97%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="EMA" scheme="https://blog.slks.xyz/tags/EMA/"/>
    
  </entry>
  
  <entry>
    <title>2.2 处理机调度及相关算法</title>
    <link href="https://blog.slks.xyz/2022/03/25/9887f629bb62/"/>
    <id>https://blog.slks.xyz/2022/03/25/9887f629bb62/</id>
    <published>2022-03-25T12:40:19.000Z</published>
    <updated>2022-04-30T07:58:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>笔记课程视频：https://www.bilibili.com/video/BV1YE411D7nH?p=13</p><h3 id="一处理机调度-概念与层次">一、处理机调度 概念与层次</h3><h4 id="调度的基本概念">1、调度的基本概念：</h4><p>​当有一堆任务要处理，但由于资源有限，这些事情没法同时处理。这就需要确定某种规则来决定处理这些任务的顺序，这就是“调度”研究的问题。</p><p>​在多道程序系统中，进程的数量往往是多于处理机的个数的，这样不可能同时并行地处理各个进程。<strong>处理机调度，就是从就绪队列中按照一定的算法选择一个进程并将处理机分配给它运行，以实现进程的并发执行。</strong></p><h4id="调度的三个层次高级调度作业调度">2、调度的三个层次—高级调度（作业调度）：</h4><p>​<strong>按一定的原则从外存上处于后备队列的作业中挑选一个（或多个）作业，给他们分配内存等必要资源，并建立相应的进程（建立PCB），以使它（们）获得竞争处理机的权利。</strong></p><ul><li>由于内存空间有限，有时无法将用户提交的作业全部放入内存，因此就需要确定某种规则来决定将作业调入内存的顺序。</li><li>高级调度是辅存（外存）与内存之间的调度。</li><li>每个作业只调入一次，调出一次。</li><li>作业调入时会建立相应的PCB，作业调出时才撤销PCB。</li></ul><p>​<strong>高级调度主要是指调入的问题，因为只有调入的时机需要操作系统来确定，但调出的时机必然是作业运行结束才调出。</strong></p><h4id="调度的三个层次中级调度内存调度">3、调度的三个层次—中级调度（内存调度）：</h4><p>​ 引入了虚拟存储技术之后，可将暂时不能运行的进程调至外存等待。</p><p>​等它重新具备了运行条件且内存又稍有空闲时，再重新调入内存。<strong>这么做的目的是为了提高内存利用率和系统吞吐量。</strong></p><ul><li>暂时调到外存等待的进程状态为挂起状态。</li><li>PCB并不会一起调到外存，而是会常驻内存。</li><li>PCB中会记录进程数据在外存中的存放位置，进程状态等信息，操作系统通过内存中的PCB来保持对各个进程的监控、管理。<strong>被挂起的进程PCB会被放到的挂起队列中。</strong></li></ul><p><strong>中级调度（内存调度），就是要决定将哪个处于挂起状态的进程重新调入内存。一个进程可能会被多次调出、调入内存，因此中级调度发生的频率要比高级调度更高。</strong></p><p><strong>注意：</strong>“挂起”和“阻塞”的区别，两种状态都是暂时不能获得CPU的服务，但挂起态是将进程映像调到外存去了，而阻塞态下进程映像还在内存中。</p><h4id="调度的三个层次低级调度进程调度">4、调度的三个层次—低级调度（进程调度）</h4><p>​低级调度（进程调度），其主要任务是按照某种方法和策略从就绪队列中选取一个进程，将处理机分配给它。</p><p>​进程调度是操作系统中最基本的一种调度，在一般的操作系统中都必须配置进程调度。进程调度的频率很高，一般几十毫秒一次。</p><h4 id="三层调度的联系和对比">5、三层调度的联系和对比：</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326111647450.png" /></p><h3id="二进程调度的时机切换过程与方式">二、进程调度的时机、切换过程与方式</h3><h4 id="何时需要进行进程调度">1、何时需要进行进程调度？</h4><ul><li>当前运行的进程主动放弃<ul><li>正常终止</li><li>发生异常而终止</li><li>进程主动请求阻塞</li></ul></li><li>当前进行的进程被动放弃<ul><li>分给进程的时间片用完</li><li>有更紧急的事需要处理（如I/O中断）</li><li>有更高优先级的进程进入就绪队列</li></ul></li></ul><h4 id="何时不能进行进程调度">2、何时不能进行进程调度？</h4><ul><li>在处理中断的过程中。中断处理过程复杂，与硬件密切相关，很难做到在中断处理过程中进行进程切换。</li><li>进程在<strong>操作系统内核程序临界区</strong>中不能进行进程调度。（但是进程在普通临界区中是可以进行调度、切换的。</li><li>在原子操作过程中（原语）。原子操作不可中断，要一气呵成（如之前讲过的修改PCB中进程状态标志，并把PCB放到相应队列）</li></ul><p><strong>注：什么是临界资源？</strong></p><p>​临界资源：一个时间段内只允许一个选程使用的资源。各进程需要互斥地访问临界资源。</p><p>​ 临界区：访问临界资源的那段代码。</p><p>​<strong>内核程序临界区</strong>一般是用来访问某种内核数据结构的，比如进程的就绪队列（由各就绪进程的PCB组成）</p><p>​<strong>内核程序临界区</strong>访问的临界资源如果不尽快释放的话，极有可能影响到操作系统内核的其他管理工作。因此在访问内核程序临界区期间不能进行调度与切换</p><h4 id="进程调度的方式">3、进程调度的方式</h4><p>​有的系统中只允许进程主动放弃处理机，有的系统中，进程可以主动放弃处理机，当有更紧急的任务需要处理时，也会强行剥夺处理机（被动放弃）</p><h5 id="非抢占方式">1）非抢占方式：</h5><p>​ 只允许进程主动放弃处理</p><h5 id="抢占方式">2）抢占方式</h5><p>​当有更紧急的任务需要处理时，会强行剥夺处理机（被动放弃）。可以优先处理更紧急的进程，也可实现让各进程按时间片轮流执行的功能（通过时钟中断）。适合于分时操停系统、实时操作系统</p><h4 id="进程的切换与过程">4、进程的切换与过程</h4><h5id="狭义的进程调度与进程切换的区别">1）“狭义的进程调度”与“进程切换”的区别：</h5><ul><li><strong>狭义的进程调度</strong>：指的是从就绪队列中选中一个要运行的进程。（这个进程可以是刚刚被暂停执行的进程，</li><li><strong>进程切换</strong>：是指一个进程让出处理机，由另一个进程占用处理机的过程。广义的进程调度包含了选择一个进程和进程切换两个步骤。</li></ul><h5id="进程切换的过程主要完成了">2）<strong>进程切换的过程主要完成了：</strong></h5><ul><li>对原来运行进程各种数据的保存</li><li>对新的进程各种数据的恢复（如：程序计数器、程序状态字、各种数据寄存器等处理机现场信息，这些信息一般保存在进程控制块）</li></ul><p><strong>注意：</strong>进程切换是有代价的，因此如果过于频繁的进行进程调度、切换，必然会使整个系统的效率降低，使系统大部分时间都花在了进程切换上，而真正用于执行进程的时间减少。</p><h4 id="调度算法的评价指标">5、调度算法的评价指标</h4><h5 id="cpu利用率">1）CPU利用率：</h5><p>​ CPU利用率 = 忙碌时间 / 总时间</p><h5 id="系统吞吐量">2）系统吞吐量：</h5><p>​ 系统吞吐量 = 总共完成了多少道作业 / 总共花了多少时间</p><h5 id="周转时间">3）周转时间：</h5><p>​周转时间，是指<strong>从作业被提交给系统开始，到作业完成为止的这段时间间隔。</strong></p><p>​ 它包括四个部分：</p><ul><li>作业在外存后备队列上等待作业调度（高级调度）的时间、</li><li>进程在就绪队列上等待进程调度（低级调度）的时间、</li><li>进程在CPU上执行的时间、</li><li>进程等待I/0操作完成的时间。</li></ul><p>后三项在一个作业的整个处理过程中，可能发生多次。</p><p>​ 平均周转时间 = 各作业周转时间之和 / 作业数</p><h5 id="带权周转时间">4）带权周转时间：</h5><p>​ 带权周转时间 = 作业周转时间 / 作业实际运行的时间</p><ul><li>对于周转时间相同的两个作业，实际运行时间长的作业在相同时间内被服务的时间更多，带权周转时间更小，用户满意度更高。</li><li>对于实际运行时间相同的两个作业，周转时间短的带权周转时间更小，用户满意度更高。</li></ul><h5 id="等待时间">5）等待时间：</h5><p>​等待时间，指进程/作业处于等待处理机状态时间之和，等待时间越长，用户满意度越低。</p><h5id="对于进程来说等待时间就是指进程建立后等待被服务的时间之和在等待i0完成的期间其实进程也是在被服务的所以不计入等待时间">对于进程来说，等待时间就是指进程建立后等待被服务的时间之和，在等待I/0完成的期间其实进程也是在被服务的，所以不计入等待时间。</h5><p>​<strong>对于作业来说，不仅要考虑建立进程后的等待时间，还要加上作业在外存后备队列中等待的时间。</strong></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220326114401542.png" /></p><h5 id="响应时间">6）响应时间：</h5><p>​ 响应时间，指从用户提交请求到首次产生响应所用的时间。</p><h4 id="调度算法-1">6、调度算法 1</h4><p><strong>调度算法的重点</strong>：</p><ul><li>算法思想</li><li>算法规则</li><li>用于作业调度还是进程调度</li><li>抢占式还是非抢占式</li><li>优点和缺点</li><li>是否会导致饥饿</li></ul><h5 id="fcfs-先来先服务非抢占式算法">1） FCFS先来先服务（非抢占式算法）</h5><p>​ 主要从公平的角度考虑，按照作业/进程到达的先后顺序进行服务。</p><ul><li>用于作业调度时，考虑的是哪个作业先到达后备队列</li><li>用于进程调度时，考虑的是哪个进程先到达就绪队列</li><li>非抢占式算法<ul><li>优点：公平，算法实现简单</li><li>缺点：排在长作业后的短作业需要等待很长时间，带权周转时间很大.FCFS算法对长作业有利,对短作业不利.</li></ul></li><li>不会导致饥饿</li></ul><h5 id="sjf-短作业优先算法-非抢占式算法">2） SJF 短作业优先算法(非抢占式算法):</h5><p>​ 追求最少的平均等待时间,最短的作业或进程优先得到服务(指要求服务时间最短)</p><p>​<strong>[每次调度时选择当前已到达且运行时间最短的作业/进程]</strong></p><ul><li>用于作业调度时，称为 短作业优先算法</li><li>用于进程调度时，称为 SPF 短进程优先算法</li><li>SJF和SPF是非抢占式算法,也有抢占式的算法: 最短剩余时间优先算法SRTN<ul><li>优点：“最短的”平均等待时间、平均周转时间</li><li>缺点：不公平。对短作业有利，对长作业不利。可能产生饥饿现象。另外，作业/进程的运行时间是由用户提供的，并不一定真实，不一定能做到真正的短作业优先</li></ul></li><li>可能导致饥饿,如果有源源不断有短作业来</li><li><strong>示例1:</strong> SPF 算法<ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092135300.png" /></li></ul></li><li><strong>示例2:</strong> SRTN 算法( 最短剩余时间优先算法 ):每当有进程加入就绪队列改变时就需要调度，<strong>如果新到达的进程剩余时间比当前运行的进程剩余时间更短，则由新进程抢占处理机，</strong>当前运行进程重新回到就绪队列。另外，<strong>当一个进程完成时也需要调度</strong><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412092403526.png" /></li></ul></li></ul><h5 id="hrrn-高响应比优先非-抢占式-算法">3） HRRN 高响应比优先:(非抢占式 算法 )</h5><p>​综合考虑作业和进程的等待时间和要求服务的时间,在每次调度时先计算各个作业/进程的响应比，选择响应比最高的作业/进程为其服务.<span class="math display">\[响应比 = \frac{等待时间 + 要求服务时间}{要求服务时间}\]</span></p><ul><li><p>既可以用于进程调度也可以用于作业调度</p><ul><li>优点:综合考虑了等待时间和运行时间,对于长作业来说,随着等待时间越来越久,其响应比也会越来越大,从而避免了长作业饥饿的问题</li><li>缺点:</li></ul></li><li><p>示例1:</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104029587.png" /></p><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104019832.png" /></li></ul></li><li><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104148079.png" /><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412104351880.png" /></p></li></ul><h4 id="调度算法-2">7、调度算法 2</h4><h5id="时间片轮转算法抢占式算法常用于分时操作系统更注重响应时间">1）时间片轮转算法：（抢占式算法）【常用于分时操作系统，更注重响应时间】</h5><ul><li>公平地、轮流地为各个进程服务，让每个进程在一定时间间隔内都可以得到响应</li><li>按照各进程到达就绪队列的顺序，轮流让各个进程执行一个时间片（如100ms）。若进程未在一个时间片内执行完，则剥夺处理机，将进程重新放到就绪队列队尾重新排队。</li><li>一般只用于进程调度（只有作业放入内存建立了相应的进程后，才能被分配处理机时间片）</li><li>由时钟装置发出<strong>时钟中断</strong>来通知CPU时间片已到。<ul><li><strong>优点：</strong>响应快，适合分时操作系统，不会导致饥饿</li><li><strong>缺点：</strong>由于高频率的进程切换，因此有一定开销</li></ul></li><li><strong>示例：</strong><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412111910996.png" /></li></ul></li></ul><p>​如果时间片太大，使得每个进程都可以在一个时间片内就完成，则时间片轮转调度算法退化为先来先服务调度算法，并且会增大进程响应时间。因此时间片不能太大。</p><p>​另一方面，进程调度、切换是有时间代价的（保存、恢复运行环境），因此如果时间片太小，会导致进程切换过于频繁，系统会花大量的时间来处理进程切换，从而导致实际用于进程执行的时间比例减少。可见时间片也不能太小。</p><h5id="优先级调度算法抢占式非抢占式版本都有常用于实时操作系统">2）优先级调度算法：（抢占式、非抢占式版本都有）【常用于实时操作系统】</h5><ul><li>随着计算机的发展，特别是实时操作系统的出现，越来越多的应用场景需要根据任务的紧急程度来决定处理顺序每个作业/进程有各自的优先级，调度时选择优先级最高的作业/进程</li><li>既可用于作业调度，也可用于进程调度。甚至，还会用于在之后会学习的I/0调度中<ul><li>非抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。</li><li>抢占式：每次调度时选择当前已到达且优先级最高的进程。当前进程主动放弃处理机时发生调度。<strong>另外，当就绪队列发生改变时也需要检查是会发生抢占。</strong></li></ul></li><li><strong>优点：</strong>用优先级区分紧急程度、重要程度，适用于实时操作系统。可灵活调整对各种作业/进程的偏好程度。</li><li><strong>缺点：</strong>若源源不断地有高优先级进程到来，则可能导致饥</li><li><strong>示例：</strong><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412112408359.png" /></li><li></li></ul></li><li>通常：<ul><li>系统进程优先级高于用户进程会得到提升</li><li>前台进程优先级高于后台进程</li><li>操作系统更偏好I/o型进程（或称I/o繁忙型进程）</li><li>注：与I/0型进程相对的是计算型进程（或称CPU繁忙型进程）</li></ul></li></ul><p>【由于I/o设备和CPU可以并行工作。如果优先让I/O繁忙型进程优先运行的话，则越有可能让I/O设备尽早地投入工作，则资源利用率、系统吞吐量都会得到提升】</p><ul><li>可以从追求公平、提升资源利用率等角度考虑<ul><li>如果某进程在就绪队列中等待了很长时间，则可以适当提升其优先级</li><li>如果某进程占用处理机运行了很长时间，则可适当降低其优先级</li><li>如果发现一个进程频繁地进行I/O操作，则可适当提升其优先级</li></ul></li></ul><h5id="多级反馈队列调度算法抢占式算法可能导致饥饿">3）多级反馈队列调度算法：【抢占式算法，可能导致饥饿】</h5><ul><li>对其他调度算法的折中权衡<ul><li>1.设置多级就绪队列，各级队列优先级从高到低，时间片从小到大</li><li>2.新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片，若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经是在最下级的队列，则重新放回该队列队尾</li><li>3.只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li></ul></li><li>用于进程调度，抢占式算法<ul><li>在k级队列的进程运行过程中，<strong>若更上级的队列（1~k-1级）中进入了一个新进程，则由于新进程处于优先级更高的队列中，因此新进程会抢占处理机，</strong>原来运行的进程放回k级队列队尾。</li></ul></li><li><strong>优点：</strong>对各类型进程相对公平（FCFS的优点）；每个新到达的进程都可以很快就得到响应（RR的优点）；短进程只用较少的时间就可完成（SPF的优点）；不必实现估计进程的运行时间（避免用户作假）；可灵活地调整对各类进程的偏好程度，比如CPU密集型进程、I/0密集型进程（拓展：可以将因l/O而阻塞的进程重新放回原队列，这样I/o型进程就可以保持较高优先级）</li><li><strong>示例：</strong><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113638505.png" /></li><li>新进程到达时先进入第1级队列，按FCFS原则排队等待被分配时间片。若用完时间片进程还未结束，则进程进入下一级队列队尾。如果此时已经在最下级的队列，则重新放回最下级队列队尾</li><li>只有第k级队列为空时，才会为k+1级队头的进程分配时间片</li><li>被抢占处理机的进程重新放回原队列队尾</li></ul></li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220412113856291.png" /></p><p>​注：比起早期的批处理操作系统来说，由于计算机造价大幅降低，因此之后出现的交互式操作系统（包括分时操作系统、实时操作系统等）更注重系统的响应时间、公平性、平衡性等指标。而这几种算法恰好也能较好地满足交互式系统的需求。因此这三种算法适合用于交互式系统。（比如UNIX使用的就是多级反馈队列调度算法）*</p>]]></content>
    
    
    <summary type="html">包含王道课程第2.2节的内容，含处理机调度的概念、层次，进程调度的时机、切换和过程，调度算法的评级指标，FCFS、SJF、HRRN调度算法以及时间片轮转、优先级调度、多级反馈队列算法等调度算法</summary>
    
    
    
    <category term="⓹ 基础类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="操作系统" scheme="https://blog.slks.xyz/categories/%E2%93%B9-%E5%9F%BA%E7%A1%80%E7%B1%BB%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="Operating System" scheme="https://blog.slks.xyz/tags/Operating-System/"/>
    
  </entry>
  
  <entry>
    <title>《StyTr2 Unbiased Image Style Transfer with Transformers》</title>
    <link href="https://blog.slks.xyz/2022/03/21/58ee25c0143c/"/>
    <id>https://blog.slks.xyz/2022/03/21/58ee25c0143c/</id>
    <published>2022-03-21T10:12:19.000Z</published>
    <updated>2022-03-22T03:14:40.000Z</updated>
    
    <content type="html"><![CDATA[<h4id="论文名称stytr2-unbiased-image-style-transfer-with-transformers">论文名称：《StyTr^2Unbiased Image Style Transfer with Transformers》</h4><h4 id="论文地址-httparxiv.orgabs2105.14576">论文地址：http://arxiv.org/abs/2105.14576</h4><h2 id="关键词">1、关键词：</h2><p>​ Image Style Transfer、Transformer</p><h2 id="摘要">2、摘要：</h2><p>​由于CNN的局部感知域性和空间不变性，输入图像的全局信息难以提取和维护。因此，传统的神经网络风格传递方法通常是有偏差的，对于同一幅参考风格图像，<strong>通过多次运行风格迁移过程可以观察到内容泄漏。</strong>为了解决这个关键问题，该文提出了一种基于Transformer的方法，即StyTr2，将输入图像的长期依赖关系考虑到无偏风格传输中。​与用于其他视觉任务的视觉转换器不同，我们的StyTr2包含两个不同的转换器编码器，分别为内容和样式生成特征序列。在编码器之后，采用多层Transformer解码器，根据样式序列对内容序列进行风格化。</p><h2 id="领域背景style-transfer">3、领域背景—Style Transfer：</h2><p>​经典的基于深度学习的图像风格迁移，样式转换方法使用多层cnn来学习样式和内容表示。由于卷积层的接收域有限，CNN无法处理长距离依赖关系。输入图像难以获得全局信息，这是图像风格传递任务的关键。将Transformer应用于计算机视觉的魅力在于:</p><ul><li><ol type="1"><li>它具有较强的表示能力，可以通过自注意机制自由地学习输入的全局信息，从而使每一层都能轻松获得整体的理解。</li></ol></li><li><ol start="2" type="1"><li>Transformer不包含局部性和空间不变性引起的归纳偏差，可以避免风格传递任务中的内容泄漏</li></ol></li></ul><h2 id="先前工作描述与比较">4、先前工作描述与比较：</h2><p>​ 暂略</p><h2 id="主要设计思想">5、主要设计思想：</h2><p>​ 在StyTr2框架中使用两个编码器来获取特定领域（Content &amp;Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。此外，针对自然语言处理中提出的位置编码方法，提出了两个方面的考虑:</p><ul><li><ol type="1"><li>不同于按逻辑顺序排列的句子，图像序列符号是通过图像内容的语义信息进行关联的;</li></ol></li><li><ol start="2" type="1"><li>对于风格迁移任务，目标是生成任意大小的风格化图像。输入图像大小的指数增长会导致位置编码的剧烈变化，从而导致较大的位置偏差和较差的输出质量。一般来说，视觉任务所需的位置编码应以输入内容为条件，而不受图像尺度变换的影响。</li></ol></li></ul><p>为此，该文还提出了<strong>基于图像语义特征的位置编码</strong>，并根据图像大小动态扩展位置编码。</p><p><strong>总结：主要贡献</strong></p><ul><li><ol type="a"><li>一个基于Transformer的风格转换框架，即StyTr2，以减少内容泄漏并实现无偏的风格化;</li></ol></li><li><ol start="2" type="a"><li>一种内容感知的位置编码机制，该机制是尺度不变的，适用于视觉生成任务;</li></ol></li></ul><h2 id="具体方法与网络架构">6、具体方法与网络架构：</h2><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321190212987.png" /></p><h3 id="图像分割为patches-linear-embedding与vit类似">1)图像分割为Patches + Linear Embedding【与ViT类似】</h3><ul><li><strong>输入：</strong><span class="math inline">\(I_c \in R^{H\times W \times 3}\)</span> 和 <span class="math inline">\(I_s \in R^{H\times W \times 3}\)</span></li><li><strong>输出：</strong>一个特征序列：$ L C<spanclass="math inline">\(，\)</span>L = $ ，<spanclass="math inline">\(m\)</span>是PatchSize，<spanclass="math inline">\(L\)</span>是特征序列tokens长度，<spanclass="math inline">\(C\)</span>是单个Token的维度。</li></ul><h3 id="位置编码content-aware-positional-encoding">2) 位置编码（ContentAware Positional Encoding）：</h3><ul><li><p><strong>想法：</strong>当使用基于Transformer的模型时，需要在输入序列中加入位置编码(PE)以获取结构信息。此论文提出了基于图像语义的位置编码，这一改进基于以下两个想法：</p></li><li><p>在传统的位置编码中：两个patch之间的位置相对关系仅仅与它们之间的距离有关。而对于图像生成任务，在计算位置编码时，我们应该考虑图像的语义</p></li><li><p>当输入图像的尺寸呈指数增长时，传统的正弦位置编码是否仍然适用于视觉任务?如下所示当调整输入图像的大小时，相同语义的patches (blueblocks)之间的相对关系会发生巨大的变化，这可能不适合视觉任务中多大小的输入。</p></li><li><p><strong>主要做法：</strong>提出了内容感知的位置编码(CAPE)，该编码具有<strong>尺度不变特性</strong>，更适合于风格迁移任务。与正弦PE只考虑Patches的相对距离不同，CAPE以图像内容语义为条件。</p></li><li><p>首先假设<span class="math inline">\(n \times n\)</span>可以足够用于表示每幅图像的语义位置。</p></li><li><p>假设输入图像为：<span class="math inline">\(I \in R^{H \times W\times 3}\)</span> ，我们将<span class="math inline">\(n \timesn\)</span>的位置编码（依据实验结果，一般情况下<spanclass="math inline">\(n=18\)</span>），放缩至<spanclass="math inline">\(L = \frac{H}{m} \times\frac{W}{m}\)</span>的大小，这样就可以使得位置编码不受图像尺度的影响。即对于两个ImagePatches而言，它们直接的位置关系不会受到图像尺度的影响。如下图所示：假设有两个不同分辨率的图像，在PatchSize大小一样的情况下，左图分辨率小，被分割后，成为<spanclass="math inline">\(2 \times 2\)</span>的Patch块，右图成为<spanclass="math inline">\(4 \times4\)</span>的Patch块。当位置编码会进行放缩以适应的时候，其就可以自己匹配不同尺度的图像。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210140364.png" /></p></li><li><p><strong>公式化表达</strong>：</p><ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321210523455.png" /></li><li><span class="math inline">\(P_{CA}(x,y)\)</span>代表第<spanclass="math inline">\((x,y)\)</span>坐标的Patch的位置编码值</li><li><spanclass="math inline">\(F_{pos}\)</span>是一个可学习的编码函数</li><li><spanclass="math inline">\(P_L\)</span>是一个可学习的位置编码，是基于图像的token序列的</li><li><span class="math inline">\(a_{ij}\)</span>为插值权重，<spanclass="math inline">\(s\)</span>是邻居的数量，其是由周围邻居加权差值计算得到的。</li><li>对于token序列<spanclass="math inline">\(\epsilon\)</span>中的第i个Patch块，假设这个Patch块的坐标是<spanclass="math inline">\((x,y)\)</span>，那么我们将计算得到的<spanclass="math inline">\(P_{CAu}\)</span>值加到<spanclass="math inline">\(\epsilon_i\)</span>中，形成最后的序列。即，如果原来的token序列<spanclass="math inline">\(\epsilon\)</span>形状是<spanclass="math inline">\(L \times C\)</span>，那么新的也应当为<spanclass="math inline">\(L \times C\)</span></li></ul></li></ul><h3 id="transformer-encoder">3) Transformer Encoder：</h3><p>​ StyTr2有两个转换Encoder来编码特定于风格（内容图像 &amp;&amp;风格图像）的特性，这些特性用于在下一阶段将序列从一个风格转换到另一个风格。</p><h4 id="part1-content-image">Part1: Content Image</h4><ul><li><strong>输入：</strong>Tokens 序列 <span class="math inline">\(Z_c\in L \times C\)</span></li><li><strong>输出：</strong>$Y_c L C $</li><li><strong>网络结构：</strong>每个transformer encoderlayer包含一个MSA和一个FFN，与Transformer结构一致，输入序列被编码至Q，K，V。<ul><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215744833.png" /></li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321215804639.png" /></li><li><spanclass="math inline">\(W_q,W_k,W_v,W_o\)</span>是可学习参数矩阵。</li><li>然后使用残差连接结构，每个模块后有LN归一化</li><li><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321220112862.png" /></li></ul></li></ul><h4 id="part2-style-image">Part2: Style Image：</h4><p>​ 按照Content Image那样子进行处理，但是对于StyleImage我们<strong>不需要进行位置编码，因为我们不需要保持它的图像结构。</strong></p><ul><li><strong>输入：</strong>风格图像Tokens 序列 <spanclass="math inline">\(Z_s \in L \times C\)</span></li><li><strong>输出：</strong>$Y_s L C $</li></ul><h3 id="transformer-decoder">4）Transformer Decoder：</h3><ul><li><strong>输入：</strong>$Y_c L C $ ， $Y_s L C $ （<spanclass="math inline">\(\hat Y_c\)</span>是<spanclass="math inline">\(Y_c\)</span>增加了CAPE位置编码后的序列）</li><li><strong>输出：</strong><span class="math inline">\(output \in\frac{HW}{64} \times C\)</span></li></ul><p>​根据参考的风格序列，用回归的方式来生成内容序列。和传统NLP任务不一样，我们使用序列中的所有Patches一次性输入来预测结果。</p><p><img src="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321224013009.png" style="zoom: 80%;" /></p><p>​由两个MSA和一个FNN模块组成。第一个MSA模块的K、V来源于Style序列，Q来源于Content序列。每个模块后面都有一个LN归一化。</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232914140.png" /></p><ul><li><p>公式化表达：</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220321232959747.png" /></p></li></ul><h3 id="decoder">5）Decoder：</h3><p>​论文使用了一个三层的CNN解码器来细化后面的Transformer解码器的输出，而不是直接对输出进行上采样来构造结果。</p><ul><li>输入：<span class="math inline">\(input \in \frac{HW}{64} \timesC\)</span></li><li>输出：<span class="math inline">\(I_{out} \in H \times W \times3\)</span></li><li>网络结构组成：<ul><li>$3 $ 卷积层</li><li>ReLU</li><li><span class="math inline">\(2 \times\)</span> 上采样操作</li></ul></li></ul><h2 id="采用的损失函数">7、采用的损失函数：</h2><h4id="content-percepture-loss-感知内容损失-style-percepture-loss感知风格损失">1）ContentPercepture Loss 感知内容损失 &amp;&amp; Style PerceptureLoss感知风格损失</h4><p>​优化结果应保持原有的内容结构，同时传递参考风格的模式。VGG提取的特征图可以作为内容特征来表示图像结构。<strong>Gram</strong>矩阵是两两向量的内积组成,所以<em>Gram</em>矩阵可以反映出该组向量中各个向量之间的某种关系。特征图的Gram矩阵可以作为风格特征来表示颜色、纹理等信息。因此，论文构建了<strong>感知内容损失</strong>来衡量生成图像<spanclass="math inline">\(I_{cs}\)</span>与参考风格图像<spanclass="math inline">\(I_c\)</span>之间的内容差异，构建<strong>感知风格损失</strong>来衡量生成图像<spanclass="math inline">\(I_{cs}\)</span>与参考风格图像<spanclass="math inline">\(I_s\)</span>之间的风格差异。</p><ul><li>Content Percepture Loss：</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103100728.png" /></p><ul><li>Style Percepture Loss:</li></ul><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322103340777.png" /></p><p>​ 因为神经网络各层的统计量(如均值和方差)包含了不同领域的特征。<spanclass="math inline">\(\phi_i\)</span>代表使用预训练的VGG19网络，其第i层提取出的特征。<spanclass="math inline">\(\mu()\)</span>代表特征的均值，<spanclass="math inline">\(\sigma()\)</span>代表特征的方差。风格的感知损失可以书写如上。</p><h4 id="identity-loss">2) Identity Loss</h4><p>​自监督学习可以利用PreText从大规模的非监督数据中挖掘其监督信息。网络可以用这种构造的监督信息进行训练，以学习下游任务的有价值表示。论文采用一个辅助的<strong>自我风格迁移任务</strong>来学习更丰富、更准确的语义和风格表达。<strong>该任务具体操作如下：</strong></p><p>​<strong>注</strong>：Pretext任务可以进一步理解为：<strong>对目标任务有帮助的辅助任务。</strong></p><p>​ 论文在StyTr2中输入两个相同的<spanclass="math inline">\(内容/风格\)</span>图像，生成的图像<spanclass="math inline">\(I_{cc}/I_{ss}\)</span>应该与输入图像<spanclass="math inline">\(I_{c}/I_{s}\)</span>相同。因此，<spanclass="math inline">\(Identity Loss\)</span>模拟<spanclass="math inline">\(I_{c}/I_{s}\)</span>与<spanclass="math inline">\(I_{cc}/I_{ss}\)</span>之间的差异:</p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104028070.png" /></p><h4 id="最终loss">3）最终Loss</h4><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/image-20220322104224116.png" /></p><p><span class="math inline">\(\lambda_c\)</span>、<spanclass="math inline">\(\lambda_s\)</span>、<spanclass="math inline">\(\lambda_{id1}\)</span>、<spanclass="math inline">\(\lambda_{id2}\)</span> = { 10 , 7 , 50 , 1 }</p>]]></content>
    
    
    <summary type="html">提出了StyTr2，该框架中使用两个编码器来获取特定领域（Content &amp; Style）的信息。在编码器之后，使用Transformer解码器逐步生成输出序列。</summary>
    
    
    
    <category term="⓶ 论文阅读笔记" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/"/>
    
    <category term="CV相关论文" scheme="https://blog.slks.xyz/categories/%E2%93%B6-%E8%AE%BA%E6%96%87%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/CV%E7%9B%B8%E5%85%B3%E8%AE%BA%E6%96%87/"/>
    
    
    <category term="Style Transfer" scheme="https://blog.slks.xyz/tags/Style-Transfer/"/>
    
    <category term="CNN" scheme="https://blog.slks.xyz/tags/CNN/"/>
    
    <category term="Transformer" scheme="https://blog.slks.xyz/tags/Transformer/"/>
    
  </entry>
  
  <entry>
    <title>关于文献综述、开题报告写作逻辑记录</title>
    <link href="https://blog.slks.xyz/2022/03/21/70cfb7bd8141/"/>
    <id>https://blog.slks.xyz/2022/03/21/70cfb7bd8141/</id>
    <published>2022-03-21T08:27:23.000Z</published>
    <updated>2022-03-21T06:47:52.000Z</updated>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="Oh, this is an invalid password. Check and try again, please." data-whm="OOPS, these decrypted content may changed, but you can still have a look.">  <script id="hbeData" type="hbeData" data-hmacdigest="4eafc87be004f2fe6450b3b1187603d145c57273c5c643dcd6508b8936edc57f">0b64cd3abe5b0a0a039a37d86c66d75e30f1e5cc7662992b49707d8fb1532b69399debf3853b2258ca954efe35d1f8c5bd240504c5d2baeffc97196da2a36e61d5f8a60dbcda8be9c594f5556387c07fb682de586f5ae7d6a50c917baf4d54f0862c449297b85832444e70ca69090890ddac89cc2a436f08f1c0dbd21e6873b0e58d57c1b38a49b41fa8c0e67d43e32fa1e34777f2ccacf9c1d5468ffcc3ed12d66cdda1d779a044bc0be7fdc965365748e4773167d46b07566110f6088839a6d82913300492778bbcab5da1c68a70b13cccfdda91a9e1adbe37e8b7be858c62c4c6a621aed2b8ef1193c4d8080e6986328ecb374f1a8dad3ddaad6dc11b3f8c46600f971b005916b0e49f81a9b61fb259361f307287571d8d2e25d5ab6626fe9cb45227b68955988a39ebfa9879013c750f46c1c7753bcb0eefdb62685e80dba4ede9d8ad8a7d9e4428ae4e6c9aef107b5c8ee4bb5c0484a17bba61e414cb34da48ef487ef122212408a2ebe107094cc187a1a00157e9af5a93d7e804d4782fc3ea3b244d1a13497609db33835d72372212f64f782a68aef1c18c6fb689b3843d99988f49bb7adc182783ac104d1f56a7588c4d430f9bbbe08acffb5b8b531c7b4917821cf187d4fb94e1094b353649ff47117542cf97ba86515c181cf9c0540a378b6fd96fad66b8a72b3e79455f29a579bcf67caef08c3aa8d0b99d80fe52883c5df69a7e3b100a6afec6809593e9ff48d61b81ae127fbae3d2117f937d9933bf54c0f76f61f59b5bb5b42934e7c6c9ddca0f05f13ccfb275fce530b20b3ea5e2afc58ab6b3ac9dbf3e85ca524fc59f28ec6387d646b1f4c02ca064072e7213ce0a2f17e7064b957b4ec37383e7dc7f8533cd6dae7149480c4f6c6bc5923f4179c5df13fe46341085410906c1be463ec9991ae1e06e46a84f6994d37ff53d6349e592ddf6f6e76b0907f804f4082a752c014021d14c8981a81f233150b5d934d2ff2f93c100f21c33833130ae23171579b92ed0ad970a9064784e81373f1864f342fc8d23df6cfb82eb15644b1cb413bd8c96510fd83417098ef27a13d41cf89da8c7f9429e19adf9543cce25e5e57f0f819c66d91f5a606ba6f8c80b982e21e0267f065a9a65fd63f2830147e57d8f910e0f0f7762ec948caa94cc7cb936b492036540b741cee998c67cb7e5bba5280b59e83d44926e1a129d63058efbcc952a5ac166bc47177d5b6dff3534a37d59c9b276485599ffe0323c57ed4047f8ba1eff7058f03aae450a41e7a4f01ca8053ec3a1d7a84055dafcfa70eac567968648a2c2360a9849c4a673a5d287285cd0e3a4ee09358708ce2ad4cf9830b89eee93debcde71e3847540e0ee726019de7ed0ca61551705a67e0dae57bdfc0aeaef5dd382c608ec6ec5376956c750bbce18e0000d76eaf5ceaf0fd8c5a759be288ac3ab7feb5f0848560add3142db45c108986bf21f3c98cd5159f71eaf52db7b7c6f0d7bebffb3b5c2c18e921569ace25d7d47295812aafe4ace9f9701109708be8281a3c430db9031591ea9350bad04c1252d03efed20989cde1628c382ae0f688c685de54003c5587a5546ba51a0d3f28e8a57d133a21ed3a5445c6e4be3293b4868fa76dd46143fad504f9bcd033c831c7bb14e612de668723f9ab482cf936788556d7a98b239bef0554485805728604d7987534b8b24613dd43d8060d7ccbea5f4894db61ad7d75b21bd712db8f98d360c1ecf8008781140abca713b294449c3188a5440b06966891a855f63296e12215b3b54b0b0f1c301b46503f980e0d4825362931ec7751f7a053ebf57e7e809be17583374525e958e7b5c4407f870cf6c3023705a53946f385098eac8f17d688c5937d0766988a722573b0c278e6fa4a7d1e0400b13af03bb572ca3b23f02816f2178f67db6d829dea4182eef4a7d4fda6c91a6188d153a8a3f7e33aa57803f6895fe8115c34962507f083e0fa4fe59cc207bf06094aeaa7a149308d7b68f450d28651f86459f9d6498854f5f61c25128610974eb180f78eed024b8f58c575ef93f06f09aeb95b8c23968427a3754ad094ced75393b3fc26a570583312924581c10a0b05d5c2dd7322cffe57dcbceb45c9c71a9c9a336c7fa8c2e4f5af5a581b1a5cf7c3b77af69dd1e6b95200a7e762debd71ef2a1e636b0b817863ce36fbd753a202a41f2e42bdf32ca56161680dd6a0a33f6770d397df397fa096271b4adbf532575b3884ab472bc4f4645fa189f5da4193956c0066bd04686d5a9e936862a896b240b33f6f40812fa595fe8421ea976dcccf19aa424890c64fa5b82eea749bbe43b4306ea57e0eb29c5b12cfb07e77fe6fbb3fc7d693506cbc0011ecda777fb753b4ec7c796ed7ecf4b1ede78dc1f3fe31db5a7b2a47b26cb709b3aea3204d7e18d27989ec30003e7840c64d311d9e9151999bf20e29c79560bf83489304498ee14bf33746ddee710dfc3a94877cd411c41c8c57459845b9184b680db0b80a6e0fa4bc41ad3843cad8e39a7e1173877760f44b230505aabe918e0cb7c0989948b4fbccfae759588b98742fc00b9878808eb01a3a3763055007881cc55cdf68703168c42153061b6d413957b4c8ebb894072127901ce3ba09d626e7a4fa65ef6abd3dde42bb2b2f60983ca080a368f99ca55c4c838f04c531fc163d68e61bba5658232f3f1d4b37975f36935cdb7a950137dcbb0bb268c6b1eec3f63d2d27079cb5a68e1e2261631d2e90db167b3b3b0df31f7980e4cd35e3ca1bf9075fc94d6392664c1e19598bc1996fc46194b3a9ff6ce539bee6c7ceea9402f48d81d8f1a941a39e56d179fdff249844494e4506005b260c73fda5831440ce4363e980ff50087244035e3202c5e87283d12c1807f19244495aa29f25eaaf7f16ecfbd69eeb69f5d1cb5b8c60f8037873bf1eda80cc98e9a8ec9772a313f7aab21d056cf65afdab174b5a4e6beea611480fd3abb253eef8db2cfbd4a13869ad03e3e27c94fa1ad857d16ac553d0d1487902a7a47c41305df45056515af178a5403ca97ea6d95f78e5086ecac17e670dc74ef271b7a9dd576f6eb8c5e59ee28122f81090a4c43e254a6dfde0713402523db74b22f0a867abeda9e7e13a4960798cc38890dbca29d3acf312ed3ef8db571cb1bc22f5806639fe146641ab5f4f8765faefd1d72d2b4ced9f7507dea31b53b0b6626d2a59883bbb78937241d5ac07c6a7ff958b11eac1aedcda77410c2c012f46c50d7b6ae403138e4ce8a2f6d827e5e0feca3f92fa66151cd8b95b8879e8e506e3cec3950fb29f51c1d6d6b6e57239378c32515141391d1d6bfe6bee3f1a3202f346b16b286b06f1f0e6bc5a7515518f2f0339b42e0ac2351e03755f1a15d684691fed82d5e4a33d828eab42fd2f7d42d8015916583a79a8fb5b24cd41993a823284a2e430abb042f83d877599295389101c8659b4329c88bca8b538fc0db05017d8efe0861448257369c61357f61553b0b509b7cd6b872f361ae010d59d03e2212105aa312d663e9bf7c13b2e7daafcdff779548553529cb7b0be029e387521112347647fa3ae8b1203cc58356715605a52d9bddf05f6d88211d53e95c63b8d0b08a554c68f7502c270bce40294bdd546e3d0d3eb9024559023dd1875067c360c40d6a6b5ca0643bb2efd224ce4621a4471dfabbe42ddc428711bd906db7cf66b2a4bb8e8045706b1305e1026be8aa79ba94b84e242e8581727ee1c6a6bfe4dfe8963cb762612d6829e8378301bdc0055a079a8a3c16cce3a0878089bbf63bf642aa1ef8cad627c37ba467369ed7ff9b4b7a457864f6edec122925b317b6a653bcef7e2c1bfcf222c4d52b3cd57ab91f022a65da00313ad0f163ac2fb2cd98f6487f51508645e859210e4307c5182b71ba69ddf7c385322c5f817eb8fba21f8595893d8709a72cec63d0f09efe45ad78175b52e11f01c47f9adb2ac93bb43fb07010d5f187add1a318f89a45476cb872d51e6b2e853194351cff0b6a055ec8b9e2c400d39f44e388105221adf8a5f4c74f57c7a8e9249a1006ec148e2a69ece6c25093a15b2e795326b00ef700e8495c94dc9a4282ef83225085d1808f9b512926647cc5e5f7bebbf3e663852f367dcecfabf21b0ed6ef6b4f591a3a17bb283eafba64742e5933353a2314568bfbe9114f3dc7ed9180784ed5154fa39b0a343006926dd93555b9047bf969c9906408f9be64f45dffb9ebaeed5dd0d07d514244895452b94a33518cc673895f118bd623c423b94e0ca1f19c82a4adf6604b50bb0167ae230c5aaaf2893f2fb9915dbe0cd1e3c8d177310fb86f22b79b6c65c4087cd98c10c845cf4021c340c3a97c783fc03c236d94330b0cc25f4687cdff4a554ba95bdfdd005c7bc18618bff28b8bde25af09589f8ef27f543f0decffd296e6477190584fd40190684deda9364c67636699639324116e1392b8e9fb0e27ee04da511674b015f6fa92f20489b2249ce4346896dcf23abbae5574843af2cc14c5386ec0b1c71e56d65dc7b90af6e4f11965c43476032e6469a1b48623b1c5f2ddf17f81df06e5dcf02fe6dcca38e65e4a3c665907ea65208d51ba3e3375d1c37a840795940b8cdaa8fdf33a9b061286755ef22c89cd5a5c74631957f0cebc8822c1716179b4bf7b04f8babb7e77514dbf9fc9e3ddd8570cdd72135fb859bf27ddab83c2d14384d1a06ca9508e57acc0fbaf32582e8439e1387994b5a0efdbb0e0d94dfe5dca9ca6e61c7eacfa9927fc30a6a100796fa97e6ccc52412fee5dd95b0e89d7d3b06e27ef2d89725bfb73323c157d3599d9f6ceb499eb2c2534b0ace1c7fff615ba087b694dd8b0e184cee7543da849d696bf847040dd3b7443e05a8ae095b5274e833309fb4ac18ddfa5e4f994bf51c41076eb57623f484aa77353433351082f095bd7238b3f224e58bf37cdf09f915d2bd9649b75ba4e7adcef39afcfa9b24f4d0ed66d621828f310173ab0207ed0287091a1f28ae0e328eeda0e476b953994b4c059e843229f05b6f7caea4b93ab993a7beab8215d4166bd8c0b8858491229d54ae0673764f5e8823b506db8f37e78c9c2ab3ea0911dba3bed5b1d5c6b19c54382e8b1dd8e53e01f00629edfca3ad9c3e924bb30cd989856a286484f6fdbfdc43dab78c34a501c7640634faa128ae7f10e49624f4837bcd9bb173c1fcf18a80814296c25c9fc81d645625ebbd5690652dd20fbffb81e2f13e80dd9f8f359b2b221385bb7f7a2d1ea0dbfbddb82d6585276ad8bcb914669b0d6c054271929183a2bca83ef6fe6ebb6f378c0660570bd21a1d2bc5efc56502dc6f502506af0223c6f6518dd5d11f31de94006a3d68a98b793b0f50e40253d601caefc3117111c1c8c035f48482b44565dface496dd0bfacb7a04c12a4c05355d31135a44ef7f236120acaf41d60f05c774c04605d3388eb4a86844a217d31e19e234a359a8457718f438b2ee73886fc2092d1becc451183ffd72d46757243473cdf963563dcebb9abc6c9cf1d1c8cfb4c8a673163db7a3d0c4bbd1d50017aeeabb29ebce994f85686712a7b858ae8460c8cb5c0f74e9a2e6b04b8956c347a769734d8e4c51c8790af15c679c2f12460368dff18bb9d1a37d998e782d8a5b2d4f90beffee7614a60df96ceb8faca556dacc7d76cd358c4654fa2d6c937331116ac0c58c1f582faae5b1acdf0bc3f8069ac258cb728df21240ac8b3c002360cb410551ed206c910efc6279130be411f65ac400f8267475053b05c7db98e320b594cca49545953849221b5719f05dbcdf7ee0e9c9171203670473613b19bfaaaac460cb098460dfcbddfde4c111ea7b7893af5b8c85a792cc182cfb2109c5ec1822f03f43e745d8699e91e9c86eebd188a1fcd176a7392fab8022c35ecbbf32261c99253b3528e982af571319bf448c06218d039923d762056917a150eb7d9bf9cdfb6b2a7667b7114d8f37bda5946cf192a743a106b65d5b66833800881d6a9e5d731dda407a94d5aca1e2fb1c7e39ea364fe88893c153c9754da582ec261ba8799294d86103cfacd38a04390277b7e5c4171fcb92604d157b69f078a90ae9a2708565ba9ef00fb85f114d8d90512c855e0fa38dff9e6f8d465949abb53b291e06404854b8f02817a033596d203d077544f1d673142b287cbefa3294432d736fd2f63b0a7a25e8dd1cd6da2dc7698e68d2ce39ca0475dfdaf49bdf4923e632e36cca2e54220da5b698977e7eea565508ab466f35320f4a35e68c1414d450bd8d7f936f565e1ea986b4c0846d1e288e9e0353f8abff28677400ca7a9ae1aac0a53dd74c55cecc479c813314ddc748439ffeba94e763f4d8d7e93e1fe0fa13e76cf9cf4a3e1ceb686d8edca9c5b4d832b1a53a9c52274a96dc453c0f7cf891f7ede7d8285786e8430389a6ef67316b1496a553b1e6c169f9d756269814d2b93a5a4a0273b79f327a104fa9e946069cb4fd5fdb49111a8b0ebd1318d64a7c6543ddf0b821cf1735bb6a6136214ec31c1f93260754eb44731ca0976b31d5ab14debcc5eb977c1930817e2c2ec11ae6f8fc0f0a3448d11f5d3aa9a3fc57c370d6ab963e49f8f6efdbf0f9a80859ab0d7fceaac90f23683d5b076add1fadf2744c4428503b457399991095c0ca4a6d5f050cef123c974e8b842bea92335a266b8e9591dddab9f5b6f76e103ea580e4c762571622ec104a87d018ec0c521578a7ddc32f138c58b203360c0d00642397402e75beb905a87dd639447514b7bafdc40e10c29eaf6d2d76862dff1f632ac3b74d7a674155ce3ba956302a1bb7c39dd814634e1af9dbdb672154242dbbf853a5ba3ba1476c1fc32e365bbeb71e4757850014cbf0440f6e320e9bebcab3cfedad9c5e07499c5987244fce8ff45bb0d31e10a8db2cc57ea854a92346e9675379771fed7a5e66360cf197bf7d29781fefce5bb744a7da92b573c3232fcc652f3d63cbeae0a0b5137aed1f764adc3afc96f520b6f762734a223170e731869af7df52a1edce9580840e391b2872f8f492af7513e93750f06639ca87a0b741adad9fe565a84a9f8d70a7b54db1f044b001da9b210944317335cea08610c0457a6b89d2ee655d8276a5cad62c049b21fb33779c09fee4db7698d9c696803d48c2ce0b91cb53fa5b739246901c7c5920ea670bfba039e85d2a570995473ba11a857317fc26f20922a356ee28764b300c804216afce2718684aa8b70cce8efd0acc9c5f6ce6a928503180c8168d79f5a5e2fe4af02932694a9ac153000d8d677ed2a521761f530906be91f44e1d3a764f4197d01b65f6fd69a5bb1a75c585333282576e43ee397fa883a8b3566f2b2c0049baf1dcb728fa767a83c7ec90ca9a81b1d3aa6290e8e2d4069a95e25b43224933492d01ddb2c1d3f6618cc4b7666b075b011b943c9a767a3998612dbb14792eb8e24e15631286013afc6c610c268120082eee1e8de8f881bc04df55033e3d6d22d54718bdcb356d8e27b4cd11895cf9a3cda9139f54fa87e24c2386e39c7055694c0fd83f1f7132101e7b1f759d880d56c657585d9f06cd5b4fa942e83ee91b30b3ff45d98f53fb12bc27d4189f391775318cabb9bc7e90faea7131592acb2798cfbc1b68bb2475a426dcc56fa40bb27c0abac585985bde26cc5f3dd4b4985e62309312db9d0ac60431c13fa064c451024d2319d9780c0fee7022f7be69211b3d6b125133ee0fc32169d460167f6076a3966a7b09c93e8d72d1dd42ff844384d68e8b8f1e169ed402a48329bd6856798c09b47c9df4cc26831e279952b6015f3e78cef715ae616f0f352218d2532aa045ccaf9b44b514d55f6e6919432dc5badf1be2e3553d194124a03e855878f156d64ca4dd9b50d8d75db688f3d11be48ecdfe664beb92d31ab94c8d94b02b4e51212ce51bfab1413123f60ea9f971b30d91ba0332e2f206121a61a667086b2e055304fd24243a0052aa3b3c8217821dc09cf9c7b3296d2ced9b8f006269785370b4b1ec70d36a57581b440c17c10420463f37aafd864fee37e3a3aa94bca7f83fcdd4eb64d2ce9484da1b948da0808721a0a6481477123fce6c9fdebd2d1f373f7690fcb0de05c8be280acc8068215ad3ff5c2e1df24221f5a7634c401ab70327751ab5ad1fc4ca8fa8b8c1d97fb37a43bd58d3509382b40f00945c1e8fa78639a99fed3176d657ad8eef3db3c3d760de1dfc32d0c82ecb0a2c8dda6c6e320857768e3caf18b6f304054a2a5fe2e179690d8e0c7561c4fbb837b63b261431e80581863b20b132087e9afaefaf1709fb710af8a2c22b97c3cd735d9786cad809b963ca35afb4734099e0ebe370bd1994097d7b886585774300f8911b17fba7a4f22f0845f9450498530f2eb438051810221c4d0ea3bfb3fc5db1be13592d2601da9951d26801a5d5acb705e6b97134eee40d14ce563c1070aad30da130e7728561f73afac576f4bb9de21ef23ab88bd8d56f693b03c5f804a90bdcd9bb867ef7b4cdfcdee6235ddb522af4508b491075c16e705f2ab937724ab3e9657343fb500d6fe51aef269259374de1b20fac67ba9440290c27891f6bc114633716dfaeed8ccdb8f89d6c027e7f908c300da18973d132b27d6d7efadef95c4caa9789a3466157455fb69e472438c919d6e4a619f2505585a87fa13b9048cf41cbc72d964c65972e3d5424f89f47422ef4318c01458a57d8ed0e9daff09a98f2e1e930bcad242e68f302a5aeef7cbcf6c1eae5eb501d1766cdacfc1a294aab1438919f38c75d63d1718bed2ee182ac92e6a3165ab5738ba627154f1ec4c36cc4e99172930e7c336821fc2a891e5974b96a206ab5d5612414e8413d7ca6f4479c5e6514f96b97ea4ef97f9b512896cae1fab0ee98ea70b65323c7644c8faaaea4f828759d3cd148847be82656d739b320641936ba8edadd15ee48f233870662a4469eaa367a2186ca067681125a6a4bc0e14e49469ec1ec9048e47112e005c951af09e2eaad4763a8d95b3f64f1048e0fb3459e6cab6a5b571959d02c317b98fb35d47e0c235ace4b7e91fd5a73db891197aeca5604a5fc77dde480a269d4962cb6bc0b97c5f063e7b17bbb2a43b1061ca11f24e49fae7dc0e7dbd6d3640b16e36ff5705e3b9b14f3f8e0235c7f44c5b29878387c483c65150b82cadd98b07fe5016758efe658e8943faf6297e20a2fc857e42b53a9e01ed47a08a0a967dac869e5867a2f0fac5dbdd26c58996b1e640717d00459c1c53919f1750c722d657322a2d42afea2821159e8a29f242e0d878b60a74c8c209bbc755528a0a478300440997656158e6aeae5ceb5b72afdef001eecd522f01051ad2c6fbb786f56df131ab6146ede9f07aaeaceaa8b5af6572fecfdd76d6171cdbd0cdaf07d273de1fe3dc77f31220124ad9accc20c98c09d1a697fa8d6541b23aa441982a3b1992a597b57789ae491ff823f8a5d4b20957bd2342</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">Hey, password is required here.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    <summary type="html">关于文献综述、开题报告写作逻辑记录</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
    <category term="Methods" scheme="https://blog.slks.xyz/tags/Methods/"/>
    
  </entry>
  
  <entry>
    <title>SCI EI 核心期刊以及计算机领域CCF会议等级分类文件</title>
    <link href="https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/"/>
    <id>https://blog.slks.xyz/2022/03/17/58ef9be2b7d9/</id>
    <published>2022-03-17T01:27:23.000Z</published>
    <updated>2022-03-17T01:39:18.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="一sci">一、SCI：</h4><p>​ 美国《科学引文索引》，SCI(科学引文索引 )、EI(工程索引)、ISTP(科技会议录索引 )是世界著名的三大科技文献检索系统，是国际公认的进行科学统计与科学评价的主要检索工具，其中以SCI最为重要。</p><p>​一般SCI<strong>侧重科学前沿理论</strong>，审核标准严格，发稿周期也比较长。</p><h4 id="二ei">二、EI：</h4><p>​ 《工程索引》（The Engineering Index,简称EI）是供查阅<strong>工程技术领域文献</strong>的综合性情报检索刊物。</p><p>​ EI的主要特点是摘录质量较高，文摘直接按字顺排列，索引简便实用</p><h4 id="三核心期刊">三、核心期刊</h4><p>​在国内简单地说，核心期刊是学术界通过一整套科学的方法，对于期刊质量进行跟踪评价，并以情报学理论为基础，将期刊进行分类定级，把最为重要的一级称之为核心期刊。</p><ul><li>（1）北京大学图书馆“中文核心期刊”，这个的认可度一般最高。</li><li>（2）南京大学“中文社会科学引文索引（CSSCI）来源期刊”。</li><li>（3）中国科学院文献情报中心“中国科学引文数据库（CSCD）来源期刊”。</li><li>（4）中国科学技术信息研究所“中国科技论文统计源期刊”（又称“中国科技核心期刊”）。</li><li>（5）中国社会科学院文献信息中心“中国人文社会科学核心期刊”。</li><li>（6）中国人文社会科学学报学会“中国人文社科学报核心期刊”。</li></ul><h4id="四中国计算机学会ccf推荐中文科技期刊目录">四、中国计算机学会CCF推荐中文科技期刊目录</h4><p>​ <ahref="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E4%B8%AD%E6%96%87%E7%A7%91%E6%8A%80%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载中国计算机学会推荐中文科技期刊目录PDF</a></p><p><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/1123qwdsa.jpg" /></p><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_3.jpg"alt="中国计算机学会推荐中文科技期刊目录(1)_页面_3" /><figcaptionaria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_3</figcaption></figure><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_4.jpg"alt="中国计算机学会推荐中文科技期刊目录(1)_页面_4" /><figcaptionaria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_4</figcaption></figure><figure><imgsrc="https://mypic416.oss-cn-hangzhou.aliyuncs.com/windows/中国计算机学会推荐中文科技期刊目录(1)_页面_5.jpg"alt="中国计算机学会推荐中文科技期刊目录(1)_页面_5" /><figcaptionaria-hidden="true">中国计算机学会推荐中文科技期刊目录(1)_页面_5</figcaption></figure><h4id="五中国计算机学会ccf推荐国际学术会议和期刊目录">五、中国计算机学会CCF推荐国际学术会议和期刊目录</h4><p>​ <ahref="https://my-blog-fantast.oss-cn-hangzhou.aliyuncs.com/%E4%B8%AD%E5%9B%BD%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AD%A6%E4%BC%9A%E6%8E%A8%E8%8D%90%E5%9B%BD%E9%99%85%E5%AD%A6%E6%9C%AF%E4%BC%9A%E8%AE%AE%E5%92%8C%E6%9C%9F%E5%88%8A%E7%9B%AE%E5%BD%95.pdf">点我下载中国计算机学会推荐国际学术会议和期刊目录 PDF</a></p><p>参考：https://zhuanlan.zhihu.com/p/57932081</p>]]></content>
    
    
    <summary type="html">SCI EI 核心期刊的区别以及计算机领域CCF会议等级分类文件整理</summary>
    
    
    
    <category term="⓻ 经验整理类笔记" scheme="https://blog.slks.xyz/categories/%E2%93%BB-%E7%BB%8F%E9%AA%8C%E6%95%B4%E7%90%86%E7%B1%BB%E7%AC%94%E8%AE%B0/"/>
    
    
  </entry>
  
</feed>
